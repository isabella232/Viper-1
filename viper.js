/* Copyright Squiz - For full terms see licence.txt */


(function(window) {

    function Viper(id, options, callback, editables)
    {
        this.id           = id;
        this._document    = document;
        this._browserType = null;
        this._specialKeys = [];
        this._prevRange   = null;
        this.enabled      = false;
        this.inlineMode   = false;

        this.HistoryManager = null;
        this.PluginManager  = null;
        this.Tools               = null;

        this._settings = {};

        this._viperElementHolder = null;
        this._registeredElements = [];
        this._attributeGetModifiers = [];
        this._attributeSetModifiers = [];
        this._mouseDownEvent        = null;
        this._retrievingValues      = 0;
        this._memberElements        = [];

        // This var is used to store the range of Viper before it loses focus. Any plugins
        // that steal focus from Viper element can use getPreviousRange.
        this._viperRange = null;

        // Callback methods which are added by external objects.
        this.callbacks = {};

        if (!options) {
            options = {};
        }

        this.setSetting('emptyTableCellContent', '<br />');

        this.init();

        if (editables && editables.length > 0) {
            this.registerEditableElements(editables);
            for (var i = 0; i < editables.length; i++) {
                (function(editableElement) {
                    Viper.Util.addEvent(editableElement, 'mousedown', function(e) {
                        self.setEditableElement(editableElement);
                    });
                }) (editables[i]);
            }
        }

        if (options) {
            var self = this;
            this._processOptions(options, function() {
                if (callback) {
                    callback.call(self, self);
                }
            });
        }
    }

    Viper.document = document;
    Viper.window   = window;

    Viper.prototype = {

        
        init: function()
        {
            this.Tools           = new Viper.Tools(this);
            this.HistoryManager  = new Viper.HistoryManager(this);
            this.PluginManager   = new Viper.PluginManager(this);
            this.KeyboardHandler = new Viper.KeyboardHandler(this);

            Viper.Selection._viper = this;

            this.registerCallback('Viper:setHtmlContent', 'Viper', function(content, callback) {
                callback.call(this, content);
                return function() {};
            });

        },

        destroy: function()
        {
            this.fireCallbacks('Viper:destroy');
            this.setEnabled(false);
            Viper.Util.removeEvent(Viper.Util.getDocuments(), '.' + this.getEventNamespace());

            if (this._viperElementHolder) {
                Viper.Util.remove(this._viperElementHolder);
            }

        },

        getId: function()
        {
            return this.id;

        },

        _processOptions: function(options, callback)
        {
            var self = this;
            for (var op in options) {
                var fn = 'set' + Viper.Util.ucFirst(op);
                if (fn === 'setSetting') {
                    delete options[op];
                    // Reserved.
                    continue;
                }

                if (Viper.Util.isFn(this[fn]) === true) {
                    this[fn](options[op], function() {
                        delete options[op];
                        self._processOptions(options, callback);
                    });
                    return;
                }

                fn = '_' + fn;
                if (Viper.Util.isFn(this[fn]) === true) {
                    this[fn](options[op], function() {
                        delete options[op];
                        self._processOptions(options, callback);
                    });
                    return;
                } else {
                    this.setSetting(op, options[op]);
                    delete options[op];
                    self._processOptions(options, callback);
                    return;
                }
            }//end for

            callback.call(this);

        },

        getPluginManager: function()
        {
            return this.PluginManager;

        },

        getHistoryManager: function()
        {
            return this.HistoryManager;

        },

        getKeyboardHandler: function()
        {
            return this.KeyboardHandler;

        },

        setSetting: function(setting, value)
        {
            this._settings[setting] = value;

            var fn = 'set' + Viper.Util.ucFirst(setting);
            if (Viper.Util.isFn(this[fn]) === true) {
                this[fn].call(this, value);
            }

        },

        
        setSettings: function(settings, clean)
        {
            if (clean === true) {
                this._settings = {};
            }

            for (var setting in settings) {
                this.setSetting(setting, settings[setting]);
            }

        },

        getSetting: function(setting)
        {
            return this._settings[setting];

        },

        getSettings: function()
        {
            return Viper.Util.clone(this._settings);

        },

        
        setCustomClass: function(className)
        {
            this._settings['customClass'] = className;
            if (this._viperElementHolder) {
                Viper.Util.addClass(this._viperElementHolder, className)
            }

        },

        getDefaultBlockTag: function()
        {
            var defaultBlockTag = this.getSetting('defaultBlockTag');
            if (Viper.Util.isset(defaultBlockTag) === true) {
                return defaultBlockTag;
            }

            return 'p';

        },

        _setLanguage: function(lang, callback)
        {
            if (!lang) {
                return;
            }

            var code = null;
            var src  = null;
            if (typeof(lang) === 'object' && lang.code) {
                code = lang.code;
                src  = lang.src;
            } else {
                code = lang;
            }

            if (code) {
                // If given code is in en-au (language code - country code) format then just use the language code.
                code = code.replace(/-\w+/, '');
            }

            if (code === 'en') {
                callback.call(this);
                return;
            }

            if (!src) {
                src = this.getViperPath().replace(/\/build$/, '') + '/build/Translation/' + code + '.js';
            }

            if (Viper.Translation.isLoaded(code) === false && src) {
                Viper.Util.loadScript(src, function() {
                    Viper.Translation.setLanguage(code);
                    callback.call(this);
                }, 2000);
            } else {
                Viper.Translation.setLanguage(code);
                callback.call(this);
            }

        },

        
        addElement: function(element)
        {
            if (!element) {
                return;
            }

            if (!this._viperElementHolder) {
                this._viperElementHolder = this._createElementHolder();
            }

            this._viperElementHolder.appendChild(element);

        },

        _createElementHolder: function()
        {
            var holder = document.createElement('div');
            Viper.document.body.appendChild(holder);

            // Add browser type.
            var browser = Viper.Util.getBrowserType();
            var version = Viper.Util.getBrowserVersion();

            if (browser && version) {
                Viper.Util.addClass(holder, 'Viper-browser-' + browser);
                Viper.Util.addClass(holder, 'Viper-browserVer-' + browser + version);
            }

            if (this._settings.customClass) {
                Viper.Util.addClass(holder, this._settings.customClass);
            }

            return holder;

        },

        getElementHolder: function()
        {
            if (!this._viperElementHolder) {
                this._viperElementHolder = this._createElementHolder();
            }

            return this._viperElementHolder;

        },

        
        setMode: function(mode)
        {
            if (mode === 'inline') {
                this.inlineMode = true;
            } else {
                this.inlineMode = false;
            }

        },

        
        getBrowserType: function()
        {
            if (this._browserType === null) {
                var tests = ['trident', 'msie', 'firefox', 'chrome', 'safari'];
                var tln   = tests.length;
                for (var i = 0; i < tln; i++) {
                    var r = new RegExp(tests[i], 'i');
                    if (r.test(navigator.userAgent) === true) {
                        if (tests[i] === 'trident') {
                            // No MSIE token for IE11+.
                            this._browserType = 'msie';
                        } else {
                            this._browserType = tests[i];
                        }

                        return this._browserType;
                    }
                }

                this._browserType = 'other';
            }

            return this._browserType;

        },

        
        getBrowserVersion: function()
        {
            var browsers = ['MSIE', 'Trident', 'Chrome', 'Safari', 'Firefox'];
            var c        = browsers.length;
            var uAgent   = navigator.userAgent;

            var browserName = null;
            for (var i = 0; i < c; i++) {
                var nameIndex = uAgent.indexOf(browsers[i]);
                if (nameIndex >= 0) {
                    browserName = browsers[i];
                    break;
                }
            }

            if (!browserName) {
                return null;
            }

            if (browserName === 'Safari') {
                browserName = 'Version';
            }

            var re = null;
            if (browserName === 'MSIE') {
                re = new RegExp('MSIE (\\d+)');
            } else if (browserName === 'Trident') {
                re = new RegExp('rv:(\\d+)');
            } else {
                re = new RegExp(browserName + '/(\\d+)');
            }

            var matches = re.exec(uAgent);
            if (!matches) {
                return null;
            }

            return parseInt(matches[1]);

        },

        
        getViperPath: function()
        {
            // TODO: This path may need to be set incase a different file name is used.
            var scripts = document.getElementsByTagName('script');
            var path    = null;
            var c       = scripts.length;
            for (var i = 0; i < c; i++) {
                if (scripts[i].src) {
                    if (scripts[i].src.match(/\/Lib\/Viper\.js.*/)) {
                        path = scripts[i].src.replace(/\/Lib\/Viper\.js.*/,'');
                        break;
                    } else if (scripts[i].src.match(/\/viper-combined\.js.*/)) {
                        path = scripts[i].src.replace(/\/viper-combined\.js.*/,'');
                        break;
                    } else if (scripts[i].src.match(/\/viper\.js.*/)) {
                        path = scripts[i].src.replace(/\/viper\.js.*/,'');
                        break;
                    }
                }
            }

            return path;

        },

        getEventNamespace: function()
        {
            return 'viper-' + this.id;

        },

        
        _addEvents: function(elem)
        {
            if (!elem) {
                elem = this.element;
            }

            this._document = elem.ownerDocument;
            Viper.document = this._document;
            if (this._document.defaultView) {
                Viper.window = this._document.defaultView;
            } else {
                Viper.window = window;
            }

            var namespace = this.getEventNamespace();

            Viper.Util.removeEvent(Viper.Util.getDocuments(), '.' + namespace);
            this._removeEvents(elem);
            var self = this;

            if (Viper.Util.isBrowser('msie', '<11') === true) {
                Viper.Util.addEvent(elem, 'mouseup.' + namespace, function(e) {
                    return self.mouseUp(e);
                });
            } else {
                Viper.Util.addEvent(Viper.Util.getDocuments(), 'mouseup.' + namespace, function(e) {
                    return self.mouseUp(e);
                });
            }

            Viper.Util.addEvent(Viper.Util.getDocuments(), 'mousedown.' + namespace, function(e) {
                return self.mouseDown(e);
            });

            this.KeyboardHandler.init();

            Viper.Util.addEvent(elem, 'blur.' + namespace, function(e) {
                if (!self._viperRange) {
                    self.resetViperRange(self._currentRange);
                }
            });

            // This is necessary for IE, because IE does not return the current range when drop event fires.
            var _dragRange = null;
            Viper.Util.addEvent(elem, 'dragstart.' + namespace, function(e) {
                _dragRange = self.getViperRange();
            });

            Viper.Util.addEvent(elem, 'drop.' + namespace, function(e) {
                Viper.Util.preventDefault(e);

                e.originalEvent.dataTransfer.dropEffect = 'move';

                // Get the range using the mouse pointer (drop location).
                var range        = self.getRangeFromCoords(e.originalEvent.clientX, e.originalEvent.clientY);
                var dataTransfer = e.originalEvent.dataTransfer;
                var origRange    = null;

                if (origRange !== null) {
                    origRange = _dragRange.cloneRange();
                }

                // Call the callback functions with dataTransfer object, range and original event.
                if (self.fireCallbacks('Viper:dropped', {dataTransfer: dataTransfer, range: range.cloneRange(), e: e, origRange: origRange}) === false) {
                    return false;
                }

                var textPlain = null;
                if (dataTransfer.types) {
                    for (var i = 0; i < dataTransfer.types.length; i++) {
                        try {
                            var data = {
                                data: dataTransfer.getData(dataTransfer.types[i]),
                                range: range,
                                origRange: _dragRange
                            };
                        } catch (e) {
                            continue;
                        }

                        if (dataTransfer.types[i] === 'text/plain' || dataTransfer.types[i] === 'Text') {
                            textPlain = data;
                        }

                        // Fire callbacks for each data type.
                        if (self.fireCallbacks('Viper:dropped:' + dataTransfer.types[i], data) === false) {
                            return false;
                        }
                    }
                } else if (Viper.Util.isBrowser('msie', '8') === true) {
                    textPlain = dataTransfer.getData('text');
                     try {
                        var data = {
                            data: textPlain,
                            range: range,
                            origRange: _dragRange
                        };
                    } catch (e) {
                    }

                    if (self.fireCallbacks('Viper:dropped:Text', data) === false) {
                        return false;
                    }
                }

                // Nothing handled this drop try text/plain.
                if (textPlain !== null && textPlain.data) {
                    Viper.Selection.addRange(range);
                    self.insertNodeAtCaret(document.createTextNode(textPlain.data));
                }

                return false;
            });

            Viper.Util.addEvent(elem, 'focus.' + namespace, function(e) {
                if (self.fireCallbacks('Viper:viperElementFocused') === false) {
                    return;
                }

                self.highlightToSelection();
            });

            if (navigator.userAgent.match(/iPad/i) !== null) {
                // On the iPad we need to detect selection changes every few ms.
                setInterval(function() {
                    self.fireSelectionChanged();
                }, 500);

                // Add scaling.
                Viper.Util.addEvent(window, 'gestureend', function() {
                    var elements = Viper.Util.getClass('Viper-scalable');
                    var c        = elements.length;
                    for (var i = 0; i < c; i++) {
                        var scale = Viper.Tools.scaleElement(elements[i]);
                        self.fireCallbacks('Viper:elementScaled', {
                            element: elements[i],
                            scale: scale
                        });
                    }
                });
            }

        },

        
        _removeEvents: function(elem)
        {
            if (!elem) {
                elem = this.element;
            }

            Viper.Util.removeEvent(elem, '.' + this.getEventNamespace());

        },

        
        setEnabled: function(enabled)
        {
            this.resetViperRange(null);

            var range = null;
            if (enabled === true && this.enabled === false) {
                this._addEvents();
                this.enabled = true;

                // Word-wrap attribute changes when contentEditable is set to true.
                this._setRadOnlyStyles();
                Viper.Selection._viper = this;

                this.element.setAttribute('contentEditable', true);
                Viper.Util.setStyle(this.element, 'outline', 'none');

                if (Viper.Util.isBrowser('msie', '<11') === true) {
                    try {
                        range = this.getCurrentRange();
                        range.setStart(this.element, 0);
                        range.collapse(true);
                        Viper.Selection.addRange(range);
                    } catch (e) {
                        // Most likely a hidden element.
                    }
                } else {
                    this.focus();
                }

                if (!range) {
                    range = this.getCurrentRange();
                }

                if (this.rangeInViperBounds(range) === false) {
                    this.initEditableElement();
                }

                var editableChild = range._getFirstSelectableChild(this.element);
                if (!editableChild) {
                    // Check if any of these elements exist in the content.
                    var tags = 'iframe,img,object,table';
                    if (Viper.Util.getTag(tags, this.element).length === 0) {
                        var blockElement = null;
                        for (var node = this.element.firstChild; node; node = node.nextSibling) {
                            if (Viper.Util.isBlockElement(node) === true
                                && Viper.Util.isStubElement(node) === false
                            ) {
                                blockElement = node;
                                break;
                            }
                        }

                        if (blockElement) {
                            if (Viper.Util.isBrowser('msie') !== true) {
                                Viper.Util.setHtml(blockElement, '<br />');
                            } else {
                                blockElement.appendChild(document.createTextNode(' '));
                            }

                            editableChild = range._getFirstSelectableChild(this.element, true);
                        } else {
                            var tagName = this.getDefaultBlockTag();
                            if (!tagName) {
                                Viper.Util.setHtml(this.element, '');
                            } else {
                                blockElement = document.createElement(tagName);
                                Viper.Util.setHtml(blockElement, '&nbsp;');
                                this.element.appendChild(blockElement);
                                editableChild = range._getFirstSelectableChild(this.element);
                            }
                        }//end if

                        var self = this;
                        setTimeout(function() {
                            self.element.focus();

                            if (editableChild) {
                                range.setStart(editableChild, 0);
                                range.collapse(true);
                                Viper.Selection.addRange(range);
                            }
                        }, 10);
                    }//end if
                } else if (Viper.Util.isBrowser('firefox') === true) {
                    range.setStart(editableChild, 0);
                    range.collapse(true);
                    Viper.Selection.addRange(range);
                }//end if

                this.fireCallbacks('Viper:enabled');
            } else if (enabled === false && this.enabled === true) {
                // Back to final mode.
                this.cleanDOM(this.element);

                if (Viper.Util.trim(Viper.Util.getNodeTextContent(this.element)) === '') {
                    if (Viper.Util.isBrowser('msie') === true && Viper.Util.getTag('*', this.element).length === 0) {
                        // This check is to prevent iframe elements stuffing up the whole browser screen in IE8 when
                        // they are the only content on the page. Makes no sense but when
                        // did IE ever make sense?
                        this.initEditableElement();
                    }
                }

                this.element.setAttribute('contentEditable', false);
                Viper.Util.setStyle(this.element, 'outline', 'invert');
                this._removeEvents();
                this.enabled = false;

                // Fire disabled with previous state set to enabled.
                this.fireCallbacks('Viper:disabled', true);
            } else if (enabled === false) {
                // Fire disabled with previous state set to disabled.
                this.fireCallbacks('Viper:disabled', false);
            }//end if

        },

        enable: function()
        {
            this.setEnabled(true);

        },

        disable: function()
        {
            this.setEnabled(false);

        },

        
        isEnabled: function()
        {
            return this.enabled;

        },

        
        _setRadOnlyStyles: function () {
            if (!this.element) {
                return;
            }

            var styles = ['word-wrap'];
            for (var i = 0; i < styles.length; i++) {
                var value = Viper.Util.getComputedStyle(this.element, styles[i]);
                Viper.Util.setStyle(this.element, styles[i], value);
            }

        },

        
        setEditableElement: function(elem)
        {
            var self = this;

            if (this.element === elem) {
                return;
            }

            // Load default plugin set if nothing has been set yet.
            if (this.PluginManager.getPlugins() === null) {
                this._useDefaultPlugins();
            }

            this.resetViperRange(null);

            if (this.element) {
                this.element.setAttribute('contentEditable', false);
                Viper.Util.setStyle(this.element, 'outline', 'invert');
            }

            this.setEnabled(false);
            this.element = elem;
            Viper.Util.setViperElement(elem);

            if (Viper.Util.inArray(elem, this._registeredElements) === false) {
                this.registerEditableElement(elem);
            }

            this.setEnabled(true);
            this.HistoryManager.setActiveElement(elem);
            this.inlineMode = false;
            elem.setAttribute('contentEditable', true);
            Viper.Util.setStyle(elem, 'outline', 'none');

            this.fireCallbacks('Viper:editableElementChanged', {element: elem});

            // Create a text field that is off screen that will handle tabbing in to Viper.
            var tabTextfield  = Viper.Util.getid(this.getId() + '-tabTextfield');
            if (!tabTextfield) {
                tabTextfield = document.createElement('input');
                tabTextfield.type = 'text';
                tabTextfield.id   = this.getId() + '-tabTextfield';
                Viper.Util.setStyle(tabTextfield, 'left', '-9999px');
                Viper.Util.setStyle(tabTextfield, 'top', '-9999px');
                Viper.Util.setStyle(tabTextfield, 'position', 'absolute');
                Viper.Util.insertBefore(this.element, tabTextfield);
            }

            Viper.Util.addEvent(tabTextfield, 'focus', function(e) {
                tabTextfield.blur();
                self.setEnabled(true);

                self.element.focus();

                self.fireCallbacks('Viper:clickedInside', e);
                self.initEditableElement();

                var range = self.getCurrentRange();

                var selectable = range._getFirstSelectableChild(self.element);
                if (!selectable) {
                    var brTags = Viper.Util.getTag('br', self.element);
                    if (brTags.length > 0) {
                        range.selectNode(brTags[0]);
                    }
                }

                if (selectable) {
                    range.setEnd(selectable, 0);
                    range.setStart(selectable, 0);
                }

                range.collapse(true);
                Viper.Selection.addRange(range);
                self.fireSelectionChanged(range, true);
            });

            // If the document of this editable is different to Viper then add the highlight class to that document.
            if (document !== elem.ownerDocument) {
                var style       = elem.ownerDocument.createElement('style');
                style.innerHTML = '.__viper_selHighlight {background-color: #CCC !important;}';
                elem.ownerDocument.head.appendChild(style);
            }

        },

        registerEditableElements: function(elements)
        {
            for (var i = 0; i < elements.length; i++) {
                this.registerEditableElement(elements[i]);
            }

        },

        registerEditableElement: function(element)
        {
            this.initEditableElement(element);
            this._registeredElements.push(element);

        },

        initEditableElement: function(elem)
        {
            var elem = elem || this.element;
            if (!elem) {
                return;
            }

            if (Viper.Util.isBrowser('msie', '<11') === true) {
                // Find iframe elements for youtube.com videos to add wmode=opaque to query
                // string so that the video does not sit on top of the editor window in IE.
                var iframeTags = Viper.Util.getTag('iframe', elem);
                for (var i = 0; i < iframeTags.length; i++) {
                    var src = iframeTags[i].getAttribute('src');
                    if (src && src.match('youtube') && !src.match('wmode=opaque')) {
                        src = Viper.Util.addToQueryString(src, {wmode: 'opaque'});
                        iframeTags[i].src = src;
                    }
                }

                // Add wmode=transparent to old object code.
                var embedTags = Viper.Util.getTag('embed', elem);
                for (var i = 0; i < embedTags.length; i++) {
                    if (Viper.Util.isTag(embedTags[i].parentNode, 'object') === true) {
                        var paramTag = document.createElement('param');
                        paramTag.setAttribute('name', 'wmode');
                        paramTag.setAttribute('value', 'transparent');
                        Viper.Util.insertBefore(embedTags[i], paramTag);
                        embedTags[i].setAttribute('wmode', 'transparent');
                    }
                }
            }//end if

            var tmp     = Viper.document.createElement('div');
            var content = this.getContents(elem);
            content     = this._closeStubTags(content);
            content     = this.removeInvalidCharacters(content);
            Viper.Util.setHtml(tmp, content);

            if ((Viper.Util.trim(Viper.Util.getNodeTextContent(tmp)).length === 0 || Viper.Util.getHtml(tmp) === '&nbsp;')
                && Viper.Util.getTag('*', tmp).length === 0
            ) {
                // Check for stub elements.
                var tags         = Viper.Util.getTag('*', tmp);
                var hasStubElems = false;
                Viper.Util.foreach(tags, function(i) {
                    if (Viper.Util.isStubElement(tags[i]) === true) {
                        hasStubElems = true;
                        return false;
                    }
                });

                if (hasStubElems !== true) {
                    // Insert initial P tags.
                    var range    = this.getCurrentRange();
                    var blockTag = this.getDefaultBlockTag();
                    if (!blockTag) {
                        Viper.Util.setHtml(elem, '');
                        elem.appendChild(document.createTextNode(' '));
                    } else {
                        var emptyCont = '<br/>';
                        if (Viper.Util.isBrowser('msie', '<9') === true) {
                            emptyCont = '&nbsp;';
                        }

                        Viper.Util.setHtml(elem, Viper.Util.getHtml(elem) +  '<' + blockTag + '>' + emptyCont + '</' + blockTag + '>');
                    }

                    try {
                        range.setStart(elem.firstChild, 0);
                        range.setEnd(elem.firstChild, 0);
                        range.collapse(false);
                        Viper.Selection.addRange(range);
                    } catch (e) {
                        // Ignore.
                    }
                }
            } else {
                var cleanedContent = this.cleanHTML(content);
                if (cleanedContent !== content) {
                    Viper.Util.setHtml(elem, cleanedContent);
                }

                var defaultTagName = this.getDefaultBlockTag();
                if (defaultTagName) {
                    var nodesToRemove = [];
                    var childNode     = elem.firstChild;
                    while (childNode) {
                        var child = childNode;
                        childNode = child.nextSibling;
                        if ((Viper.Util.isBlockElement(child) === true && Viper.Util.isStubElement(child) === false)
                            || (child.nodeType !== Viper.Util.ELEMENT_NODE && child.nodeType !== Viper.Util.TEXT_NODE)
                            || Viper.Util.isTag(child, 'hr') === true
                            || Viper.Util.isTag(child, 'iframe') === true
                            || Viper.Util.isTag(child, 'object') === true
                        ) {
                            continue;
                        } else if (child.nodeType === Viper.Util.TEXT_NODE && Viper.Util.trim(child.data) === '') {
                            nodesToRemove.push(child);
                            continue;
                        }

                        var p = null;
                        if (child.previousSibling && Viper.Util.isTag(child.previousSibling, defaultTagName) === true) {
                            p = child.previousSibling;
                        } else {
                            p = document.createElement(defaultTagName);
                            Viper.Util.insertBefore(child, p);
                        }

                        if (child.nodeType === Viper.Util.TEXT_NODE) {
                            child.data = Viper.Util.trim(child.data);
                        }

                        p.appendChild(child);
                    }//end for

                    Viper.Util.remove(nodesToRemove);

                    var range           = this.getCurrentRange();
                    var firstSelectable = range._getFirstSelectableChild(elem);
                    if (!firstSelectable && elem.childNodes.length > 0) {
                        for (var i = 0; i < elem.childNodes.length; i++) {
                            var child = elem.childNodes[i];
                            if (Viper.Util.isBlockElement(child) === true
                                && Viper.Util.isStubElement(child) === false
                                && Viper.Util.getHtml(child) === ''
                            ) {
                                Viper.Util.setHtml(child, '&nbsp;');
                            }
                        }
                    }
                }//end if
            }//end if

        },

        getEditableElement: function()
        {
            return this.element;

        },

        setMemberElements: function(elements)
        {
            this._memberElements = elements;

        },

        addMemberElements: function(elements)
        {
            this._memberElements.concat(elements);

        },

        isMemberElement: function(element)
        {
            var isMember = Viper.Util.inArray(element, this._memberElements);
            return isMember;

        },

        resetPlugins: function()
        {
            this._useDefaultPlugins();

        },

        _useDefaultPlugins: function()
        {
            // Default plugins (all Viper plugins).
            var plugins = 'ViperCoreStylesPlugin|ViperInlineToolbarPlugin|ViperHistoryPlugin|ViperListPlugin|ViperFormatPlugin|ViperToolbarPlugin|ViperCopyPastePlugin|ViperImagePlugin|ViperLinkPlugin|ViperAccessibilityPlugin|ViperSourceViewPlugin|ViperSearchReplacePlugin|ViperLangToolsPlugin|ViperCharMapPlugin|ViperCursorAssistPlugin|ViperReplacementPlugin|ViperTableEditorPlugin';
            this.PluginManager.setPlugins(plugins.split('|'));

            // Default button ordering.
            var buttons = [
                ['bold', 'italic', 'subscript', 'superscript', 'strikethrough', 'class'], 'removeFormat', ['justify', 'formats', 'headings'], ['undo', 'redo'], ['unorderedList', 'orderedList', 'indentList', 'outdentList'], 'insertTable', 'image', 'hr', ['insertLink', 'removeLink', 'anchor'], 'insertCharacter', 'searchReplace', 'langTools', 'accessibility', 'sourceEditor'
            ];
            this.getPluginManager().setPluginSettings('ViperToolbarPlugin', {buttons: buttons});

            var inlineToolbarButtons = [['bold', 'italic', 'class'], ['justify', 'formats', 'headings'], ['unorderedList', 'orderedList', 'indentList', 'outdentList'], ['insertLink', 'removeLink', 'anchor'], ['image', 'imageMove']];
            this.getPluginManager().setPluginSettings('ViperInlineToolbarPlugin', {buttons: inlineToolbarButtons});

            // Accessibility Plugin, standard.
            this.getPluginManager().setPluginSettings('ViperAccessibilityPlugin', {standard: 'WCAG2AA'});

            this.setSetting('defaultBlockTag', this.getDefaultBlockTag());

        },

        getViperElement: function()
        {
            return this.element;

        },

        getViperElementDocument: function()
        {
            return this.element.ownerDocument;

        },

        
        getCurrentRange: function()
        {
            var range          = Viper.Selection.getRangeAt(0);
            this._currentRange = range.cloneRange();
            return range;

        },

        
        getViperRange: function(element)
        {
            if (Viper.Util.isBrowser('msie') === false) {
                this.highlightToSelection(element);
            }

            if (this._viperRange) {
                return this._viperRange;
            }

            return this.getCurrentRange();

        },

        resetViperRange: function(range)
        {
            range            = range || null;
            this._viperRange = range;

        },

        
        selectElement: function(element)
        {
            var range = this.getViperRange();
            range.selectNode(element);
            Viper.Selection.addRange(range);

        },

        selectAll: function(elem)
        {
            elem      = elem || this.getViperElement();
            var range = this.getViperRange();

            if (!elem.firstChild) {
                return;
            }

            var start = elem.firstChild;
            if (start.nodeType !== Viper.Util.TEXT_NODE) {
                start = document.createTextNode('');
                Viper.Util.insertBefore(elem.firstChild, start);
            }

            var end = elem.lastChild;
            if (end.nodeType !== Viper.Util.TEXT_NODE) {
                end = document.createTextNode('');
                Viper.Util.insertAfter(elem.lastChild, end);
            }

            range.setStart(start, 0);
            range.setEnd(end, end.data.length);
            Viper.Selection.addRange(range);

        },

        getNodeSelection: function(range)
        {
            range = range || this.getViperRange();

            var nodeSelection = range.getNodeSelection();
            var node          = this.fireCallbacks('Viper:getNodeSelection', {range: range});

            if (node) {
                nodeSelection = node;
            }

            return nodeSelection;

        },

        addAttributeGetModifier: function (callback)
        {
            this._attributeGetModifiers.push(callback);

        },

        addAttributeSetModifier: function (callback)
        {
            this._attributeSetModifiers.push(callback);

        },

        
        getAttribute: function (element, attribute)
        {
            var value = element.getAttribute(attribute);

            var modifiersCount = this._attributeGetModifiers.length;
            if (modifiersCount > 0) {
                for (var i = 0; i < modifiersCount; i++) {
                    value = this._attributeGetModifiers[i].call(this, element, attribute, value);
                }
            }

            return value;

        },

        
        setAttribute: function(element, attribute, value, keepEmptyAttribute)
        {
            if (!element || !element.setAttribute) {
                return;
            }

            if (!value && keepEmptyAttribute !== true && Viper.Util.hasAttribute(element, attribute) === true) {
                element.removeAttribute(attribute);

                this.fireCallbacks('Viper:attributeRemoved', {element: element, attribute: attribute});

                if (Viper.Util.isTag(element, 'span') === true
                    && element.attributes
                    && element.attributes.length === 0
                ) {
                    var range        = this.getViperRange();
                    var selectedNode = range.getNodeSelection();

                    var firstSelectable = null;
                    var lastSelectable  = null;
                    if (selectedNode === element) {
                        // Select again.
                        firstSelectable = range._getFirstSelectableChild(element);
                        lastSelectable  = range._getLastSelectableChild(element);
                    }

                    while (element.firstChild) {
                        Viper.Util.insertBefore(element, element.firstChild);
                    }

                    Viper.Util.remove(element);

                    if (firstSelectable && lastSelectable) {
                        range.setStart(firstSelectable, 0);
                        range.setEnd(lastSelectable, lastSelectable.data.length);
                        Viper.Selection.addRange(range);
                        this.resetViperRange(range);
                    }
                }//end if
            } else if (value || keepEmptyAttribute === true) {
                var self           = this;
                var notModified    = true;
                var modifiersCount = this._attributeSetModifiers.length;
                if (modifiersCount > 0) {
                    this._retrievingValues++;
                    var doneCount          = 0;
                    for (var i = 0; i < modifiersCount; i++) {
                        notModified = this._attributeSetModifiers[i].call(
                            this,
                            element,
                            attribute,
                            value,
                            function() {
                                doneCount++;
                                if (doneCount === modifiersCount) {
                                    self._retrievingValues--;
                                    if (self._valuesRetrievedCallback) {
                                        self._valuesRetrievedCallback.call(self);
                                    }
                                }
                            }
                        );
                    }

                    if (notModified !== false) {
                        element.setAttribute(attribute, value);
                        self._retrievingValues--;
                        if (self._valuesRetrievedCallback) {
                            self._valuesRetrievedCallback.call(self);
                        }
                    }
                } else {
                    element.setAttribute(attribute, value);
                }//end if
            }//end if

        },

        
        moveCaretAway: function(sourceElement, back)
        {
            back      = back || false;
            var range = this.getViperRange();
            return range.moveCaretAway(sourceElement, this.getViperElement(), this.getDefaultBlockTag(), back);

        },


        
        getCaretCoords: function()
        {
            // TODO: Change this to range coords.
            var coords = {};
            try {
                var bookmark = this.createBookmark();
                Viper.Util.setStyle(bookmark.end, 'display', 'inline');
                coords = Viper.Util.getElementCoords(bookmark.end);
                Viper.Util.remove(bookmark.start);
                Viper.Util.remove(bookmark.end);
            } catch (e) {
                coords = {
                    x: -1,
                    y: -1
                };
            }

            return coords;

        },


        
        getRangeFromCoords: function(x, y)
        {
            var doc = this.getViperElement().ownerDocument;
            var range = null;
            if (doc.caretRangeFromPoint) {
                // Webkit.
                var rangeObj = doc.caretRangeFromPoint(x, y);
                range        = new Viper.MozRange(rangeObj);
            } else if (doc.caretPositionFromPoint) {
                // Firefox.
                var rangeObj = doc.caretPositionFromPoint(x, y);
                range        = this.getCurrentRange().cloneRange();
                range.setStart(rangeObj.offsetNode, rangeObj.offset);
                range.collapse(true);
            } else if (doc.body.createTextRange) {
                var rangeObj = doc.body.createTextRange();
                try {
                    rangeObj.moveToPoint(x, y);
                } catch (e) {
                }

                range = new Viper.IERange(rangeObj);

                if (Viper.doc.createRange) {
                    rangeObj         = Viper.doc.createRange();
                    var ieToMozRange = new Viper.MozRange(rangeObj);
                    ieToMozRange.setStart(range.startContainer, range.startOffset);
                    ieToMozRange.collapse(true);
                    range = ieToMozRange;
                }
            }//end if

            return range;

        },


        
        getElementAtCoords: function(x, y)
        {
            var elem = null;
            var doc  = this.getViperElement().ownerDocument;
            if (doc.caretRangeFromPoint) {
                // Webkit.
                var range = doc.caretRangeFromPoint(x, y);
                if (range) {
                    if (range.startContainer === range.endContainer
                        && range.startOffset === range.endOffset
                    ) {
                        if ((range.startContainer.nodeType !== Viper.Util.TEXT_NODE) && (range.startOffset < range.startContainer.childNodes.length)) {
                            elem = range.startContainer.childNodes[range.startOffset];
                        } else {
                            elem = range.startContainer;
                        }
                    }
                }
            } else if (doc.caretPositionFromPoint) {
                // Firefox.
                var range = doc.caretPositionFromPoint(x, y);
                if (range) {
                    if (Viper.Util.isBlockElement(range.offsetNode) === true) {
                        var offset = range.offset;
                        if (offset >= range.offsetNode.childNodes.length) {
                            offset = (range.offsetNode.childNodes.length - 1);
                        }

                        elem = range.offsetNode.childNodes[offset];
                    } else {
                        elem = range.offsetNode;
                    }
                }
            } else if (doc.body.createTextRange) {
                // IE.
                var range = doc.body.createTextRange();
                try {
                    range.moveToPoint(x, y);
                } catch (e) {
                    // Thrown usualy when the point is on an element like img.
                    return document.elementFromPoint(x, y);
                }

                elem = range.parentElement();
            }//end if

            return elem;

        },

        
        rangeInViperBounds: function(range)
        {
            range = range || this.getCurrentRange();
            if (range === null || this.isOutOfBounds(range.startContainer) || this.isOutOfBounds(range.endContainer)) {
                return false;
            }

            return true;

        },

        
        isOutOfBounds: function(element)
        {
            if (element === this.element || Viper.Util.isChildOf(element, this.element) === true) {
                return false;
            }

            return true;

        },

        isWholeViperElementSelected: function(range)
        {
            range = range || this.getViperRange();
            if (range.collapsed === false) {
                var viperElement    = this.getViperElement();
                var firstSelectable = range._getFirstSelectableChild(viperElement);
                if ((firstSelectable === range.startContainer || viperElement === range.startContainer) && range.startOffset === 0) {
                    var prevContainer   = range.getPreviousContainer(range.startContainer, null, false, true);
                    if (this.isOutOfBounds(prevContainer) === false) {
                        return false;
                    }

                    var nextContainer = range.getNextContainer(range.endContainer, null, false, true);
                    if (this.isOutOfBounds(nextContainer) === false) {
                        return false;
                    }

                    var lastSelectable  = range._getLastSelectableChild(viperElement);
                    if ((range.endContainer === viperElement && range.endOffset >= viperElement.childNodes.length)
                        || (range.endContainer === lastSelectable && range.endOffset === lastSelectable.data.length)
                    ) {
                        return true;
                    } else if (Viper.Util.isBrowser('msie', '8') === true
                        && range.endContainer === viperElement
                        && range.startContainer === firstSelectable
                        && range.startOffset === 0
                        && range.endOffset === 0
                    ) {
                        return true;
                    }
                }
            }

            return false;

        },

        
        insertNodeAtCaret: function(node, range)
        {
            range = range || this.getViperRange();

            // If we have any nodes highlighted, then we want to delete them before
            // inserting the new text.
            if (range.collapsed !== true) {
                if (Viper.Util.isBrowser('chrome') === true
                    && range.startOffset === 0
                    && range.startContainer === range._getFirstSelectableChild(this.element)
                    && range.endOffset === (this.element.childNodes.length - 1)
                ) {
                    // Whole editable container.
                    Viper.Util.setHtml(this.element, '');
                } else {
                    range.deleteContents();
                    Viper.Selection.addRange(range);
                }

                if (Viper.Util.trim(Viper.Util.getHtml(this.element)) === '') {
                    this.initEditableElement();
                }

                range = this.getCurrentRange();

                if (range.startContainer === range.endContainer
                    && this.element === range.startContainer
                    && range.startOffset === range.endOffset
                    && range.startOffset === 0
                ) {
                    // The whole editable element is selected. Need to remove everything
                    // and init its contents.
                    Viper.Util.empty(this.element);
                    this.initEditableElement();

                    // Update the range.
                    var firstSelectable = range._getFirstSelectableChild(this.element);
                    range.setStart(firstSelectable, 0);
                    range.collapse(true);
                }
            } else if (Viper.Util.isStubElement(range.startContainer.parentNode) === true) {
                var newNode = Viper.document.createTextNode('');
                Viper.Util.insertBefore(range.startContainer.parentNode, newNode);
                Viper.Util.remove(range.startContainer.parentNode);
                range.setStart(newNode, 0);
                range.collapse(true);
                Viper.Selection.addRange(range);
            }//end if

            if (typeof node === 'string') {
                if (node === '\r') {
                    return;
                }

                var newNode  = Viper.document.createTextNode(node);
                var noBlock  = true;
                newRange = range;

                if (newRange.collapsed === true
                    && newRange.startContainer.parentNode
                    && newRange.startContainer.parentNode.firstChild.nodeType === Viper.Util.TEXT_NODE
                    && newRange.startContainer.parentNode.firstChild === newRange.startContainer.parentNode.lastChild
                    && Viper.Util.trim(newRange.startContainer.parentNode.firstChild.data) === ''
                ) {
                    newRange.setStart(newRange.startContainer.parentNode.firstChild, 0);
                    newRange.collapse(true);
                    newRange.startContainer.parentNode.firstChild.data = '';
                } else if (newRange.collapsed === true
                    && Viper.Util.isStubElement(newRange.startContainer) === true
                ) {
                    var tmpTextNode = Viper.document.createTextNode('');
                    Viper.Util.insertBefore(newRange.startContainer, tmpTextNode);
                    Viper.Util.remove(newRange.startContainer);
                    newRange.setStart(tmpTextNode, 0);
                    newRange.collapse(true);
                }

                if (this.fireCallbacks('Viper:nodesInserted', {node: newNode, range: newRange}) === false) {
                    noBlock = false;
                }

                if (noBlock === false) {
                    return false;
                }

                this.contentChanged();
                return;
            } else {
                // We need to import nodes from a document fragment into the current
                // this._document, so that we don't have document fragments within our this._document,
                // as they don't have parentNodes and are hard to work with.
                if (node.nodeType === Viper.Util.DOCUMENT_FRAGMENT_NODE) {
                    if (Viper.Util.isBrowser('msie', '<11') === true) {
                        // Insert a marker span tag to the caret positioon.
                        range.rangeObj.pasteHTML('<span id="__viperMarker"></span>');
                        var marker = Viper.Util.getid('__viperMarker');

                        // Put the node contents after the marker.
                        Viper.Util.insertAfter(marker, node);

                        // Remove the marker.
                        Viper.Util.remove(marker);
                        range.collapse(false);
                        return;
                    } else {
                        var newNode = null;
                        var clen    = node.childNodes.length;
                        for (var i = 0; i < clen; i++) {
                            var child = node.childNodes[i];

                            // We need to skip text nodes that don't represent any content
                            // as if they exist as the last node in the fragment, we won't
                            // be able to set the end of the range to that node.
                            if (child.nodeType === Viper.Util.TEXT_NODE) {
                                if (Viper.Util.trim(child.data) === '') {
                                    continue;
                                }
                            }

                            newNode = Viper.document.importNode(child, true);
                            range.insertNode(newNode);

                            // We need to move to the end of the new node after insertion.
                            // Otherwise next node will be inserted before this one.
                            range.selectNode(newNode);
                            range.collapse(false);
                        }//end for

                        node = newNode;
                        range.moveEnd('character', -1);
                        range.moveEnd('character', 1);
                        range.collapse(false);
                        return;
                    }//end if
                } else if (Viper.Util.isStubElement(range.startContainer) === true) {
                    Viper.Util.insertBefore(range.startContainer, node);
                } else {
                    range.insertNode(node);
                }//end if

                range.setEndAfter(node, (this._getNodeOffset(node) + 1));
                range.collapse(false);
            }//end if

        },

        
        insertTextAtCaret: function(text)
        {
            if (typeof text !== 'string') {
                throw('InvalidArgumentException: text must be a string');
            }

            return this.insertNodeAtCaret(text);

        },

        
        deleteRangeContent: function()
        {
            var range = this.getViperRange();
            if (this.KeyboardHandler.handleDelete() !== false) {
                range.deleteContents();
                Viper.Selection.addRange(range);
            }

            // Get the updated range.
            range = this.getViperRange();
            return range;

        },

        
        _getNodeOffset: function(node)
        {
            var nodes = node.parentNode.childNodes;
            var ln    = nodes.length;
            for (var i = 0; i < ln; i++) {
                if (nodes[i] === node) {
                    return i;
                }
            }

        },

        
        createUneditableElement: function (options) {
            if (!options) {
                options = {};
            }

            var tagName = options.tagName || 'span';
            var content = options.content || '';

            var elem = document.createElement(tagName);

            // Disable editing.
            Viper.Util.attr(elem, 'contenteditable', false);

            Viper.Util.setHtml(elem, content);

            if (options.attributes) {
                for (var attrName in options.attributes) {
                    Viper.Util.attr(elem, attrName, options.attributes[attrName]);
                }
            }

            return elem;

        },

        makeElementUneditable: function (element) {
            Viper.Util.attr(element, 'contenteditable', false);

        },

        
        surroundContents: function(tag, attributes, range, keepSelection)
        {
            range = range || this.getCurrentRange();

            if (range.collapsed === true) {
                return;
            }

            if (this.rangeInViperBounds(range) !== true) {
                return;
            }

            var otag           = tag;
            var startContainer = range.getStartNode();
            var endContainer   = range.getEndNode();
            var nodeSelection  = range.getNodeSelection(null, true);

            // Selected contents from same node.
            if (nodeSelection) {
                // Get the most outer surrounding parent which is not a block element.
                var parents = Viper.Util.getSurroundingParents(nodeSelection, null, 'inline', this.getViperElement());
                if (parents.length > 0 || Viper.Util.isBlockElement(nodeSelection) === false && Viper.Util.isStubElement(nodeSelection) === false) {
                    if (parents.length > 0) {
                        nodeSelection = parents.pop();
                    }

                    var node = Viper.document.createElement(tag);
                    this._setWrapperElemAttributes(node, attributes);
                    Viper.Util.insertBefore(nodeSelection, node);
                    node.appendChild(nodeSelection);

                    if (keepSelection !== true) {
                        range.setStart(range._getFirstSelectableChild(node), 0);
                        range.setEnd(range._getLastSelectableChild(node), range._getLastSelectableChild(node).data.length);
                        Viper.Selection.addRange(range);
                    }

                    return node;
                }
            }

            if (startContainer === endContainer) {
                if (startContainer.nodeType === Viper.Util.TEXT_NODE) {
                    // Selection is a text node.
                    // Just wrap the contents with the specified node.
                    var node = Viper.document.createElement(tag);
                    this._setWrapperElemAttributes(node, attributes);

                    var rangeContent = range.toString();
                    Viper.Util.setNodeTextContent(node, rangeContent);

                    range.deleteContents();
                    range.insertNode(node);

                    var textNode = node.firstChild;

                    if (!attributes && Viper.Util.isTag(node.previousSibling, tag) === true) {
                        // Move contents to previous sibling.
                        Viper.Util.moveChildrenToElement(node, node.previousSibling);
                        node = node.previousSibling;
                        Viper.Util.remove(node.nextSibling);
                    }

                    // Check if the next sibling is the same tag.
                    if (!attributes && Viper.Util.isTag(node.nextSibling, tag) === true) {
                        Viper.Util.moveChildrenToElement(node.nextSibling, node);
                        Viper.Util.remove(node.nextSibling);
                    }

                    if (keepSelection !== true) {
                        range.setStart(textNode, 0);
                        range.setEnd(textNode, textNode.data.length);
                        Viper.Selection.addRange(range);
                    }

                    return node;
                } else {
                    var self = this;
                    this._wrapElement(startContainer.childNodes[range.startOffset], tag, null, attributes);
                }//end if
            } else {
                if (nodeSelection && Viper.Util.isBlockElement(nodeSelection) === false && nodeSelection.nodeType !== Viper.Util.TEXT_NODE) {
                    var newElement = document.createElement(otag);
                    this._setWrapperElemAttributes(newElement, attributes);

                    while (nodeSelection.firstChild) {
                        newElement.appendChild(nodeSelection.firstChild);
                    }

                    nodeSelection.appendChild(newElement);

                    range.selectNode(newElement);
                    Viper.Selection.addRange(range);

                    return newElement;
                } else if (startContainer.nodeType === Viper.Util.TEXT_NODE
                    && this.getViperElement().firstChild === startContainer
                    && Viper.Util.trim(startContainer.data) === ''
                ) {
                    startContainer = range._getFirstSelectableChild(this.getViperElement());
                }

                var startBlockParent = Viper.Util.getFirstBlockParent(startContainer);
                if (!endContainer) {
                    if (range.endContainer === this.getViperElement()
                        && range.endContainer.childNodes
                        && !range.endContainer.childNodes[range.endOffset]
                    ) {
                        endContainer = range._getLastSelectableChild(this.getViperElement());
                    } else {
                        endContainer = startContainer;
                    }
                }

                var rangeContents  = range.getHTMLContentsObj();
                var endBlockParent = Viper.Util.getFirstBlockParent(endContainer);
                var bookmark       = this.createBookmark();

                if (startBlockParent === endBlockParent
                    && !nodeSelection
                ) {
                    if (!bookmark.start.previousSibling
                        && bookmark.start.parentNode !== startBlockParent
                    ) {
                        // Move bookmark outside of its parent.
                        Viper.Util.insertBefore(bookmark.start.parentNode, bookmark.start);
                    }

                    if (!bookmark.end.nextSibling
                        && bookmark.end.parentNode !== endBlockParent
                    ) {
                        // Move bookmark outside of its parent.
                        Viper.Util.insertAfter(bookmark.end.parentNode, bookmark.end);
                    }

                    var elements = Viper.Util.getElementsBetween(bookmark.start, bookmark.end);
                    Viper.Util.remove(elements);

                    if (!bookmark.start.nextSibling) {
                        var parent = bookmark.start.parentNode;
                        while (!parent.nextSibling) {
                            parent = parent.parentNode;
                        }

                        Viper.Util.insertAfter(parent, bookmark.start);
                    }

                    if (!bookmark.end.previousSibling) {
                        var parent = bookmark.end.parentNode;
                        while (!parent.previousSibling) {
                            parent = parent.parentNode;
                        }

                        Viper.Util.insertBefore(parent, bookmark.end);
                    }

                    var newElement = null;
                    if (otag !== 'span'
                        && bookmark.start.previousSibling
                        && Viper.Util.isTag(bookmark.start.previousSibling, otag) === true
                    ) {
                        // If the previous element is the same tag then just join to it.
                        newElement = bookmark.start.previousSibling;
                        newElement.appendChild(bookmark.start);
                        while (rangeContents.firstChild) {
                            newElement.appendChild(rangeContents.firstChild);
                        }

                        newElement.appendChild(bookmark.end);
                    } else if (otag !== 'span'
                        && bookmark.end.nextSibling
                        && Viper.Util.isTag(bookmark.end.nextSibling, otag) === true
                    ) {
                        // If the next element is the same tag then just join to it.
                        newElement = bookmark.end.nextSibling;
                        if (newElement.firstChild) {
                            Viper.Util.insertBefore(newElement.firstChild, bookmark.end);
                        } else {
                            newElement.appendChild(bookmark.end);
                        }

                        while (rangeContents.lastChild) {
                            Viper.Util.insertBefore(newElement.firstChild, rangeContents.lastChild);
                        }

                        Viper.Util.insertBefore(newElement.firstChild, bookmark.start);
                    } else {
                        // Create a new element.
                        newElement = document.createElement(otag);
                        Viper.Util.insertAfter(bookmark.start, newElement);

                        while (rangeContents.firstChild) {
                            newElement.appendChild(rangeContents.firstChild);
                        }
                    }//end if

                    this._setWrapperElemAttributes(newElement, attributes);

                    // Remove same nested tags.
                    var nestedTags      = Viper.Util.getTag(otag, newElement);
                    var nestedTagsCount = nestedTags.length;
                    for (var i = 0; i < nestedTagsCount; i++) {
                        if (this.isBookmarkElement(nestedTags[i]) === true || otag === 'span') {
                            continue;
                        }

                        while (nestedTags[i].firstChild) {
                            Viper.Util.insertBefore(nestedTags[i], nestedTags[i].firstChild);
                        }

                        Viper.Util.remove(nestedTags[i]);
                    }

                    if (keepSelection !== true) {
                        this.selectBookmark(bookmark);
                    } else {
                        Viper.Util.remove(bookmark.start);
                        Viper.Util.remove(bookmark.end);
                    }

                    return newElement;
                }//end if

                var startContainer = null;
                var endContainer   = null;
                startContainer     = bookmark.start.previousSibling;
                endContainer       = bookmark.end.nextSibling;
                if (!endContainer) {
                    // If the bookmark.end is at the end of another tag move it outside.
                    var bookmarkEnd = bookmark.end.parentNode;
                    while (bookmarkEnd) {
                        if (bookmark.start.parentNode === bookmarkEnd.parentNode) {
                            Viper.Util.insertAfter(bookmarkEnd, bookmark.end);
                            break;
                        } else if (bookmark.end.nextSibling || bookmarkEnd === this.getViperElement()) {
                            // Not the last node in this parent so we cannot move it.
                            break;
                        } else {
                            Viper.Util.insertAfter(bookmarkEnd, bookmark.end);
                            if (bookmark.end.nextSibling) {
                                break;
                            } else {
                                bookmarkEnd = bookmark.end.parentNode;
                            }
                        }
                    }

                    endContainer = Viper.document.createTextNode('');
                    Viper.Util.insertAfter(bookmark.end, endContainer);
                }//end if

                if (!startContainer) {
                    // If the bookmark.end is at the end of another tag move it outside.
                    var bookmarkStart = bookmark.start.parentNode;
                    while (bookmarkStart) {
                        if (bookmark.end.parentNode === bookmarkStart.parentNode) {
                            Viper.Util.insertBefore(bookmarkStart, bookmark.start);
                            break;
                        } else if (bookmarkStart.previousSibling || bookmarkStart === this.getViperElement()) {
                            // Not the last node in this parent so we cannot move it.
                            break;
                        }

                        bookmarkStart = bookmarkStart.parentNode;
                    }

                    startContainer = Viper.document.createTextNode('');
                    Viper.Util.insertBefore(bookmark.start, startContainer);
                }

                var elements = Viper.Util.getElementsBetween(startContainer, endContainer);
                var c        = elements.length;
                var self     = this;

                for (var i = 0; i < c; i++) {
                    this._wrapElement(elements[i], tag, null, attributes);
                }

                if (keepSelection !== true) {
                    this.selectBookmark(bookmark);
                } else {
                    Viper.Util.remove(bookmark.start);
                    Viper.Util.remove(bookmark.end);
                }
            }//end if

        },

        
        _wrapElement: function(parent, tag, callback, attributes)
        {
            if (!parent) {
                return;
            } else if (Viper.Util.attr(parent, 'viperbookmark')) {
                return;
            } else if (parent.nodeType === Viper.Util.COMMENT_NODE) {
                if (callback) {
                    callback.call(this, parent);
                }

                return;
            }

            if (!attributes && Viper.Util.getParents(parent, tag).length > 0) {
                // This element is already inside the specified tag.
                // TODO: This may cause problems with spans etc and may need to check
                // specific attributes as well.
                // Also, what if we do want to wrap the element anyway? Have force option?
                return;
            }

            if (parent.nodeType === Viper.Util.TEXT_NODE) {
                if (Viper.Util.isBlank(parent.data) !== true) {
                    if (parent.previousSibling && parent.previousSibling.nodeType === Viper.Util.TEXT_NODE) {
                        if (parent.previousSibling.nodeValue === '') {
                            Viper.Util.remove(parent.previousSibling);
                        }
                    }

                    // If the previous/next sibling is type of specified tag then
                    // add this text node to that sibling.
                    if (parent.previousSibling
                        && Viper.Util.isTag(parent.previousSibling, tag) === true
                        && !Viper.Util.attr(parent.previousSibling, 'viperbookmark')
                        && (!attributes || attributes.cssClass !== '__viper_selHighlight')
                    ) {
                        // Add it to the preivous sibling.
                        parent.previousSibling.appendChild(parent);
                    } else if (parent.nextSibling
                        && Viper.Util.isTag(parent.nextSibling, tag) === true
                        && !Viper.Util.attr(parent.nextSibling, 'viperbookmark')
                        && (!attributes || attributes.cssClass !== '__viper_selHighlight')
                    ) {
                        if (parent.nextSibling.firstChild) {
                            // Add it before the first child of the next sibling.
                            Viper.Util.insertBefore(parent.nextSibling.firstChild, parent);
                        } else {
                            // Add it to the next sibling.
                            parent.nextSibling.appendChild(parent);
                        }
                    } else {
                        // Create the tag and add it to DOM.
                        var elem = Viper.document.createElement(tag);
                        this._setWrapperElemAttributes(elem, attributes);

                        Viper.Util.setNodeTextContent(elem, parent.nodeValue);
                        Viper.Util.insertBefore(parent, elem);
                        Viper.Util.remove(parent);

                        if (callback) {
                            callback.call(this, elem);
                        }
                    }//end if
                } else if (parent.previousSibling
                    && Viper.Util.isTag(parent.previousSibling, tag) === true
                    && !Viper.Util.attr(parent.previousSibling, 'viperbookmark')
                ) {
                    parent.previousSibling.appendChild(parent);
                }//end if
            } else if (Viper.Util.isStubElement(parent) === false) {
                if (Viper.Util.isBlockElement(parent) === false && Viper.Util.hasBlockChildren(parent) === false) {
                    if (Viper.Util.isTag(parent, tag) !== true) {
                        // Does not have any block elements, so we can
                        // wrap the content inside the specified tag.
                        if (parent.previousSibling
                            && parent.previousSibling.tagName
                            && parent.previousSibling.tagName.toLowerCase() === tag
                            && Viper.Util.isBlockElement(parent) === false
                            && !Viper.Util.attr(parent.previousSibling, 'viperbookmark')) {
                            parent.previousSibling.appendChild(parent);
                        } else {
                            var elem = Viper.document.createElement(tag);
                            this._setWrapperElemAttributes(elem, attributes);

                            Viper.Util.insertBefore(parent, elem);
                            elem.appendChild(parent);
                            this.removeTagFromChildren(elem, tag);

                            if (callback) {
                                callback.call(this, elem);
                            }
                        }
                    } else if (!parent.firstChild) {
                        // This is the tag we want however its empty, remove it.
                        parent.parentNode.removeChild(parent);
                    } else if (parent.previousSibling
                        && Viper.Util.isTag(parent.previousSibling, tag) === true
                        && !Viper.Util.attr(parent.previousSibling, 'viperbookmark')
                    ) {
                        // This is the tag we are looking for but there is already one
                        // of these tags before this one so move its children to that tag.
                        while (parent.firstChild) {
                            parent.previousSibling.appendChild(parent.firstChild);
                        }

                        parent.parentNode.removeChild(parent);
                    }//end if
                } else {
                    // Because the node contains block level elements
                    // we have to find the non block elements and wrap content around them.
                    var c        = parent.childNodes.length;
                    var children = [];
                    for (var i = 0; i < c; i++) {
                        children.push(parent.childNodes[i]);
                    }

                    for (var i = 0; i < c; i++) {
                        this._wrapElement(children[i], tag, callback, attributes);
                    }
                }//end if
            }//end if

        },

        _setWrapperElemAttributes: function(element, attributes)
        {
            if (!element || !attributes) {
                return;
            }

            if (attributes.cssClass) {
                Viper.Util.addClass(element, attributes.cssClass);
            }

            if (attributes.attributes) {
                for (var attr in attributes.attributes) {
                    this.setAttribute(element, attr, attributes.attributes[attr]);
                }
            }

        },


        
        removeTagFromChildren: function(parent, tag, incParent)
        {
            var c          = parent.childNodes.length;
            var childNodes = [];
            for (var i = 0; i < c; i++) {
                childNodes.push(parent.childNodes[i]);
            }

            for (var i = 0; i < c; i++) {
                var child = childNodes[i];
                if (child.nodeType === Viper.Util.ELEMENT_NODE) {
                    this.removeTagFromChildren(child, tag, true);
                }
            }

            if (incParent === true) {
                this.removeTag(parent, tag);
            }

        },

        removeTag: function(elem, tag)
        {
            if (elem.parentNode && elem.parentNode.nodeType === Viper.Util.ELEMENT_NODE) {
                if (elem.nodeType === Viper.Util.ELEMENT_NODE) {
                    if (elem.tagName.toLowerCase() === tag) {
                        var span = null;
                        while (elem.firstChild) {
                            if (span !== null) {
                                span.appendChild(elem.firstChild);
                            } else {
                                Viper.Util.insertBefore(elem, elem.firstChild);
                            }
                        }

                        Viper.Util.remove(elem);
                    }
                }//end if
            }//end if

        },

        removeStylesBetweenElems: function(start, end, style, range)
        {
            var elems = Viper.Util.getElementsBetween(start, end, range);
            elems.unshift(start);
            var len = elems.length;
            for (var i = 0; i < len; i++) {
                this.removeTagFromChildren(elems[i], style, true);
            }

        },

        removeStyle: function(style, nodeSelection)
        {
            var range         = this.getViperRange();
            range             = this.adjustRange(range);
            var startNode     = range.getStartNode();
            var endNode       = range.getEndNode();
            var viperElement  = this.getViperElement();
            var nodeSelection = nodeSelection || range.getNodeSelection();

            if (nodeSelection) {
                var startSelNode = range._getFirstSelectableChild(nodeSelection);
                var endSelNode   = range._getLastSelectableChild(nodeSelection);

                // A whole node is selected. Remove all nested style tags and the node it self its the same tag.
                var styleTags = Viper.Util.getTag(style, nodeSelection);
                var sln       = styleTags.length;
                for (var i = 0; i < sln; i++) {
                    while (styleTags[i].firstChild) {
                        Viper.Util.insertBefore(styleTags[i], styleTags[i].firstChild);
                    }

                    Viper.Util.remove(styleTags[i]);
                }

                // Check the surrounding parents.
                var surrounding = Viper.Util.getSurroundingParents(nodeSelection, style, null, this.getViperElement());
                for (var i = 0; i < surrounding.length; i++) {
                    if (Viper.Util.isTag(surrounding[i], style) === true) {
                        while (surrounding[i].firstChild) {
                            Viper.Util.insertBefore(surrounding[i], surrounding[i].firstChild);
                        }

                        Viper.Util.remove(surrounding[i]);
                    }
                }

                if (Viper.Util.isTag(nodeSelection, style) === true) {
                    // This node is the style tag, move all its child nodes and delete it.
                    while (nodeSelection.firstChild) {
                        Viper.Util.insertBefore(nodeSelection, nodeSelection.firstChild);
                    }

                    Viper.Util.remove(nodeSelection);
                }

                // Check if it has a parent with this style, if not stop here.
                if (Viper.Util.getParents(nodeSelection, style, this.getViperElement()).length === 0) {
                    range.setStart(startSelNode, 0);
                    range.setEnd(endSelNode, endSelNode.data.length);

                    Viper.Selection.addRange(range);
                    return;
                }
            }//end if

            // Create bookmark and update the start and end nodes incase bookmark updated the range.
            var bookmark = this.createBookmark(range);
            startNode    = range.getStartNode();
            endNode      = range.getEndNode();

            if (startNode.nodeType === Viper.Util.TEXT_NODE
                && Viper.Util.trim(startNode.data) === ''
                && startNode === viperElement.firstChild
            ) {
                // Firefox sets the first child to be a textNode with \n as its content
                // if whole content is selected. Get the first selectable child.
                startNode = range._getFirstSelectableChild(viperElement);

                if (Viper.Util.isBrowser('msie') === true) {
                    range.setStart(startNode, 0);
                }
            }

            if (!endNode) {
                endNode = startNode;
            }

            this.removeStylesBetweenElems(startNode, endNode, style, range);

            var startParents = Viper.Util.getParents(bookmark.start, style, this.element);
            var endParents   = Viper.Util.getParents(bookmark.end, style, this.element);

            if (startParents.length === 0 && endParents.length === 0) {
                // Start and End is not inside of style tag, so we are done.
                Viper.Selection.addRange(range);
                this.removeBookmarks();
                return;
            }

            // Bookmark and get the top style parents.
            var startTopParent = startParents.pop();
            var endTopParent   = endParents.pop();

            if (startTopParent === endTopParent) {
                var start     = Viper.Util.cloneNode(startTopParent);
                var selection = Viper.Util.cloneNode(startTopParent);
                var end       = Viper.Util.cloneNode(startTopParent);

                // First remove everything from start bookmark to last child.
                var lastChild    = Viper.Util.getLastChildTextNode(start);
                var elemsBetween = Viper.Util.getElementsBetween(this.getBookmark(start, 'start'), lastChild);
                elemsBetween.push(this.getBookmark(start, 'start'));
                elemsBetween.push(this.getBookmark(start, 'end'));
                elemsBetween.push(lastChild);
                Viper.Util.remove(elemsBetween);

                // Remove everything from first child to end bookmark.
                var firstChild   = Viper.Util.getFirstChildTextNode(end);
                var elemsBetween = Viper.Util.getElementsBetween(firstChild, this.getBookmark(end, 'end'));
                elemsBetween.push(this.getBookmark(end, 'end'));
                elemsBetween.push(this.getBookmark(end, 'start'));
                elemsBetween.push(firstChild);
                Viper.Util.remove(elemsBetween);

                // Remove everything before and after bookmark start and end.
                var firstChild   = Viper.Util.getFirstChildTextNode(selection);
                var elemsBetween = Viper.Util.getElementsBetween(firstChild, this.getBookmark(selection, 'start'));
                elemsBetween.push(firstChild);
                Viper.Util.remove(elemsBetween);
                var lastChild    = Viper.Util.getLastChildTextNode(selection);
                var elemsBetween = Viper.Util.getElementsBetween(this.getBookmark(selection, 'end'), lastChild);
                elemsBetween.push(lastChild);
                Viper.Util.remove(elemsBetween);

                var div = Viper.document.createElement('div');
                div.appendChild(selection);
                this.removeTagFromChildren(div, style, true);

                Viper.Util.removeEmptyNodes(start);
                Viper.Util.removeEmptyNodes(end);

                Viper.Util.removeEmptyNodes(div, function(elToDel) {
                    if (Viper.Util.isTag(elToDel, 'span') === true
                        && Viper.Util.hasClass(elToDel, 'viperBookmark') === true
                    ) {
                        // Do not remove bookmark.
                        return false;
                    }
                });

                if (start.firstChild) {
                    if (Viper.Util.isBlank(Viper.Util.getNodeTextContent(start)) !== true) {
                        Viper.Util.insertBefore(startTopParent, start);
                    } else {
                        while (start.firstChild) {
                            Viper.Util.insertBefore(startTopParent, start.firstChild);
                        }
                    }
                }

                Viper.Util.insertBefore(startTopParent, div.childNodes);

                if (end.firstChild) {
                    if (Viper.Util.isBlank(Viper.Util.getNodeTextContent(end)) !== true) {
                        Viper.Util.insertBefore(startTopParent, end);
                    } else {
                        while (end.firstChild) {
                            Viper.Util.insertBefore(startTopParent, end.firstChild);
                        }
                    }
                }

                Viper.Util.remove(startTopParent);

                var originalBookmark = {
                    start: this.getBookmark(this.element, 'start'),
                    end: this.getBookmark(this.element, 'end')
                };

                this.selectBookmark(originalBookmark);
                return;
            }//end if

            // Start of selection is in the style tag.
            if (startTopParent) {
                var clone = Viper.Util.cloneNode(startTopParent);

                // Remove everything from bookmark to lastChild (inclusive).
                var lastChild    = Viper.Util.getLastChildTextNode(startTopParent);
                var elemsBetween = Viper.Util.getElementsBetween(bookmark.start, lastChild);
                elemsBetween.push(bookmark.start);
                elemsBetween.push(lastChild);
                Viper.Util.remove(elemsBetween);

                // From the cloned node, remove everything from firstChild to start bookmark.
                var firstChild = Viper.Util.getFirstChildTextNode(clone);
                elemsBetween   = Viper.Util.getElementsBetween(firstChild, this.getBookmark(clone, 'start'));
                elemsBetween.push(firstChild);
                Viper.Util.remove(elemsBetween);

                // Wrap the clone in to a div then remove its style tag.
                var div = Viper.document.createElement('div');
                div.appendChild(clone);
                this.removeTagFromChildren(div, style);
                Viper.Util.insertAfter(startTopParent, div.childNodes);

                if (Viper.Util.isTag(startTopParent, style) === true) {
                    this.removeEmptyNodes(startTopParent);
                    if (startTopParent.childNodes.length === 0) {
                        Viper.Util.remove(startTopParent);
                    }
                }
            }//end if

            // End of selection is in the style tag.
            if (endTopParent) {
                var clone = Viper.Util.cloneNode(endTopParent);

                // Remove everything from firstChild to bookmark (inclusive).
                var firstChild   = Viper.Util.getFirstChildTextNode(endTopParent);
                var elemsBetween = Viper.Util.getElementsBetween(firstChild, bookmark.end);
                elemsBetween.push(firstChild);
                Viper.Util.remove(elemsBetween);

                // From the cloned node, remove everything from end bookmark to lastChild.
                var lastChild = Viper.Util.getLastChildTextNode(clone);
                elemsBetween  = Viper.Util.getElementsBetween(this.getBookmark(clone, 'end'), lastChild);
                elemsBetween.push(lastChild);
                Viper.Util.remove(elemsBetween);

                // Wrap the clone in to a div then remove its style tag.
                var div = Viper.document.createElement('div');
                div.appendChild(clone);
                this.removeTagFromChildren(div, style);
                Viper.Util.insertBefore(endTopParent, div.childNodes);

                if (Viper.Util.isTag(endTopParent, style) === true) {
                    this.removeEmptyNodes(endTopParent);
                    if (endTopParent.childNodes.length === 0) {
                        Viper.Util.remove(endTopParent);
                    }
                }
            }//end if

            var originalBookmark = {
                start: this.getBookmark(this.element, 'start'),
                end: this.getBookmark(this.element, 'end')
            };

            this.selectBookmark(originalBookmark);

        },

        
        setCaretAfterNode: function(node)
        {
            if (!node || !node.parentNode) {
                return false;
            }

            var range = this.getCurrentRange();
            if (node.nextSibling && node.nextSibling.nodeType === Viper.Util.TEXT_NODE) {
                // Next sibling is a textnode so move the caret to that node.
                node = node.nextSibling;
            } else {
                var text = null;
                if (node.nextSibling) {
                    text = Viper.Util.getFirstChildTextNode(node.nextSibling);
                }

                if (!text) {
                    // Create a new text node and set the caret to that node.
                    text = Viper.document.createTextNode(String.fromCharCode(160));
                    Viper.Util.insertAfter(node, text);
                }

                node = text;
            }

            range.setStart(node, 0);
            range.collapse(true);
            Viper.Selection.addRange(range);

            this.fireCaretUpdated();

            return true;

        },

        createSpaceNode: function()
        {
            var node = null;
            if (Viper.Util.isBrowser('msie', '<11') === true) {
                node = Viper.document.createTextNode(String.fromCharCode(160));
            } else {
                node = Viper.document.createTextNode(' ');
            }

            return node;

        },

        
        insertAfter: function(node, newNode)
        {
            // Fire beforeInsertAfter.
            this.fireCallbacks('Viper:beforeInsertAfter', {node: node, newNode: newNode});

            Viper.Util.insertAfter(node, newNode);

            this.contentChanged(true);

        },

        
        insertBefore: function(node, newNode)
        {
            // Fire beforeInsertAfter.
            this.fireCallbacks('Viper:beforeInsertBefore', {node: node, newNode: newNode});

            Viper.Util.insertBefore(node, newNode);

            this.contentChanged(true);

        },


        selectBookmark: function(bookmark)
        {
            this.blurActiveElement();

            var range       = this.getCurrentRange();
            var startPos    = null;
            var endPos      = null;
            var startOffset = 0;
            var endOffset   = 0;
            if (bookmark.start.nextSibling === bookmark.end
                || Viper.Util.getElementsBetween(bookmark.start, bookmark.end).length === 0
            ) {
                // Bookmark is collapsed.
                // Pick the best node to select. Make sure that if next sibling is block element the previous sibling is not
                // then use the previous sibling.
                if (bookmark.end.nextSibling
                    && (Viper.Util.isBlockElement(bookmark.end.nextSibling) === false || !bookmark.start.previousSibling || Viper.Util.isBlockElement(bookmark.start.previousSibling))
                ) {
                    if ((Viper.Util.isTag(bookmark.end.nextSibling, 'span') !== true || Viper.Util.hasClass(bookmark.end.nextSibling, 'viperBookmark') === false)) {
                        if (Viper.Util.isStubElement(bookmark.end.nextSibling) === false) {
                            startPos = Viper.Util.getFirstChildTextNode(bookmark.end.nextSibling);
                        } else if (Viper.Util.isTag(bookmark.end.nextSibling, 'br') === true) {
                            startPos = bookmark.end.nextSibling;
                        } else {
                            startPos = document.createTextNode('');
                            Viper.Util.insertAfter(bookmark.end, startPos);
                        }
                    } else {
                        startPos = document.createTextNode('');
                        Viper.Util.insertAfter(bookmark.end, startPos);
                    }
                } else if (bookmark.start.previousSibling) {
                    startPos = Viper.Util.getFirstChildTextNode(bookmark.start.previousSibling);
                    if (startPos && startPos.nodeType === Viper.Util.TEXT_NODE) {
                        startOffset = startPos.length;
                    }
                } else {
                    // Create a text node in parent.
                    bookmark.end.parentNode.appendChild(Viper.document.createTextNode(''));
                    startPos = Viper.Util.getFirstChildTextNode(bookmark.end.nextSibling);
                }
            } else {
                if (bookmark.start.nextSibling) {
                    // Find the next non empty text node.
                    startPos = Viper.Util.getFirstChildTextNode(bookmark.start.nextSibling);
                    if (startPos && startPos.nodeType === Viper.Util.TEXT_NODE) {
                        while (startPos && startPos.data.length === 0 && startPos.nextSibling) {
                            startPos = Viper.Util.getFirstChildTextNode(startPos.nextSibling);
                        }
                    } else {
                        // Handle situation where there is no first text node.
                        var tmpTextNode = document.createTextNode('');
                        Viper.Util.insertBefore(bookmark.start.nextSibling, tmpTextNode);
                        startPos    = tmpTextNode;
                        startOffset = 0;
                    }
                } else {
                    if (!bookmark.start.previousSibling) {
                        var tmp = Viper.document.createTextNode('');
                        Viper.Util.insertBefore(bookmark.start, tmp);
                    }

                    startPos    = Viper.Util.getLastChildTextNode(bookmark.start.previousSibling);
                    startOffset = startPos.length;
                }

                if (bookmark.end.previousSibling) {
                    // Find the previous non empty text node.
                    endPos = Viper.Util.getLastChildTextNode(bookmark.end.previousSibling);
                    if (endPos && endPos.nodeType === Viper.Util.TEXT_NODE) {
                        while (endPos && endPos.data.length === 0 && endPos.previousSibling) {
                            endPos = Viper.Util.getLastChildTextNode(endPos.previousSibling);
                        }

                        if (endPos.data) {
                            endOffset = endPos.data.length;
                        }
                    } else {
                        // Handle situation where there is no last text node.
                        var tmpTextNode = document.createTextNode('');
                        Viper.Util.insertAfter(bookmark.end.previousSibling, tmpTextNode);
                        endPos    = tmpTextNode;
                        endOffset = 0;
                    }
                } else {
                    endPos    = Viper.Util.getFirstChildTextNode(bookmark.end.nextSibling);
                    endOffset = 0;
                }
            }//end if

            Viper.Util.remove([bookmark.start, bookmark.end]);

            if (endPos === null) {
                range.setStart(startPos, startOffset);
                range.setEnd(startPos, startOffset);
                range.collapse(false);
            } else {
                var length = 0;

                if (Viper.Util.isStubElement(startPos) === true) {
                    // Image etc.
                    Viper.Selection.removeAllRanges();
                    range.selectNode(startPos);
                } else if (Viper.Util.isStubElement(endPos) === true) {
                    // Image etc.
                    Viper.Selection.removeAllRanges();
                    range.selectNode(endPos);
                } else {
                    // Normalise text nodes and select bookmark.
                    while (startPos && startPos.previousSibling && startPos.previousSibling.nodeType === Viper.Util.TEXT_NODE) {
                        startOffset += startPos.previousSibling.data.length;

                        if (endPos === startPos) {
                            endOffset += startPos.previousSibling.data.length;
                        }

                        startPos.data = startPos.previousSibling.data + startPos.data;
                        Viper.Util.remove(startPos.previousSibling);
                    }

                    while (endPos && endPos.nextSibling && endPos.nextSibling.nodeType === Viper.Util.TEXT_NODE) {
                        endPos.data += endPos.nextSibling.data;
                        Viper.Util.remove(endPos.nextSibling);
                    }

                    if (endPos.previousSibling === startPos) {
                        endOffset     += startPos.data.length;
                        startPos.data += endPos.data;
                        Viper.Util.remove(endPos);
                        endPos = startPos;
                    } else {
                        while (endPos.previousSibling && endPos.previousSibling.nodeType === Viper.Util.TEXT_NODE) {
                            endPos.data = endPos.previousSibling.data + endPos.data;
                            endOffset  += endPos.previousSibling.data.length;

                            if (endPos.previousSibling === startPos) {
                                startPos = endPos;
                            }

                            Viper.Util.remove(endPos.previousSibling);
                        }

                        if (endPos !== startPos) {
                            while (startPos.nextSibling && startPos.nextSibling.nodeType === Viper.Util.TEXT_NODE) {
                                startPos.data += startPos.nextSibling.data;
                                Viper.Util.remove(startPos.nextSibling);
                            }
                        }
                    }//end if

                    Viper.Selection.removeAllRanges();
                    range.setEnd(endPos, endOffset);
                    range.setStart(startPos, startOffset);
                    range.setEnd(endPos, endOffset);
                    range.setStart(startPos, startOffset);
                }//end if
            }//end if

            try {
                if (this.isEditableInIframe() === true) {
                    this.focus();
                }

                Viper.Selection.addRange(range);
            } catch (e) {
                // IE may throw exception for hidden elements..
            }

            return range;

        },

        getBookmark: function(parent, type)
        {
            var bookmarks = Viper.Util.getClass('viperBookmark_' + type, parent);
            var elem      = bookmarks.shift();

            // Remove rest of the bookmarks if there are any..
            Viper.Util.remove(bookmarks);

            return elem;

        },

        getBookmarkById: function(bookmarkid, parent)
        {
            parent = parent || this.getViperElement();
            var bookmarks = Viper.Util.find(parent, '[data-bookmarkid="' + bookmarkid + '"]');
            if (bookmarks.length !== 2) {
                return null;
            }

            var bookmark = {
                start: bookmarks[0],
                end: bookmarks[1]
            }

            return bookmark;

        },

        isBookmarkElement: function(element)
        {
            if (Viper.Util.hasClass(element, 'viperBookmark') === true) {
                return true;
            }

            return false;

        },

        removeBookmarks: function(elem, removeContent)
        {
            elem = elem || this.element;

            if (removeContent === true) {
                // Also remove the content thats bookmarked.
                var starts = Viper.Util.find(elem, '.viperBookmark_start');
                var ends   = Viper.Util.find(elem, '.viperBookmark_end');
                for (var i = 0; i < starts.length; i++) {
                    var bookmark = {
                        start: starts[i],
                        end: ends[i]
                    };

                    this.removeBookmark(bookmark);
                }
            }

            Viper.Util.remove(Viper.Util.getClass('viperBookmark', elem, 'span'));

        },

        
        removeBookmark: function(bookmark, keepParent)
        {
            if (!bookmark.start || !bookmark.end) {
                return false;
            }

            var viperElement = this.getViperElement();
            var elems        = Viper.Util.getElementsBetween(bookmark.start, bookmark.end);
            elems.push(bookmark.start, bookmark.end);
            var parents = Viper.Util.$(elems).parents();

            // Remove elements between the bookmarks.
            Viper.Util.remove(elems);

            if (keepParent !== true) {
                // Remove any parent element that is now empty.
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i] === viperElement) {
                        break;
                    }

                    if (Viper.Util.elementIsEmpty(parents[i]) === true) {
                        Viper.Util.remove(parents[i]);
                    }
                }
            }

        },

        createBookmark: function(range, keepOldBookmarks, bookmarkid)
        {
            // Remove all bookmarks?
            if (keepOldBookmarks !== true) {
                this.removeBookmarks(this.element);
            }

            var currRange      = range || this.getViperRange();
            var range          = currRange.cloneRange();
            var startContainer = range.startContainer;
            var endContainer   = range.endContainer;
            var startOffset    = range.startOffset;
            var endOffset      = range.endOffset;

            if (range.startContainer
                && range.startContainer === range.endContainer
                && Viper.Util.isTag(range.startContainer, 'br') === true
            ) {
                var prevSibling = range.startContainer.previousSibling;
                var nextSibling = range.startContainer.nextSibling;
                if (prevSibling && prevSibling.nodeType === Viper.Util.TEXT_NODE) {
                    range.setStart(prevSibling, prevSibling.data.length);
                } else if (nextSibling && nextSibling.nodeType === Viper.Util.TEXT_NODE) {
                    range.setStart(nextSibling, 0);
                } else {
                    var tmpNode = document.createTextNode('');
                    Viper.Util.insertBefore(range.startContainer, tmpNode);
                    range.setStart(tmpNode, 0);
                }

                range.collapse(true);
                Viper.Selection.addRange(range);
            } else if ((Viper.Util.isBrowser('firefox') === true || Viper.Util.isBrowser('msie') === true)
                && startContainer === endContainer
                && startOffset === 0
                && startContainer === this.getViperElement()
                && endOffset >= endContainer.childNodes.length
            ) {
                var firstSelectable = range._getFirstSelectableChild(this.getViperElement());
                var lastSelectable  = range._getLastSelectableChild(this.getViperElement());
                if (firstSelectable && lastSelectable) {
                    startContainer = firstSelectable;
                    startOffset    = 0;
                    range.setStart(firstSelectable, 0);
                    range.setEnd(lastSelectable, lastSelectable.data.length);
                }
            }//end if

            var endBookmark           = Viper.document.createElement('span');
            endBookmark.style.display = 'none';
            Viper.Util.setHtml(endBookmark, '&nbsp;');
            Viper.Util.addClass(endBookmark, 'viperBookmark viperBookmark_end');
            endBookmark.setAttribute('viperBookmark', 'end');

            if (bookmarkid) {
                endBookmark.setAttribute('data-bookmarkid', bookmarkid);
            }

             // Create the start bookmark.
            var startBookmark           = Viper.document.createElement('span');
            startBookmark.style.display = 'none';
            Viper.Util.addClass(startBookmark, 'viperBookmark viperBookmark_start');
            Viper.Util.setHtml(startBookmark, '&nbsp;');
            startBookmark.setAttribute('viperBookmark', 'start');

            if (bookmarkid) {
                startBookmark.setAttribute('data-bookmarkid', bookmarkid);
            }

            var viperElement  = this.getViperElement();
            var nodeSelection = range.getNodeSelection();
            if (nodeSelection === viperElement) {
                // Whole Viper element is selected.
                if (!viperElement.firstChild) {
                    // There are no contents.
                    viperElement.appendChild(startBookmark);
                    viperElement.appendChild(endBookmark);
                } else {
                    Viper.Util.insertBefore(viperElement.firstChild, startBookmark);
                    Viper.Util.insertAfter(viperElement.lastChild, endBookmark);
                }
            } else {
                // Collapse to the end of range.
                range.collapse(false);

                var startNode = range.getStartNode();
                range.insertNode(endBookmark);
                if (Viper.Util.isChildOf(endBookmark, this.element) === false) {
                    this.element.appendChild(endBookmark);
                }

                // Move the range to where it was before.
                if (startContainer.parentNode) {
                    // This check is to pevent IE11 stuffing up empty text nodes when range is collapsed.
                    range.setStart(startContainer, startOffset);
                    range.collapse(true);
                }

                try {
                    if (startContainer.parentNode) {
                        range.insertNode(startBookmark);
                    } else {
                        Viper.Util.insertBefore(endBookmark, startBookmark);
                    }

                    // Make sure start and end are in correct position.
                    if (startBookmark.previousSibling === endBookmark) {
                        // Reverse..
                        Viper.Util.insertBefore(endBookmark, startBookmark);
                    }
                } catch (e) {
                    // NS_ERROR_UNEXPECTED: I believe this is a Firefox bug.
                    // It seems like if the range is collapsed and the text node is empty
                    // (i.e. length = 0) then Firefox tries to split the node for no reason and fails...
                    Viper.Util.insertBefore(endBookmark, startBookmark);
                }

                if (Viper.Util.isChildOf(startBookmark, this.element) === false) {
                    if (this.element.firstChild) {
                        Viper.Util.insertBefore(this.element.firstChild, startBookmark);
                    } else {
                        // Should not happen...
                        this.element.appendChild(startBookmark);
                    }
                }

                if (Viper.Util.isBrowser('chrome') === true || Viper.Util.isBrowser('safari') === true) {
                    // Sigh.. Move the range where its suppose to be instead of Webkit deciding that it should
                    // move the end of range to the begining of the next sibling -.-.
                    if (!endBookmark.previousSibling) {
                        var node = endBookmark.parentNode.previousSibling;
                        while (node) {
                            if (node.nodeType !== Viper.Util.TEXT_NODE || Viper.Util.isBlank(node.data) === false) {
                                break;
                            }

                            node = node.previousSibling;
                        }

                        if (node === startBookmark.parentNode) {
                            startBookmark.parentNode.appendChild(endBookmark);
                        }
                    }
                }

                if (!endBookmark.previousSibling) {
                    var tmp = Viper.document.createTextNode('');
                    Viper.Util.insertBefore(endBookmark, tmp);
                }

                // The original range object must be changed.
                if (!startBookmark.nextSibling) {
                    var tmp = Viper.document.createTextNode('');
                    Viper.Util.insertAfter(startBookmark, tmp);
                }

                currRange.setStart(startBookmark.nextSibling, 0);
                currRange.setEnd(endBookmark.previousSibling, (endBookmark.previousSibling.length || 0));

                // Check if the bookmark is inside a special element.
                if (nodeSelection && this.isSpecialElement(nodeSelection) === true) {
                    // Move it outside of the special key.
                    Viper.Util.insertBefore(nodeSelection, startBookmark);
                    Viper.Util.insertAfter(nodeSelection, endBookmark);
                }
            }//end if

            var bookmark = {
                start: startBookmark,
                end: endBookmark
            };

            return bookmark;

        },

        
        createBookmarkFromHighlight: function(outer)
        {
            var highlights = this.getHighlights();
            if (highlights.length === 0) {
                return null;
            }

            var startBookmark           = Viper.document.createElement('span');
            startBookmark.style.display = 'none';
            Viper.Util.addClass(startBookmark, 'viperBookmark viperBookmark_start');
            Viper.Util.setHtml(startBookmark, '&nbsp;');
            startBookmark.setAttribute('viperBookmark', 'start');

            var outerParent = null;
            if (outer === true && highlights.length === 1) {
                // If the highlight is one element and outer is set to true then
                // create the bookmark at most outer surrounding parent.
                outerParent = Viper.Util.getTopSurroundingParent(highlights[0]);
                if (outerParent) {
                    Viper.Util.insertBefore(outerParent, startBookmark);
                }
            }

            if (!outerParent) {
                Viper.Util.insertBefore(highlights[0], startBookmark);
            }

            var endBookmark           = Viper.document.createElement('span');
            endBookmark.style.display = 'none';
            Viper.Util.setHtml(endBookmark, '&nbsp;');
            Viper.Util.addClass(endBookmark, 'viperBookmark viperBookmark_end');
            endBookmark.setAttribute('viperBookmark', 'end');

            if (outerParent) {
                Viper.Util.insertAfter(outerParent, endBookmark);
            } else {
                Viper.Util.insertAfter(highlights[(highlights.length - 1)], endBookmark);
            }

            var bookmark = {
                start: startBookmark,
                end: endBookmark
            };

            return bookmark;

        },

        insertNodeAtBookmark: function(node, bookmark, noSelect)
        {
            if (!bookmark || !node) {
                return;
            }

            Viper.Util.insertBefore(bookmark.start, node);

            if (noSelect !== true) {
                // Select the bookmark.
                this.selectBookmark(bookmark);
            }

        },

        splitNodeAtRange: function(tag, range, copyMidTags)
        {
            range = range || this.getCurrentRange();

            var bookmark = this.createBookmark(range);
            return this.splitNodeAtBookmark(tag, bookmark, copyMidTags);

        },

        
        splitNodeAtBookmark: function(tag, bookmark, copyMidTags)
        {
            if (!bookmark) {
                return;
            }

            // Get the parent node with specified tag.
            var node      = bookmark.start.parentNode;
            var foundNode = null;
            while (node && node !== this.element) {
                if (Viper.Util.isTag(node, tag) === true) {
                    // Note, we do not want to break out of the loop yet..
                    // Need to find the most outer parent with specified tag.
                    foundNode = node;
                }

                node = node.parentNode;
            }

            var prevNode = null;
            var nextNode = null;
            var midNode  = null;

            if (foundNode === null) {
                // Parent with specified tag was not found.
                prevNode = bookmark.start.previousSibling;
                nextNode = bookmark.end.nextSibling;

                if (!prevNode && !nextNode) {
                    prevNode = Viper.document.createTextNode('');
                    Viper.Util.insertBefore(bookmark.start, prevNode);
                    nextNode = prevNode;
                }
            } else {
                // Construct the end section, which is selection from end bookmark to
                // the end of the found node.
                var selStart = document.createTextNode('');
                var selEnd   = document.createTextNode('');

                Viper.Util.insertAfter(bookmark.end, selStart);
                Viper.Util.insertAfter(foundNode, selEnd);

                var range = this.getViperRange();
                range.setStart(selStart, 0);
                range.setEnd(selEnd, 0);
                var endContents = range.extractContents();

                var tmp = document.createElement('div');
                while (endContents.firstChild) {
                    tmp.appendChild(endContents.firstChild);
                }

                var nextNode = null;
                if (Viper.Util.elementIsEmpty(tmp) === false) {
                    while (tmp.lastChild) {
                        nextNode = tmp.lastChild;
                        Viper.Util.remove(tmp.lastChild);
                        Viper.Util.insertAfter(selEnd, nextNode);
                    }
                }

                Viper.Util.empty(tmp);

                // Get the mid contents without the specified tag.
                Viper.Util.insertBefore(bookmark.start, selStart);
                Viper.Util.insertAfter(foundNode, selEnd);
                range.setStart(selStart, 0);
                range.setEnd(selEnd, 0);
                var midContents = range.extractContents();

                while (midContents.firstChild) {
                    tmp.appendChild(midContents.firstChild);
                }

                var tagsToRemove = Viper.Util.getTag(tag, tmp);
                for (var i = 0; i < tagsToRemove.length; i++) {
                    while (tagsToRemove[i].firstChild) {
                        Viper.Util.insertBefore(tagsToRemove[i], tagsToRemove[i].firstChild);
                    }

                    Viper.Util.remove(tagsToRemove);
                }

                while (tmp.lastChild) {
                    Viper.Util.insertAfter(foundNode, tmp.lastChild);
                }

                var prevNode = foundNode;

                Viper.Util.remove(selEnd);

                try {
                    selStart.data = '';
                } catch (e) {
                    selStart = document.createTextNode('');
                }

                Viper.Util.insertAfter(bookmark.start, selStart);
                midNode = selStart;
            }//end if

            this.selectBookmark(bookmark);

            return {
                prevNode: prevNode,
                nextNode: nextNode,
                midNode: midNode
            };

        },

        
        highlightSelection: function()
        {
            var highlights = Viper.Util.getClass('__viper_selHighlight', this.element);
            if (highlights.length > 0) {
                return false;
            }

            var range = this.getViperRange();
            if (this.rangeInViperBounds(range) === false) {
                return false;
            }

            var selectedNode = range.getNodeSelection();

            if (selectedNode && selectedNode === this.element) {
                // Viper Element cannot be selected.
                selectedNode = null;
            }

            if (selectedNode && selectedNode.nodeType === Viper.Util.ELEMENT_NODE) {
                Viper.Util.addClass(selectedNode, '__viper_selHighlight __viper_cleanOnly');
            } else if (range.collapsed === true) {
                var span = document.createElement('span');
                Viper.Util.addClass(span, '__viper_selHighlight');
                Viper.Util.setStyle(span, 'border-right', '1px solid #000');

                if (Viper.Util.isStubElement(range.startContainer) === false) {
                    range.insertNode(span);
                    var parentNode = span.parentNode;
                } else {
                    parentNode = range.startContainer.parentNode;
                }

                if (parentNode) {
                    var tagName = Viper.Util.getTagName(parentNode);
                    if (Viper.Util.inArray(tagName, ['table', 'tbody', 'tr']) === true) {
                        Viper.Util.remove(span);
                    }
                }
            } else if (range.startContainer
                && range.endContainer
                && range.endContainer.previousSibling === range.startContainer.nextSibling
                && Viper.Util.isTag(range.startContainer.nextSibling, 'img') === true
                && Viper.Util.isTag(range.endContainer.previousSibling, 'img') === true
            ) {
                // This is for early IE version where range is set before and after an image. Still want to just highlight
                // the image element instead of using surroundContents below.
                Viper.Util.addClass(range.startContainer.nextSibling, '__viper_selHighlight __viper_cleanOnly');
            } else {
                var attributes = {
                    cssClass: '__viper_selHighlight'
                };

                var span = document.createElement('span');
                span.setAttribute('class', '__viper_selHighlight');
                this.surroundContents('span', attributes, range, true);
            }//end if

        },

        highlightToSelection: function(element)
        {
            element = element || this.element;

            // There should be one...
            var highlights = Viper.Util.getClass('__viper_selHighlight', element);
            if (highlights.length === 0) {
                return false;
            }

            var range     = this.getCurrentRange();
            var c         = highlights.length;
            var startNode = false;
            var child     = null;

            if (c === 1 && Viper.Util.hasClass(highlights[0], '__viper_cleanOnly') === true) {
                Viper.Util.removeClass(highlights[0], '__viper_cleanOnly');
                Viper.Util.removeClass(highlights[0], '__viper_selHighlight');
                if (!highlights[0].getAttribute('class')) {
                    highlights[0].removeAttribute('class');
                }

                if (element === this.element) {
                    range.selectNode(highlights[0]);
                    Viper.Selection.addRange(range);
                }

                return true;
            }

            for (var i = 0; i < c; i++) {
                if (highlights[i].firstChild) {
                    while (highlights[i].firstChild) {
                        child = highlights[i].firstChild;
                        Viper.Util.insertBefore(highlights[i], child);

                        if (!startNode) {
                            // Set the selection start.
                            startNode = child;
                            range.setStart(child, 0);
                        }
                    }

                    Viper.Util.remove(highlights[i]);

                    if (i === (c - 1)) {
                        if (child.nodeType === Viper.Util.TEXT_NODE) {
                            range.setEnd(child, child.data.length);
                        } else if (startNode === child) {
                            range.selectNode(startNode);
                        } else {
                            var lastSelectable = range._getLastSelectableChild(child);
                            range.setEnd(lastSelectable, lastSelectable.data.length);
                        }
                    }
                } else {
                    if (highlights[i].nextSibling && highlights[i].nextSibling.nodeType === Viper.Util.TEXT_NODE) {
                        var nextSibling = highlights[i].nextSibling;
                        if (!startNode) {
                            range.setStart(nextSibling, 0);
                            startNode = nextSibling;
                        }

                        Viper.Util.remove(highlights[i]);

                        if (i === (c - 1)) {
                            range.setEnd(nextSibling, 0);
                        }
                    } else {
                        var textNode = document.createTextNode('');
                        Viper.Util.insertAfter(highlights[i], textNode);
                        range.setStart(textNode, 0);
                        range.collapse(true);

                        Viper.Util.remove(highlights[i]);

                        if (i === (c - 1)) {
                            range.setEnd(textNode, 0);
                        }
                    }//end if
                }//end if
            }//end for

            if (element === this.element) {
                Viper.Selection.addRange(range);
                this.resetViperRange(range.cloneRange());
            }

            return true;

        },

        removeHighlights: function(element)
        {
            element = element || this.element;

            // There should be one...
            var highlights = this.getHighlights(element);
            if (highlights.length === 0) {
                return;
            }

            for (var i = 0; i < highlights.length; i++) {
                var highlight = highlights[i];

                if (Viper.Util.hasClass(highlight, '__viper_cleanOnly') === true) {
                    Viper.Util.removeClass(highlight, '__viper_cleanOnly');
                    Viper.Util.removeClass(highlight, '__viper_selHighlight');
                    if (!highlight.getAttribute('class')) {
                        highlight.removeAttribute('class');
                    }
                } else {
                    while (highlight.firstChild) {
                        child = highlight.firstChild;
                        Viper.Util.insertBefore(highlight, child);
                    }

                    Viper.Util.remove(highlight);
                }
            }//end for

            return true

        },

        getHighlights: function(element)
        {
            element = element || this.element;

            // There should be one...
            var highlights = Viper.Util.getClass('__viper_selHighlight', element);
            return highlights;

        },

        isViperHighlightElement: function(element)
        {
            if (Viper.Util.isTag(element, 'span') === true
                && Viper.Util.hasClass(element, '__viper_selHighlight') === true
            ) {
                return true;
            }

            return false;

        },

        isSpecialElement: function(element)
        {
            var isSpecialElem = false;
            if (element) {
                isSpecialElem = this.getPluginManager().isSpecialElement(element);
            }

            return isSpecialElem;

        },

        fireSelectionChanged: function(range, forceUpdate)
        {
            if (!range) {
                range = this.getViperRange();
                try {
                    range = this.adjustRange(range);
                } catch (e) {
                }
            }

            if (!this._prevRange
                || forceUpdate === true
                || this._prevRange.startContainer !== range.startContainer
                || this._prevRange.endContainer !== range.endContainer
                || this._prevRange.startOffset !== range.startOffset
                || this._prevRange.endOffset !== range.endOffset
                || this._prevRange.collapsed !== range.collapsed
            ) {
                this._prevRange = range;

                if (this._retrievingValues > 0) {
                    var self = this;
                    this._valuesRetrievedCallback = function() {
                        self.fireCallbacks('Viper:selectionChanged', range);
                    };
                } else {
                    this._valuesRetrievedCallback = null;
                    this.fireCallbacks('Viper:selectionChanged', range);
                }
            }

        },

        
        isSpecialKey: function(e)
        {
            return Viper.Util.inArray(e.which, this._specialKeys);

        },

        
        addSpecialKey: function(keyCode)
        {
            this._specialKeys.push(keyCode);

        },

        mouseDown: function(e)
        {
            this._mouseDownEvent = e;
            if (e.which === 3) {
                this.fireCallbacks('Viper:rightMouseDown', e);
                return false;
            }

            var target = Viper.Util.getMouseEventTarget(e);
            var inside = true;

            if (this.element !== target && Viper.Util.isChildOfElems(target, [this.element]) !== true && this.isMemberElement(target) !== true) {
                inside = false;

                // Ask plugins if its one of their element.
                var pluginName = this._getPluginForElement(target);
                if (!pluginName && Viper.Util.isChildOfElems(target, [this._viperElementHolder]) !== true) {
                    this.setEnabled(false);
                    return this.fireCallbacks('Viper:clickedOutside', e);
                } else {
                    return true;
                }
            } else if (this.enabled === false) {
                this.setEnabled(true);
            }

            this.removeHighlights();

            this.fireCallbacks('Viper:clickedInside', e);
            this.fireCaretUpdated();

            // Mouse down in active element.
            if (this.fireCallbacks('Viper:mouseDown', e) === false) {
                Viper.Util.preventDefault(e);
                return false;
            }

            if (inside !== true || this.removeHighlights() !== true) {
                var self = this;
                setTimeout(function() {
                    var range = null;
                    try {
                        range = self.adjustRange();
                    } catch (e) {
                    }

                    // Delay calling the fireSelectionChanged to get the updated range.
                    self.fireSelectionChanged(range);
                }, 5);
            }

            this.resetViperRange(null);

        },

        mouseUp: function(e)
        {
            if (e.which === 3) {
                this.fireCallbacks('Viper:rightMouseUp', e);
                return false;
            }

            if (this.fireCallbacks('Viper:mouseUp', e) === false) {
                Viper.Util.preventDefault(e);
                return false;
            }

            var target     = Viper.Util.getMouseEventTarget(e);
            var pluginName = this._getPluginForElement(target);
            if (pluginName || Viper.Util.isChildOfElems(target, [this._viperElementHolder]) === true) {
                return;
            }

            // This setTimeout is very strange indeed. We need to wait a bit for browser
            // to update the selection object..
            var self = this;
            setTimeout(function() {
                var range = null;
                try {
                    range = self.adjustRange(null, 'mouseup');
                } catch (e) {
                }

                if (range
                    && range.collapsed === true
                    && range.startContainer
                    && range.startContainer.nodeType === 9
                    && (Viper.Util.isBrowser('msie') === true || Viper.Util.isBrowser('edge') === true)
                ) {
                    // If clicked inside the previous selection then IE takes a lot
                    // longer to update the caret position so if the range is collapsed
                    // wait nearly half a second to trigger the selection changed
                    // event. The delay is only required when the startContainer is set as the
                    // document node.
                    setTimeout(function() {
                        var x = self.getCurrentRange();
                        self.fireSelectionChanged(self.adjustRange(null, 'mouseup'), true);
                    }, 450);
                } else {
                    if (Viper.Util.isBrowser('msie', '>=11') === true
                        || Viper.Util.isBrowser('edge') === true
                    ) {
                        if (range.startContainer !== range.endContainer
                            && range.startContainer.nodeType === Viper.Util.TEXT_NODE
                            && range.startOffset === range.startContainer.data.length
                            && range.startContainer.nextSibling
                            && range.startContainer.nextSibling.nodeType == Viper.Util.ELEMENT_NODE
                        ) {
                            // Handle <p>text [<strong>text] </strong></p> -> <p>text <strong>[text] </strong></p>.
                            var firstChild = range._getFirstSelectableChild(range.startContainer.nextSibling);
                            if (firstChild && firstChild.nodeType === Viper.Util.TEXT_NODE) {
                                range.setStart(firstChild, 0);
                                Viper.Selection.addRange(range);
                            }
                        }

                    }

                    self.fireSelectionChanged(range, true);
                }
            }, 8);

        },

        
        adjustRange: function(range, type)
        {
            range = range || this.getViperRange();
            if (range.collapsed !== false) {
                if (Viper.Util.isBrowser('msie', '9') === true) {
                    if (range.startContainer === range.endContainer) {
                        if (range.startContainer.nodeType === Viper.Util.ELEMENT_NODE) {
                            if (range.startOffset === range.startContainer.childNodes.length) {
                                var child = range.startContainer.childNodes[range.startContainer.childNodes.length - 1];
                                if (Viper.Util.isStubElement(child) === false && child.nodeType === Viper.Util.ELEMENT_NODE) {
                                    var sel = range._getLastSelectableChild(child);
                                    if (sel && sel.nodeType === Viper.Util.TEXT_NODE) {
                                        range.setEnd(sel, sel.data.length);
                                        range.collapse(false);
                                        Viper.Selection.addRange(range);
                                    }
                                }
                            }
                        }
                    }
                }

                return range;
            }

            // A few range adjustments for double click word selection etc.
            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();

            if (!endNode && startNode && Viper.Util.isStubElement(startNode) === true) {
                return range;
            }

            if (!endNode && range.startContainer && range.startContainer.nodeType === Viper.Util.ELEMENT_NODE) {
                var lastSelectable = range._getLastSelectableChild(range.startContainer);
                if (lastSelectable) {
                    endNode            = lastSelectable;
                    range.endContainer = endNode;
                    range.endOffset    = endNode.data.length;
                    Viper.Selection.addRange(range);
                }
            }

            if (type === 'mouseup'
                && endNode
                && endNode.nodeType === Viper.Util.TEXT_NODE
                && range.endOffset === 0
                && endNode !== startNode
                && endNode.previousSibling
                && endNode.previousSibling.nodeType !== Viper.Util.TEXT_NODE
            ) {
                // When a word at the end of a tag is double clicked then move the
                // end of the range to the last selectable child of that tag.
                var textChild = range._getLastSelectableChild(endNode.previousSibling);
                if (textChild) {
                    range.setEnd(textChild, textChild.data.length);
                    Viper.Selection.addRange(range);
                }
            }

            if (Viper.Util.isBrowser('firefox') === true) {
                if (startNode && startNode.nodeType === Viper.Util.TEXT_NODE
                    && endNode && endNode.nodeType === Viper.Util.TEXT_NODE
                    && startNode.data.length === range.startOffset
                    && range.endOffset === 0
                    && startNode.nextSibling
                    && startNode.nextSibling === endNode.previousSibling
                    && startNode.nextSibling.nodeType !== Viper.Util.TEXT_NODE
                ) {
                    // When a word is double clicked and the word is wrapped with a tag
                    // e.g. strong then select the strong tag.
                    var firstSelectable = range._getFirstSelectableChild(startNode.nextSibling);
                    var lastSelectable  = range._getLastSelectableChild(startNode.nextSibling);
                    range.setStart(firstSelectable, 0);
                    range.setEnd(lastSelectable, lastSelectable.data.length);
                    Viper.Selection.addRange(range);
                } else if (startNode && startNode.nodeType === Viper.Util.TEXT_NODE
                    && endNode && endNode.nodeType === Viper.Util.TEXT_NODE
                    && startNode.data.length === range.startOffset
                    && startNode !== endNode
                    && startNode.nextSibling
                    && startNode.nextSibling.nodeType !== Viper.Util.TEXT_NODE
                ) {
                    // A range starts at the end of a text node and the next sibling
                    // is not a text node so move the range inside the first selectable
                    // child of the next sibling. This usually happens in FF when you
                    // double click a word which is at the start of a strong/em/u tag,
                    // we move the range inside the tag.
                    var firstSelectable = range._getFirstSelectableChild(startNode.nextSibling);
                    if (firstSelectable) {
                        range.setStart(firstSelectable, 0);
                        Viper.Selection.addRange(range);
                    }
                }
            } else if (startNode
                && endNode
                && startNode.nodeType === Viper.Util.TEXT_NODE
                && endNode.nodeType === Viper.Util.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === endNode.data.length
            ) {
                if (range.endOffset === 0 && !endNode.previousSibling) {
                    // In Webkit, when a whole paragraph is selected sometimes the range
                    // starts from the beginning of the next paragraph causing range to
                    // span two paragraphs.. If this is the case then move the range...
                    var lastSelectable = range._getLastSelectableChild(endNode.parentNode.previousSibling.previousSibling);
                    if (lastSelectable) {
                        range.setEnd(lastSelectable, lastSelectable.data.length);
                        Viper.Selection.addRange(range);
                    }
                } else if (range.endOffset > 0
                    && Viper.Util.isBlank(Viper.Util.trim(endNode.data)) === true
                    && range.commonAncestorContainer === this.getViperElement()
                    && range.commonAncestorContainer.firstElementChild === range.commonAncestorContainer.lastElementChild
                    && range._getFirstSelectableChild(range.commonAncestorContainer, startNode)
                    && range._getLastSelectableChild(range.commonAncestorContainer, endNode)
                ) {
                    // This is the case where selection starts from first selectable and ends at last selectable
                    // where last selectable is empty text node after a block element.
                    // E.g. <viperEl><div><p>[aaa</p><p>bbb</p></div>    ]</viperEl>
                    // Range should be adjusted to select the common parent.
                    range.selectNode(range.commonAncestorContainer.firstElementChild);
                    Viper.Selection.addRange(range);
                }
            } else if (endNode && endNode.nodeType === Viper.Util.ELEMENT_NODE && Viper.Util.isTag(endNode, 'br') === true) {
                // Firefox adds br tags at the end of new paragraphs sometimes selecting
                // text from somewhere in paragraph to the end of paragraph causes
                // selection issues.
                if (endNode.previousSibling) {
                    var child = range._getLastSelectableChild(endNode.previousSibling);
                    if (child) {
                        range.setEnd(child, child.data.length);
                        Viper.Selection.addRange(range);
                    }
                }
            } else if (range.startContainer.nodeType === Viper.Util.TEXT_NODE
                && range.endContainer.nodeType === Viper.Util.ELEMENT_NODE
                && range.endOffset === 0
                && range.startOffset === range.startContainer.data.length
            ) {
                range.collapse(true);
                Viper.Selection.addRange(range);
            } else if (Viper.Util.isBrowser('msie', '>=11')
                && Viper.Util.isText(range.startContainer) === true
                && range.startOffset === range.startContainer.data.length
                && Viper.Util.isText(range.startContainer.nextSibling) === false
                && range.collapsed === false
            ) {
                // Range needs to be moved when <p>text [<strong>te]xt</strong></p> so that range is
                // inside the tag.
                var sel = range._getFirstSelectableChild(range.startContainer.nextSibling);
                if (Viper.Util.isText(sel) === true) {
                    range.setStart(sel, 0);
                    Viper.Selection.addRange(range);
                }
            }//end if

            return range;

        },

        focus: function()
        {
            if (this.element) {
                try {
                    if (Viper.Util.isBrowser('msie') === true || Viper.Util.isBrowser('edge') === true) {
                        var range = this.getViperRange();
                        Viper.Selection.addRange(range);

                        this.fireCaretUpdated();
                        this.fireCallbacks('Viper:focused');
                        return;
                    }

                    var elementScrollCoords = Viper.Util.getElementScrollCoords(this.element);
                    var scrollCoords        = Viper.Util.getScrollCoords(Viper.Util.getDocumentWindow());
                    this.element.focus();

                    var range = this.getViperRange();
                    Viper.Selection.addRange(range);

                    // IE and Webkit fix.
                    this.element.scrollTop  = elementScrollCoords.y;
                    this.element.scrollLeft = elementScrollCoords.x;
                    Viper.window.scrollTo(scrollCoords.x, scrollCoords.y);

                    this.fireCaretUpdated();

                    this.fireCallbacks('Viper:focused');
                } catch (e) {
                    // Catch the IE error: Can't move focus to control because its invisible.
                }//end try
            }//end if

        },

        isEditableInIframe: function(element)
        {
            element = element || this.element;

            if (document !== element.ownerDocument) {
                return true;
            }

            return false;

        },

        blurActiveElement: function()
        {
            if (document.activeElement
                && document.activeElement !== this.element
                && document.activeElement.blur
                && document.activeElement !== document.body
            ) {
                // Call the blur method of the active element incase its an input box etc
                // which causes problems on IE when range is set below.
                // Note that the above activeElement != body check is to prevent the best
                // browser in the world changing focus to another window..
                document.activeElement.blur();
            }

        },

        fireCaretUpdated: function(range)
        {
            range = range || this.getCurrentRange();
            this.fireCallbacks('caretPositioned', {range: range});

        },

        fireNodesChanged: function(nodes)
        {
            if (!nodes) {
                nodes = [this.element];
            }

            this.getViperRange().clearNodeSelectionCache();

            this.fireCallbacks('Viper:nodesChanged', nodes);

            if (nodes.length === 1 && nodes[0] && nodes[0].nodeType === Viper.Util.TEXT_NODE) {
                this.HistoryManager.add('Viper', 'text_change');
            } else {
                this.HistoryManager.add();
            }

        },

        contentChanged: function(selectionNotChanged, range)
        {
            range = range || null;

            if (selectionNotChanged !== true) {
                this.fireSelectionChanged(range, true);
            }

            this.fireNodesChanged();

        },

        _getPluginForElement: function(element)
        {
            return this.getPluginManager().getPluginForElement(element);

        },

        registerCallback: function(type, namespace, callback)
        {
            if (Viper.Util.isFn(callback) === false) {
                return;
            }

            if (Viper.Util.isArray(type) === true) {
                for (var i = 0; i < type.length; i++) {
                    this.registerCallback(type[i], namespace, callback);
                }

                return;
            }

            if (!this.callbacks[type]) {
                this.callbacks[type] = {
                    namespaces: {},
                    others: []
                };
            }

            if (namespace) {
                this.callbacks[type].namespaces[namespace] = callback;
            } else {
                this.callbacks[type].others.push(callback);
            }

        },

        fireCallbacks: function(type, data, doneCallback)
        {
            var callbackList = [];
            if (this.callbacks[type]) {
                // Put the callbacks in an array.
                for (var namespace in this.callbacks[type].namespaces) {
                    if (this.callbacks[type].namespaces.hasOwnProperty(namespace) === true) {
                        var callback = this.callbacks[type].namespaces[namespace];
                        if (callback) {
                            callbackList.push(callback);
                        }
                    }
                }

                var len = this.callbacks[type].others.length;
                for (var i = 0; i < len; i++) {
                    callbackList.push(this.callbacks[type].others[i]);
                }
            }

            return this._fireCallbacks(callbackList, data, doneCallback, null, type);

        },

        _fireCallbacks: function(callbacks, data, doneCallback, retVal, type)
        {
            if (callbacks.length === 0) {
                if (doneCallback) {
                    doneCallback.call(this, data, retVal);
                }

                return retVal;
            }

            var callback = callbacks.shift();
            if (callback) {
                var self = this;
                try {
                    var returnValue = callback.call(this, data, function(returnValue) {
                        if (retVal === false) {
                            returnValue = false;
                        }

                        self._fireCallbacks(callbacks, data, doneCallback, returnValue, type);
                    });

                    if (Viper.Util.isFn(returnValue) === true) {
                        return;
                    }

                    if (retVal === false) {
                        returnValue = false;
                    }

                    return this._fireCallbacks(callbacks, data, doneCallback, returnValue, type);
                } catch (e) {
                    console.error(e, callback, e.stack);
                }
            }

        },

        removeCallback: function(type, namespace)
        {
            if (!type) {
                if (namespace) {
                    // Remove all events for specified namespace.
                    for (var type in this.callbacks) {
                        if (this.callbacks.hasOwnProperty(type) === true) {
                            this.removeCallback(type, namespace);
                        }
                    }
                }
            } else if (this.callbacks[type]) {
                if (namespace) {
                    if (this.callbacks[type].namespaces[namespace]) {
                        delete this.callbacks[type].namespaces[namespace];
                    }
                } else {
                    // Remove all.
                    delete this.callbacks[type];
                }
            }

        },


        
        getHtml: function(elem, settings)
        {
            elem = elem || this.element;

            if (typeof elem === 'string') {
                var tmp = elem;
                elem    = Viper.document.createElement('div');
                Viper.Util.setHtml(elem, tmp);
            }

            if (!elem) {
                return '';
            }

            var originalSettings = this.getSettings();

            if (!settings) {
                // When getHtml is called the final output of empty table cells should
                // be &nbsp; to make them look fine in all browsers.
                this.setSetting('emptyTableCellContent', '&nbsp;');
            } else {
                this.setSettings(settings);
            }

            // Clone the element so we dont modify the actual contents.
            var clone = Viper.Util.cloneNode(elem);

            this.removeHighlights(clone);
            this.removeEmptyNodes(clone);

            // Remove special Viper elements.
            this._removeViperElements(clone);

            // TODO: What if some of the plugins need to run after plugin X, Y, Z
            // e.g. Keyword plugin?
            // Plugins can hookin to this method to modify the HTML
            // before Viper returns its HTML contents.
            this.fireCallbacks('Viper:getHtml', {element: clone});
            var html = Viper.Util.getHtml(clone);
            html     = this.cleanHTML(html);

            var defaultBlockTag = this.getDefaultBlockTag();
            if (html === '' && defaultBlockTag) {
                html = '<' + defaultBlockTag + '></' + defaultBlockTag + '>';
            }

            html = html.replace(/<\/viper:param>/ig, '');
            html = html.replace(/<viper:param /ig, '<param ');
            html = html.replace(/<:object/ig, '<object');
            html = html.replace(/<\/:object/ig, '</object');

            html = html.replace(/__viper_attr_/g, '');
            html = this.removeInvalidCharacters(html);

            // Revert to original settings.
            this.setSettings(originalSettings, true);

            return html;

        },

        getRawHTML: function(elem)
        {
            elem = elem || this.element;
            return Viper.Util.getHtml(elem);

        },

        setRawHTML: function(html)
        {
            Viper.Util.setHtml(this.element, html);

        },

        
        getContents: function(elem)
        {
            elem = elem || this.element;

            // Clone the element so we dont modify the actual contents.
            var clone = Viper.Util.cloneNode(elem);

            // Remove special Viper elements.
            this._removeViperElements(clone);

            // Plugins can hookin to this method to modify the HTML
            // before Viper returns its HTML contents.
            this.fireCallbacks('getContents', {element: clone});
            var html = Viper.Util.getHtml(clone);

            if (Viper.Util.isBrowser('msie') === true) {
                html = html.replace(/<:object /ig, '<object ');
                html = html.replace(/<\/:object>/ig, '</object>');
            }

            return html;

        },

        _removeViperElements: function(elem)
        {
            var bookmarks = Viper.Util.getClass('viperBookmark', elem);
            if (bookmarks) {
                Viper.Util.remove(bookmarks);
            }

            // Remove viper selection.
            var highlights = Viper.Util.getClass('__viper_selHighlight', elem);
            for (var i = 0; i < highlights.length; i++) {
                if (Viper.Util.hasClass(highlights[i], '__viper_cleanOnly') !== true) {
                    while (highlights[i].firstChild) {
                        Viper.Util.insertBefore(highlights[i], highlights[i].firstChild);
                    }

                    Viper.Util.remove(highlights[i]);
                } else {
                    Viper.Util.removeClass(highlights[i], '__viper_selHighlight');
                    Viper.Util.removeClass(highlights[i], '__viper_cleanOnly');
                    if (!highlights[0].getAttribute('class')) {
                        highlights[0].removeAttribute('class');
                    }
                }
            }

        },

        
        setContents: function(contents)
        {
            if (typeof contents === 'string') {
                this.element.innerHTML = contents;
            } else if (contents) {
                this.element.appendChild(contents);
            }

            this.fireCallbacks('setContents', {element: this.element});

            this.initEditableElement();

        },

        
        setHtml: function(contents, callback)
        {
            contents = this.removeInvalidCharacters(contents);
            var self = this;
            this.fireCallbacks('Viper:setHtmlContent', contents, function(data, newContents) {
                self._setHTML(newContents, callback);
            });

        },

        _setHTML: function(contents, callback)
        {
            var clone = Viper.document.createElement('div');

            if (typeof contents === 'string') {
                clone.innerHTML = contents;
                Viper.Util.remove(Viper.Util.getTag('script', clone));
            } else if (contents) {
                clone.appendChild(contents);
            }

            this.resetViperRange(null);

            var range          = this.getCurrentRange();
            var lastSelectable = range._getLastSelectableChild(clone);
            if (lastSelectable
                && lastSelectable.nodeType === Viper.Util.TEXT_NODE
                && (!lastSelectable.nextSibling || Viper.Util.isTag(lastSelectable.nextSibling, 'br') === true)
            ) {
                lastSelectable.data = Viper.Util.rtrim(lastSelectable.data);
            }

            this.removeEmptyNodes(clone);

            var self = this;
            this.fireCallbacks('Viper:setHtml', {element: clone}, function() {
                var html = Viper.Util.getHtml(clone);
                if (Viper.Util.isBrowser('msie', 8) === true) {
                    // IE8 has problems with param tags, it removes them from the content
                    // so Viper needs to change the tag name when content is being set
                    // and change it back to original when content is being retrieved.
                    html = html.replace(/<\/param>/ig, '</viper:param>');
                    html = html.replace(/<param /ig, '<viper:param ');
                }

                self.element.innerHTML = html;
                self.initEditableElement();

                self.contentChanged();
                if (callback) {
                    callback.call(this);
                }
            });

        },

        _closeStubTags: function (content)
        {
            var re  = /<(area|base|basefont|br|hr|input|img|link|meta|embed|viper:param|param)((\s+[_\-\w]+(\s*=\s*(?:"[^">]*"|\'[^\'>]+\'))?)+)?\s*>/ig;
            content = content.replace(re, "<$1$2 />");
            return content;

        },

        cleanHTML: function(content, attrBlacklist)
        {
            attrBlacklist = attrBlacklist || ['sizset'];

            content = content.replace(/<(p|div|h1|h2|h3|h4|h5|h6|li)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>\s*/ig, "<$1$2>");
            content = content.replace(/\s*<\/(p|div|h1|h2|h3|h4|h5|h6|li)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>/ig, "</$1$2>");
            content = this._closeStubTags(content);
            content = content.replace(/<\/?\s*([A-Z\d:]+)/g, function(str) {
                return str.toLowerCase();
            });

            content = this.replaceEntities(content);

            // Regex to get list of HTML tags.
            var subRegex = '\\s+([_\\-:\\w]+)(?:\\s*=\\s*("(?:[^"]+)?"|\'(?:[^\']+)?\'|[^\'">\\s]+))?';

            // Regex to get list of attributes in an HTML tag.
            var tagRegex  = new RegExp('(<[\\w:]+)(?:' + subRegex + ')+\\s*(\/?>)', 'g');
            var attrRegex = new RegExp(subRegex, 'g');

            content = content.replace(tagRegex, function(match, tagStart, a, tagEnd) {
                match = match.replace(attrRegex, function(a, attrName, attrValue) {
                    // All attribute names must be lowercase.
                    attrName = attrName.toLowerCase();

                    if (Viper.Util.inArray(attrName, attrBlacklist) === true) {
                        // This attribute is not allowed.
                        return '';
                    } else if (attrName.indexOf(':') >= 0) {
                        return '';
                    } else if (attrName.match(/^sizcache\d+$/)) {
                        return '';
                    }

                    if (attrName === 'style') {
                        // Style attribute value must be lowercase.
                        attrValue = attrValue.toLowerCase();
                    }

                    // Remove single and double quotes and then wrap the value with
                    // double quotes.
                    if (attrValue) {
                        attrValue = Viper.Util.trim(attrValue, '"\'');
                    } else {
                        attrValue = '';
                    }

                    var res = ' ' + attrName + '="' + attrValue + '"';
                    return res;
                });

                return match;
            });

            return content;

        },

        
        cleanDOM: function(elem, tagName)
        {
            if (!elem) {
                elem = this.element;
            }

            // Remove attributes with empty values.
            Viper.Util.removeAttr(Viper.Util.find(elem, '[style=""]'), 'style');
            Viper.Util.removeAttr(Viper.Util.find(elem, '[class=""]'), 'class');

            this.removeNotAllowedAttributes(elem);

            this._cleanDOM(elem, tagName, true);

            if (Viper.Util.isBlockElement(elem) === true) {
                var range    = this.getViperRange(elem);
                var lastElem = range._getLastSelectableChild(elem);
                if (lastElem
                    && lastElem.nodeType === Viper.Util.TEXT_NODE
                    && (!lastElem.nextSibling || Viper.Util.isTag(lastElem.nextSibling, 'br') === true)
                ) {
                    lastElem.data = Viper.Util.rtrim(lastElem.data.replace(/(&nbsp;)*$/, ''));
                }
            }

        },

        
        removeNotAllowedAttributes: function(elem)
        {
            // Find elements with contenteditable attribute and remove then.
            var notAllowedAttributes = ['contenteditable'];
            for (var i = 0; i < notAllowedAttributes.length; i++) {
                Viper.Util.removeAttr(Viper.Util.find(elem, '[' + notAllowedAttributes[i] + ']'), notAllowedAttributes[i]);
            }

        },

        _cleanDOM: function(elem, tagName, topLevel)
        {
            if (!elem) {
                return;
            }

            if (elem.firstChild && Viper.Util.isTag(elem, 'pre') !== true) {
                this._cleanDOM(elem.firstChild, tagName);
            }

            if (elem === this.element || topLevel === true) {
                return;
            }

            var nextSibling = elem.nextSibling;
            this._cleanNode(elem, tagName);

            if (nextSibling) {
                this._cleanDOM(nextSibling, tagName);
            }

        },

        _cleanNode: function(node, tag)
        {
            if (node === this.element) {
                return;
            }

            if (node.nodeType === Viper.Util.ELEMENT_NODE) {
                var tagName = node.tagName.toLowerCase();
                if (tag && tag !== tagName) {
                    return;
                } else if (node.className !== '' || node.id !== '') {
                    // If the node has CSS classes or ID set then do not remove it.
                    switch (tagName) {
                        case 'textarea':
                        case 'form':
                        case 'input':
                        case 'button':
                        case 'select':
                        case 'label':
                            // Form fields must be removed.
                            Viper.Util.remove(node);
                        break;

                        default:
                            // Keep node.
                        break;
                    }

                    return;
                }

                switch (tagName) {
                    case 'br':
                        if (!node.nextSibling
                            || (node.hasAttribute && node.hasAttribute('_moz_dirty'))
                        ) {
                            if (!node.previousSibling
                                && (Viper.Util.isTag(node.parentNode, 'td') === true
                                || Viper.Util.isTag(node.parentNode, 'th') === true)
                            ) {
                                // This BR element is the only child of the table cell,
                                // depending on emptyTableCellContent, set the cell's
                                // content.
                                var emptyTableCellContent = this.getSetting('emptyTableCellContent');
                                Viper.Util.setHtml(node.parentNode, emptyTableCellContent);
                                return;
                            }

                            // Remove all BR tags and spaces just before this one.
                            var prev = node.previousSibling;
                            while (prev) {
                                if (Viper.Util.isTag(prev, 'br') === true
                                    || (prev.nodeType === Viper.Util.TEXT_NODE && Viper.Util.trim(prev.nodeValue) === '')
                                ) {
                                    var removeNode = prev;
                                    prev       = prev.previousSibling;
                                    Viper.Util.remove(removeNode);
                                } else {
                                    break;
                                }
                            }

                            if (tag) {
                                var newNode = Viper.document.createTextNode(' ');
                                Viper.Util.insertBefore(node, newNode);
                            }

                            Viper.Util.remove(node);
                        } else {
                            // Also remove the br tags that are at the end of an element.
                            // They are usually added to give the empty element height/width.
                            var next   = node.nextSibling;
                            var brLast = true;
                            while (next) {
                                if (next.nodeType !== Viper.Util.TEXT_NODE || Viper.Util.trim(next.nodeValue) !== '') {
                                    brLast = false;
                                    break;
                                }

                                next = next.nextSibling;
                            }

                            if (brLast === true) {
                                // Rmove all BR tags just before this one.
                                var prev = node.previousSibling;
                                while (prev) {
                                    if (Viper.Util.isTag(prev, 'br') === true
                                        || (prev.nodeType === Viper.Util.TEXT_NODE && Viper.Util.trim(prev.nodeValue) === '')
                                    ) {
                                        var removeNode = prev;
                                        prev       = prev.previousSibling;
                                        Viper.Util.remove(removeNode);
                                    } else {
                                        break;
                                    }
                                }

                                Viper.Util.remove(node);
                            }
                        }//end if
                    break;

                    case 'a':
                        if (!node.getAttribute('name') && !node.firstChild) {
                            Viper.Util.remove(node);
                        }
                    break;

                    case 'td':
                    case 'th':
                    case 'caption':
                        var html = Viper.Util.trim(Viper.Util.getHtml(node));
                        if (html === '' || Viper.Util.trim(html.replace(/&nbsp;/g, '')) === '') {
                            Viper.Util.setHtml(node, '&nbsp;');
                        }
                    break;

                    case 'textarea':
                    case 'form':
                    case 'input':
                    case 'button':
                    case 'select':
                    case 'label':
                        Viper.Util.remove(node);
                    break;

                    case 'strong':
                    case 'em':
                        if (Viper.Util.isTag(node.parentNode, tagName) === true) {
                            // Same as parent tag, move child nodes out and remove this
                            // node.
                            while (node.firstChild) {
                                Viper.Util.insertBefore(node, node.firstChild);
                            }

                            Viper.Util.remove(node);
                            break;
                        } else if (node.previousSibling && Viper.Util.isTag(node.previousSibling, tagName) === true) {
                            while (node.firstChild) {
                                node.previousSibling.appendChild(node.firstChild);
                            }

                            Viper.Util.remove(node);
                            break;
                        }

                    default:
                        var cont = Viper.Util.trim(Viper.Util.getHtml(node));
                        if ((Viper.Util.isStubElement(node) === false
                            && !node.firstChild)
                            || cont === '&nbsp;'
                            || (cont === '' && Viper.Util.isTag(node, ['p', 'div']))
                        ) {
                            Viper.Util.remove(node);
                        }
                    break;
                }//end switch
            } else if (node.nodeType === Viper.Util.TEXT_NODE && !tag) {
                if (Viper.Util.isTag(node.parentNode, 'td') === false) {
                    if (Viper.Util.trim(node.data, "\f\n\r\t\v\u2028\u2029") === '') {
                        Viper.Util.remove(node);
                    } else if (Viper.Util.trim(node.data) === '' && node.data.indexOf("\n") === 0) {
                        Viper.Util.remove(node);
                    } else if (node.data.match(/\n\s+\S+\n\s+/) !== null && !node.previousSibling && !node.nextSibling) {
                        node.data = Viper.Util.trim(node.data);
                    } else {
                        var nbsp = String.fromCharCode(160);

                        // Remove extra spaces from the node.
                        node.data = node.data.replace(/^\s+/g, ' ');
                        node.data = node.data.replace(/\s*\n\s*/g, ' ');

                        // TODO: We should normalise these text nodes before calling this method. This way there is no
                        // reason to do this check here as there will be no sibling text nodes.
                        if (node.data.charAt(0) === ' '
                           && node.previousSibling
                           && node.previousSibling.nodeType === Viper.Util.TEXT_NODE
                           && (node.previousSibling.data.charAt(node.previousSibling.data.length - 1) === nbsp
                           || node.previousSibling.data.charAt(node.previousSibling.data.length - 1) === ' ')
                        ) {
                           node.data = node.data.replace(/^\s+/g, nbsp);
                        }

                        if (node.data.charAt(node.data.length - 1) === ' '
                            && node.nextSibling
                            && node.nextSibling.nodeType === Viper.Util.TEXT_NODE
                            && (node.nextSibling.data.charAt(0) === ' '
                            || node.nextSibling.data.charAt(0) === nbsp)
                        ) {
                            node.data = node.data.replace(/\s+$/g, nbsp);
                        }

                        // Replace two spaces with two &nbsp;.
                        node.data = node.data.replace(/\s{2,2}/g, nbsp + nbsp);
                    }
                } else {
                    node.data = node.data.replace(/^\n+\s*$/m, '');
                }
            }//end if

        },

        removeEmptyNodes: function(element, content)
        {
            if (content && !element) {
                element = document.createElement('div');
                Viper.Util.setHtml(element, content);
            } else if (!content) {
                if (!element) {
                    element = this.element;
                }
            } else {
                return;
            }

            this.cleanDOM(element);

            return element;

        },

        replaceEntities: function(html)
        {
            // Replace special Word characters with HTML ones..
            var specialCharcodes = {
                '8211': '&ndash;',
                '8212': '&mdash;',
                '8226': '*'
            };

            for (var code in specialCharcodes) {
                html = html.replace(new RegExp(String.fromCharCode(code), 'g'), specialCharcodes[code]);
            }

            return Viper.Util.replaceCommonNamedEntities(html);

        },

        removeElem: function(elem)
        {
            if (Viper.Util.isArray(elem) === true) {
                var eln = elem.length;
                for (var i = 0; i < eln; i++) {
                    this.removeElem(elem[i]);
                }
            } else if (elem) {
                var parent = elem.parentNode;
                Viper.Util.remove(elem);
                if (parent) {
                    for (var node = parent.firstChild; node; node = node.nextSibling) {
                        if (node.nodeType !== Viper.Util.TEXT_NODE || node.nodeValue.length !== 0) {
                            // Not empty.
                            return;
                        }
                    }

                    // If parent is now empty then remove it.
                    Viper.Util.remove(parent);
                }
            }

        },

        removeInvalidCharacters: function(content)
        {
            // Remove all control chars.
            content = content.replace(/[\x00-\x09]/g, '');
            return content;

        }

    };

    // Add Viper to global namespace.
    window.Viper = Viper;

}) (window);

(function() {
    var ViperUtil = Viper.Util = {
        $: window.$ || window.jQuery || window.dfxjQuery || (function() {throw new Error('jQuery not found!')})(),
        ELEMENT_NODE: 1,
        ATTRIBUTE_NODE: 2,
        TEXT_NODE: 3,
        CDATA_SECTION_NODE: 4,
        ENTITY_REFERENCE_NODE: 5,
        ENTITY_NODE: 6,
        PROCESSING_INSTRUCTION_NODE : 7,
        COMMENT_NODE: 8,
        DOCUMENT_NODE: 9,
        DOCUMENT_TYPE_NODE: 10,
        DOCUMENT_FRAGMENT_NODE: 11,
        NOTATION_NODE: 12,
        DOM_VK_DELETE: 46,
        DOM_VK_LEFT: 37,
        DOM_VK_UP: 38,
        DOM_VK_RIGHT: 39,
        DOM_VK_DOWN: 40,
        DOM_VK_ENTER: 13,
        DOM_VK_BACKSPACE: 8,
        _browserType: null,
        _browserVersion: null,
        _viperElement: null,

        isKey: function(e, keys)
        {
            var eKeys = [];
            if (e.ctrlKey === true || e.metaKey === true) {
                eKeys.push('ctrl');
            }

            if (e.shiftKey === true) {
                eKeys.push('shift');
            }

            if (e.altKey === true) {
                eKeys.push('alt');
            }

            switch (e.keyCode) {
                case 13:
                    eKeys.push('enter');
                break;

                case ViperUtil.DOM_VK_LEFT:
                    eKeys.push('left');
                break;

                case ViperUtil.DOM_VK_RIGHT:
                    eKeys.push('right');
                break;

                case ViperUtil.DOM_VK_UP:
                    eKeys.push('up');
                break;

                case ViperUtil.DOM_VK_DOWN:
                    eKeys.push('down');
                break;

                case 9:
                    eKeys.push('tab');
                break;

                case ViperUtil.DOM_VK_DELETE:
                    eKeys.push('delete');
                break;

                case ViperUtil.DOM_VK_BACKSPACE:
                    eKeys.push('backspace');
                break;

                default:
                    var code = e.which;

                    // Other characters (a-z0-9..).
                    if (code) {
                        eKeys.push(String.fromCharCode(code).toLowerCase());
                    }
                break;
            }//end switch

            eKeys = eKeys.sort();

            keys       = keys.toLowerCase().split('+').sort();
            var kCount = keys.length;
            if (kCount !== eKeys.length) {
                return false;
            }

            for (var i = 0; i < kCount; i++) {
                if (keys[i] !== eKeys[i]) {
                    return false;
                }
            }

            return true;

        },

        isInputKey: function(e)
        {
            if ((e.which !== 0 || e.keyCode === 46)
                && e.ctrlKey !== true
                && e.altKey !== true
                && e.metaKey !== true
                && e.which !== 27
            ) {
                return true;
            }

            return false;

        },

        isTag: function(node, tag)
        {
            if (typeof tag !== 'object') {
                if (node && node.tagName && node.tagName.toLowerCase() === tag.toLowerCase()) {
                    return true;
                }
            } else if (node && node.tagName) {
                var tagName = node.tagName.toLowerCase();
                var ln      = tag.length;
                for (var i = 0; i < ln; i++) {
                    if (tagName === tag[i].toLowerCase()) {
                        return true;
                    }
                }
            }

            return false;

        },

        getTagName: function(node)
        {
            if (node && node.tagName) {
                return node.tagName.toLowerCase();
            }

            return null;

        },

        
        remove: function(element)
        {
            if (element) {
                return ViperUtil.$(element).remove();
            }

        },

        
        insertBefore: function(before, elem)
        {
            ViperUtil.$(before).before(elem);

        },

        
        insertAfter: function(after, elem)
        {
            ViperUtil.$(after).after(elem);

        },

        moveChildrenToElement: function(sourceElement, targetElement, joinTextNodes)
        {
            while (sourceElement.firstChild) {
                if (joinTextNodes === true
                    && this.isText(targetElement.lastChild) === true
                    && this.isText(sourceElement.firstChild) === true
                ) {
                    targetElement.lastChild.data += sourceElement.firstChild.data;
                    ViperUtil.remove(sourceElement.firstChild);
                } else {
                    targetElement.appendChild(sourceElement.firstChild);
                }
            }

        },

        
        addClass: function(element, classNames)
        {
            ViperUtil.$(element).addClass(classNames);

        },

        
        removeClass: function(element, classNames)
        {
            ViperUtil.$(element).removeClass(classNames);

        },

        
        toggleClass: function(elems, className)
        {
            ViperUtil.$(elems).toggleClass(className);

        },

        
        setStyle: function(element, property, value)
        {
            if (element) {
                ViperUtil.$(element).css(property, value);
            }

        },

        
        getTag: function(tagName, startElement, onlyChildren)
        {
            var ret;

            if (!startElement) {
                startElement = document;
            }

            if (onlyChildren === true) {
                ret = ViperUtil.$.makeArray(ViperUtil.$(startElement).children(tagName));
            } else {
                ret = ViperUtil.$.makeArray(ViperUtil.$(startElement).find(tagName));
            }

            return ret;

        },

        
        setHtml: function(element, content)
        {
            if (element) {
                ViperUtil.$(element).html(content);
            }

        },

        
        getHtml: function(element)
        {
            return ViperUtil.$(element).html();

        },

        
        isBlockElement: function(element)
        {
            if (!element) {
                return false;
            }

            switch (element.nodeName.toLowerCase()) {
                case 'p':
                case 'div':
                case 'pre':
                case 'ul':
                case 'ol':
                case 'li':
                case 'table':
                case 'tbody':
                case 'td':
                case 'th':
                case 'tr':
                case 'caption':
                case 'fieldset':
                case 'form':
                case 'blockquote':
                case 'dl':
                case 'dir':
                case 'center':
                case 'address':
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                case 'img':
                case 'header':
                case 'nav':
                case 'section':
                case 'main':
                case 'article':
                case 'aside':
                case 'footer':
                case 'details':
                case 'figure':
                case 'dialog':
                case 'canvas':
                case 'audio':
                case 'video':
                    return true;
                break;

                default:
                    return false;
                break;
            }//end switch

            return false;

        },

        
        isStubElement: function(element)
        {
            if (element) {
                switch (element.nodeName.toLowerCase()) {
                    case 'img':
                    case 'br':
                    case 'hr':
                    case 'iframe':
                    case 'param':
                    case 'link':
                    case 'meta':
                    case 'input':
                    case 'frame':
                    case 'col':
                    case 'base':
                    case 'area':
                    case 'embed':
                    case 'canvas':
                    case 'source':
                    case 'track':
                        return true;

                    break;

                    default:
                        return false;

                    break;
                }//end switch
            }//end if

            return false;

        },

        isEmptyElement: function (element) {
            if (!element.firstChild) {
                return true;
            }

            var brCount = 0;
            for (var i = 0; i < element.childNodes.length; i++) {
                var el = element.childNodes[i];
                if (el.nodeType === ViperUtil.TEXT_NODE) {
                    if (ViperUtil.trim(el.data).length !== 0) {
                        return false;
                    } else {
                        // Ignore empty text nodes.
                        continue;
                    }
                } else if (ViperUtil.isTag(el, 'br') === false) {
                    return false;
                } else if (brCount !== 0) {
                    return false;
                } else {
                    brCount++;
                }
            }

            return true;

        },

        isText: function (node) {
            if (node && node.nodeType === this.TEXT_NODE) {
                return true;
            }

            return false;

        },

        
        ltrim: function (str, trimChars)
        {
            trimChars = trimChars || '\\s';
            return str.replace(new RegExp('^[' + trimChars + ']+', 'g'), '');

        },

        
        rtrim: function (str, trimChars)
        {
            trimChars = trimChars || '\\s';
            return str.replace(new RegExp('[' + trimChars + ']+$', 'g'), '');

        },


        
        trim: function(value, trimChars)
        {
            return ViperUtil.ltrim(ViperUtil.rtrim(value, trimChars), trimChars);

        },

        ucFirst: function(str)
        {
            return str.substr(0,1).toUpperCase() + str.substr(1, str.length);

        },

        replaceAll: function(search, replace, subject)
        {
            // Escape search.
            search = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

            var r = new RegExp(search, 'g');
            return subject.replace(r, replace);

        },

        
        isBlank: function(value)
        {
            if (!value || /^\s*$/.test(value)) {
                return true;
            }

            return false;

        },

        isset: function(v)
        {
            if (typeof v !== 'undefined' && v !== null) {
                return true;
            }

            return false;

        },

        isObj: function(v)
        {
            if (v !== null && typeof v === 'object') {
                return true;
            }

            return false;

        },

        isEmpty: function(value)
        {
            if (value) {
                if (value instanceof Array) {
                    if (value.length > 0) {
                        return false;
                    }
                } else {
                    for (var id in value) {
                        if (value.hasOwnProperty(id) === true) {
                            return false;
                        }
                    }
                }
            }

            return true;

        },

        
        addEvent: function(elements, type, callback, data)
        {
            if (elements) {
                if (type === 'safedblclick') {
                    ViperUtil.safedblclick(elements, callback, data);
                } else if (type === 'mousewheel') {
                    ViperUtil.$(elements).mousewheel(callback);
                } else {
                    ViperUtil.$(elements).bind(type, data, callback);
                }
            }

        },

        
        removeEvent: function(elements, type, func)
        {
            if (elements) {
                ViperUtil.$(elements).unbind(type, func);
            }

        },

        safedblclick: function(elements, clickCallback, dblClickCallback, data)
        {
            var t = null;
            ViperUtil.$(elements).bind('click', data, function(e) {
                clearTimeout(t);
                t = setTimeout(function() {
                    clickCallback.call(this, e, data);
                }, 250);
            });

            ViperUtil.$(elements).bind('dblclick', data, function(e) {
                clearTimeout(t);
                dblClickCallback.call(this, e, data);
            });

        },

        
        trigger: function(elements, type, data)
        {
            if (elements) {
                ViperUtil.$(elements).trigger(type, data);
            }

        },

        hover: function(elements, over, out)
        {
            if (elements) {
                ViperUtil.$(elements).hover(over, out);
            }

        },

        
        preventDefault: function(e)
        {
            e.preventDefault();
            e.stopPropagation();

        },

        
        getMouseEventTarget: function(evt)
        {
           var ret = null;
            if (evt.target) {
                ret = evt.target;
            } else if (evt.srcElement) {
                ret = evt.srcElement;
            }

            return ret;

        },

        
        getClass: function(className, startElement, tagName, onlyChildren)
        {
            var ret;

            if (!startElement) {
                startElement = document.body;
            }

            className = '.' + className.split(' ').join('.');

            if (tagName) {
                className = tagName + className;
            }

            if (onlyChildren === true) {
                ret = ViperUtil.$.makeArray(ViperUtil.$(startElement).children(className));
            } else {
                ret = ViperUtil.$.makeArray(ViperUtil.$(startElement).find(className));
            }

            return ret;

        },

        
        hasClass: function(element, className)
        {
            return ViperUtil.$(element).hasClass(className);

        },

        
        getStyle: function(element, property)
        {
            return ViperUtil.$(element).css(property);

        },

        
        getComputedStyle: function (el, styleName)
        {
            if (styleName) {
                styleName = ViperUtil.camelCase(styleName);
            }

            if (document.defaultView && document.defaultView.getComputedStyle) {
                var styles = document.defaultView.getComputedStyle(el, null);
                if (styleName) {
                    return styles[styleName];
                }

                return styles;
            } else if (el.currentStyle) {
                if (styleName) {
                    return el.currentStyle[styleName];
                }

                return el.currentStyle;
            }

        },

        getFirstBlockParent: function(elem, stopEl, incSelf)
        {
            if (incSelf === true && ViperUtil.isBlockElement(elem) === true) {
                return elem;
            }

            stopEl = stopEl || this._viperElement;

            while (elem.parentNode) {
                elem = elem.parentNode;
                if (stopEl && elem === stopEl) {
                    return null;
                }

                if (ViperUtil.isBlockElement(elem) === true) {
                    return elem;
                }
            }

            return null;

        },

        getParents: function(elements, filter, stopEl, blockElementsOnly)
        {
            stopEl  = stopEl || this._viperElement;
            var res = ViperUtil.$(elements).parents(filter);
            var ln  = res.length;
            var ar  = [];
            for (var i = 0; i < ln; i++) {
                if (stopEl && (res[i] === stopEl || (this.isPartOfDOM(res[i]) === true && ViperUtil.isChildOf(res[i], stopEl) === false))) {
                    break;
                }

                if (blockElementsOnly !== true || ViperUtil.isBlockElement(res[i]) === true) {
                    ar.push(res[i]);
                }
            }

            return ar;

        },

        
        getSurroundingParents: function(node, tagName, elementType, stopElem)
        {
            var parents = [];
            if (!node) {
                return parents;
            }

            stopElem   = stopElem || this._viperElement;
            var parent = node.parentNode;
            while (parent) {
                if (stopElem && parent === stopElem) {
                    break;
                }

                var c = parent.childNodes.length;
                if (c > 1) {
                    for (var i = 0; i < c; i++) {
                        var child = parent.childNodes[i];
                        if (child.nodeType === ViperUtil.ELEMENT_NODE) {
                            if (child !== node) {
                                return parents;
                            }
                        } else if (child !== node && ViperUtil.isBlank(ViperUtil.trim(child.data)) !== true) {
                            return parents;
                        }
                    }
                }

                if (!tagName) {
                    var isOfType = false;
                    if (elementType) {
                        switch (elementType) {
                            case 'block':
                                isOfType = ViperUtil.isBlockElement(parent);
                            break;

                            case 'stub':
                                isOfType = ViperUtil.isStubElement(parent);
                            break;

                            default:
                                if (parent.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isBlockElement(parent) === false) {
                                    // Inline
                                    isOfType = true;
                                }
                            break;
                        }
                    } else {
                        isOfType = true;
                    }

                    if (isOfType) {
                        parents.push(parent);
                    }
                } else if (ViperUtil.isTag(parent, tagName) === true) {
                    parents.push(parent);
                }

                node   = parent;
                parent = parent.parentNode;
            }

            return parents;

        },

        getTopSurroundingParent: function(node, tagName, elementType, stopElem)
        {
            var parents = this.getSurroundingParents(node, tagName, elementType, stopElem);
            if (parents.length > 0) {
                return parents.pop();
            }

        },

        hasSurroundingParent: function(element, parentTagName, stopEl)
        {
            var parents = this.getSurroundingParents(element, parentTagName, null, stopEl);
            if (parents.length > 0) {
                return true;
            }

            return false;

        },

        getSurroundedChildren: function(element, asTagNames)
        {
            var children = [];
            if (!element) {
                return children;
            }

            if (element.childNodes.length !== 1 || element.firstChild.nodeType !== ViperUtil.ELEMENT_NODE) {
                return children;
            }

            if (asTagNames === true) {
                children.push(ViperUtil.getTagName(element.firstChild));
            } else {
                children.push(element.firstChild);
            }

            children = children.concat(this.getSurroundedChildren(element.firstChild));
            return children;

        },

        getBlockChildren: function(parent)
        {
            var children = [];
            var c        = parent.childNodes.length;
            for (var i = 0; i < c; i++) {
                if (parent.childNodes[i].nodeType === this.ELEMENT_NODE) {
                    if (this.isBlockElement(parent.childNodes[i]) === true) {
                        children.push(parent.childNodes[i]);
                    }
                }
            }

            return children;

        },

        hasBlockChildren: function(parent)
        {
            var c = parent.childNodes.length;
            for (var i = 0; i < c; i++) {
                if (parent.childNodes[i].nodeType === this.ELEMENT_NODE) {
                    if (this.isBlockElement(parent.childNodes[i]) === true) {
                        return true;
                    }
                }
            }

            return false;

        },

        elementIsEmpty: function(elem)
        {
            if (this.isBlank(this.getNodeTextContent(elem)) === true) {
                // Might have stub elements.
                var tags = this.getTag('*', elem);
                var ln   = tags.length;
                for (var i = 0; i < ln; i++) {
                    if (this.isStubElement(tags[i]) === true) {
                        return false;
                    }
                }

                return true;
            }

            return false;

        },

        isChildOfElems: function(el, parents)
        {
            while (el && el.parentNode) {
                if (this.inArray(el.parentNode, parents) === true) {
                    return true;
                }

                el = el.parentNode;
            }

            return false;

        },

        
        isChildOf: function(el, parent, stopElem)
        {
            try {
                stopElem = stopElem || this._viperElement;

                if (parent instanceof Array) {
                    var c = parent.length;
                    while (el && el !== stopElem && el.parentNode) {
                        for (var i = 0; i < c; i++) {
                            if (el.parentNode === parent[i]) {
                                return true;
                            }
                        }

                        el = el.parentNode;
                    }
                } else {
                    while (el && el !== stopElem && el.parentNode) {
                        if (el.parentNode === parent) {
                            return true;
                        }

                        el = el.parentNode;
                    }
                }
            } catch (e) {
                // Sometimes elements have "Invalid argument" as parentNode in IE
                // which causes exception..
            }

            return false;

        },

        
        getElementsBetween: function(fromElem, toElem, range)
        {
            var elements = [];

            if (!fromElem || !toElem) {
                return elements;
            }

            if (fromElem === toElem) {
                return elements;
            }

            // The toElem could be a child of fromElem.
            if (ViperUtil.isChildOf(toElem, fromElem) === true) {
                var fElemLen = fromElem.childNodes.length;
                for (var i = 0; i < fElemLen; i++) {
                    if (fromElem.childNodes[i] === toElem) {
                        break;
                    } else if (ViperUtil.isChildOf(toElem, fromElem.childNodes[i]) === true) {
                        return ViperUtil.arrayMerge(elements, ViperUtil.getElementsBetween(fromElem.childNodes[i], toElem));
                    } else {
                        elements.push(fromElem.childNodes[i]);
                    }
                }

                return elements;
            }

            // Get the next siblings of the fromElem.
            var startEl = fromElem.nextSibling;
            while (startEl) {
                if (ViperUtil.isChildOf(toElem, startEl) === true) {
                    // If the toElem is a child of this element then
                    // we have to get the elements from this node to target node.
                    elements = ViperUtil.arrayMerge(elements, ViperUtil.getElementsBetween(startEl, toElem));
                    return elements;
                } else if (startEl === toElem) {
                    return elements;
                } else {
                    elements.push(startEl);
                    startEl = startEl.nextSibling;
                }
            }

            var fromParents = ViperUtil.getParents(fromElem);
            var toParents   = ViperUtil.getParents(toElem);

            // Find the parents of fromElem that are not parent of toElem.
            var parentElems = ViperUtil.arrayDiff(fromParents, toParents, true);
            var pElemLen    = parentElems.length;
            for (var j = 0; j < (pElemLen - 1); j++) {
                elements = ViperUtil.arrayMerge(elements, ViperUtil.getSiblings(parentElems[j], 'next'));
            }

            var lastParent = parentElems[(parentElems.length - 1)];
            if (lastParent) {
                elements = ViperUtil.arrayMerge(elements, ViperUtil.getElementsBetween(lastParent, toElem));

                if (lastParent.firstChild === lastParent.lastChild
                    && lastParent.firstChild === fromElem
                    && lastParent !== toElem
                    && (!range || range.startOffset === 0)
                ) {
                   elements.push(lastParent);
                }
            }

            return elements;

        },

        
        getSiblings: function(element, dir, elementNodesOnly, stopElem)
        {
            if (elementNodesOnly === true) {
                if (dir === 'prev') {
                    return ViperUtil.$(element).prevAll();
                } else {
                    return ViperUtil.$(element).nextAll();
                }
            } else {
                var elems = [];
                if (dir === 'prev') {
                    while (element.previousSibling) {
                        element = element.previousSibling;
                        if (element === stopElem) {
                            break;
                        }

                        elems.push(element);
                    }
                } else {
                    while (element.nextSibling) {
                        element = element.nextSibling;
                        if (element === stopElem) {
                            break;
                        }

                        elems.push(element);
                    }
                }

                return elems;
            }//end if

        },

        
        isPartOfDOM: function (element, parent)
        {
            parent = parent || document.body;
            return parent.contains(element);

        },

        
        arrayMerge: function (array1, array2)
        {
            // We won't maintain the index if array1 is a JS array because if it tries to
            // merge with a string index it would fail.
            if (array1 instanceof Array) {
                var maintainIndex = false;
            } else {
                var maintainIndex = true;
            }

            // Do the merging.
            ViperUtil.foreach(array2, function(idx) {
                var value = array2[idx];
                if (maintainIndex === true) {
                    array1[idx] = value;
                } else {
                    array1.push(value);
                }
            });

            return array1;

        },

        
        foreach: function(value, cb)
        {
            if (value instanceof Array) {
                var len = value.length;
                for (var i = 0; i < len; i++) {
                    var res = cb.call(this, i);
                    if (res === false) {
                        break;
                    }
                }
            } else {
                for (var id in value) {
                    if (value.hasOwnProperty(id) === true) {
                        var res = cb.call(this, id);
                        if (res === false) {
                            break;
                        }
                    }
                }
            }

        },

        
        attr: function(elements, key, val)
        {
            if (ViperUtil.isset(val) === true) {
                return ViperUtil.$(elements).attr(key, val);
            } else {
                return ViperUtil.$(elements).attr(key);
            }

        },

        removeAttr: function(elements, name)
        {
            ViperUtil.$(elements).removeAttr(name);

        },

        
        getBoundingRectangle: function(element)
        {
            // Retrieve the coordinates and dimensions of the element.
            var coords     = ViperUtil.getElementCoords(element);
            var width      = ViperUtil.getElementWidth(element);
            var height     = ViperUtil.getElementHeight(element);

            // Create an array by using the elements dimensions.
            var result = {
                x1: parseInt(coords.x),
                y1: parseInt(coords.y),
                x2: parseInt(coords.x + width),
                y2: parseInt(coords.y + height)
            };
            return result;

        },

        
        getNodeTextContent: function(node)
        {
           return ViperUtil.$(node).text();

        },

        getUniqueId: function()
        {
            var id  = Math.ceil((1 + Math.random()) * 100000).toString();
            id     += Math.ceil((1 + Math.random()) * 100000).toString();
            return id;

        },

        
        getid: function(id, startElement)
        {
            if (!startElement) {
                startElement = document;
            }

            element = startElement.getElementById(id);
            return element;

        },

        
        empty: function(element)
        {
            if (element) {
                return ViperUtil.$(element).empty();
            }

        },

        find: function(parent, exp)
        {
            // Note: For valid selectors for exp go to http://docs.jquery.com/Selectors.
            return ViperUtil.$(parent).find(exp);

        },

        getFirstChildTextNode: function(node)
        {
            if (node.firstChild) {
                if (node.firstChild.nodeType === ViperUtil.ELEMENT_NODE) {
                    return ViperUtil.getFirstChildTextNode(node.firstChild);
                } else {
                    return node.firstChild;
                }
            } else if (node && node.nodeType === ViperUtil.TEXT_NODE) {
                return node;
            }

            return null;

        },

        getFirstElementChild: function (node)
        {
            if (node) {
                if (node.firstElementChild) {
                    return node.firstElementChild;
                } else {
                    var child = node.firstChild
                    while (child) {
                        if (child.nodeType === ViperUtil.ELEMENT_NODE) {
                            return child;
                        }

                        child = child.nextSibling;
                    }
                }
            }

            return null;

        },

        getLastChildTextNode: function(node)
        {
            if (node.lastChild) {
                if (node.lastChild.nodeType === ViperUtil.ELEMENT_NODE) {
                    return ViperUtil.getLastChildTextNode(node.lastChild);
                } else {
                    return node.lastChild;
                }
            } else if (node && node.nodeType === ViperUtil.TEXT_NODE) {
                return node;
            }

            return null;

        },

        copyAttributes: function(fromElem, toElem, override)
        {
            override = override || true;

            if (!fromElem || !toElem) {
                return;
            }

            for (var i = 0; i < fromElem.attributes.length; i++) {
                var attr = fromElem.attributes[i];
                if (override !== true || this.hasAttribute(toElem, attr.name) === false) {
                    this.attr(toElem, attr.name, attr.value);
                }
            }

        },

        hasAttribute: function(element, attribute)
        {
            if (element.hasAttribute) {
                return element.hasAttribute(attribute);
            } else if (element.getAttribute) {
                if (element.getAttribute(attribute) === null) {
                    return false;
                } else {
                    return true;
                }
            }

            return false;

        },

        
        hasContent: function (element)
        {
            if (ViperUtil.isBlank(ViperUtil.getNodeTextContent(element)) === true) {
                // Might have stub elements.
                var tags = ViperUtil.getTag('*', element);
                var ln   = tags.length;
                for (var i = 0; i < ln; i++) {
                    if (ViperUtil.isStubElement(tags[i]) === true && ViperUtil.isTag(tags[i], 'br') === false) {
                        return true;
                    }
                }

                return false;
            }

            return true;

        },

        
        getElementHeight: function(element, inner)
        {
            if (inner === true) {
                return element.clientHeight;
            } else {
                return element.offsetHeight;
            }

        },

        
        getElementWidth: function(element, inner)
        {
            if (inner === true) {
                return element.clientWidth;
            } else {
                return element.offsetWidth;
            }

        },

        isFn: function(f)
        {
            if (typeof f === 'function') {
                return true;
            }

            return false;

        },

        
        getWindowDimensions: function(win)
        {
            win = win || window;
            var windowWidth  = 0;
            var windowHeight = 0;
            if (win.innerWidth) {
                // Will work on Mozilla, Opera and Safari etc.
                windowWidth  = win.innerWidth;
                windowHeight = win.innerHeight;
                // If the scrollbar is showing (it is always showing in IE) then its'
                // width needs to be subtracted from the height and/or width.
                var scrollWidth = ViperUtil.getScrollbarWidth();
                // The documentElement.scrollHeight.
                if (win.document.documentElement.scrollHeight > windowHeight) {
                    // Scrollbar is shown.
                    if (typeof scrollWidth === 'number') {
                        windowWidth -= scrollWidth;
                    }
                }

                if (win.document.body.scrollWidth > windowWidth) {
                    // Scrollbar is shown.
                    if (typeof scrollWidth === 'number') {
                        windowHeight -= scrollWidth;
                    }
                }
            } else if (win.document.documentElement && (win.document.documentElement.clientWidth || win.document.documentElement.clientHeight)) {
                // Internet Explorer.
                windowWidth  = win.document.documentElement.clientWidth;
                windowHeight = win.document.documentElement.clientHeight;
            } else if (win.document.body && (win.document.body.clientWidth || win.document.body.clientHeight)) {
                // Browsers that are in quirks mode or weird examples fall through here.
                windowWidth  = win.document.body.clientWidth;
                windowHeight = win.document.body.clientHeight;
            }//end if

            var result = {
                'width'  : windowWidth,
                'height' : windowHeight
            };
            return result;

        },

        
        getScrollCoords: function(win)
        {
            win = win || window;
            var scrollX = 0;
            var scrollY = 0;
            if (win.pageYOffset) {
                // Mozilla, Firefox, Safari and Opera will fall into here.
                scrollX = win.pageXOffset;
                scrollY = win.pageYOffset;
            } else if (win.document.body && (win.document.body.scrollLeft || win.document.body.scrollTop)) {
                // This is the DOM compliant method of retrieving the scroll position.
                // Safari and OmniWeb supply this, but report wrongly when the window
                // is not scrolled. They are caught by the first condition however, so
                // this is not a problem.
                scrollX = win.document.body.scrollLeft;
                scrollY = win.document.body.scrollTop;
            } else {
                // Internet Explorer will get into here when in strict mode.
                scrollX = win.document.documentElement.scrollLeft;
                scrollY = win.document.documentElement.scrollTop;
            }

            var coords = {
                x: scrollX,
                y: scrollY
            };
            return coords;

        },

        getElementScrollCoords: function(element)
        {
            var scrollX = 0;
            var scrollY = 0;

            if (ViperUtil.isset(element.scrollLeft) === true) {
                scrollX = element.scrollLeft;
                scrollY = element.scrollTop;
            }

            var coords = {
                x: scrollX,
                y: scrollY
            };
            return coords;

        },

        
        getScrollbarWidth: function()
        {
            if (ViperUtil._scrollBarWidth) {
                return ViperUtil._scrollBarWidth;
            }

            var wrapDiv            = null;
            var childDiv           = null;
            var widthNoScrollBar   = 0;
            var widthWithScrollBar = 0;
            // Outer scrolling div.
            wrapDiv                = document.createElement('div');
            wrapDiv.style.position = 'absolute';
            wrapDiv.style.top      = '-1000px';
            wrapDiv.style.left     = '-1000px';
            wrapDiv.style.width    = '100px';
            wrapDiv.style.height   = '50px';
            // Start with no scrollbar.
            wrapDiv.style.overflow = 'hidden';

            // Inner content div.
            childDiv              = document.createElement('div');
            childDiv.style.width  = '100%';
            childDiv.style.height = '200px';

            // Put the inner div in the scrolling div.
            wrapDiv.appendChild(childDiv);
            // Append the scrolling div to the doc.
            document.body.appendChild(wrapDiv);

            // Width of the inner div sans scrollbar.
            widthNoScrollBar = childDiv.offsetWidth;
            // Add the scrollbar.
            wrapDiv.style.overflow = 'auto';
            // Width of the inner div width scrollbar.
            widthWithScrollBar = childDiv.offsetWidth;

            // Remove the scrolling div from the doc.
            document.body.removeChild(document.body.lastChild);

            // Pixel width of the scroller.
            var scrollBarWidth = (widthNoScrollBar - widthWithScrollBar);
            // Set the DOM variable so we don't have to run this again.
            ViperUtil._scrollBarWidth = scrollBarWidth;
            return scrollBarWidth;

        },

        
        getElementCoords: function(element, relative)
        {
            var offset = ViperUtil.$(element).offset();
            return {
                x: offset.left,
                y: offset.top
            };

        },

        getElementFrameElement: function(element)
        {
            if (element.ownerDocument.defaultView) {
                return element.ownerDocument.defaultView.frameElement;
            } else {
                return element.ownerDocument.frames.frameElement;
            }

            return null;

        },

        
        determinePosition: function(element, settings)
        {
            settings         = settings || {};
            targetElement    = settings.targetElement;
            alignClassPrefix = settings.alignClassPrefix || 'ViperUtil-align';
            arrowClassPrefix = settings.arrowClassPrefix || 'ViperUtil-arrow';
            var validPositions = {
                left: ['right.middle', 'right.top', 'right.bottom'],
                right: ['left.middle', 'left.top', 'left.bottom'],
                bottom:['top.left', 'top.middle', 'top.right'],
                top: ['bottom.left', 'bottom.middle', 'bottom.right']
            };

            var classNames = ['top', 'left', 'right', 'bottom', 'middle', 'center'];
            ViperUtil.foreach(
                classNames,
                function(i) {
                    ViperUtil.removeClass(element, alignClassPrefix + classNames[i]);
                    ViperUtil.removeClass(element, arrowClassPrefix + classNames[i]);
                }
            );

            // Check if the target element is off screen.
            if (this.isElementOffScreen(targetElement) === true) {
                // Set position to the top left of the window.
                var relPos = ViperUtil.getRelativeWindowPosition(
                    targetElement.ownerDocument.defaultView.frameElement,
                    element.ownerDocument.defaultView.frameElement
                );

                ViperUtil.setStyle(element, 'left', relPos.x + 'px');
                ViperUtil.setStyle(element, 'top', relPos.y + 'px');

                return;
            }

            // Get target elements position.
            var relPos     = ViperUtil.getRelativeWindowPosition(targetElement, this.getElementFrameElement(element));
            var targetRect = {};
            targetRect.x1  = relPos.x;
            targetRect.y1  = relPos.y;
            targetRect.x2  = relPos.x + ViperUtil.getElementWidth(targetElement);
            targetRect.y2  = relPos.y + ViperUtil.getElementHeight(targetElement);

            // Get the rectangle of the element that will be moved.
            var elemRect = ViperUtil.getBoundingRectangle(element);
            var elemH    = (elemRect.y2 - elemRect.y1);
            var elemW    = (elemRect.x2 - elemRect.x1);

            // Get window dimensions.
            var winDim     = ViperUtil.getWindowDimensions(element.ownerDocument.defaultView);
            var targetMidX = 0;
            var targetMidY = 0;
            var self       = this;

            var _positionElement = function(position, arrowPositions) {
                switch (position) {
                    case 'top':
                        targetMidX = targetRect.x1 + ((targetRect.x2 - targetRect.x1) / 2);
                        targetMidY = targetRect.y1;
                    break;

                    case 'bottom':
                        targetMidX = targetRect.x1 + ((targetRect.x2 - targetRect.x1) / 2);
                        targetMidY = targetRect.y2;
                    break;

                    case 'left':
                        targetMidX = targetRect.x1;
                        targetMidY = targetRect.y1 + ((targetRect.y2 - targetRect.y1) / 2);
                    break;

                    case 'right':
                        targetMidX = targetRect.x2;
                        targetMidY = targetRect.y1 + ((targetRect.y2 - targetRect.y1) / 2);
                    break;

                    default:
                    return false;
                }//end switch

                // Using the default position top left (of the intervention box) determine
                // the correct position.
                var oln            = arrowPositions.length;
                var arrowElemWidth = 19;
                var arrowElemHeight = 31;
                var arrowPadding    = 15;
                for (var o = 0; o < oln; o++) {
                    var posX  = 0;
                    var posY  = 0;
                    var classParts = arrowPositions[o].split('.');
                    switch (classParts[0]) {
                        case 'top':
                            posY = targetMidY;
                        break;

                        case 'bottom':
                            posY = (targetMidY - elemH);
                        break;

                        case 'right':
                            posX = (targetMidX - elemW - arrowElemWidth);
                        break;

                        case 'left':
                            posX = targetMidX;
                        break;

                        default:
                            // Unknown type.
                        break;
                    }//end switch

                    switch (classParts[1]) {
                        case 'left':
                            posX = targetMidX;
                        break;

                        case 'right':
                            posX = (targetMidX - elemW);
                        break;

                        case 'middle':
                            if (classParts[0] === 'top' || classParts[0] === 'bottom') {
                                classParts[1] = 'center';
                                posX     = (targetMidX - (elemW / 2));
                            } else {
                                posY = (targetMidY - (elemH / 2));
                            }
                        break;

                        case 'top':
                            posY = (targetMidY - (arrowElemHeight / 2) - arrowPadding);
                        break;

                        case 'bottom':
                            posY = (targetMidY - (elemH - (arrowElemHeight / 2) - arrowPadding));
                        break;

                        default:
                            // Unknown type.
                        break;
                    }//end switch

                    var scrollCoords = ViperUtil.getScrollCoords(element.ownerDocument.defaultView);

                    if (settings.fixedPositioning === true) {
                        posX  = Math.abs(posX);
                        posY  = Math.abs(posY);
                    } else {
                        posX += scrollCoords.x;
                        posY += scrollCoords.y;
                    }

                    ViperUtil.addClass(element, arrowClassPrefix + classParts[0]);
                    ViperUtil.addClass(element, alignClassPrefix + classParts[1]);
                    ViperUtil.setStyle(element, 'left', posX + 'px');
                    ViperUtil.setStyle(element, 'top', posY + 'px');

                    // Check if the element is on the screen.
                    if (self.isElementCutOff(element) === false) {
                        // Its on the screen so set styles and stop looping.
                        // Or last in loop (keep the last arrow style).
                        return true;
                    } else {
                        ViperUtil.removeClass(element, arrowClassPrefix + classParts[0]);
                        ViperUtil.removeClass(element, alignClassPrefix + classParts[1]);
                    }
                }//end for

                return false;
            };

            var positioned = false;
            if (settings.position) {
                positioned = _positionElement(settings.position, settings.arrowPositions)
            }

            if (positioned === false) {
                // Auto position.
                for (var pos in validPositions) {
                    if (_positionElement(pos, validPositions[pos]) === true) {
                        return;
                    }
                }
            }

        },

        isElementOffScreen: function(element)
        {
            var coords       = ViperUtil.getElementCoords(element);
            var dims         = ViperUtil.getElementDimensions(element);
            var scrollCoords = ViperUtil.getScrollCoords(element.ownerDocument.defaultView);
            var windowDims   = ViperUtil.getWindowDimensions(element.ownerDocument.defaultView);

            coords.x -= scrollCoords.x;
            coords.y -= scrollCoords.y;
            if (coords.y + dims.height < 0
                || coords.y > windowDims.height
                || coords.x + dims.width < 0
                || coords.x > windowDims.width
            ) {
                return true;
            }

            return false;

        },

        
        isElementCutOff: function(element)
        {
            // Get the actual view size.
            var win          = element.ownerDocument.defaultView || window;
            var scrollCoords = ViperUtil.getScrollCoords(win);
            var winHeight    = ViperUtil.$(win).height();
            var winWidth     = ViperUtil.$(win).width();
            var relPos       = ViperUtil.getRelativeWindowPosition(element);
            var elDim        = ViperUtil.getElementDimensions(element);
            var coords       = ViperUtil.getElementCoords(element, true);

            coords.x -= scrollCoords.x;
            coords.y -= scrollCoords.y;

            // Check position in current document.
            if (coords.y < 0
                || coords.y + elDim.height > winHeight
                || coords.x < 0
                || coords.x + elDim.width > winWidth
            ) {
                return true;
            }

            while (win.frameElement) {
                win = win.frameElement.ownerDocument.defaultView;
                var parentHeight = ViperUtil.$(win).height();
                var parentWidth  = ViperUtil.$(win).width();
                if (parentHeight < winHeight) {
                    winHeight = parentHeight;
                }

                if (parentWidth < winWidth) {
                    winWidth = parentWidth;
                }
            }

            // Check position in parent documents.
            if (relPos.y < 0
                || relPos.y + elDim.height > winHeight
                || relPos.x < 0
                || relPos.x + elDim.width > winWidth
            ) {
                return true;
            }

            return false;

        },

         isIntersectingRect: function(rect1, rect2)
         {
             if (rect2.x1 > rect1.x2
                 || rect2.x2 < rect1.x1
                 || rect2.y1 > rect1.y2
                 || rect2.y2 < rect1.y1
             ) {
                 return false;
             }

             return true;

        },

        
        getElementDimensions: function(element, inner)
        {
            // Default to outer dimensions by default.
            if (inner === undefined) {
                inner = false;
            }

            var result = {
                width: ViperUtil.getElementWidth(element, inner),
                height: ViperUtil.getElementHeight(element, inner)
            };

            return result;

        },


        
        getRelativeWindowPosition: function(elem, topFrame)
        {
            var offset       = null;
            var frameElement = this.getElementFrameElement(elem);
            if (frameElement) {
                offset = ViperUtil.getElementCoords(elem);
                if (frameElement !== topFrame) {
                    var frameOffset = ViperUtil.getRelativeWindowPosition(frameElement, topFrame);
                    offset.x       += frameOffset.x;
                    offset.y       += frameOffset.y;
                }
            } else {
                offset = ViperUtil.getElementCoords(elem);
            }

            var scrollCoords = ViperUtil.getScrollCoords(elem.ownerDocument.defaultView);
            offset.y        -= scrollCoords.y;
            offset.x        -= scrollCoords.x;

            return offset;

        },

        removeEmptyNodes: function(parent, callback)
        {
            var elems   = ViperUtil.$(parent).find(':empty');
            var i       = elems.length;
            var removed = false;
            while (i > 0) {
                i--;
                if (ViperUtil.isStubElement(elems[i]) === false) {
                    if (!callback || callback.call(this, elems[i]) !== false) {
                        ViperUtil.remove(elems[i]);
                        removed = true;
                    }
                }
            }

            if (removed === true) {
                this.removeEmptyNodes(parent, callback);
            }

        },

        
        getXPath: function(node)
        {
            var path = '';

            while (node && node.parentNode) {
                if (node.nodeType === ViperUtil.TEXT_NODE) {
                    var sibling = node.previousSibling;
                    var pos     = 1;
                    while (sibling) {
                        pos++;
                        sibling = sibling.previousSibling;
                    }

                    if (pos <= 1) {
                        path = '/node()';
                    } else {
                        path = '/node()[' + pos + ']';
                    }
                } else {
                    var nodeName = node.nodeName.toLowerCase();
                    var sibling = node.previousSibling;
                    var pos     = 1;
                    while (sibling) {
                        if (sibling.nodeType === ViperUtil.ELEMENT_NODE &&
                            nodeName === sibling.nodeName.toLowerCase()
                        ) {
                            pos++;
                        }

                        sibling = sibling.previousSibling;
                    }

                    if (pos <= 1) {
                        path = '/' + nodeName + path;
                    } else {
                        path = '/' + nodeName + '[' + pos + ']' + path;
                    }
                }//end if

                node = node.parentNode;
            }//end while

            return path;

        },

        
        getNodeFromXPath: function(path)
        {
            if (document.evaluate) {
                var node = document.evaluate(path, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                return node.singleNodeValue;
            } else {
                return ViperUtil.getNodeFromPath(path);
            }

        },


        
        getNodeFromPath: function(path)
        {
            var paths  = path.split('/');
            var parent = document;
            var pln    = paths.length;
            for (var i = 0; i < pln; i++) {
                if (ViperUtil.trim(paths[i]) === '') {
                    continue;
                }

                parent = ViperUtil.getNodeFromPathSegment(parent, paths[i]);
            }

            return parent;

        },

        
        getNodeFromPathSegment: function(parent, path)
        {
            var pos = path.match(/\[(\d+)\]/);

            if (!pos) {
                pos = 1;
            } else {
                pos = parseInt(pos[1]);
                if (!pos) {
                    pos = 1;
                }
            }

            var brPos = path.indexOf('[') || path.length;
            var type  = path.substr(0, brPos);

            if (!type) {
                type = path;
            }

            var node, found = 1;
            var cln         = parent.childNodes.length;
            for (var i = 0; i < cln; i++) {
                node = parent.childNodes[i];

                if (node.nodeType === ViperUtil.DOCUMENT_TYPE_NODE) {
                    continue;
                }

                if (type === 'node()') {
                    if (found === pos) {
                        return node;
                    }

                    found++;
                } else if (node.nodeName && type === node.nodeName.toLowerCase()) {
                    if (found === pos) {
                        return node;
                    }

                    found++;
                }
            }

            throw Error('XPath: node could not be found');

        },

        getFrames: function(doc)
        {
            doc = doc || document;
            if (doc.frames) {
                return doc.frames;
            } else if (doc.defaultView.frames) {
                return doc.defaultView.frames;
            }

            return [];
        },


        
         getDocuments: function(nested, parentDoc)
         {
             parentDoc  = parentDoc || document;
             var docs   = [parentDoc];
             var frames = this.getFrames(parentDoc);
             var c      = frames.length;
             for (var i = 0; i < c; i++) {
                 var doc = this.getIFrameDocument(frames[i]);
                 if (doc !== null) {
                     if (nested === true) {
                         docs = docs.concat(dfx.getDocuments(nested, doc))
                     } else {
                         docs.push(doc);
                     }
                 }
             }

             return docs;

        },

        getTopDocument: function()
        {
            var doc = document;
            while (doc.defaultView.frameElement) {
                doc = doc.defaultView.frameElement.ownerDocument;
            }

            return doc;

        },

        
        getIFrameDocument: function(iframe)
        {
            var doc = null;
            try {
                if (iframe.contentDocument) {
                    doc = iframe.contentDocument;
                } else if (iframe.contentWindow) {
                    doc = iframe.contentWindow.document;
                } else if (iframe.document) {
                    doc = iframe.document;
                }
            } catch (e) {
                doc = null;
            }

            return doc;

        },

        getDocumentOffset: function(doc)
        {
            var doc    = doc || Viper.document;
            var offset = {
                x: 0,
                y: 0
            };

            while (document !== doc) {
                var frameElem = doc.defaultView.frameElement;
                if (!frameElem) {
                    continue;
                }

                var coords = this.getElementCoords(frameElem);
                offset.x  += coords.x;
                offset.y  += coords.y;
                doc        = frameElem.ownerDocument;
            }

            return offset;

        },


        getDocumentWindow: function()
        {
            return Viper.document.defaultView;

        },

        
        sprintf: function(str)
        {
            var c = arguments.length;
            if (c <= 1) {
                return str;
            }

            for (var i = 1; i < c; i++) {
                str = str.replace(/%s/, arguments[i]);
            }

            return str;

        },

        walk: function(elem, callback, stopElem, lvl)
        {
            if (!elem || elem === stopElem) {
                return false;
            }

            if (!lvl) {
                lvl = 0;
            }

            var nextSibling = elem.nextSibling;
            var parentNode  = elem.parentNode;

            var retVal = callback.call(this, elem, lvl);
            if (retVal === false) {
                // Stop.
                return false;
            } else if (retVal instanceof Object) {
                nextSibling = retVal;
            }

            if (elem.childNodes && elem.childNodes.length > 0) {
                if (ViperUtil.walk(elem.firstChild, callback, stopElem, (lvl + 1)) === false) {
                    return false;
                }
            } else if (nextSibling) {
                if (ViperUtil.walk(nextSibling, callback, stopElem, lvl) === false) {
                    return false;
                }
            } else {
                while (parentNode && !parentNode.nextSibling) {
                    parentNode = parentNode.parentNode;
                    lvl--
                }

                if (!parentNode) {
                    return false;
                }

                if (ViperUtil.walk(parentNode.nextSibling, callback, stopElem, (lvl - 1)) === false) {
                    return false;
                }
            }//end if

        },

        
        setNodeTextContent: function(node, txt)
        {
           return ViperUtil.$(node).text(txt);

        },

        
        inherits: function(child, parent)
        {
            var above = function(){};
            if (ViperUtil.isset(parent) === true) {
                for (value in parent.prototype) {
                    // If the child method already exists, move this method to the parent
                    // so it can be called using super.method().
                    if (child.prototype[value]) {
                        above.prototype[value] = parent.prototype[value];
                        continue;
                    }

                    child.prototype[value] = parent.prototype[value];
                }
            }

            if (child.prototype) {
                above.prototype.constructor = parent;
                child.prototype['super']    = new above();
            }

        },

        isArray: function(v)
        {
            return ViperUtil.$.isArray(v);

        },

        
        inArray: function(needle, haystack, typeSensitive)
        {
            if (ViperUtil.isset(typeSensitive) === false) {
                typeSensitive = true;
            }

            var hln = haystack.length;
            for (var i = 0; i < hln; i++) {
                if ((typeSensitive === true && needle === haystack[i]) ||
                    (typeSensitive === false && needle == haystack[i])
                ) {
                    return true;
                }
            }

            return false;

        },

        
        arraySearch: function(needle, haystack)
        {
            var length = haystack.length;
            for (var i = 0; i < length; i++) {
                if (haystack[i] === needle) {
                    return i;
                }
            }

            return -1;

        },

        removeArrayIndex: function(array, index)
        {
            if (!array || index >= array.length) {
                return null;
            }

            return array.splice(index, 1);

        },

        
        arrayDiff: function(array1, array2, firstOnly)
        {
            var al  = array1.length;
            var res = [];
            for (var i = 0; i < al; i++) {
                if (ViperUtil.inArray(array1[i], array2) === false) {
                    res.push(array1[i]);
                }
            }

            if (firstOnly !== true) {
                al = array2.length;
                for (var i = 0; i < al; i++) {
                    if (ViperUtil.inArray(array2[i], array1) === false) {
                        res.push(array2[i]);
                    }
                }
            }

            return res;

        },

        arrayIntersect: function(array1, array2)
        {
            var newArray = [];
            var n1c = array1.length;
            var n2c = array2.length;
            for (var i = 0; i < n1c; i++) {
                if (newArray.length === n2c) {
                    break;
                }

                for (var j = 0; j < n2c; j++) {
                    if (array1[i] === array2[j]) {
                        newArray.push(array1[i]);
                        break;
                    }
                }
            }

            return newArray;

        },

        arrayUnique: function(array) {
            var tmp      = {};
            var newArray = [];
            var ln  = array.length;
            for (var i = 0; i < ln; i++) {
                if (tmp[array[i]] === true) {
                    continue;
                }

                tmp[array[i]] = true;
                newArray.push(array[i]);
            }

            return newArray;

        },

        
        ellipsize: function(value, length)
        {
            // Type validation.
            if (typeof value !== 'string' || typeof length !== 'number') {
                return '';
            }

            // Length needs to be at least zero.
            if (length < 0) {
                return '';
            }

            // If the string is not long enough, don't change it.
            if (value.length <= length) {
                return value;
            }

            value = value.substr(0, length);
            value = value.replace(/\s$/, '');

            // Figure out how many dots are on the end of the
            // string so we don't add too many.
            var end       = value.substr((length - 3), 3);
            var endNoDots = end.replace(/\.$/, '');
            var numDots   = (end.length - endNoDots.length);

            value = value + ViperUtil.strRepeat('.', (3 - numDots));
            return value;

        },

        strRepeat: function(str, multiplier)
        {
            var rstr = '';
            for (var i = 0; i < multiplier; i++) {
                rstr += str;
            }

            return rstr;

        },

        stripTags: function(content, allowedTags)
        {
            var match;
            var re      = new RegExp(/<\/?(\w+)((\s+\w+(\s*=\s*(?:".*?"|'.*?'|[^'">\s]+))?)+\s*|\s*)\/?>/gim);
            var resCont = content;
            while ((match = re.exec(content)) != null) {
                if (ViperUtil.isset(allowedTags) === false || ViperUtil.inArray(match[1], allowedTags) !== true) {
                    resCont = resCont.replace(match[0], '');
                }
            }

            return resCont;

        },

        commonEntitiesArray: {
            160: '&nbsp;',     // space
            168: '&uml;',      //  ¨
            169: '&copy;',     //  ©
            170: '&ordf;',     //  ª
            171: '&laquo;',    //  «
            172: '&not;',      //  ¬
            173: '&shy;',      //  ­
            174: '&reg;',      //  ®
            175: '&macr;',     //  ¯
            176: '&deg;',      //  °
            177: '&plusmn;',   //  ±
            178: '&sup2;',     //  ²
            179: '&sup3;',     //  ³
            180: '&acute;',    //  ´
            181: '&micro;',    //  µ
            182: '&para;',     //  ¶
            183: '&middot;',   //  ·
            184: '&cedil;',    //  ¸
            185: '&sup1;',     //  ¹
            186: '&ordm;',     //  º
            187: '&raquo;',    //  »
            188: '&frac14;',   //  ¼
            189: '&frac12;',   //  ½
            190: '&frac34;',   //  ¾
            191: '&iquest;',   //  ¿
            215: '&times;',    //  ×
            247: '&divide;',   //  ÷
            977: '&thetasym;', //  ϑ
            978: '&upsih;',    //  ϒ
            982: '&piv;',      //  ϖ
            8216: '&lsquo;',   //  ‘
            8217: '&rsquo;',   //  ’
            8218: '&sbquo;',   //  ‚
            8220: '&ldquo;',   //  “
            8221: '&rdquo;',   //  ”
            8222: '&bdquo;',   //  „
            8223: '&ldquo;',   //  “
            8226: '&bull;',    //  *
            8230: '&hellip;',  //  …
            8242: '&prime;',   //  ′
            8243: '&Prime;',   //  ″
            8254: '&oline;',   //  ‾
            8260: '&frasl;',   //  ⁄
            8472: '&weierp;',  //  ℘
            8465: '&image;',   //  ℑ
            8476: '&real;',    //  ℜ
            8482: '&trade;',   //  ™
            8501: '&alefsym;', //  ℵ
            8592: '&larr;',    //  ←
            8593: '&uarr;',    //  ↑
            8594: '&rarr;',    //  →
            8595: '&darr;',    //  ↓
            8596: '&harr;',    //  ↔
            8629: '&crarr;',   //  ↵
            8656: '&lArr;',    //  ⇐
            8657: '&uArr;',    //  ⇑
            8658: '&rArr;',    //  ⇒
            8659: '&dArr;',    //  ⇓
            8660: '&hArr;',    //  ⇔
            8704: '&forall;',  //  ∀
            8706: '&part;',    //  ∂
            8707: '&exist;',   //  ∃
            8709: '&empty;',   //  ∅
            8711: '&nabla;',   //  ∇
            8712: '&isin;',    //  ∈
            8713: '&notin;',   //  ∉
            8715: '&ni;',      //  ∋
            8719: '&prod;',    //  ∏
            8721: '&sum;',     //  ∑
            8722: '&minus;',   //  −
            8727: '&lowast;',  //  ∗
            8730: '&radic;',   //  √
            8733: '&prop;',    //  ∝
            8734: '&infin;',   //  ∞
            8736: '&ang;',     //  ∠
            8743: '&and;',     //  ∧
            8744: '&or;',      //  ∨
            8745: '&cap;',     //  ∩
            8746: '&cup;',     //  ∪
            8747: '&int;',     //  ∫
            8756: '&there4;',  //  ∴
            8764: '&sim;',     //  ∼
            8773: '&cong;',    //  ≅
            8776: '&asymp;',   //  ≈
            8800: '&ne;',      //  ≠
            8801: '&equiv;',   //  ≡
            8804: '&le;',      //  ≤
            8805: '&ge;',      //  ≥
            8834: '&sub;',     //  ⊂
            8835: '&sup;',     //  ⊃
            8836: '&nsub;',    //  ⊄
            8838: '&sube;',    //  ⊆
            8839: '&supe;',    //  ⊇
            8853: '&oplus;',   //  ⊕
            8855: '&otimes;',  //  ⊗
            8869: '&perp;',    //  ⊥
            8901: '&sdot;',    //  ⋅
            8968: '&lceil;',   //  ⌈
            8969: '&rceil;',   //  ⌉
            8970: '&lfloor;',  //  ⌊
            8971: '&rfloor;',  //  ⌋
            9001: '&lang;',    //  ⟨
            9002: '&rang;',    //  ⟩
            9674: '&loz;',     //  ◊
            9824: '&spades;',  //  ♠
            9827: '&clubs;',   //  ♣
            9829: '&hearts;',  //  ♥
            9830: '&diams;'    //  ♦
        },

        alphabetEntitiesArray: {
            161: '&iexcl;',    //  ¡
            162: '&cent;',     //  ¢
            163: '&pound;',    //  £
            164: '&curren;',   //  ¤
            165: '&yen;',      //  ¥
            166: '&brvbar;',   //  ¦
            167: '&sect;',     //  §
            192: '&Agrave;',   //  À
            193: '&Aacute;',   //  Á
            194: '&Acirc;',    //  Â
            195: '&Atilde;',   //  Ã
            196: '&Auml;',     //  Ä
            197: '&Aring;',    //  Å
            198: '&AElig;',    //  Æ
            199: '&Ccedil;',   //  Ç
            200: '&Egrave;',   //  È
            201: '&Eacute;',   //  É
            202: '&Ecirc;',    //  Ê
            203: '&Euml;',     //  Ë
            204: '&Igrave;',   //  Ì
            205: '&Iacute;',   //  Í
            206: '&Icirc;',    //  Î
            207: '&Iuml;',     //  Ï
            208: '&ETH;',      //  Ð
            209: '&Ntilde;',   //  Ñ
            210: '&Ograve;',   //  Ò
            211: '&Oacute;',   //  Ó
            212: '&Ocirc;',    //  Ô
            213: '&Otilde;',   //  Õ
            214: '&Ouml;',     //  Ö
            216: '&Oslash;',   //  Ø
            217: '&Ugrave;',   //  Ù
            218: '&Uacute;',   //  Ú
            219: '&Ucirc;',    //  Û
            220: '&Uuml;',     //  Ü
            221: '&Yacute;',   //  Ý
            222: '&THORN;',    //  Þ
            223: '&szlig;',    //  ß
            224: '&agrave;',   //  à
            225: '&aacute;',   //  á
            226: '&acirc;',    //  â
            227: '&atilde;',   //  ã
            228: '&auml;',     //  ä
            229: '&aring;',    //  å
            230: '&aelig;',    //  æ
            231: '&ccedil;',   //  ç
            232: '&egrave;',   //  è
            233: '&eacute;',   //  é
            234: '&ecirc;',    //  ê
            235: '&euml;',     //  ë
            236: '&igrave;',   //  ì
            237: '&iacute;',   //  í
            238: '&icirc;',    //  î
            239: '&iuml;',     //  ï
            240: '&eth;',      //  ð
            241: '&ntilde;',   //  ñ
            242: '&ograve;',   //  ò
            243: '&oacute;',   //  ó
            244: '&ocirc;',    //  ô
            245: '&otilde;',   //  õ
            246: '&ouml;',     //  ö
            248: '&oslash;',   //  ø
            249: '&ugrave;',   //  ù
            250: '&uacute;',   //  ú
            251: '&ucirc;',    //  û
            252: '&uuml;',     //  ü
            253: '&yacute;',   //  ý
            254: '&thorn;',    //  þ
            255: '&yuml;',     //  ÿ
            402: '&fnof;',     //  ƒ
            913: '&Alpha;',    //  Α
            914: '&Beta;',     //  Β
            915: '&Gamma;',    //  Γ
            916: '&Delta;',    //  Δ
            917: '&Epsilon;',  //  Ε
            918: '&Zeta;',     //  Ζ
            919: '&Eta;',      //  Η
            920: '&Theta;',    //  Θ
            921: '&Iota;',     //  Ι
            922: '&Kappa;',    //  Κ
            923: '&Lambda;',   //  Λ
            924: '&Mu;',       //  Μ
            925: '&Nu;',       //  Ν
            926: '&Xi;',       //  Ξ
            927: '&Omicron;',  //  Ο
            928: '&Pi;',       //  Π
            929: '&Rho;',      //  Ρ
            931: '&Sigma;',    //  Σ
            932: '&Tau;',      //  Τ
            933: '&Upsilon;',  //  Υ
            934: '&Phi;',      //  Φ
            935: '&Chi;',      //  Χ
            936: '&Psi;',      //  Ψ
            937: '&Omega;',    //  Ω
            945: '&alpha;',    //  α
            946: '&beta;',     //  β
            947: '&gamma;',    //  γ
            948: '&delta;',    //  δ
            949: '&epsilon;',  //  ε
            950: '&zeta;',     //  ζ
            951: '&eta;',      //  η
            952: '&theta;',    //  θ
            953: '&iota;',     //  ι
            954: '&kappa;',    //  κ
            955: '&lambda;',   //  λ
            956: '&mu;',       //  μ
            957: '&nu;',       //  ν
            958: '&xi;',       //  ξ
            959: '&omicron;',  //  ο
            960: '&pi;',       //  π
            961: '&rho;',      //  ρ
            962: '&sigmaf;',   //  ς
            963: '&sigma;',    //  σ
            964: '&tau;',      //  τ
            965: '&upsilon;',  //  υ
            966: '&phi;',      //  φ
            967: '&chi;',      //  χ
            968: '&psi;',      //  ψ
            969: '&omega;'    //  ω
        },

        replaceNamedEntities: function(html)
        {
            var newHtml = '';
            var ln      = html.length;
            for (i = 0; i < ln; i++) {
                code = html.charCodeAt(i);
                if (code > 127) {
                    var entity = ViperUtil.commonEntitiesArray[code];
                    if (!entity) {
                        entity = ViperUtil.alphabetEntitiesArray[code];
                    }

                    if (entity) {
                        newHtml += entity;
                    } else {
                        newHtml += html.charAt(i);
                    }
                } else {
                    newHtml += html.charAt(i);
                }
            }

            return newHtml;

        },

        
        replaceCommonNamedEntities: function(html)
        {
            var newHtml = '';
            var ln      = html.length;
            for (i = 0; i < ln; i++) {
                code = html.charCodeAt(i);
                if (code > 127) {
                    var entity = ViperUtil.commonEntitiesArray[code];
                    if (entity) {
                        newHtml += entity;
                    } else {
                        newHtml += html.charAt(i);
                    }
                } else {
                    newHtml += html.charAt(i);
                }
            }

            return newHtml;

        },

        getTextNodes: function(parent, removeEmpty)
        {
            var nodes = [];

            if (ViperUtil.isBrowser('msie') === false) {
                var walk  = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT)
                while (node = walk.nextNode()) {
                    nodes.push(node);
                }
            } else {
                if (parent && parent.childNodes) {
                    var ln = parent.childNodes.length;
                    for (var i = 0; i < ln; i++) {
                        var child = parent.childNodes[i];
                        if (child.nodeType === ViperUtil.TEXT_NODE) {
                            if (removeEmpty === true && /^\s*$/.test(child.data) === true) {
                                ViperUtil.remove(child);
                            } else {
                                nodes.push(child);
                            }
                        } else if (child.childNodes && child.childNodes.length > 0) {
                            nodes = nodes.concat(ViperUtil.getTextNodes(child));
                        }
                    }
                }
            }

            return nodes;

        },

        normaliseTextNodeSiblings: function (element)
        {
            var prevCont = element.previousSibling;
            var nextCont = element.nextSibling;
            var info     = null;

            var joinTextNodes = function(toNode, node) {
                if (ViperUtil.isText(toNode) !== true || ViperUtil.isText(node) !== true) {
                    return;
                }

                if (node.data[0] === ' ' && toNode.data[(toNode.data.length - 1)] === ' ') {
                    // Node starts with space and toNode ends with space, convert space to nbsp.
                    node.data = String.fromCharCode(160) + node.data.substr(1);
                }

                toNode.data += node.data;

                ViperUtil.remove(node);
            };

            if (prevCont
                && nextCont
                && prevCont.nodeType === ViperUtil.TEXT_NODE
                && nextCont.nodeType === ViperUtil.TEXT_NODE
            ) {
                // Both siblings
                info = {
                    splitOffset: prevCont.data.length,
                    textNode: prevCont
                };

                if (nextCont.data[0] === ' ' && prevCont.data[(prevCont.data.length - 1)] === ' ') {
                    nextCont.data = String.fromCharCode(160) + nextCont.data.substr(1);
                }

                prevCont.data += nextCont.data;
            } else if (this.isText(nextCont) === true) {
                // Next container is text.
                info = {
                    splitOffset: element.data.length,
                    textNode: element
                };

                while (this.isText(element.nextSibling) === true) {
                    joinTextNodes(element, element.nextSibling);
                }
            }

            return info;

        },

        getCommonAncestor: function(a, b)
        {
            var node = a;
            while (node) {
                if (ViperUtil.isChildOf(b, node) === true) {
                    return node;
                }

                node = node.parentNode;
            }

            return null;

        },

        
        rangeInDiffBlocks: function(range)
        {
            if (range.startContainer !== range.endContainer
                && this.getFirstBlockParent(range.startContainer, true) !== this.getFirstBlockParent(range.endContainer, true)
            ) {
                return true;
            }

            return false;

        },

        clone: function(value, shallow)
        {
            if (typeof value !== 'object') {
                return value;
            }

            if (value === null) {
                var valueClone = null;
            } else {
                var valueClone = new value.constructor();
                for (var property in value) {
                    if (shallow) {
                        valueClone[property] = value[property];
                    }

                    if (value[property] === null) {
                        valueClone[property] = null;
                    } else if (typeof value[property] === 'object') {
                        valueClone[property] = ViperUtil.clone(value[property], shallow);
                    } else {
                        valueClone[property] = value[property];
                    }
                }
            }

            return valueClone;

        },

        
        addToQueryString: function(url, addQueries)
        {
            var mergedUrl        = '';
            var baseUrl          = ViperUtil.baseUrl(url);
            var queryStringArray = ViperUtil.queryString(url);
            mergedQry = ViperUtil.objectMerge(queryStringArray, addQueries);

            var queryStr = '?';
            ViperUtil.foreach(mergedQry, function(key) {
                    queryStr = queryStr + key + '=' + mergedQry[key] + '&';
                });

            // More than just a ? to add to the URL?
            if (queryStr.length > 1) {
                // Put the URL together with qry str and take off the trailing &.
                mergedUrl = baseUrl + queryStr.substr(0, (queryStr.length - 1));
            } else {
                mergedUrl = url;
            }

            var anchorPartURL = ViperUtil.getURLAnchor(url);
            if (anchorPartURL.length > 0) {
                mergedUrl = mergedUrl + anchorPartURL;
            }

            return mergedUrl;

        },

        
        queryString: function(url)
        {
            var result    = {};
            var qStartIdx = url.search(/\?/);
            if (qStartIdx === -1) {
                return result;
            } else {
                var aStartIdx = url.search(/\#/);
                if (aStartIdx === -1) {
                    var anchorPartAdj = 0;
                } else {
                    var anchorPartAdj = (url.length - aStartIdx + 1);
                }

                // QryStr part is between ? and # in the URL.
                var queryStr = url.substr((qStartIdx + 1), (url.length - qStartIdx - anchorPartAdj));
                if (queryStr.length > 0) {
                    var pairs = queryStr.split('&');
                    var len   = pairs.length;
                    var pair  = [];
                    for (var i = 0; i < len; i++) {
                        // Is it a valid key value pair?
                        if (pairs[i].search('=') !== -1) {
                            pair            = pairs[i].split('=');
                            result[pair[0]] = pair[1];
                        }
                    }

                    return result;
                } else {
                    return result;
                }
            }//end if

        },

        
        getURLAnchor: function(url)
        {
            if (typeof url === 'string') {
                var aStartIdx = url.search(/\#/);
                if (aStartIdx === -1) {
                    url = '';
                } else {
                    url = url.substr(aStartIdx, (url.length - aStartIdx));
                }
            }

            return url;

        },

        baseUrl: function(fullUrl)
        {
            var qStartIdx = fullUrl.search(/\?|#/);
            if (qStartIdx === -1) {
                return fullUrl;
            } else {
                var baseUrl = fullUrl.substr(0, qStartIdx);
                return baseUrl;
            }

        },

        loadScript: function(src, callback, timeout)
        {
            var t = null;
            if (timeout) {
                t = setTimeout(callback, timeout);
            }

            var script = document.createElement('script');
            script.onload = function() {
                clearTimeout(t);
                script.onload = null;
                script.onreadystatechange = null;
                callback.call(this);

            };

            script.onreadystatechange = function() {
                if (/^(complete|loaded)$/.test(this.readyState) === true) {
                    clearTimeout(t);
                    script.onreadystatechange = null;
                    script.onload();
                }

            }

            script.src = src;

            if (document.head) {
                document.head.appendChild(script);
            } else {
                document.getElementsByTagName('head')[0].appendChild(script);
            }

        },

        objectMerge: function (ob1, ob2)
        {
            ViperUtil.foreach(ob2, function(key) {
                ob1[key] = ob2[key];
                return true;
            });

            return ob1;

        },

        
        camelCase: function(property)
        {
            // Regular expression to find the next hyphen followed by a letter and to
            // seperate the letter in the results.
            var hyphenTest = /-([a-z])/;
            // While there is a hyphen in the string (reg.test == true) replace it with
            // its' trailing letter uppercased.
            while (hyphenTest.test(property) == true) {
                property = property.replace(hyphenTest, RegExp.$1.toUpperCase());
            }

            return property;

        },

        
        getBrowserType: function()
        {
            if (ViperUtil._browserType === null) {
                var tests = ['edge', 'trident', 'msie', 'firefox', 'chrome', 'safari'];
                var tln   = tests.length;
                for (var i = 0; i < tln; i++) {
                    var r = new RegExp(tests[i], 'i');
                    if (r.test(navigator.userAgent) === true) {
                        if (tests[i] === 'trident') {
                            // No MSIE token for IE11+.
                            ViperUtil._browserType = 'msie';
                        } else {
                            ViperUtil._browserType = tests[i];
                        }
                        return ViperUtil._browserType;
                    }
                }

                ViperUtil._browserType = 'other';
            }

            return ViperUtil._browserType;

        },

        
        getBrowserVersion: function()
        {
            if (ViperUtil._browserVersion !== null) {
                return ViperUtil._browserVersion;
            }

            var browsers = ['Edge', 'MSIE', 'Trident', 'Chrome', 'Safari', 'Firefox'];
            var c        = browsers.length;
            var uAgent   = navigator.userAgent;

            var browserName = null;
            for (var i = 0; i < c; i++) {
                var nameIndex = uAgent.indexOf(browsers[i]);
                if (nameIndex >= 0) {
                    browserName = browsers[i];
                    break;
                }
            }

            if (!browserName) {
                return null;
            }

            if (browserName === 'Safari') {
                browserName = 'Version';
            }

            var re = null;
            if (browserName === 'MSIE') {
                re = new RegExp('MSIE (\\d+)');
            } else if (browserName === 'Trident') {
                re = new RegExp('rv:(\\d+)');
            } else {
                re = new RegExp(browserName + '/(\\d+)');
            }

            var matches = re.exec(uAgent);
            if (!matches) {
                return null;
            }

            ViperUtil._browserVersion = parseInt(matches[1]);
            return ViperUtil._browserVersion;

        },

        
        isBrowser: function(browser, version)
        {
            if (ViperUtil.getBrowserType() !== browser) {
                return false;
            } else if (!version) {
                return true;
            }

            version        = version.toString();
            var currentVer = ViperUtil.getBrowserVersion().toString();
            if (version === currentVer) {
                return true;
            }

            var match = version.match(/^(<=|>=|<|>)([\d\.]+$)/);
            if (!match) {
                return false;
            }

            version = parseFloat(match[2]);
            switch (match[1]) {
                case '<=':
                    return (currentVer <= version);

                case '>=':
                    return (currentVer >= version);

                case '<':
                    return (currentVer < version);

                case '>':
                    return (currentVer > version);

                default:
                    return false;
            }

            return false;

        },

        getOS: function()
        {
            var platform = navigator.platform.toLowerCase();
            if (platform.indexOf('win') === 0) {
                return 'windows';
            } else if (platform.indexOf('mac') === 0) {
                return 'mac';
            } else if (platform.indexOf('linux') === 0) {
                return 'linux';
            }

            return platform;

        },

        isOS: function(os)
        {
            if (this.getOS() === os) {
                return true;
            }

            return false;

        },

        
        cloneNode: function(node)
        {
            // Clone the element so we dont modify the actual contents.
            var clone = null;
            if (ViperUtil.isBrowser('msie', '8') === true && node.nodeType !== ViperUtil.TEXT_NODE) {
                // This is to resolve the HTML5 element cloning issue in IE8.
                var clone = document.createElement('div');
                ViperUtil.setHtml(clone, ViperUtil.trim(node.outerHTML));
                clone = clone.firstChild;
            } else {
                clone = node.cloneNode(true);
            }

            return clone;

        },

        
        dcall: function(c)
        {
            if (!ViperUtil._dcall) {
                ViperUtil._dcall = 0;
            }

            ViperUtil._dcall++;

            if (c === ViperUtil._dcall) {
                debugger;
            }

            console.info(ViperUtil._dcall);
        },

        setViperElement: function(element)
        {
            this._viperElement = element;

        }

    };

    if (!window.console) {
        window.console = {
            info: function(){},
            error: function(){}
        }
    };

    
    try {
    !function(a,b){function c(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=y.elements;return"string"==typeof a?a.split(" "):a}function e(a,b){var c=y.elements;"string"!=typeof c&&(c=c.join(" ")),"string"!=typeof a&&(a=a.join(" ")),y.elements=c+" "+a,j(b)}function f(a){var b=x[a[v]];return b||(b={},w++,a[v]=w,x[w]=b),b}function g(a,c,d){if(c||(c=b),q)return c.createElement(a);d||(d=f(c));var e;return e=d.cache[a]?d.cache[a].cloneNode():u.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!e.canHaveChildren||t.test(a)||e.tagUrn?e:d.frag.appendChild(e)}function h(a,c){if(a||(a=b),q)return a.createDocumentFragment();c=c||f(a);for(var e=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)e.createElement(h[g]);return e}function i(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return y.shivMethods?g(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+d().join().replace(/[\w\-:]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(y,b.frag)}function j(a){a||(a=b);var d=f(a);return!y.shivCSS||p||d.hasCSS||(d.hasCSS=!!c(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),q||i(a,d),a}function k(a){for(var b,c=a.getElementsByTagName("*"),e=c.length,f=RegExp("^(?:"+d().join("|")+")$","i"),g=[];e--;)b=c[e],f.test(b.nodeName)&&g.push(b.applyElement(l(b)));return g}function l(a){for(var b,c=a.attributes,d=c.length,e=a.ownerDocument.createElement(A+":"+a.nodeName);d--;)b=c[d],b.specified&&e.setAttribute(b.nodeName,b.nodeValue);return e.style.cssText=a.style.cssText,e}function m(a){for(var b,c=a.split("{"),e=c.length,f=RegExp("(^|[\\s,>+~])("+d().join("|")+")(?=[[\\s,>+~#.:]|$)","gi"),g="$1"+A+"\\:$2";e--;)b=c[e]=c[e].split("}"),b[b.length-1]=b[b.length-1].replace(f,g),c[e]=b.join("}");return c.join("{")}function n(a){for(var b=a.length;b--;)a[b].removeNode()}function o(a){function b(){clearTimeout(g._removeSheetTimer),d&&d.removeNode(!0),d=null}var d,e,g=f(a),h=a.namespaces,i=a.parentWindow;return!B||a.printShived?a:("undefined"==typeof h[A]&&h.add(A),i.attachEvent("onbeforeprint",function(){b();for(var f,g,h,i=a.styleSheets,j=[],l=i.length,n=Array(l);l--;)n[l]=i[l];for(;h=n.pop();)if(!h.disabled&&z.test(h.media)){try{f=h.imports,g=f.length}catch(o){g=0}for(l=0;g>l;l++)n.push(f[l]);try{j.push(h.cssText)}catch(o){}}j=m(j.reverse().join("")),e=k(a),d=c(a,j)}),i.attachEvent("onafterprint",function(){n(e),clearTimeout(g._removeSheetTimer),g._removeSheetTimer=setTimeout(b,500)}),a.printShived=!0,a)}var p,q,r="3.7.3",s=a.html5||{},t=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,u=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,v="_html5shiv",w=0,x={};!function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",p="hidden"in a,q=1==a.childNodes.length||function(){b.createElement("a");var a=b.createDocumentFragment();return"undefined"==typeof a.cloneNode||"undefined"==typeof a.createDocumentFragment||"undefined"==typeof a.createElement}()}catch(c){p=!0,q=!0}}();var y={elements:s.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",version:r,shivCSS:s.shivCSS!==!1,supportsUnknownElements:q,shivMethods:s.shivMethods!==!1,type:"default",shivDocument:j,createElement:g,createDocumentFragment:h,addElements:e};a.html5=y,j(b);var z=/^$|\b(?:all|print)\b/,A="html5shiv",B=!q&&function(){var c=b.documentElement;return!("undefined"==typeof b.namespaces||"undefined"==typeof b.parentWindow||"undefined"==typeof c.applyElement||"undefined"==typeof c.removeNode||"undefined"==typeof a.attachEvent)}();y.type+=" print",y.shivPrint=o,o(b),"object"==typeof module&&module.exports&&(module.exports=y)}("undefined"!=typeof window?window:this,document);
    } catch (e) {}

})();

(function(Viper) {
    Viper.Translation = new function()
    {
        var _strings = {};
        var _lang    = null;

        this.add = function(code, strings)
        {
            _strings[code] = strings;

        };

        this.isLoaded = function(code)
        {
            if (_strings[code]) {
                return true;
            }

            return false;
        };

        this.setLanguage = function(code)
        {
            _lang = code;

        };

        // Define the _() method.
        Viper._ = function(str) {
            if (_lang !== null && _strings[_lang]) {
                str = _strings[_lang][str] || str;
            }

            return str;
        };

    };

})(Viper);


(function(ViperUtil, ViperSelection, _) {
    Viper.Tools = function(viper)
    {
        this.viper = viper;

        this._items          = {};
        this._preventMouseUp = false;

        var self = this;
        this.viper.registerCallback(
            'Viper:mouseUp',
            'ViperTools',
            function(e) {
                if (self._preventMouseUp === true) {
                    self._preventMouseUp = false;
                    return false;
                }
            }
        );

    }

    Viper.Tools.prototype = {

        addItem: function(id, item)
        {
            this._items[id] = item;

        },

        removeItem: function(id)
        {
            var item = this.getItem(id);
            if (!item) {
                return;
            }

            delete this._items[id];

            if (item.element) {
                ViperUtil.remove(item.element);
            }

            this.viper.removeCallback(null, 'ViperTools-' + id);
            this.viper.removeCallback(null, id);

            this.viper.fireCallbacks('ViperTools:itemRemoved', id);

        },

        getItem: function(id)
        {
            return this._items[id];

        },

        createRow: function(id, customClass)
        {
            var elem = document.createElement('div');
            ViperUtil.addClass(elem, 'Viper-subSectionRow');

            if (customClass) {
                ViperUtil.addClass(elem, customClass);
            }

            this.addItem(
                id,
                {
                    type: 'row',
                    element: elem
                }
            );

            return elem;

        },

        
        createButtonGroup: function(id, customClass)
        {
            var group = document.createElement('div');
            ViperUtil.addClass(group, 'Viper-buttonGroup');

            if (customClass) {
                ViperUtil.addClass(group, customClass);
            }

            this.addItem(
                id,
                {
                    type: 'buttonGroup',
                    element: group,
                    buttons: []
                }
            );

            return group;

        },


        
        createButton: function(id, content, titleAttr, customClass, clickAction, disabled, isActive)
        {
            if (!content) {
                if (customClass) {
                    // Must be an icon button.
                    content = '<span class="Viper-buttonIcon ' + customClass + '"></span>';
                } else {
                    content = '';
                }

                content += '&nbsp;';
            }

            var button = document.createElement('div');
            button.setAttribute('id', this.viper.getId() + '-' + id);

            if (titleAttr) {
                if (disabled === true) {
                    titleAttr = titleAttr + ' [' + _('Not available') + ']';
                }

                button.setAttribute('title', titleAttr);
            }

            ViperUtil.setHtml(button, content);
            ViperUtil.addClass(button, 'Viper-button');

            if (disabled === true) {
                ViperUtil.addClass(button, 'Viper-disabled');
            }

            if (customClass) {
                ViperUtil.addClass(button, customClass);
            }

            var mouseUpAction  = function() {};
            var preventMouseUp = false;
            var self           = this;
            if (clickAction) {
                ViperUtil.addEvent(
                    button,
                    'mousedown.' + this.viper.getEventNamespace(),
                    function(e) {
                        if (ViperUtil.isBrowser('msie', '<11') === true) {
                            // This block of code prevents IE moving user selection to the.
                            // button element when clicked. When the button element is removed
                            // and added back to DOM selection is not moved. Seriously, IE?
                            if (button.previousSibling) {
                                var sibling = button.previousSibling;
                                button.parentNode.removeChild(button);
                                ViperUtil.insertAfter(sibling, button);
                            } else if (button.nextSibling) {
                                var sibling = button.nextSibling;
                                button.parentNode.removeChild(button);
                                ViperUtil.insertBefore(sibling, button);
                            } else {
                                var parent = button.parentNode;
                                button.parentNode.removeChild(button);
                                parent.appendChild(button);
                            }
                        }//end if

                        self._preventMouseUp = true;
                        ViperUtil.preventDefault(e);
                        if (ViperUtil.hasClass(button, 'Viper-disabled') === true) {
                            return false;
                        }

                        setTimeout(
                            function() {
                                // Incase button is moved/removed during the click action.
                                self._preventMouseUp = false;
                            },
                            200
                        );

                        self.viper.fireCallbacks('ViperTools:buttonClicked', id);
                        return clickAction.call(this, e);
                    }
                );
            }//end if

            ViperUtil.addEvent(
                button,
                'mouseup.' + this.viper.getEventNamespace(),
                function(e) {
                    mouseUpAction.call(this, e);
                    self._preventMouseUp = false;
                    ViperUtil.preventDefault(e);
                    return false;
                }
            );

            if (isActive === true) {
                ViperUtil.addClass(button, 'Viper-active');
            }

            this.addItem(
                id,
                {
                    type: 'button',
                    element: button,
                    setIconClass: function(iconClass) {
                        var btnIconElem = ViperUtil.getClass('Viper-buttonIcon', button);
                        if (btnIconElem.length === 0) {
                            btnIconElem = document.createElement('span');
                            ViperUtil.addClass(btnIconElem, 'Viper-buttonIcon');
                            ViperUtil.insertBefore(button.firstChild, btnIconElem);
                        } else {
                            btnIconElem           = btnIconElem[0];
                            btnIconElem.className = 'Viper-buttonIcon';
                        }

                        ViperUtil.addClass(btnIconElem, iconClass);
                    },
                    setButtonShortcut: function(key) {
                        var extraTitleAttr = ' (' + key + ')';
                        if (extraTitleAttr.indexOf('CTRL') >= 0) {
                            if (navigator.platform.indexOf('Mac') >= 0) {
                                extraTitleAttr = extraTitleAttr.replace('CTRL', 'CMD');
                            }
                        }

                        button.setAttribute('title', titleAttr + extraTitleAttr);

                        self.viper.registerCallback(
                            'Viper:keyDown',
                            'ViperTools-' + id,
                            function(e) {
                                if (ViperUtil.isKey(e, key) === true) {
                                    if (ViperUtil.hasClass(button, 'Viper-disabled') !== true) {
                                        clickAction.call(e, button);
                                    }

                                    return false;
                                }
                            }
                        );
                    },
                    setMouseUpAction: function(callback) {
                        mouseUpAction = callback;
                    },
                    isEnabled: function() {
                        return !this._disabled;
                    },
                    isActive: function() {
                        return ViperUtil.hasClass(button, 'Viper-active');
                    },
                    _disabled: disabled
                }
            );

            return button;

        },

        addButtonToGroup: function(buttonid, groupid)
        {
            var button = this.getItem(buttonid);
            var group  = this.getItem(groupid);
            if (!button || !group || button.type !== 'button' || group.type !== 'buttonGroup') {
                throw new Error('Invalid argument for ViperTools.addButtonToGroup(\'' + buttonid + '\', \'' + groupid + '\')');
                return;
            }

            group.element.appendChild(button.element);
            group.buttons.push(buttonid);

        },

        setButtonInactive: function(buttonid)
        {
            var button = this.getItem(buttonid);
            if (!button) {
                return;
            }

            ViperUtil.removeClass(button.element, 'Viper-active');

        },

        setButtonActive: function(buttonid)
        {
            var button = this.getItem(buttonid);
            if (!button) {
                return;
            }

            ViperUtil.addClass(button.element, 'Viper-active');
            this.enableButton(buttonid);

        },

        enableButton: function(buttonid)
        {
            var buttonObj = this.getItem(buttonid);
            if (!buttonObj || buttonObj.isEnabled() === true) {
                return;
            }

            var button = buttonObj.element;

            var title = button.getAttribute('title');
            if (title) {
                button.setAttribute('title', title.replace(' [' + _('Not available') + ']', ''));
            }

            ViperUtil.removeClass(button, 'Viper-disabled');
            buttonObj._disabled = false;

        },

        disableButton: function(buttonid)
        {
            var buttonObj = this.getItem(buttonid);
            if (buttonObj.isEnabled() !== true) {
                return;
            }

            var button = buttonObj.element;
            var title  = button.getAttribute('title');
            if (title) {
                title = title.replace(' [' + _('Not available') + ']', '');
                button.setAttribute('title', title + ' [' + _('Not available') + ']');
            }

            ViperUtil.addClass(button, 'Viper-disabled');
            buttonObj._disabled = true;

        },

        
        createTextbox: function(id, label, value, action, required, expandable, desc, events, labelWidth)
        {
            return this._createTextbox(id, label, value, action, required, expandable, desc, events, labelWidth);

        },

        createTextarea: function(id, label, value, required, desc, events, labelWidth, rows, cols)
        {
            return this._createTextbox(id, label, value, null, required, false, desc, events, labelWidth, true, rows, cols);

        },

        _createTextbox: function(id, label, value, action, required, expandable, desc, events, labelWidth, isTextArea, rows, cols)
        {
            label = label || '&nbsp;';
            value = value || '';

            var textBox = document.createElement('div');
            ViperUtil.addClass(textBox, 'Viper-textbox');

            if (required === true && !value) {
                ViperUtil.addClass(textBox, 'Viper-required');
            }

            var labelEl = document.createElement('label');
            ViperUtil.addClass(labelEl, 'Viper-textbox-label');
            textBox.appendChild(labelEl);

            var main = document.createElement('div');
            ViperUtil.addClass(main, 'Viper-textbox-main');
            labelEl.appendChild(main);

            var title = document.createElement('span');
            ViperUtil.addClass(title, 'Viper-textbox-title');
            ViperUtil.setHtml(title, label);

            if (labelWidth) {
                ViperUtil.setStyle(title, 'width', labelWidth);
            }

            var width = 0;
            // Wrap the element in a generic class so the width calculation is correct
            // for the font size.
            var tmp = document.createElement('div');
            ViperUtil.addClass(tmp, 'ViperITP');

            if (navigator.userAgent.match(/iPad/i) !== null) {
                ViperUtil.addClass(tmp, 'device-ipad');
            }

            ViperUtil.setStyle(tmp, 'display', 'block');
            tmp.appendChild(title);
            this.viper.addElement(tmp);
            width = (ViperUtil.getElementWidth(title) + 10) + 'px';
            tmp.parentNode.removeChild(tmp);

            main.appendChild(title);

            var inputType = 'input';
            if (isTextArea === true) {
                inputType = 'textarea';
            }

            var input   = document.createElement(inputType);
            input.value = value;

            if (isTextArea === true) {
                ViperUtil.addClass(input, 'Viper-textbox-textArea');
            } else {
                input.type = 'text';
                ViperUtil.addClass(input, 'Viper-textbox-input');
            }

            ViperUtil.setStyle(main, 'padding-left', width);
            main.appendChild(input);

            if (required === true) {
                input.setAttribute('placeholder', _('required'));
            }

            if (desc) {
                // Description.
                var descEl = document.createElement('span');
                ViperUtil.addClass(descEl, 'Viper-textbox-desc');
                ViperUtil.setHtml(descEl, desc);
                textBox.appendChild(descEl);
            }

            var moveCaretToEnd = true;
            if (ViperUtil.isBrowser('msie') === true) {
                // Need to add this mouseDown event for IE to disable the caret moving
                // to the end of the text in the input field. When the mouse is clicked
                // the caret is placed to the start of the field instead of the end,
                // so when the mouse is used to focus in to the field we do not move it
                // to the end of the textbox.
                ViperUtil.addEvent(
                    input,
                    'mousedown',
                    function(e) {
                        moveCaretToEnd = false;
                    }
                );
            }

            // IE paste fix.
            input.onpaste = function(e) {
                if (ViperUtil.isBrowser('msie') === true) {
                    // Because Viper does the copy/cut in HTML format IE failed to paste it in to textboxes. So we prevent
                    // the default action and set the value of the input field using the clipboardData.
                    input.value = window.clipboardData.getData("Text");
                    return false;
                }
            };

            var self = this;
            ViperUtil.addEvent(
                input,
                'focus',
                function(e) {
                    ViperUtil.addClass(textBox, 'Viper-focused');
                    self.viper.highlightSelection();

                    if (ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true) {
                        if (moveCaretToEnd === true) {
                            setTimeout(
                                function() {
                                    if (ViperUtil.isBrowser('msie', '>=9') === true) {
                                        var textRange = input.createTextRange();
                                        textRange.move('character', input.value.length)
                                        textRange.select();
                                    } else if (ViperUtil.isBrowser('edge') === true) {
                                        input.setSelectionRange(input.value.length, input.value.length);
                                    } else {
                                        input.focus();
                                        // Set the caret to the end of the textfield.
                                        input.value = input.value;
                                    }
                                },
                                10
                            );
                        }

                        moveCaretToEnd = true;
                    } else {
                        // Set the caret to the end of the textfield.
                        input.value = input.value;
                    }//end if

                    if (ViperUtil.isBrowser('firefox') === true) {
                        setTimeout(
                            function() {
                                input.selectionStart = input.value.length;
                            },
                            2
                        );
                    }
                }
            );

            ViperUtil.addEvent(
                input,
                'blur',
                function() {
                    ViperUtil.removeClass(textBox, 'Viper-active');
                    ViperUtil.removeClass(textBox, 'Viper-focused');
                }
            );

            var changed          = false;
            var _addActionButton = function() {
                var actionIcon = document.createElement('span');
                ViperUtil.addClass(actionIcon, 'Viper-textbox-action');
                main.appendChild(actionIcon);
                ViperUtil.addEvent(
                    actionIcon,
                    'click',
                    function() {
                        if (ViperUtil.hasClass(textBox, 'Viper-actionRevert') === true) {
                            input.value = value;
                            ViperUtil.removeClass(textBox, 'Viper-actionRevert');
                            ViperUtil.addClass(textBox, 'Viper-actionClear');
                            actionIcon.setAttribute('title', 'Clear this value');
                        } else if (ViperUtil.hasClass(textBox, 'Viper-actionClear') === true) {
                            value       = input.value;
                            input.value = '';
                            ViperUtil.removeClass(textBox, 'Viper-actionClear');

                            if (value) {
                                ViperUtil.addClass(textBox, 'Viper-actionRevert');
                                actionIcon.setAttribute('title', 'Revert to original value');
                                if (required === true) {
                                    ViperUtil.addClass(textBox, 'Viper-required');
                                }
                            } else if (required === true) {
                                ViperUtil.addClass(textBox, 'Viper-required');
                                ViperUtil.setStyle(actionIcon, 'display', 'none');
                            }
                        }//end if

                        self.viper.fireCallbacks('ViperTools:changed:' + id);
                    }
                );

                return actionIcon;
            };

            if (value !== '' && isTextArea !== true) {
                var actionIcon = _addActionButton();
                actionIcon.setAttribute('title', 'Clear this value');
                ViperUtil.addClass(textBox, 'Viper-actionClear');
            }

            ViperUtil.addEvent(
                input,
                'keyup',
                function(e) {
                    ViperUtil.addClass(textBox, 'Viper-focused');

                    if (isTextArea !== true) {
                        var actionIcon = ViperUtil.getClass('Viper-textbox-action', main);
                        if (actionIcon.length === 0) {
                            actionIcon = _addActionButton();
                        } else {
                            actionIcon = actionIcon[0];
                        }
                    }

                    ViperUtil.setStyle(actionIcon, 'display', 'block');
                    ViperUtil.setStyle(actionIcon, 'visibility', 'visible');

                    ViperUtil.removeClass(textBox, 'Viper-actionClear');
                    ViperUtil.removeClass(textBox, 'Viper-actionRevert');

                    if (input.value !== value && value !== '') {
                        // Show the revert icon.
                        if (isTextArea !== true) {
                            actionIcon.setAttribute('title', 'Revert to original value');
                            ViperUtil.addClass(textBox, 'Viper-actionRevert');
                        }

                        ViperUtil.removeClass(textBox, 'Viper-required');
                    } else if (input.value !== '') {
                        if (isTextArea !== true) {
                            actionIcon.setAttribute('title', 'Clear this value');
                            ViperUtil.addClass(textBox, 'Viper-actionClear');
                        }

                        ViperUtil.removeClass(textBox, 'Viper-required');
                    } else {
                        if (isTextArea !== true) {
                            ViperUtil.setStyle(actionIcon, 'display', 'none');
                        }

                        if (required === true) {
                            ViperUtil.addClass(textBox, 'Viper-required');
                        }
                    }//end if

                    if ((e.which !== 13 || isTextArea === true) && (input.value !== value)) {
                        self.viper.fireCallbacks('ViperTools:changed:' + id);
                    }

                    // Action.
                    if (action && e.which === 13) {
                        self.viper.focus();
                        action.call(input, input.value);
                    } else if (!action && e.which === 13 && isTextArea !== true && (ViperUtil.isBrowser('chrome') || ViperUtil.isBrowser('safari'))) {
                        var forms = ViperUtil.getParents(main, 'form', self.viper.getViperElement());
                        if (forms.length > 0 && ViperUtil.getTag('input', forms[0]).length > 2) {
                            return forms[0].onsubmit();
                        }
                    }
                }
            );

            if (events) {
                for (var eventType in events) {
                    ViperUtil.addEvent(input, eventType, events[eventType]);
                }
            }

            this.addItem(
                id,
                {
                    type: 'textbox',
                    element: textBox,
                    input: input,
                    label: labelEl,
                    required: required,
                    getValue: function() {
                        return input.value;
                    },
                    setValue: function(newValue, isInitialValue) {
                        input.value = newValue;
                        value       = newValue;

                        if (isTextArea !== true) {
                            var actionIcon = ViperUtil.getClass('Viper-textbox-action', main);
                            if (actionIcon.length === 0) {
                                actionIcon = _addActionButton();
                            } else {
                                actionIcon = actionIcon[0];
                            }

                            ViperUtil.setStyle(actionIcon, 'display', 'block');
                        }

                        ViperUtil.removeClass(textBox, 'Viper-actionClear');
                        ViperUtil.removeClass(textBox, 'Viper-actionRevert');

                        if (isTextArea !== true) {
                            if (input.value !== value && value !== '') {
                                // Show the revert icon.
                                actionIcon.setAttribute('title', 'Revert to original value');
                                ViperUtil.addClass(textBox, 'Viper-actionRevert');
                                ViperUtil.removeClass(textBox, 'Viper-required');
                            } else if (input.value !== '') {
                                actionIcon.setAttribute('title', 'Clear this value');
                                ViperUtil.addClass(textBox, 'Viper-actionClear');
                                ViperUtil.removeClass(textBox, 'Viper-required');
                            } else {
                                ViperUtil.setStyle(actionIcon, 'display', 'none');
                                if (required === true) {
                                    ViperUtil.addClass(textBox, 'Viper-required');
                                }
                            }
                        }

                        if (isInitialValue === false) {
                            self.viper.fireCallbacks('ViperTools:changed:' + id);
                        }
                    },
                    disable: function() {
                        ViperUtil.addClass(textBox, 'Viper-disabled');
                        input.setAttribute('disabled', true);
                        input.blur();
                    },
                    enable: function() {
                        ViperUtil.removeClass(textBox, 'Viper-disabled');
                        input.removeAttribute('disabled');
                    },
                    setRequired: function(required) {
                        if (required === true) {
                            input.setAttribute('placeholder', _('required'));

                            if (ViperUtil.trim(input.value) === '') {
                                ViperUtil.addClass(textBox, 'Viper-required');
                            }
                        } else {
                            ViperUtil.removeClass(textBox, 'Viper-required');
                            input.removeAttribute('placeholder');
                        }

                        this.required = required;
                    },
                    setLabel: function (newLabel) {
                        ViperUtil.setHtml(ViperUtil.getClass('Viper-textbox-title', labelEl)[0], newLabel)
                    }
                }
            );

            return textBox;

        },

        setFieldEvent: function(itemid, eventType, event)
        {
            var item = this.getItem(itemid);
            if (!item || !item.input) {
                return;
            }

            ViperUtil.addEvent(item.input, eventType, event);

        },

        
        setFieldErrors: function(itemid, errors)
        {
            var item = this.getItem(itemid);
            if (!item || !item.input) {
                return;
            }

            errors = errors || [];

            var errorCount = errors.length;

            var msgsElement = ViperUtil.getClass('Viper-' + item.type + '-messages', item.element);
            if (msgsElement.length === 0) {
                if (errorCount === 0) {
                    return;
                }

                msgsElement = document.createElement('div');
                ViperUtil.addClass(msgsElement, 'Viper-textbox-messages');
                item.label.appendChild(msgsElement);
            } else {
                msgsElement = msgsElement[0];
                if (errorCount === 0) {
                    ViperUtil.remove(msgsElement);
                    return;
                }

                ViperUtil.empty(msgsElement);
            }

            var content = '';
            for (var i = 0; i < errorCount; i++) {
                content += '<span class="Viper-textbox-error">' + errors[i] + '</span>';
            }

            ViperUtil.setHtml(msgsElement, content);

        },

        
        createCheckbox: function(id, label, checked, changeCallback)
        {
            var labelElem = document.createElement('label');
            ViperUtil.addClass(labelElem, 'Viper-checkbox');

            if (checked === true) {
                ViperUtil.addClass(labelElem, 'Viper-active');
            }

            var checkbox     = document.createElement('input');
            checkbox.type    = 'checkbox';
            checkbox.checked = checked || false;

            var checkboxSwitch = document.createElement('span');
            ViperUtil.addClass(checkboxSwitch, 'Viper-checkbox-switch');

            var checkboxSlider = document.createElement('span');
            ViperUtil.addClass(checkboxSlider, 'Viper-checkbox-slider');

            checkboxSwitch.appendChild(checkboxSlider);
            checkboxSwitch.appendChild(checkbox);

            var text = document.createElement('span');
            ViperUtil.addClass(text, 'Viper-checkbox-title');
            ViperUtil.setHtml(text, label);

            labelElem.appendChild(text);
            labelElem.appendChild(checkboxSwitch);

            var self = this;

            if (ViperUtil.isBrowser('msie', '<11') === true) {
                // IE does not trigger the click event for input when the label
                // element is clicked, so add the click event to label element and change
                // the checkbox state.
                ViperUtil.addEvent(
                    labelElem,
                    'click',
                    function() {
                        checkbox.checked = !checkbox.checked;

                        if (checkbox.checked === true) {
                            ViperUtil.addClass(labelElem, 'Viper-active');
                        } else {
                            ViperUtil.removeClass(labelElem, 'Viper-active');
                        }

                        if (changeCallback) {
                            changeCallback.call(this, checkbox.checked);
                        }

                        self.viper.fireCallbacks('ViperTools:changed:' + id);
                        self.viper.highlightSelection();
                    }
                );
            } else {
                ViperUtil.addEvent(
                    checkbox,
                    'click',
                    function() {
                        if (checkbox.checked === true) {
                            ViperUtil.addClass(labelElem, 'Viper-active');
                        } else {
                            ViperUtil.removeClass(labelElem, 'Viper-active');
                        }

                        if (changeCallback) {
                            changeCallback.call(this, checkbox.checked);
                        }

                        self.viper.fireCallbacks('ViperTools:changed:' + id);
                    }
                );
            }//end if

            this.addItem(
                id,
                {
                    type: 'checkbox',
                    element: labelElem,
                    input: checkbox,
                    getValue: function() {
                        return checkbox.checked;
                    },
                    setValue: function(checked, isInitialValue) {
                        checkbox.checked = checked;

                        if (checked === true) {
                            ViperUtil.addClass(labelElem, 'Viper-active');
                        } else {
                            ViperUtil.removeClass(labelElem, 'Viper-active');
                        }

                        if (changeCallback && isInitialValue !== true) {
                            changeCallback.call(this, checked, true);
                        }
                    }
                }
            );

            return labelElem;

        },


        
        createRadiobutton: function(name, value, label, checked)
        {
            var labelElem = document.createElement('label');
            ViperUtil.addClass(labelElem, 'Viper-radiobtn-label');

            var radio     = document.createElement('input');
            radio.type    = 'radio';
            radio.name    = name;
            radio.value   = value;
            radio.checked = checked || false;

            ViperUtil.addClass(radio, 'Viper-radiobtn');

            var span = document.createElement('span');
            ViperUtil.addClass(span, 'Viper-radio-text');
            ViperUtil.setHtml(span, label);

            labelElem.appendChild(radio);
            labelElem.appendChild(span);

            return labelElem;

        },

        createPopup: function(id, title, topContent, midContent, bottomContent, customClass, draggable, resizable, openCallback, closeCallback, resizeCallback)
        {
            title = title || '&nbsp;';

            var self = this;

            var main = document.createElement('div');
            ViperUtil.addClass(main, 'Viper-popup Viper-themeDark');

            if (customClass) {
                ViperUtil.addClass(main, customClass);
            }

            var header = document.createElement('div');
            ViperUtil.addClass(header, 'Viper-popup-header');

            if (draggable !== false) {
                var dragIcon = document.createElement('div');
                ViperUtil.addClass(dragIcon, 'Viper-popup-dragIcon');
                header.appendChild(dragIcon);

                var overlay = document.createElement('div');
                ViperUtil.addClass(overlay, 'Viper-dragOverlay');

                ViperUtil.$(main).draggable(
                    {
                        handle: header,
                        start: function() {
                            self.viper.addElement(overlay);
                        },
                        stop: function() {
                            ViperUtil.remove(overlay);
                        }
                    }
                );
            }

            header.appendChild(document.createTextNode(title));

            var closeIcon = document.createElement('div');
            ViperUtil.addClass(closeIcon, 'Viper-popup-closeIcon');
            header.appendChild(closeIcon);
            ViperUtil.addEvent(
                closeIcon,
                'mousedown',
                function() {
                    self.closePopup(id, 'closeIcon');
                }
            );

            var fullScreen = false;

            var originalOpenCallback = openCallback;
            openCallback = function() {
                fullScreen = false;
                if (originalOpenCallback) {
                    return originalOpenCallback.call(this);
                }
            }

            // Close popup when ESC key is pressed.
            this.viper.registerCallback(
                'Viper:keyUp',
                'ViperTools',
                function(e) {
                    if (e.which === 27 && main.parentNode) {
                        self.closePopup(id);
                    }
                }
            );

            var showfullScreen = function() {
                var headerHeight  = ViperUtil.getElementHeight(header);
                var topHeight     = ViperUtil.getElementHeight(topContent);
                var bottomHeight  = ViperUtil.getElementHeight(bottomContent);
                var toolbarHeight = 35;

                var windowDim = ViperUtil.getWindowDimensions();
                ViperUtil.setStyle(main, 'left', 0);
                ViperUtil.setStyle(main, 'top', toolbarHeight + 'px');
                ViperUtil.setStyle(main, 'margin-left', 0);
                ViperUtil.setStyle(main, 'margin-top', 0);
                ViperUtil.setStyle(midContent, 'width', (windowDim.width - 20) + 'px');
                ViperUtil.setStyle(midContent, 'height', (windowDim.height - toolbarHeight - bottomHeight - headerHeight - topHeight - 10) + 'px');
                if (resizeCallback) {
                    resizeCallback.call(this);
                }
            };

            var currentSize = null;
            ViperUtil.addEvent(
                header,
                'safedblclick',
                function() {},
                function() {
                    if (fullScreen !== true) {
                        fullScreen     = true;
                        var mainCoords = ViperUtil.getElementCoords(main);
                        currentSize    = {
                            width: ViperUtil.getElementWidth(midContent),
                            height: ViperUtil.getElementHeight(midContent),
                            left: mainCoords.x,
                            top: mainCoords.y
                        };

                        showfullScreen();

                        ViperUtil.removeEvent(window, 'resize.ViperTools-popup-' + id);
                        ViperUtil.addEvent(
                            window,
                            'resize.ViperTools-popup-' + id,
                            function() {
                                // Update the popup size since its in full screen.
                                showfullScreen();
                            }
                        );
                    } else {
                        ViperUtil.removeEvent(window, 'resize.ViperTools-popup-' + id);

                        fullScreen = false;
                        ViperUtil.setStyle(main, 'left', currentSize.left + 'px');
                        ViperUtil.setStyle(main, 'top', currentSize.top + 'px');
                        ViperUtil.setStyle(midContent, 'width', currentSize.width + 'px');
                        ViperUtil.setStyle(midContent, 'height', currentSize.height + 'px');
                        if (resizeCallback) {
                            resizeCallback.call(this);
                        }
                    }//end if
                }
            );

            main.appendChild(header);

            if (topContent) {
                ViperUtil.addClass(topContent, 'Viper-popup-top');
                main.appendChild(topContent);
            }

            ViperUtil.addClass(midContent, 'Viper-popup-content');
            main.appendChild(midContent);

            if (bottomContent) {
                ViperUtil.addClass(bottomContent, 'Viper-popup-bottom');
                main.appendChild(bottomContent);
            }

            if (resizable !== false) {
                var resizeElements = function(ui) {
                    ViperUtil.setStyle(midContent, 'width', ui.size.width + 'px');
                    ViperUtil.setStyle(midContent, 'height', ui.size.height + 'px');
                };

                // Create overlay element that sits behind the popup when dragging/resizing incase there are child frames.
                var overlay = document.createElement('div');
                ViperUtil.addClass(overlay, 'Viper-dragOverlay');

                ViperUtil.$(midContent).resizable(
                    {
                        handles: 'se',
                        resize: function(e, ui) {
                            if (resizeCallback) {
                                resizeCallback.call(this, e, ui);
                            }
                        },
                        start: function() {
                            self.viper.addElement(overlay);
                        },
                        stop: function(e, ui) {
                            ViperUtil.remove(overlay);
                            if (resizeCallback) {
                                resizeCallback.call(this, e, ui);
                            }
                        }
                    }
                );
            }//end if

            this.addItem(
                id,
                {
                    type: 'popup',
                    element: main,
                    topContent: topContent,
                    midContent: midContent,
                    bottomContent: bottomContent,
                    openCallback: openCallback,
                    closeCallback: closeCallback,
                    showTop: function() {
                        ViperUtil.$(topContent).slideDown(
                            null,
                            function() {
                                if (fullScreen === true) {
                                    showfullScreen();
                                }
                            }
                        );
                    },
                    hideTop: function() {
                        ViperUtil.$(topContent).slideUp(
                            null,
                            function() {
                                if (fullScreen === true) {
                                    showfullScreen();
                                }
                            }
                        );
                    }
                }
            );

            return main;

        },

        openPopup: function(id, width, height, minWidth)
        {
            var popup        = this.getItem(id);
            var contentElem  = popup.midContent;
            var popupElement = popup.element;

            if (minWidth) {
                ViperUtil.setStyle(contentElem, 'min-width', minWidth);
            }

            if (width) {
                ViperUtil.setStyle(contentElem, 'width', width + 'px');
            }

            if (height) {
                ViperUtil.setStyle(contentElem, 'height', height + 'px');
            }

            ViperUtil.setStyle(popupElement, 'left', '-9999px');
            ViperUtil.setStyle(popupElement, 'top', '-9999px');
            ViperUtil.setStyle(popupElement, 'visibility', 'hidden');
            this.viper.addElement(popupElement);

            // Set the pos to be the middle of the screen.
            var elementDim = ViperUtil.getBoundingRectangle(popupElement);
            var windowDim  = ViperUtil.getWindowDimensions();

            var toolbarHieght = 36;

            var marginTop = (((elementDim.y2 - elementDim.y1) / 2) * -1);

            // If the popup is off the top of the screen then move it back down.
            var offScreenTop = (windowDim.height / 2) + marginTop
            if (offScreenTop < toolbarHieght) {
                marginTop -= (offScreenTop - toolbarHieght);
            }

            if ((elementDim.y2 - elementDim.y1) > (windowDim.height - toolbarHieght)) {
                ViperUtil.setStyle(contentElem, 'height', (height - (elementDim.y2 - elementDim.y1 - windowDim.height) - toolbarHieght) + 'px');
            }

            ViperUtil.setStyle(popupElement, 'margin-left', (((elementDim.x2 - elementDim.x1) / 2) * -1) + 'px');
            ViperUtil.setStyle(popupElement, 'margin-top', marginTop + 'px');

            ViperUtil.setStyle(popupElement, 'left', '50%');
            ViperUtil.setStyle(popupElement, 'top', '50%');

            if (popup.openCallback) {
                if (popup.openCallback.call(this) === false) {
                    // Do not open.
                    popupElement.parentNode.removeChild(popupElement);
                    return;
                }
            }

            this.viper.fireCallbacks('ViperTools:popup:open', id);

            ViperUtil.$(popup.element).draggable('enable');

            ViperUtil.setStyle(popupElement, 'visibility', 'visible');

        },

        closePopup: function(id, closer)
        {
            var popup = this.getItem(id);
            if (popup.closeCallback) {
                if (popup.closeCallback.call(this, closer) === false) {
                    // Do not close.
                    return;
                }
            }

            ViperUtil.$(popup.element).draggable('disable');

            if (popup.element.parentNode) {
                popup.element.parentNode.removeChild(popup.element);
            }

            this.viper.fireCallbacks('ViperTools:popup:close', id);

        },

        createInlineToolbar: function(id, compact, elementTypes, updateCallback)
        {
            var self    = this;
            var toolbar = document.createElement('div');
            var viper   = this.viper;
            ViperUtil.attr(toolbar, 'data-toolid', id);
            ViperUtil.attr(toolbar, 'id', this.viper.getId() + '-' + id);

            var toolsContainer = document.createElement('div');
            toolbar.appendChild(toolsContainer);

            var subSectionContainer = document.createElement('div');
            ViperUtil.setHtml(subSectionContainer, '<span class="Viper-subSectionArrow"></span>');
            toolbar.appendChild(subSectionContainer);

            ViperUtil.addClass(toolbar, 'ViperITP Viper-themeDark Viper-scalable');
            ViperUtil.addClass(toolsContainer, 'ViperITP-tools');
            ViperUtil.addClass(subSectionContainer, 'ViperITP-subSectionWrapper');

            if (navigator.userAgent.match(/iPad/i) !== null) {
                ViperUtil.addClass(toolbar, 'device-ipad');
            }

            if (compact === true) {
                ViperUtil.addClass(toolbar, 'Viper-compact');
            }

            ViperUtil.addEvent(
                toolbar,
                'mousedown',
                function(e) {
                    var target = ViperUtil.getMouseEventTarget(e);
                    if (ViperUtil.isTag(target, 'input') !== true && ViperUtil.isTag(target, 'textarea') !== true) {
                        ViperUtil.preventDefault(e);
                        return false;
                    }
                }
            );

            ViperUtil.addEvent(
                toolbar,
                'mouseup',
                function(e) {
                    ViperUtil.preventDefault(e);
                    return false;
                }
            );

            var _update = false;
            this.viper.registerCallback(
                'Viper:selectionChanged',
                id,
                function(range) {
                    if (self.viper.rangeInViperBounds(range) === false) {
                        return;
                    }

                    if (range.collapsed === true && _update !== true) {
                        self.getItem(id).hide();
                        return;
                    }

                    // Update the toolbar position, contents and lineage for this new selection.
                    self.getItem(id).update(range);
                }
            );

            // Add scroll event to iframes so that the toolbar is closed when the
            // scroll is happening.
            this.viper.registerCallback(
                'Viper:editableElementChanged',
                id,
                function() {
                    var elemDoc = self.viper.getViperElementDocument();
                    if (elemDoc !== document) {
                        var t       = null;
                        var toolbar = self.getItem(id);
                        ViperUtil.removeEvent(elemDoc.defaultView, 'scroll.' + id);
                        ViperUtil.addEvent(
                            elemDoc.defaultView,
                            'scroll.' + id,
                            function(e) {
                                if (toolbar.isVisible() === true) {
                                    self.getItem(id).updatePosition();
                                }
                            }
                        );
                    }//end if
                }
            );

            this.viper.registerCallback(
                ['Viper:clickedOutside', 'Viper:disabled'],
                id,
                function(range) {
                    self.getItem(id).hide();
                }
            );

            this.viper.registerCallback(
                ['Viper:mouseDown',
                'ViperHistoryManager:undo'],
                id,
                function(data) {
                    _update = false;
                    if (data && data.target) {
                        var target = ViperUtil.getMouseEventTarget(data);
                        if (target === toolbar || ViperUtil.isChildOf(target, toolbar) === true) {
                            if (ViperUtil.isTag(target, 'input') === true
                                || ViperUtil.isTag(target, 'textarea') === true
                            ) {
                                // Allow event to bubble so the input element can get focus etc.
                                return true;
                            }

                            return false;
                        } else if (elementTypes
                            && ViperUtil.inArray(ViperUtil.getTagName(target), elementTypes) === true
                        ) {
                            self.getItem(id).update(null, target);
                            return;
                        } else if (ViperUtil.inArray(ViperUtil.getTagName(target), self.getItem(id)._keepOpenTagList) === true) {
                            _update = true;
                            return;
                        } else {
                            var allParents = ViperUtil.getParents(target, null, self.viper.getViperElement());
                            for (var i = 0; i < allParents.length; i++) {
                                if (ViperUtil.inArray(ViperUtil.getTagName(allParents[i]), self.getItem(id)._keepOpenTagList) === true) {
                                    _update = true;
                                    return;
                                }
                            }

                            var parents = ViperUtil.getSurroundingParents(target);
                            for (var i = 0; i < parents.length; i++) {
                                if (ViperUtil.inArray(ViperUtil.getTagName(parents[i]), self.getItem(id)._keepOpenTagList) === true) {
                                    _update = true;
                                    return;
                                }
                            }
                        }//end if
                    }//end if

                    self.getItem(id).hide();
                }
            );

            var tools          = this;
            var buttonElements = null;
            this.addItem(
                id,
                {
                    type: 'toolbar',
                    element: toolbar,
                    addButton: function(button, index) {
                        if (ViperUtil.isset(index) === true && toolsContainer.childNodes.length > index) {
                            if (index < 0) {
                                index = toolsContainer.childNodes.length + index;
                                if (index < 0) {
                                    index = 0;
                                }
                            }

                            ViperUtil.insertBefore(toolsContainer.childNodes[index], button);
                        } else {
                            toolsContainer.appendChild(button);
                        }
                    },
                    showButton: function(buttonid, disabled) {
                        if (tools.getItem(buttonid).type !== 'button') {
                            throw new Error('Invalid button for showButton(): ' + buttonid);
                        }

                        this._buttonShown = true;

                        var button = self.getItem(buttonid);
                        ViperUtil.removeClass(button.element, 'ViperITP-button-hidden');
                        ViperUtil.removeClass(button.element.parentNode, 'ViperITP-button-hidden');

                        if (disabled === true) {
                            self.disableButton(buttonid);
                        } else {
                            self.enableButton(buttonid);
                        }
                    },
                    update: function(range, element) {
                        if (!updateCallback || self.viper.isEnabled() === false) {
                            return;
                        }

                        var selectedNode = element || null;
                        range            = range || self.viper.getViperRange();

                        if (!selectedNode) {
                            if (elementTypes && elementTypes.length > 0) {
                                return;
                            }
                        }

                        var activeSection = this._activeSection;
                        if (range.collapsed === true) {
                            // Clicking inside a link element etc should not activate the
                            // sub section again.
                            activeSection = null;
                        }

                        this.closeActiveSubsection(true);

                        this._buttonShown     = false;
                        this._subSectionShown = false;
                        this.resetButtons();

                        if (buttonElements === null) {
                            // Store the original button structure in to buttonElements
                            // so that we can re construct it here in the next update call.
                            // This must be done as the updateCallback may remove buttons
                            // from the toolbar using showButton, showButtonGroup methods.
                            buttonElements = [];
                            for (var node = toolsContainer.firstChild; node; node = node.nextSibling) {
                                if (ViperUtil.hasClass(node, 'Viper-buttonGroup') === true) {
                                    var groupButtons = [node];
                                    for (var button = node.firstChild; button; button = button.nextSibling) {
                                        groupButtons.push(button);
                                    }

                                    buttonElements.push(groupButtons);
                                } else if (ViperUtil.hasClass('Viper-button') === true) {
                                    buttonElements.push(node);
                                }
                            }
                        } else {
                            while (toolsContainer.firstChild) {
                                toolsContainer.removeChild(toolsContainer.firstChild);
                            }

                            for (var i = 0; i < buttonElements.length; i++) {
                                if (buttonElements[i].length) {
                                    for (var j = 1; j < buttonElements[i].length; j++) {
                                        buttonElements[i][0].appendChild(buttonElements[i][j]);
                                    }

                                    toolsContainer.appendChild(buttonElements[i][0]);
                                } else {
                                    toolsContainer.appendChild(buttonElements[i]);
                                }
                            }
                        }//end if

                        updateCallback.call(this, range, selectedNode, activeSection !== null);

                        var buttonsToRemove = ViperUtil.getClass('ViperITP-button-hidden', toolsContainer);
                        for (var i = 0; i < buttonsToRemove.length; i++) {
                            buttonsToRemove[i].parentNode.removeChild(buttonsToRemove[i]);
                        }

                        if (this._buttonShown === true || this._subSectionShown === true) {
                            this.updatePosition(range, selectedNode);
                        } else {
                            this.hide();
                        }

                        if (activeSection) {
                            this.toggleSubSection(activeSection);
                        }
                    },

                    resetButtons: function() {
                        ViperUtil.removeClass(toolbar, 'Viper-subSectionVisible');
                        ViperUtil.addClass(ViperUtil.getClass('Viper-buttonGroup', toolsContainer), 'ViperITP-button-hidden');

                        var buttons = ViperUtil.getClass('Viper-button', toolsContainer);
                        ViperUtil.addClass(buttons, 'ViperITP-button-hidden');
                        ViperUtil.removeClass(buttons, 'Viper-selected');
                        ViperUtil.removeClass(buttons, 'Viper-active');
                    },

                    hide: function() {
                        if (this._onHideCallback) {
                            if (this._onHideCallback.call(this) === false) {
                                return false;
                            }
                        }

                        this.closeActiveSubsection(true);
                        this._activeSection = null;
                        ViperUtil.removeClass(toolbar, 'Viper-visible');

                        // Disable all subsection action buttons.
                        for (subsectionid in this._subSectionActionWidgets) {
                            tools.disableButton(subsectionid + '-applyButton');
                        }

                        return true;
                    },

                    isVisible: function() {
                        return ViperUtil.hasClass(toolbar, 'Viper-visible');
                    },

                    
                    makeSubSection: function(id, element, onOpenCallback, onCloseCallback) {
                        if (!element) {
                            return false;
                        }

                        var subSection = document.createElement('div');
                        var form       = document.createElement('form');

                        subSection.appendChild(form);
                        form.appendChild(element);
                        form.onsubmit = function() {
                            return false;
                        };

                        var submitBtn  = document.createElement('input');
                        submitBtn.type = 'submit';
                        ViperUtil.setStyle(submitBtn, 'display', 'none');
                        form.appendChild(submitBtn);

                        ViperUtil.addClass(subSection, 'Viper-subSection');

                        this._subSections[id] = subSection;

                        subSectionContainer.appendChild(subSection);

                        tools.addItem(
                            id,
                            {
                                type: 'VITPSubSection',
                                element: subSection,
                                form: form,
                                _onOpenCallback: onOpenCallback,
                                _onCloseCallback: onCloseCallback
                            }
                        );

                        return subSection;
                    },

                    
                    setSubSectionButton: function(buttonid, subSectionid) {
                        if (!this._subSections[subSectionid]) {
                            // Throw exception not a valid sub section id.
                            throw new Error('Invalid sub section id: ' + subSectionid);
                            return false;
                        }

                        var button = tools.getItem(buttonid).element;
                        var self   = this;

                        this._subSectionButtons[subSectionid] = buttonid;

                        ViperUtil.removeEvent(button, 'mousedown');
                        ViperUtil.addEvent(
                            button,
                            'mousedown',
                            function(e) {
                                if (ViperUtil.isBrowser('msie', '<11') === true) {
                                    // This block of code prevents IE moving user selection to the.
                                    // button element when clicked. When the button element is removed
                                    // and added back to DOM selection is not moved. Seriously, IE?
                                    if (button.previousSibling) {
                                        var sibling = button.previousSibling;
                                        button.parentNode.removeChild(button);
                                        ViperUtil.insertAfter(sibling, button);
                                    } else if (button.nextSibling) {
                                        var sibling = button.nextSibling;
                                        button.parentNode.removeChild(button);
                                        ViperUtil.insertBefore(sibling, button);
                                    } else {
                                        var parent = button.parentNode;
                                        button.parentNode.removeChild(button);
                                        parent.appendChild(button);
                                    }
                                }//end if

                                // Set the subSection to visible and hide rest of the sub sections.
                                self.toggleSubSection(subSectionid);

                                ViperUtil.preventDefault(e);
                            }
                        );
                    },

                    
                    toggleSubSection: function(subSectionid, ignoreCallbacks) {
                        var subSection = this._subSections[subSectionid];
                        if (!subSection) {
                            return false;
                        }

                        if (this._activeSection) {
                            var activeSubSection = this._activeSection;
                            this.closeActiveSubsection(ignoreCallbacks);
                            if (subSectionid === activeSubSection) {
                                return;
                            }
                        }

                        // Make sure all Viper-active has been removed from all sub sections
                        // at this point.
                        ViperUtil.removeClass(ViperUtil.getClass('Viper-subSection Viper-active', subSectionContainer), 'Viper-active');

                        if (this._subSectionButtons[subSectionid]) {
                            var subSectionButton = tools.getItem(this._subSectionButtons[subSectionid]).element;
                            if (ViperUtil.hasClass(subSectionButton, 'ViperITP-button-hidden') === true) {
                                this._activeSection = null;
                                return;
                            }
                        }

                        if (ignoreCallbacks !== true) {
                            var openCallback = tools.getItem(subSectionid)._onOpenCallback;
                            if (openCallback) {
                                openCallback.call(this);
                            }
                        }

                        // Make the button selected.
                        ViperUtil.addClass(subSectionButton, 'Viper-selected');

                        ViperUtil.addClass(subSection, 'Viper-active');
                        ViperUtil.addClass(toolbar, 'Viper-subSectionVisible');
                        this._activeSection = subSectionid;
                        this._updateSubSectionArrowPos();

                        var self = this;
                        setTimeout(
                            function() {
                                self.focusSubSection();
                            },
                            50
                        );

                        this._subSectionShown = true;

                        var subSectionForm = tools.getItem(subSectionid).form;
                        ViperUtil.removeEvent(document, 'keydown.' + id);
                        ViperUtil.addEvent(
                            document,
                            'keydown.' + id,
                            function(e) {
                                if (subSectionForm && e.which === 13 && ViperUtil.isTag(e.target, 'textarea') === false) {
                                    return subSectionForm.onsubmit();
                                }
                            }
                        );
                    },

                    focusSubSection: function() {
                        try {
                            var subSection    = this._subSections[this._activeSection];
                            var inputElements = ViperUtil.getTag('input[type=text], textarea', subSection);
                            if (inputElements.length > 0) {
                                inputElements[0].focus();
                                ViperUtil.removeClass(inputElements[0].parentNode.parentNode.parentNode, 'Viper-active');

                                if (ViperUtil.isBrowser('msie') === false) {
                                    tools.viper.highlightSelection();
                                } else {
                                    setTimeout(
                                        function() {
                                            inputElements[0].focus();
                                        },
                                        10
                                    );
                                }
                            }
                        } catch (e) {
                        }
                    },

                    closeActiveSubsection: function(ignoreCallbacks) {
                        if (this._activeSection) {
                            var prevSubSection = this._subSections[this._activeSection];
                            if (prevSubSection) {
                                ViperUtil.removeClass(prevSubSection, 'Viper-active');

                                tools.viper.fireCallbacks('ViperToolbar:subsectionClosed', this._activeSection);

                                if (this._subSectionButtons[this._activeSection]) {
                                    ViperUtil.removeClass(tools.getItem(this._subSectionButtons[this._activeSection]).element, 'Viper-selected');
                                }

                                if (ignoreCallbacks !== true) {
                                    var closeCallback = tools.getItem(this._activeSection)._onCloseCallback;
                                    if (closeCallback) {
                                        closeCallback.call(this);
                                    }
                                }

                                ViperUtil.removeClass(toolbar, 'Viper-subSectionVisible');
                                this._activeSection = null;

                                ViperUtil.removeEvent(document, 'keydown.' + id);
                                return;
                            }
                        }//end if
                    },

                    
                    setSubSectionAction: function(subSectionid, action, widgetids) {
                        widgetids      = widgetids || [];
                        var subSection = tools.getItem(subSectionid);
                        if (!subSection) {
                            return;
                        }

                        subSection.form.onsubmit = function(e) {
                            if (e) {
                                ViperUtil.preventDefault(e);
                            }

                            var button = tools.getItem(subSectionid + '-applyButton');
                            if (button.isEnabled() === false) {
                                return false;
                            }

                            tools.viper.focus();

                            if (ViperUtil.isBrowser('msie') === false) {
                                try {
                                    action.call(this);
                                } catch (e) {
                                    console.error('Sub Section Action threw exception:' + e.message, e.stack);
                                }
                            } else {
                                // IE needs this timeout so focus works <3..
                                setTimeout(
                                    function() {
                                        try {
                                            action.call(this);
                                        } catch (e) {
                                            console.error('Sub Section Action threw exception:' + e.message, e.stack);
                                        }
                                    },
                                    2
                                );
                            }

                            tools.disableButton(subSectionid + '-applyButton');

                            return false;
                        };

                        var button = tools.createButton(subSectionid + '-applyButton', _('Apply Changes'), _('Apply Changes'), '', subSection.form.onsubmit, true);
                        subSection.element.appendChild(button);

                        this.addSubSectionActionWidgets(subSectionid, widgetids);
                    },

                    addSubSectionActionWidgets: function(subSectionid, widgetids) {
                        if (!this._subSectionActionWidgets[subSectionid]) {
                            this._subSectionActionWidgets[subSectionid] = [];
                        }

                        var self = this;
                        for (var i = 0; i < widgetids.length; i++) {
                            this._subSectionActionWidgets[subSectionid].push(widgetids[i]);

                            (function(widgetid) {
                                tools.viper.registerCallback(
                                    'ViperTools:changed:' + widgetid,
                                    'ViperToolbarPlugin:' + id,
                                    function() {
                                        var subSectionWidgets = self._subSectionActionWidgets[subSectionid];
                                        var c      = subSectionWidgets.length;
                                        var enable = true;
                                        for (var j = 0; j < c; j++) {
                                            var widget = tools.getItem(subSectionWidgets[j]);
                                            if (widget && widget.required === true && ViperUtil.trim(widget.getValue()) === '') {
                                                enable = false;
                                                break;
                                            }
                                        }

                                        if (enable === true) {
                                            tools.enableButton(subSectionid + '-applyButton');
                                        } else {
                                            tools.disableButton(subSectionid + '-applyButton');
                                        }
                                    }
                                );
                            }) (widgetids[i]);
                        }//end for
                    },

                    getActiveSection: function() {
                        return this._activeSection;
                    },

                    addKeepOpenTag: function(tagName) {
                        this._keepOpenTagList.push(tagName);
                    },

                    orderButtons: function(buttonOrder) {
                        // Get all the buttons from the container.
                        var buttons = ViperUtil.getClass('Viper-button', toolsContainer);
                        var c       = buttons.length;

                        if (c === 0) {
                            return;
                        }

                        // Clear the buttons container contents.
                        while (toolsContainer.firstChild) {
                            toolsContainer.removeChild(toolsContainer.firstChild);
                        }

                        // Get the button ids and their elements.
                        var addedButtons = {};
                        for (var i = 0; i < c; i++) {
                            var button       = buttons[i];
                            var id           = button.id.toLowerCase().replace(self.viper.getId().toLowerCase() + '-vitp', '');
                            addedButtons[id] = button;
                        }

                        var bc = buttonOrder.length;
                        for (var i = 0; i < bc; i++) {
                            var button = buttonOrder[i];
                            if (typeof button === 'string') {
                                button = button.toLowerCase();
                                if (addedButtons[button]) {
                                    // Button is included in the setting, add it to the toolbar.
                                    this.addButton(addedButtons[button]);
                                }
                            } else {
                                var gc      = button.length;
                                var groupid = null;
                                for (var j = 0; j < gc; j++) {
                                    if (addedButtons[button[j].toLowerCase()]) {
                                        if (groupid === null) {
                                            // Create the group.
                                            groupid      = 'ViperInlineToolbarPlugin:buttons:' + i;
                                            groupElement = self.createButtonGroup(groupid);
                                            this.addButton(groupElement);
                                        }

                                        // Button is included in the setting, add it to group.
                                        self.addButtonToGroup('vitp' + ViperUtil.ucFirst(button[j]), groupid);
                                    }
                                }
                            }//end if
                        }//end for
                    },
                    hideToolsSection: function() {
                        ViperUtil.setStyle(toolsContainer, 'display', 'none');
                        ViperUtil.addClass(toolbar, 'Viper-noTools');
                    },
                    setOnHideCallback: function(callback) {
                        this._onHideCallback = callback;
                    },
                    _subSections: {},
                    _activeSection: null,
                    _subSectionButtons: {},
                    _subSectionActionWidgets: {},
                    _buttonShown: false,
                    _subSectionShown: false,
                    _verticalPosUpdateOnly: false,
                    _keepOpenTagList: [],
                    _onHideCallback: null,
                    updatePosition: function(range, selectedNode) {
                        var _self = this;
                        self.viper.Tools.updatePositionOfElement(toolbar, range, selectedNode, function() {
                            _self.hide();
                        });
                    },
                    setVerticalUpdateOnly: function(verticalOnly) {
                        this._verticalPosUpdateOnly = verticalOnly;
                    },
                    _updateSubSectionArrowPos: function() {
                        if (!this._activeSection) {
                            return;
                        }

                        var button = this._subSectionButtons[this._activeSection];
                        if (!button) {
                            return;
                        }

                        button = tools.getItem(button).element;
                        if (!button) {
                            return;
                        }

                        var buttonRect = ViperUtil.getBoundingRectangle(button);
                        var toolbarPos = ViperUtil.getBoundingRectangle(toolbar);
                        var xPos       = (buttonRect.x1 - toolbarPos.x1 + ((buttonRect.x2 - buttonRect.x1) / 2));
                        ViperUtil.setStyle(subSectionContainer.firstChild, 'left', xPos + 'px');
                    }
                }
            );

            this.viper.addElement(toolbar);

            return toolbar;

        },

        getVisibleToolbarRectangles: function()
        {
            var rects           = [];
            var visibleToolbars = ViperUtil.getClass('ViperITP Viper-visible', this.viper.getElementHolder());
            if (visibleToolbars.length === 0) {
                return rects;
            }

            for (var i = 0; i < visibleToolbars.length; i++) {
                rects.push(ViperUtil.getBoundingRectangle(visibleToolbars[i]));
            }

            return rects;

        },

        createToolTip: function(id, content, element)
        {
            var self    = this;
            var tooltip = document.createElement('div');
            ViperUtil.addClass(tooltip, 'Viper-tooltip');
            ViperUtil.setHtml(tooltip, content);

            var visible = false;
            var mouseX  = 0;
            var mouseY  = 0;

            if (element && element !== 'mouse') {
                // Show tooltip on hover.
                var timer = null;
                ViperUtil.hover(
                    element,
                    function() {
                        timer = setTimeout(
                            function() {
                                self.getItem(id).show(element);
                            },
                            500
                        );
                    },
                    function() {
                        clearTimeout(timer);
                        self.getItem(id).hide();
                    }
                );
            } else if (element === 'mouse') {
                ViperUtil.addEvent(
                    document,
                    'mousemove',
                    function(e) {
                        mouseX = e.pageX;
                        mouseY = e.pageY;

                        if (visible !== true) {
                            return;
                        }

                        ViperUtil.setStyle(tooltip, 'left', mouseX + 'px');
                        ViperUtil.setStyle(tooltip, 'top', mouseY + 'px');
                    }
                );
            }//end if


            this.addItem(
                id,
                {
                    type: 'tooltip',
                    element: tooltip,
                    show: function(elem) {
                        if (elem && elem.nodeType) {
                            // Show tooltip on this element.
                            var rect = ViperUtil.getBoundingRectangle(elem);

                            ViperUtil.setStyle(tooltip, 'left', rect.x2 + 'px');
                            ViperUtil.setStyle(tooltip, 'top', rect.y2 + 'px');

                            self.viper.addElement(tooltip);
                            visible = true;
                        } else if (elem === 'mouse' || element === 'mouse') {
                            // Follow the mouse pointer.
                            ViperUtil.setStyle(tooltip, 'left', mouseX + 'px');
                            ViperUtil.setStyle(tooltip, 'top', mouseY + 'px');
                            self.viper.addElement(tooltip);
                            visible = true;
                        }
                    },
                    hide: function() {
                        visible = false;
                        if (tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                    }
                }
            );

            return tooltip;

        },

        createPopoutPanel: function(id, contentElement) {
            var panel = document.createElement('div');
            ViperUtil.addClass(panel, 'Viper-popoutPanel');

            ViperUtil.attr(panel, 'data-id', id);

            if (contentElement) {
                panel.appendChild(contentElement);
            }

            this.viper.addElement(panel);

            // Positioning.
            this.addItem(
                id,
                {
                    type: 'popoutPanel',
                    element: panel,
                    show: function(target) {
                        ViperUtil.addClass(panel, 'ViperUtil-visible');
                        ViperUtil.determinePosition(
                            panel,
                            {
                                targetElement: target,
                                position: 'right',
                                arrowPositions: ['left.middle', 'left.top', 'left.bottom']
                            }
                        );
                    },
                    hide: function() {
                        ViperUtil.removeClass(panel, 'ViperUtil-visible');
                    },
                    isOpen: function() {
                        return ViperUtil.hasClass(panel, 'ViperUtil-visible');
                    }
                }
            );

            return panel;

        },

        createSelectionList: function(id, listItems, itemClickedCallback) {
            var self = this;
            var list = document.createElement('ol');
            ViperUtil.addClass(list, 'Viper-selectionList');

            for (var itemid in listItems) {
                var li = document.createElement('li');
                ViperUtil.attr(li, 'data-id', itemid);

                if (typeof listItems[itemid] === 'string') {
                    ViperUtil.setHtml(li, listItems[itemid]);
                } else {
                    ViperUtil.setHtml(li, listItems[itemid].content);

                    if (listItems[itemid].selected === true) {
                        ViperUtil.addClass(li, 'ViperUtil-selectionList-selected');
                    }
                }

                list.appendChild(li);
            }

            ViperUtil.addEvent(
                list,
                'click',
                function (e) {
                    if (ViperUtil.isTag(e.target, 'li') === true) {
                        ViperUtil.toggleClass(e.target, 'selected');
                        self.viper.fireCallbacks('ViperTools:changed:' + id);
                        if (itemClickedCallback) {
                            itemClickedCallback.call(
                                this,
                                ViperUtil.attr(e.target, 'data-id'),
                                ViperUtil.hasClass(e.target, 'selected'),
                                e.target
                            );
                        }
                    }
                }
            );

            ViperUtil.addEvent(
                list,
                'click',
                function(e) {
                }
            );

            this.addItem(
                id,
                {
                    type: 'selectionList',
                    element: list,
                    setSelectedItems: function(itemids, isInitialValue) {
                        var items = ViperUtil.getTag('li', list);
                        var ln = items.length;
                        for (var i = 0; i < ln; i++) {
                            if (ViperUtil.inArray(ViperUtil.attr(items[i], 'data-id'), itemids) === true) {
                                ViperUtil.addClass(items[i], 'selected');
                            } else {
                                ViperUtil.removeClass(items[i], 'selected');
                            }
                        }

                        if (isInitialValue !== true) {
                            self.viper.fireCallbacks('ViperTools:changed:' + id);
                        }
                    },
                    getSelectedItems: function() {
                        var selectedItems = ViperUtil.getClass('selected', list);
                        var items         = [];
                        for (var i = 0; i < selectedItems.length; i++) {
                            items.push(ViperUtil.attr(selectedItems[i], 'data-id'));
                        }

                        return items;
                    },
                    removeFromSelection: function(itemid) {
                        var items = ViperUtil.getClass('selected', list);
                        var ln = items.length;
                        for (var i = 0; i < ln; i++) {
                            if (ViperUtil.attr(items[i], 'data-id') === itemid) {
                                ViperUtil.removeClass(items[i], 'selected');
                                self.viper.fireCallbacks('ViperTools:changed:' + id);
                                break;
                            }
                        }
                    },
                    hideItem: function(itemid) {
                        var item = this._getItem(itemid);
                        ViperUtil.setStyle(item, 'display', 'none');
                    },
                    showItem: function(itemid) {
                        var item = this._getItem(itemid);
                        ViperUtil.setStyle(item, 'display', 'block');
                    },
                    _getItem: function(itemid) {
                        return ViperUtil.find(list, '[data-id="' + itemid + '"]')[0];
                    }
                }
            );

            return list;

        },

        scaleElement: function(element)
        {
            var zoom = (document.documentElement.clientWidth / window.innerWidth);
            if (zoom === 1) {
                var scale = 1;
                ViperUtil.setStyle(element, '-webkit-transform', 'scale(' + scale + ', ' + scale + ')');
                ViperUtil.setStyle(element, '-moz-transform', 'scale(' + scale + ', ' + scale + ')');
                return;
            }

            var scale = ((1 / zoom) + 0.2);

            ViperUtil.setStyle(element, '-webkit-transform', 'scale(' + scale + ', ' + scale + ')');
            ViperUtil.setStyle(element, '-moz-transform', 'scale(' + scale + ', ' + scale + ')');

            return scale;

        },

        updatePositionOfElement: function(element, range, selectedNode, hideCallback) {
            var margin = 15;
            var tools  = this.viper.Tools;
            range = range || tools.viper.getViperRange();

            var getElementCoords = function(element) {
                var elemRect     = ViperUtil.getBoundingRectangle(element);
                var scrollCoords = ViperUtil.getScrollCoords(element.ownerDocument.defaultView);
                return {
                    left: (elemRect.x1 - scrollCoords.x),
                    right: (elemRect.x2 - scrollCoords.x),
                    top: (elemRect.y1 - scrollCoords.y),
                    bottom: (elemRect.y2 - scrollCoords.y)
                };
            };

            var rangeCoords  = null;
            var selectedNode = selectedNode || range.getNodeSelection(range);
            if (selectedNode !== null) {
                rangeCoords = getElementCoords(selectedNode);
            } else {
                rangeCoords = range.rangeObj.getBoundingClientRect();
            }

            if (!rangeCoords || (rangeCoords.left === 0 && rangeCoords.top === 0 && ViperUtil.isBrowser('firefox') === true)) {
                if (range.collapsed === true) {
                    var span = document.createElement('span');
                    tools.viper.insertNodeAtCaret(span);
                    rangeCoords = getElementCoords(span);
                    ViperUtil.remove(span);

                    if (!rangeCoords) {
                        return;
                    }
                } else {
                    var startNode = range.getStartNode();
                    var endNode   = range.getEndNode();
                    if (!startNode || !endNode) {
                        return;
                    }

                    if (startNode.nodeType === ViperUtil.TEXT_NODE
                        && startNode.data.indexOf("\n") === 0
                        && endNode.nodeType === ViperUtil.TEXT_NODE
                        && range.endOffset === endNode.data.length
                    ) {
                        range.setStart(endNode, endNode.data.length);
                        range.collapse(true);
                        rangeCoords = range.rangeObj.getBoundingClientRect();
                    }
                }//end if
            }//end if

            if (!rangeCoords || (rangeCoords.bottom === 0 && rangeCoords.height === 0 && rangeCoords.left === 0)) {
                if (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true) {
                    // Webkit bug workaround. https://bugs.webkit.org/show_bug.cgi?id=65324.
                    // OK.. Yet another fix. With the latest Google Chrome (17.0.963.46)
                    // the !rangeCoords check started to fail because its no longer
                    // returning null for a collapsed range, instead all values are set to 0.
                    var startNode = range.getStartNode();
                    if (startNode.nodeType === ViperUtil.TEXT_NODE) {
                        if (range.startOffset < startNode.data.length) {
                            var offset = range.startOffset;
                            if (startNode.data.length > 1) {
                                offset += 1;
                            }

                            range.setEnd(startNode, offset);
                            rangeCoords = range.rangeObj.getBoundingClientRect();
                            range.collapse(true);
                            if (rangeCoords) {
                                rangeCoords.right = rangeCoords.left;
                            }
                        } else if (range.startOffset > 0) {
                            range.setStart(startNode, (range.startOffset - 1));
                            rangeCoords = range.rangeObj.getBoundingClientRect();
                            range.collapse(false);
                            if (rangeCoords) {
                                rangeCoords.right = rangeCoords.left;
                            }
                        }
                    }
                } else {
                    // Point to top of Viper element.
                    rangeCoords        = getElementCoords(tools.viper.getViperElement());
                    rangeCoords.bottom = (rangeCoords.top + 10);
                }//end if
            }//end if

            var frameOffset = {x: 0, y: 0};
            if (Viper.document !== document && Viper.document.defaultView.frameElement) {
                // Viper element is inside an iframe, need to adjust the position.
                frameOffset      = ViperUtil.getDocumentOffset();
                var newCoords    = {};
                newCoords.bottom = (rangeCoords.bottom + frameOffset.y);
                newCoords.top    = (rangeCoords.top + frameOffset.y);
                newCoords.bottom = (rangeCoords.bottom + frameOffset.y);
                newCoords.left   = (rangeCoords.left + frameOffset.x);
                newCoords.right  = (rangeCoords.right + frameOffset.x);
                newCoords.height = rangeCoords.height;
                newCoords.width  = rangeCoords.width;
                rangeCoords      = newCoords;
            }

            var scrollCoords = ViperUtil.getScrollCoords();
            if ((selectedNode && selectedNode.ownerDocument !== document)
                || (range.startContainer && range.startContainer.ownerDocument !== document)
            ) {
                scrollCoords.x = 0;
                scrollCoords.y = 0;
            }

            ViperUtil.addClass(element, 'Viper-calcWidth');
            ViperUtil.setStyle(element, 'width', 'auto');
            var elementWidth = ViperUtil.getElementWidth(element);
            ViperUtil.removeClass(element, 'Viper-calcWidth');
            ViperUtil.setStyle(element, 'width', elementWidth + 'px');

            var viperElemCoords = getElementCoords(tools.viper.getViperElement());
            var elemWindowDim   = ViperUtil.getWindowDimensions(Viper.document.defaultView);
            var mainWindowDim   = ViperUtil.getWindowDimensions();

            if (this._verticalPosUpdateOnly !== true) {
                var left = ((rangeCoords.left + ((rangeCoords.right - rangeCoords.left) / 2) + scrollCoords.x) - (elementWidth / 2));
                ViperUtil.removeClass(element, 'Viper-orientationLeft Viper-orientationRight');

                if (left > (elemWindowDim.width + frameOffset.x)) {
                    // Dont go off screen, point to the editable element.
                    left = viperElemCoords.left;
                }

                if (left < 0) {
                    left += (elementWidth / 2);
                    ViperUtil.addClass(element, 'Viper-orientationLeft');
                } else if (left + elementWidth > mainWindowDim.width) {
                    left -= (elementWidth / 2);
                    ViperUtil.addClass(element, 'Viper-orientationRight');
                }

                ViperUtil.setStyle(element, 'left', left + 'px');
            }

            var top = (rangeCoords.bottom + margin);
            if (ViperUtil.getStyle(element, 'position') !== 'fixed') {
                top += scrollCoords.y;
            }

            if (top === 0) {
                if (hideCallback) {
                    hideCallback.call(this);
                }
                return;
            } else if (((top + 50) > (mainWindowDim.height + scrollCoords.y)) || (top > elemWindowDim.height + scrollCoords.y + frameOffset.y)) {
                if (hideCallback) {
                    hideCallback.call(this);
                }

                return;
            } else if (top < viperElemCoords.top && Viper.document === document) {
                top = (viperElemCoords.top + 50);
                if (left < viperElemCoords.left && this._verticalPosUpdateOnly !== true) {
                    ViperUtil.setStyle(element, 'left', viperElemCoords.left + 50 + 'px');
                }
            } else if (Viper.document !== document && top < ViperUtil.getDocumentOffset().y) {
                if (hideCallback) {
                    hideCallback.call(this);
                }

                return;
            }

            ViperUtil.setStyle(element, 'top', top + 'px');
            ViperUtil.addClass(element, 'Viper-visible');
        }

    };

})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil) {

    Viper.Selection = {
        _selection: null,
        _viper: null,

        
        _getSelection: function()
        {
            if (Viper.window.getSelection) {
                return Viper.window.getSelection();
            } else if (Viper.document.selection) {
                return Viper.document.selection;
            } else if (Viper.document.getSelection) {
                return Viper.document.getSelection();
            } else {
                return null;
            }

        },

        
        createRange: function()
        {
             var rangeObj = null;
             if (Viper.document.createRange) {
                 rangeObj = Viper.document.createRange();
                 return new Viper.MozRange(rangeObj);
             } else if (Viper.document.body.createTextRange) {
                 rangeObj = Viper.document.body.createTextRange();
                 return new Viper.IERange(rangeObj);
             } else {
                 throw Error('UnsupportedOperationException: createRange() not supported.');
             }

        },

        
        getRangeAt: function(pos)
        {
            this._selection = this._getSelection();

            var selection = this._selection;

            if (selection.getRangeAt) {
                // Moz/Safari.
                try {
                    if (selection.rangeCount > 0) {
                        var range    = selection.getRangeAt(pos);
                        var mozRange = new Viper.MozRange(range);
                    } else {
                        var mozRange = this.createRange();
                    }

                    return mozRange;
                } catch (e) {
                    return null;
                }
            } else {
                // IE.
                var rangeObj = selection.createRange();
                if (!rangeObj.duplicate) {
                    rangeObj = Viper.document.body.createTextRange();
                }

                var range = new Viper.IERange(rangeObj);
                return range;
            }//end if

        },

        
        addRange: function(range)
        {
            this._selection = this._getSelection();

            if (ViperUtil.isBrowser('msie', '<9') === true) {
                // IE.
                try {
                    range.rangeObj.select();
                } catch (e) {
                    // Stop the stupid error: Could not complete the operation due to error 800a025e.
                    // This happens when range is not selectable, e.g. element is hidden.
                    // Still happens in IE8.. sigh..
                }
            } else if (this._selection.addRange) {
                // Moz/Safari.
                if (this._selection.rangeCount > 0) {
                    this._selection.removeAllRanges();
                }

                this._selection.addRange(range.rangeObj);
            }

            if (this._viper) {
                this._viper.resetViperRange(range)
            }

        },

        removeRange: function(range)
        {
            var selection = this._getSelection();
            if (selection) {
                if (selection.removeRange) {
                    selection.removeRange(range.rangeObj);
                } else if (selection.empty) {
                    selection.empty();
                }
            }

        },

        removeAllRanges: function()
        {
            var selection = this._getSelection();
            if (selection.removeAllRanges) {
                selection.removeAllRanges();
            }

        }

    };

})(Viper.Util);


(function(ViperUtil, ViperSelection) {
    Viper.DOMRange = function(rangeObj)
    {
        this.rangeObj = rangeObj;

        
        this.startContainer = null;

        
        this.endContainer = null;

        
        this.startOffset = 0;

        
        this.endOffset = 0;

        
        this.collapsed = true;

        
        this.commonAncestorContainer = null;

        
        this.anchorToStart = 'undefined';

    }

    
    Viper.DOMRange.START_TO_START = 0;

    
    Viper.DOMRange.START_TO_END = 1;

    
    Viper.DOMRange.END_TO_END = 3;

    
    Viper.DOMRange.END_TO_START = 4;

    
    Viper.DOMRange.CHARACTER_UNIT = 'character';

    
    Viper.DOMRange.WORD_UNIT = 'word';

    
    Viper.DOMRange.LINE_UNIT = 'line';



    Viper.DOMRange.prototype = {

        
        setStart: function(node, offset) {},

        
        setEnd: function(node, offset) {},

        
        setStartBefore: function(node) {},

        
        setStartAfter: function(node) {},

        
        setEndBefore: function(node) {},

        
        setEndAfter: function(node) {},

        
        selectNode: function(node) {},

        
        selectNodeContents: function(node) {},

        
        surroundContents: function(node) {},

        
        collapse: function(toStart) {},

        // Range Comparisons.
        
        compareBoundaryPoints: function(how, sourceRange) {},

        // Extract Content.
        
        deleteContents: function() {},

        
        extractContents: function() {},

        
        cloneContents: function() {},

        // Inserting.
        
        insertNode: function(node) {},

        // Misc.
        
        cloneRange: function() {},

        
        toString: function() {},

        
        detach: function() {},

        

        
        getCommonElement: function () {},

        
        moveStart: function(unitType, units) {},

        
        moveEnd: function(unitType, units) {},

        
        setAnchor: function(toStart) {},

        
        setFocus: function(node, offset) {},

        
        moveFocus: function(unitType, units) {},

        
        getRangeCoords: function(toStart) {},

        
        getBoundingClientRect: function() {},

        
        getPreviousContainer: function(container, skippedBlockElem, skipEmptyNodes, stubElementIsSelectable, stopAtBlockElement)
        {
            if (!container) {
                return null;
            }

            while (container.previousSibling) {
                container = container.previousSibling;
                if (container.nodeType !== ViperUtil.TEXT_NODE) {
                    if (ViperUtil.isStubElement(container) === true) {
                        return container;
                    } else {
                        var child = this._getLastSelectableChild(container, skipEmptyNodes, stubElementIsSelectable);
                        if (child !== null) {
                            return child;
                        }
                    }
                } else if (this._isSelectable(container) === true) {
                    return container;
                }
            }

            // Look at parents next sibling.
            while (container && !container.previousSibling) {
                container = container.parentNode;
            }

            if (!container) {
                return null;
            }

            if (stopAtBlockElement === true && ViperUtil.isBlockElement(container) === true) {
                return null;
            }

            container = container.previousSibling;
            if (this._isSelectable(container) === true) {
                return container;
            } else if (skippedBlockElem && ViperUtil.isBlockElement(container) === true) {
                skippedBlockElem.push(container);
            }

            if (container && container.nodeType !== ViperUtil.TEXT_NODE) {
                var selChild = this._getLastSelectableChild(container, skipEmptyNodes, stubElementIsSelectable);
                if (selChild !== null) {
                    return selChild;
                }
            }

            return this.getPreviousContainer(container, skippedBlockElem, skipEmptyNodes, stubElementIsSelectable);

        },

        _isSelectable: function(container)
        {
            if (container
                && container.nodeType === ViperUtil.TEXT_NODE
                && container.data.length !== 0
                && container.data.match(/^\n\s*$/) === null
            ) {
                return true;
            }

            return false;

        },

        
        getNextContainer: function(container, skippedBlockElem, skipSpaceTextNodes, stubElementIsSelectable, stopAtBlockElement)
        {
            if (!container) {
                return null;
            }

            while (container.nextSibling) {
                container = container.nextSibling;
                if (container.nodeType !== ViperUtil.TEXT_NODE) {
                    var child = this._getFirstSelectableChild(container, stubElementIsSelectable);
                    if (child !== null) {
                        return child;
                    }
                } else if (this._isSelectable(container) === true) {
                    return container;
                }
            }

            // Look at parents next sibling.
            while (container && !container.nextSibling) {
                container = container.parentNode;
            }

            if (!container) {
                return null;
            }

            if (stopAtBlockElement === true && ViperUtil.isBlockElement(container) === true) {
                return null;
            }

            container = container.nextSibling;
            if (this._isSelectable(container) === true) {
                return container;
            } else if (skippedBlockElem && ViperUtil.isBlockElement(container) === true) {
                skippedBlockElem.push(container);
            }

            var selChild = this._getFirstSelectableChild(container, stubElementIsSelectable);
            if (selChild !== null
                && ((stubElementIsSelectable === true && ViperUtil.isTag(selChild, 'br') === true)
                || (skipSpaceTextNodes !== true || ViperUtil.trim(selChild.data) !== ''))
            ) {
                if (selChild.nodeType !== ViperUtil.TEXT_NODE || selChild.data.charCodeAt(0) !== 10) {
                    return selChild;
                }
            }

            return this.getNextContainer(container, skippedBlockElem, skipSpaceTextNodes, stubElementIsSelectable);

        },

        _getFirstSelectableChild: function(element, stubElementIsSelectable)
        {
            if (element) {
                if (element.nodeType !== ViperUtil.TEXT_NODE) {
                    var child = element.firstChild;
                    while (child) {
                        if (ViperUtil.attr(child, 'contenteditable') === 'false') {
                            // Create a new text node if this element is not editable.
                            var newNode = document.createTextNode('');
                            ViperUtil.insertBefore(child, newNode);
                            return newNode;
                        } else if (this._isSelectable(child) === true || (stubElementIsSelectable === true && ViperUtil.isStubElement(child) === true)) {
                            return child;
                        } else if (child.firstChild) {
                            // This node does have child nodes.
                            var res = this._getFirstSelectableChild(child, stubElementIsSelectable);
                            if (res !== null) {
                                return res;
                            } else {
                                child = child.nextSibling;
                            }
                        } else {
                            child = child.nextSibling;
                        }
                    }
                } else {
                    // Given element is a text node so return it.
                    return element;
                }//end if
            }//end if

            return null;

        },

        _getLastSelectableChild: function(element, skipEmptyNodes, stubElementIsSelectable)
        {
            if (element) {
                if (element.nodeType !== ViperUtil.TEXT_NODE) {
                    var child = element.lastChild;
                    while (child) {
                        if (ViperUtil.attr(child, 'contenteditable') === 'false') {
                            // Create a new text node if this element is not editable.
                            var newNode = document.createTextNode('');
                            ViperUtil.insertAfter(child, newNode);
                            return newNode;
                        } else if (this._isSelectable(child) === true || (stubElementIsSelectable === true && ViperUtil.isStubElement(child) === true)) {
                            return child;
                        } else if (child.lastChild) {
                            // This node does have child nodes.
                            var res = this._getLastSelectableChild(child, stubElementIsSelectable);
                            if (res !== null) {
                                return res;
                            } else {
                                child = child.previousSibling;
                            }
                        } else {
                            child = child.previousSibling;
                        }
                    }
                } else {
                    if (skipEmptyNodes !== true || element.data.match(/^\n\s*$/) === null) {
                        // Given element is a text node so return it.
                        return element;
                    }
                }//end if
            }//end if

            return null;

        },

        moveCaretAway: function(sourceElement, parentElement, defaultTagName, back)
        {
            var next       = true;
            var selectable = null;

            if (back === true) {
                next = false;
                selectable = this.getPreviousContainer(sourceElement, null, true, true);
                if (!selectable || (selectable !== parentElement && ViperUtil.isChildOf(selectable, parentElement) === false) === true) {
                    next       = true;
                    selectable = this.getNextContainer(sourceElement, null, true, true);
                }
            } else {
                selectable = this.getNextContainer(sourceElement, null, true, true);
                if (!selectable || (selectable !== parentElement && ViperUtil.isChildOf(selectable, parentElement) === false) === true) {
                    next       = false;
                    selectable = this.getPreviousContainer(sourceElement, null, true, true);
                }
            }

            if (!selectable || (selectable !== parentElement && ViperUtil.isChildOf(selectable, parentElement) === false) === true) {
                // Create a new default container.
                var defTag = null;
                if (defaultTagName !== '') {
                    defTag = document.createElement(defaultTagName);
                    ViperUtil.setHtml(defTag, '<br/>');
                } else {
                    defTag = document.createTextNode(' ');
                }

                ViperUtil.insertAfter(sourceElement, defTag);
                this.setStart(defTag, 0);
                this.collapse(true);
                ViperSelection.addRange(this);
                return false;
            } else if (next === true || selectable.nodeType !== ViperUtil.TEXT_NODE) {
                this.setStart(selectable, 0);
                this.collapse(true);
            } else {
                this.setStart(selectable, selectable.data.length);
                this.collapse(true);
            }

            ViperSelection.addRange(this);
            return this;

        },

        _normalizeNode: function(node)
        {
            // Joins all sibling text elements.
            if (node.nodeType === ViperUtil.ELEMENT_NODE) {
                var c      = node.childNodes.length;
                var str    = '';
                var mChild = null;
                for (var i = 0; i < c; i++) {
                    var child = node.childNodes[i];
                    if (child.nodeType === ViperUtil.TEXT_NODE) {
                        str += child.data;
                        if (mChild === null) {
                            mChild = child;
                        } else {
                            // Remove this node.
                            ViperUtil.remove(child);
                        }
                    } else if (mChild !== null) {
                        mChild.data = str;
                        mCHild      = null;
                    }
                }

                if (mChild !== null) {
                    mChild.nodeValue = str;
                }
            } else if (node.nodeType === ViperUtil.TEXT_NODE) {
                this._normalizeNode(node.parentNode);
            }//end if

        },

        getNodeIndex: function(node)
        {
            if (!node || !node.parentNode) {
                return;
            }

            var index = 0;
            var prev  = node.previousSibling;

            while (prev) {
                prev = prev.previousSibling;
                index++;
            }

            return index;

        },

        getStartNode: function()
        {
            if (!this.startContainer) {
                return null;
            }

            if (this.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                var ln = this.startContainer.childNodes.length;
                if (ln > this.startOffset) {
                    return this.startContainer.childNodes[this.startOffset];
                } else if (ln === this.startOffset && ViperUtil.isStubElement(this.startContainer.childNodes[this.startOffset - 1]) === true) {
                    // When the last child is a stub element (e.g. img) and range is set after it the offset becomes greater
                    // than the number of children.
                    return this.startContainer.childNodes[this.startOffset - 1];
                } else if (ln > 0 && ln === this.startOffset && this.startContainer.childNodes[this.startOffset - 1].nodeType !== ViperUtil.TEXT_NODE && this.collapsed === true) {
                    return this._getLastSelectableChild(this.startContainer.childNodes[this.startOffset - 1]);
                }
            }

            return this.startContainer;

        },

        getEndNode: function()
        {
            if (!this.endContainer) {
                return null;
            }

            if (this.endContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                var ln = this.endContainer.childNodes.length;
                if (ln > this.endOffset) {
                    return this.endContainer.childNodes[this.endOffset];
                } else if (ln === this.endOffset && ln !== 0) {
                    var lastChild = this.endContainer.childNodes[this.endOffset - 1];
                    if (ViperUtil.isStubElement(lastChild) === true) {
                        // When the last child is a stub element (e.g. img) and range is set after it the offset becomes greater
                        // than the number of children.
                        return this.endContainer.childNodes[this.endOffset - 1];
                    } else if (lastChild.nodeType === ViperUtil.ELEMENT_NODE
                        && lastChild.lastChild.nodeType === ViperUtil.TEXT_NODE
                        && this.startContainer.nodeType === ViperUtil.TEXT_NODE
                    ) {
                        return lastChild.lastChild;
                    } else if (ln > 0 && ln === this.endOffset && this.endContainer.childNodes[this.endOffset - 1].nodeType !== ViperUtil.TEXT_NODE && this.collapsed === true) {
                        return this._getLastSelectableChild(this.endContainer.childNodes[this.endOffset - 1]);
                    }
                }
            }

            return this.endContainer;

        },

        
        _nodeSel: {},

        
        clearNodeSelectionCache: function()
        {
            this._nodeSel = {};
        },

        getNodeSelection: function(range, forceUpdate)
        {
            range = range || this;

            if (forceUpdate !== true
                && this._nodeSel
                && this._nodeSel.startContainer === range.startContainer
                && this._nodeSel.endContainer === range.endContainer
                && this._nodeSel.startOffset === range.startOffset
                && this._nodeSel.endOffset === range.endOffset
                && this._nodeSel.collapsed === range.collapsed
                && this._nodeSel.commonAncestor === range.commonAncestorContainer
                && this._nodeSel.startNode === range.getStartNode()
                && this._nodeSel.endNode === range.getEndNode()
            ) {
                return this._nodeSel.node;
            }

            this._nodeSel.startContainer = range.startContainer;
            this._nodeSel.endContainer   = range.endContainer;
            this._nodeSel.startOffset    = range.startOffset;
            this._nodeSel.endOffset      = range.endOffset;
            this._nodeSel.collapsed      = range.collapsed;
            this._nodeSel.startNode      = range.getStartNode();
            this._nodeSel.endNode        = range.getEndNode();
            this._nodeSel.commonAncestor = range.commonAncestorContainer;
            this._nodeSel.node           = null;

            // Webkit seems to get the range incorrectly when range is set on a node.
            // For example: <p>text</p><p>text</p> if the range.selectNode is called for
            // the first P then the next getCurrentRange call returns range start as
            // first P and range end as before the first character of the next 2nd P tag.
            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();
            var common    = range.getCommonElement();

            if (!startNode && !endNode) {
                this._nodeSel.node = null;
                return null;
            } else if (startNode
                && endNode
                && startNode === endNode
                && startNode.nodeType !== ViperUtil.TEXT_NODE
                && range.startOffset === range.endOffset
                && this.startContainer.childNodes.length >= range.startOffset
                && ViperUtil.isStubElement(startNode) === false
            ) {
                // Case: <p><img />*</p> and a character is typed. It should not return img as selected.
                this._nodeSel.node = null;
                return null;
            } else if (startNode
                && endNode
                && startNode === endNode
                && startNode.nodeType !== ViperUtil.TEXT_NODE
                && (range.startOffset + 1) === range.endOffset
                && this.startContainer.childNodes.length >= range.startOffset
            ) {
                // Case: <p>[<img />]</p>. Image clicked.
                this._nodeSel.node = startNode;
                return startNode;
            } else if (startNode
                && endNode
                && startNode.nodeType === ViperUtil.ELEMENT_NODE
                && endNode.nodeType === ViperUtil.ELEMENT_NODE
                && startNode !== endNode
                && endNode === common
                && !startNode.nextElementSibling
                && ((range.startOffset + 1) === range.endOffset)
            ) {
                // Last element in the container however the range start node is the last element but end node is the common
                // parent with endOffset = startOffset + 1.
                this._nodeSel.node = startNode;
                return startNode;
            } else if (startNode && !endNode) {
                if (startNode.nodeType === ViperUtil.TEXT_NODE) {
                    if (range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                        && range.endOffset >= range.endContainer.childNodes.length
                        && startNode.nodeType === ViperUtil.TEXT_NODE
                        && range.startOffset === 0
                        && range.endContainer === range.commonAncestorContainer
                        && (common.firstChild === startNode || this._getFirstSelectableChild(common) === startNode)
                    ) {
                        // Selection starts from the start of the first editable element to the end of the
                        // common element, make the selected node as the common element.
                        this._nodeSel.node = range.commonAncestorContainer;
                        return this._nodeSel.node;
                    } else if (this._nodeSel.startOffset === startNode.data.length
                        && startNode.nextSibling
                        && startNode.nextSibling.nodeType === ViperUtil.ELEMENT_NODE
                        && this._nodeSel.endContainer.childNodes.length === this._nodeSel.endOffset
                        && this._nodeSel.endContainer.childNodes[(this._nodeSel.endOffset - 1)] === startNode.nextSibling
                    ) {
                        // Inline element selection at the end of a block element (IE).
                        this._nodeSel.node = startNode.nextSibling;
                        return this._nodeSel.node;
                    } else if (ViperUtil.trim(startNode.data) === '') {
                        this._nodeSel.node = null;
                        return null;
                    } else {
                        this._nodeSel.node = null;
                        return null;
                    }
                } else if (startNode.nodeType === ViperUtil.ELEMENT_NODE
                    && this.endContainer === this.startContainer
                    && this.startOffset === 0
                    && this.endOffset >= this.endContainer.childNodes.length
                ) {
                    if (this.endOffset === 1 && this.endContainer.childNodes.length === 1) {
                        // Singe element exists in the container.
                        startNode = this.endContainer.childNodes[0];
                    } else {
                        startNode = this.endContainer;
                    }
                }

                this._nodeSel.node = startNode;
                return startNode;
            } else if (!startNode && endNode) {
                this._nodeSel.node = endNode;
                return endNode;
            } else if (startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && startNode === endNode
                && range.startOffset === 0
                && range.endOffset === endNode.data.length
                && range.collapsed === false
                && endNode.nextSibling
                && (!ViperUtil.isTag(endNode.nextSibling, 'br') || endNode.nextSibling.nextSibling)
            ) {
                this._nodeSel.node = null;
                return null;
            } else if (startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && startNode === endNode
                && range.startOffset === startNode.data.length
                && range.collapsed === true
            ) {
                // Image Selection checks for IE.
                if (ViperUtil.isBrowser('msie', '<11') === true
                    && startNode.nextSibling
                    && ViperUtil.isTag(startNode.nextSibling, 'img') === true
                    && endNode.previousSibling
                    && ViperUtil.isTag(startNode.previousSibling, 'img') === true
                    && range.endOffset === 0
                    && range.startOffset === 0
                ) {
                    this._nodeSel.node = startNode.nextSibling;
                    return this._nodeSel.node;
                } else if (ViperUtil.isBrowser('msie', '<11') === true
                    && startNode.nextSibling
                    && ViperUtil.isTag(startNode.nextSibling, 'img') === true
                    && endNode === startNode
                    && range.endOffset === 0
                    && range.startOffset === 0
                ) {
                    this._nodeSel.node = startNode.nextSibling;
                    return this._nodeSel.node;
                }

                this._nodeSel.node = null;
                return null;
            } else if (startNode.nodeType === ViperUtil.ELEMENT_NODE
                && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                && startNode.nextSibling === endNode
            ) {
                this._nodeSel.node = startNode;
                return startNode;
            } else if (startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === endNode.data.length
                && this._getFirstSelectableChild(common) === startNode
                && this._getLastSelectableChild(common) === endNode
            ) {
                this._nodeSel.node = common;
                return common;
            } else if (range.startContainer === range.endContainer
                && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.startOffset === 0
                && range.endOffset === 0
                && (range.startContainer.childNodes.length === 0
                || (range.startContainer.childNodes.length === 1
                    && ViperUtil.isStubElement(range.startContainer.childNodes[0]) === false
                    && (range.startContainer.childNodes[0].nodeType !== ViperUtil.TEXT_NODE || range.startContainer.childNodes[0].data.length === 0)))
            ) {
                this._nodeSel.node = range.startContainer;
                return range.startContainer;
            } else if (startNode.nodeType === ViperUtil.ELEMENT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === endNode.data.length
                && this._getLastSelectableChild(startNode) === endNode
            ) {
                this._nodeSel.node = startNode;
                return startNode;
            } else if (startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === endNode.data.length
                && range.commonAncestorContainer
                && range.commonAncestorContainer.nodeType === ViperUtil.ELEMENT_NODE
                && this._getFirstSelectableChild(range.commonAncestorContainer) === startNode
                && this._getLastSelectableChild(range.commonAncestorContainer) === endNode
            ) {
                this._nodeSel.node = range.commonAncestorContainer;
                return range.commonAncestorContainer;
            } else if (startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === endNode.data.length
                && common
                && this._getFirstSelectableChild(common) === startNode
                && this._getLastSelectableChild(common) === endNode
            ) {
                this._nodeSel.node = common;
                return common;
            } else if (ViperUtil.isBrowser('chrome') === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === 0
                && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                && ViperUtil.isBlockElement(range.endContainer) === true
                && this._getFirstSelectableChild(ViperUtil.getFirstBlockParent(startNode)) === startNode
                && this.getNextContainer(ViperUtil.getFirstBlockParent(startNode), null, false, true) === range._getFirstSelectableChild(range.endContainer)
            ) {
                this._nodeSel.node = ViperUtil.getFirstBlockParent(startNode);
                return this._nodeSel.node;
            } else if (startNode !== endNode
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode.nodeType === ViperUtil.ELEMENT_NODE
                && this.endOffset === 0
                && this.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                && this._getFirstSelectableChild(this.endContainer) === startNode
                && ViperUtil.isBrowser('msie', '<11') === true
            ) {
                this._nodeSel.node = this.endContainer;
                return this._nodeSel.node;
            } else if (endNode !== startNode
                && endNode === common
                && (startNode === common.firstElementChild || startNode === common.firstChild)
                && range.startOffset === 0
            ) {
                // <div>[<p><em>text</em></p><p><em>text</em></p>]</div>.
                this._nodeSel.node = common;
                return this._nodeSel.node;
            } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === range.startContainer.data.length
                && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.endOffset === 1
                && ViperUtil.isBlockElement(range.endContainer) === false
            ) {
                // (IE) Handling drag selection of EM tag in this case:
                // <p>test [<em><a href="..">test</a></em>] text</p>.
                // Need to select the most inner child.
                var surroundedChildren = ViperUtil.getSurroundedChildren(range.endContainer);
                var selNode            = range.endContainer;
                if (surroundedChildren.length > 0) {
                    selNode = surroundedChildren.pop();
                }

                this._nodeSel.node = selNode;
                return this._nodeSel.node;
            } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === range.startContainer.data.length
                && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.endOffset === range.endContainer.childNodes.length
                && ViperUtil.isText((range.endContainer.childNodes[range.endContainer.childNodes.length - 1]).previousSibling) === true
            ) {
                // <p>text[<img />]</p>.
                this._nodeSel.node = range.endContainer.childNodes[range.endContainer.childNodes.length - 1];
                return this._nodeSel.node;
            } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === range.startContainer.data.length
                && range.endOffset === 0
                && range.startContainer.nextSibling === range.endContainer.previousSibling
                && range.startContainer.nextSibling.nodeType === ViperUtil.ELEMENT_NODE
            ) {
                this._nodeSel.node = range.startContainer.nextSibling;
                return this._nodeSel.node;
            } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.startContainer.childNodes[range.startOffset]
                && range.startContainer.childNodes[range.startOffset].nodeType === ViperUtil.ELEMENT_NODE
                && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === 0
                && range.endContainer.previousSibling === range.startContainer.childNodes[range.startOffset]
            ) {
                this._nodeSel.node = range.endContainer.previousSibling;
                return this._nodeSel.node;
            }

            // We may need to adjust the "startNode" depending on its offset.
            var startMoved = null;
            if (startNode.nodeType === ViperUtil.TEXT_NODE) {
                if (range.startOffset !== 0) {
                    if (range.startOffset !== startNode.data.length) {
                        this._nodeSel.node = null;
                        return null;
                    } else {
                        // Range is at the end of a text node, find the first selectable
                        // node in the next siblong and change the startNode to that.
                        if (startNode.nextSibling) {
                            startNode = this._getFirstSelectableChild(startNode.nextSibling);
                            if (!startNode) {
                                this._nodeSel.node = null;
                                return null;
                            }
                        } else {
                            startMoved = {
                                startContainer: this.startContainer,
                                startOffset: this.startOffset
                            };

                            // There is no sibling move range by 1 char.
                            this.moveStart(Viper.DOMRange.CHARACTER_UNIT, 1);
                            startNode = range.getStartNode();
                        }
                    }
                }
            } else if (startNode.nodeType === ViperUtil.ELEMENT_NODE
                && endNode.nodeType === ViperUtil.ELEMENT_NODE
                && common === startNode
            ) {
                this._nodeSel.node = startNode;
                return startNode;
            }

            if (startNode.previousSibling) {
                if (startNode.previousSibling.nodeType !== ViperUtil.TEXT_NODE
                    || startNode.previousSibling.data.length !== 0
                ) {
                    if (startMoved) {
                        this.setStart(startMoved.startContainer, startMoved.startOffset);
                    } else if (ViperUtil.isBrowser('msie', '<11') === true) {
                        if (startNode.parentNode === endNode && range.startOffset + 1 === range.endOffset) {
                            // Handle <div><p>text</p>*<blockquote><p>text</p></blockquote>*</div>.
                            this._nodeSel.node = startNode;
                            return startNode;
                        }
                    }

                    this._nodeSel.node = null;
                    return null;
                }
            }

            if (endNode.nodeType === ViperUtil.TEXT_NODE) {
                if (range.endOffset !== 0) {
                    if (range.endOffset === endNode.data.length
                        && !endNode.nextSibling
                        && (startNode.parentNode === endNode.parentNode
                        || this._getLastSelectableChild(startNode.parentNode) === endNode)
                    ) {
                        this._nodeSel.node = startNode.parentNode;
                        return startNode.parentNode;
                    } else {
                        this._nodeSel.node = null;
                        return null;
                    }
                }
            } else if (!endNode.nextSibling && ViperUtil.isTag(endNode, 'br') === true) {
                // Handle Firefox _moz_dirty at the end of an element.
                if (this._getLastSelectableChild(startNode.parentNode) === endNode.previousSibling) {
                    this._nodeSel.node = startNode.parentNode;
                    return startNode.parentNode;
                }
            }

            this._nodeSel.node = null;
            return null;

        }

    };

})(Viper.Util, Viper.Selection);



(function(ViperUtil, ViperSelection) {
    Viper.IERange = function(rangeObj)
    {
        ViperUtil.inherits(Viper.IERange, Viper.DOMRange);
        Viper.DOMRange.call(this, rangeObj);

        this._initContainerInfo();
        this._setCollapsed();

        this._prevHeight    = null;
        this._prevContainer = null;

        
        Viper.DOMRange.START_TO_START = 'StartToStart';

        
        Viper.DOMRange.START_TO_END = 'StartToEnd';

        
        Viper.DOMRange.END_TO_END = 'EndToEnd';

        
        Viper.DOMRange.END_TO_START = 'EndToStart';

    }

    Viper.IERange._prevRange = {
        range: null,
        startContainer: null,
        endContainer: null,
        startOffset: 0,
        endOffset: 0
    };


    Viper.IERange.prototype = {


        
        _initContainerInfo: function()
        {
            var clone  = this.rangeObj.duplicate();

            if (Viper.IERange._prevRange.range !== null) {
                // IE check..
                try {
                    // Check if start or end container throws invalid pointer exception (IE8..).
                    Viper.IERange._prevRange.startContainer.parentNode;
                    Viper.IERange._prevRange.endContainer.parentNode;

                    if (clone.isEqual(Viper.IERange._prevRange.range) === true) {
                        this.startContainer = Viper.IERange._prevRange.startContainer;
                        this.endContainer   = Viper.IERange._prevRange.endContainer;
                        this.startOffset    = Viper.IERange._prevRange.startOffset;
                        this.endOffset      = Viper.IERange._prevRange.endOffset;
                        return;
                    }
                } catch(e) {
                    Viper.IERange._prevRange.range = null;
                }
            }

            Viper.IERange._prevRange.range = clone;

            var eclone = this.rangeObj.duplicate();

            clone.collapse(true);

            var info = this._getContainerInfo(clone);

            this.startContainer = info.container;
            this.startOffset    = info.offset;

            if (eclone.text.length > 0
                && eclone.htmlText.charAt(0) === '<'
                && eclone.htmlText.charAt(eclone.htmlText.length - 1) === '>'
            ) {
                var startParentElement = clone.parentElement();
                if (startParentElement !== eclone.parentElement() || ViperUtil.isBlockElement(startParentElement) === true) {
                    var pElemB = eclone.parentElement();
                    eclone.moveEnd('character', -1);
                    var pElemA = eclone.parentElement();
                    if (ViperUtil.isBlockElement(pElemB) === true
                        && ViperUtil.isBlockElement(pElemA) === false
                        && !pElemA.nextSibling
                    ) {
                        // eclone.moveEnd('character', -1);
                    } else {
                        eclone.moveEnd('character', 1);
                    }
                }
            }

            eclone.collapse(false);

            if (eclone.isEqual(clone) !== true) {
                var einfo = this._getContainerInfo(eclone);
                this.endContainer = einfo.container;
                this.endOffset    = einfo.offset;
            } else {
                this.endContainer = info.container;
                this.endOffset    = info.offset;
            }

            Viper.IERange._prevRange.startContainer = this.startContainer;
            Viper.IERange._prevRange.endContainer   = this.endContainer;
            Viper.IERange._prevRange.startOffset    = this.startOffset;
            Viper.IERange._prevRange.endOffset      = this.endOffset;

        },

        // Range Select Modifiers.
        
        setStart: function(node, offset)
        {
            if (document.activeElement && ViperUtil.isTag(document.activeElement, 'input')) {
                document.activeElement.blur();
            }

            var moveTo = node;
            if (moveTo.nodeType === ViperUtil.TEXT_NODE) {
                moveTo = moveTo.parentNode;
            }

            var clone = this.rangeObj.duplicate();

            clone.moveToElementText(moveTo);
            clone.collapse(true);
            var charOffset = this._getCharOffsetWithinParent(node, offset);
            clone.move(Viper.DOMRange.CHARACTER_UNIT, charOffset);

            this.rangeObj.setEndPoint('StartToStart', clone);

            this.startContainer = node;
            this.startOffset    = offset;

            try {
                // Do a retarded invalid argument check. If parentNode is 'invalid argument' then execption will be thrown
                // meaning the node is no longer valid so set it to null.
                this.endContainer && this.endContainer.parentNode;
            } catch (e) {
                this.endContainer = null;
                this.endOffset = null;
            }

            if (this.endContainer === null && this.endOffset === null) {
                this.endContainer = node;
                this.endOffset    = offset;
            }

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        
        setEnd: function(node, offset)
        {
            if (document.activeElement && ViperUtil.isTag(document.activeElement, 'input')) {
                document.activeElement.blur();
            }

            var moveTo = node;
            if (moveTo.nodeType === ViperUtil.TEXT_NODE) {
                moveTo = moveTo.parentNode;
            }

            var clone = this.rangeObj.duplicate();
            clone.moveToElementText(moveTo);
            clone.collapse(true);

            var charOffset = this._getCharOffsetWithinParent(node, offset);
            clone.move(Viper.DOMRange.CHARACTER_UNIT, charOffset);

            this.rangeObj.setEndPoint('EndToEnd', clone);

            this.endContainer = node;
            this.endOffset    = offset;

            try {
                // Do a retarded invalid argument check. If parentNode is 'invalid argument' then execption will be thrown
                // meaning the node is no longer valid so set it to null.
                this.startContainer && this.startContainer.parentNode;
            } catch (e) {
                this.startContainer = null;
                this.startOffset = null;
            }

            if (this.startContainer === null && this.startOffset === null) {
                this.startContainer = node;
                this.startOffset    = offset;
            }

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        
        setStartBefore: function(node)
        {
            // Looks like Firefox setStartBefore() method sets the range to
            // the specified node and offset to 0. I can't see how this is
            // different from setStart(node, 0)...
            this.setStart(node, 0);

        },

        
        setStartAfter: function(node)
        {
            var next = this.getNextContainer(node);
            this.setStart(next, 0);
            
            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        setEndBefore: function(node)
        {
            var previous = this.getPreviousContainer(node);
            if (previous.nodeType === ViperUtil.TEXT_NODE) {
                this.setEnd(previous, previous.length);
            } else {
                var clone = this.rangeObj.duplicate();
                clone.moveToElementText(previous);
                clone.collapse(false);
                this.rangeObj.setEndPoint('EndToEnd', clone);

                this._setCollapsed();
                this._setCommonAncestorContainer();
            }

        },

        
        setEndAfter: function(node)
        {
            this.setEnd(node.parentNode, this.getNodeIndex(node) + 1);

        },

        
        selectNode: function(node)
        {
            if (node.nodeType === ViperUtil.TEXT_NODE) {
                this.setStart(node, 0);
                this.setEnd(node, node.length);
            } else {
                // Seems like moveToElementText does not select the node
                // if the node is empty.
                // So if it is empty then insert a single space.
                if (node.innerHTML && node.innerHTML.length === 0) {
                    node.innerText = ' ';
                }

                this.rangeObj.moveToElementText(node);

                this.endContainer   = node.parentNode;
                this.startContainer = node.parentNode;

                this.startOffset = this._findElementNodeOffset(node);
                this.endOffset   = this.startOffset + 1;

                this._setCollapsed();
                this._setCommonAncestorContainer();
            }//end if

        },

        _findElementNodeOffset: function(node)
        {
            if (node.nodeType !== ViperUtil.ELEMENT_NODE) {
                return;
            }

            var parent = node.parentNode;
            var l      = parent.childNodes.length;
            for (var i = 0; i < l; i++) {
                if (parent.childNodes[i] === node) {
                    return i;
                }
            }

            return -1;

        },

        
        selectNodeContents: function(node)
        {
            if (node.nodeType === ViperUtil.TEXT_NODE) {
                this.setStart(node, 0);
                this.setEnd(node, node.length);
            } else {
                this.rangeObj.moveToElementText(node);
                this.rangeObj.moveStart('character', 1);
                this.rangeObj.moveStart('character', -1);
                this.rangeObj.moveEnd('character', -1);
                this.rangeObj.moveEnd('character', 1);
            }

        },

        
        surroundContents: function(node)
        {
            var contents = this.extractContents();
            node.appendChild(contents);
            this.insertNode(node);

        },

        
        collapse: function(toStart)
        {
            this.rangeObj.collapse(toStart);
            this.collapsed = true;

            if (toStart) {
                this.endContainer = this.startContainer;
                this.endOffset    = this.startOffset;
            } else {
                this.startContainer = this.endContainer;
                this.startOffset    = this.endOffset;
            }

        },

        // Range Comparisons.
        
        compareBoundaryPoints: function(how, sourceRange)
        {
            return this.rangeObj.compareEndPoints(how, sourceRange.rangeObj);

        },

        // Extract Content.
        
        deleteContents: function()
        {
            if (this.startContainer === this.endContainer
                && this.startContainer.nodeType === ViperUtil.TEXT_NODE
            ) {
                // Do not use execCommand in this case. Because if the node is at the end
                // of a paragraph then the execCommand will join the next paragraph to
                // the current one..
                var before = this.startContainer.data.substring(0, this.startOffset);
                var after  = this.startContainer.data.substring(this.endOffset);
                this.startContainer.data = before + after;
                this.setStart(this.startContainer, this.startOffset);
                this.collapse(true);
            } else {
                this.rangeObj.execCommand('Delete');
                this._clearRangeCache();
                this._initContainerInfo();
            }

        },

        comparePoint: function(node, offset)
        {
            var clone = this.cloneRange();
            clone.setStart(node, offset);
            clone.collapse();

            return this.rangeObj.compareEndPoints('StartToStart', clone.rangeObj);

        },

        
        extractContents: function()
        {
            var fragment = Viper.document.createDocumentFragment();
            var div      = Viper.document.createElement('div');
            ViperUtil.setHtml(div, this.rangeObj.htmlText);
            // Add the children of the div to fragment.
            var c = div.childNodes.length;
            for (var i = 0; i < c; i++) {
                var child = ViperUtil.cloneNode(div.childNodes[i]);
                fragment.appendChild(child);
            }

            // Remove the contents.
            this.rangeObj.text = '';

            return fragment;

        },

        createDocumentFragment: function(str)
        {
            var fragment  = Viper.document.createDocumentFragment();
            var div       = Viper.document.createElement('div');
            div.innerHTML = str;

            // Add the children of the div to fragment.
            var c = div.childNodes.length;
            for (var i = 0; i < c; i++) {
                var child = ViperUtil.cloneNode(div.childNodes[i]);
                fragment.appendChild(child);
            }

            return fragment;

        },

        
        cloneContents: function()
        {
            var fragment = this.createDocumentFragment(this.rangeObj.htmlText);
            return fragment;

        },

        // Inserting.
        
        insertNode: function(node)
        {
            var before = null;
            if (this.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                if (this.startContainer.childNodes.length === this.startOffset) {
                    this.startContainer.appendChild(node);
                } else {
                    this.startContainer.insertBefore(node, this.startContainer.childNodes[this.startOffset]);
                    this.setStart(this.startContainer, this.startOffset + 1);
                }

                return;
            } else if (this.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                if (this.startOffset === 0) {
                    before = this.startContainer;
                } else {
                    var length = this.startContainer.data.length;
                    if (length > this.startOffset) {
                        before = this.startContainer.splitText(this.startOffset);
                    } else if (this.startContainer.nextSibling) {
                        before = this.startContainer.nextSibling;
                    } else {
                        // If there is no next sibling then should we insert it as
                        // the last child of the parent or find the next text container?
                        // before = this.getNextContainer(this.startContainer);.
                        this.startContainer.parentNode.appendChild(node);
                    }
                }
            }//end if

            if (before !== null) {
                ViperUtil.insertBefore(before, node);
            }

            this.setStart(node, 0);
            this.collapse(true);
            this._setCommonAncestorContainer();

        },

        // Misc.
        
        cloneRange: function()
        {
            var range = new Viper.IERange(this.rangeObj.duplicate());
            range.startContainer          = this.startContainer;
            range.startOffset             = this.startOffset;
            range.endContainer            = this.endContainer;
            range.endOffset               = this.endOffset;
            range.commonAncestorContainer = this.commonAncestorContainer;
            range.collapsed               = this.collapsed;

            return range;

        },

        
        detach: function()
        {
            this.rangeObj = null;
            this.commonAncestorContainer = null;

        },

        getStartNode: function()
        {
            if (!this.startContainer) {
                return null;
            }

            if (this.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                var node = this.startContainer.childNodes[this.startOffset];
                if (node) {
                    return node;
                }
            }

            return this.startContainer;

        },

        
        _setCollapsed: function()
        {
            if (this.startContainer === this.endContainer && this.startOffset === this.endOffset) {
                this.collapsed = true;
            } else {
                this.collapsed = false;
            }

        },

        
        _setCommonAncestorContainer: function()
        {
            if (this.startContainer === this.endContainer) {
                this.commonAncestorContainer = this.startContainer;
            } else {
                this.commonAncestorContainer = ViperUtil.getCommonAncestor(this.startContainer, this.endContainer);
            }

        },

        
        _getContainerInfo: function(textRange)
        {
            var element = textRange.parentElement();
            var range   = element.ownerDocument.body.createTextRange();
            range.moveToElementText(element);

            try {
                range.setEndPoint("EndToStart", textRange);
            } catch (e) {
            }

            var rangeLength = range.text.replace(/\r\n/g, '').length;
            var nodeLength  = 0;

            // Choose Direction.
            if (rangeLength < (element.innerText.length / 2)) {
                var direction = 1;
                var node      = element.firstChild;
            } else {
                direction = -1;
                node      = element.lastChild;
                range.moveToElementText(element);
                try {
                    range.setEndPoint("StartToStart", textRange);
                } catch (e) {
                }

                rangeLength = range.text.replace(/\r\n/g, '').length;
            }

            // Loop through child nodes.
            while (node) {
                switch (node.nodeType) {
                    case ViperUtil.TEXT_NODE:
                        nodeLength = node.data.length;
                        if (nodeLength < rangeLength) {
                            var difference = (rangeLength - nodeLength);
                            if (direction === 1) {
                                range.moveStart("character", difference);
                            } else {
                                range.moveEnd("character", -difference);
                            }

                            rangeLength = difference;
                        } else {
                            if (direction === 1) {
                                return {
                                    container: node,
                                    offset: rangeLength
                                };
                            } else {
                                return {
                                    container: node,
                                    offset: (nodeLength - rangeLength)
                                };
                            }
                        }//end if
                    break;

                    case ViperUtil.ELEMENT_NODE:
                        nodeLength = node.innerText.length;

                        if (direction === 1) {
                            range.moveStart("character", nodeLength);
                        } else {
                            range.moveEnd("character", -nodeLength);
                        }

                        rangeLength = (rangeLength - nodeLength);

                        if (rangeLength < 0) {
                            rangeLength = 0;
                        }
                    break;

                    default:
                        // Not supported.
                    break;
                }//end switch

                if (direction === 1) {
                    node = node.nextSibling;
                } else {
                    node = node.previousSibling;
                }
            }//end while

            // The TextRange was not found. Return a reasonable value instead.
            return {
                container: element,
                offset: 0
            };

        },

        getStartOffset: function(incSpaces)
        {
            return this.startOffset;

        },

        
        _getCharOffsetWithinParent: function(node, offset)
        {
            // NEW Version: 08-01-09 (Thanks to Mozile).
            var move    = null;
            var tmpNode = null;
            if (node.nodeType === ViperUtil.TEXT_NODE) {
                move    = offset;
                tmpNode = node.previousSibling;
            } else if (node.nodeType === ViperUtil.ELEMENT_NODE) {
                move = 0;
                if (offset > 0) {
                    tmpNode = node.childNodes[(offset - 1)];
                } else {
                    return 0;
                }
            }

            while (tmpNode) {
                var nodeLength = 0;
                if (tmpNode.nodeType === ViperUtil.ELEMENT_NODE) {
                    nodeLength = tmpNode.innerText.length;
                    if (ViperUtil.isStubElement(tmpNode) === true) {
                        if (ViperUtil.isBrowser('msie', '8') === true) {
                            nodeLength = 1;
                        } else {
                            nodeLength = 2;
                        }
                    } else if (ViperUtil.isBlockElement(tmpNode) === true) {
                        nodeLength++;
                    }
                } else if (tmpNode.nodeType === ViperUtil.TEXT_NODE) {
                    nodeLength = tmpNode.data.length;
                }

                move   += nodeLength;
                tmpNode = tmpNode.previousSibling;
            }

            return move;

        },


        
        moveStart: function(unitType, units, updateInfo)
        {
            switch (unitType) {
                case Viper.DOMRange.CHARACTER_UNIT:
                case Viper.DOMRange.WORD_UNIT:
                    this.rangeObj.moveStart(unitType, units);
                    var text = this.rangeObj.text;

                    // Remove char(13)char(10) (\r\n).
                    var match = text.match(/\r\n/g, '');
                    if (match !== null && match.length > 0) {
                        // Count all the new line characters.
                        var u = match.length;
                        if (units < 0) {
                            u = (u * -1);
                        }

                        this.rangeObj.moveStart(Viper.DOMRange.CHARACTER_UNIT, u);
                    }
                break;

                case Viper.DOMRange.LINE_UNIT:
                    this._moveLine(true, units);
                break;

                default:
                    throw Error('InvalidArgumentException: unitType "' + unitType + '" not valid.');
                break;
            }//end switch

            if (updateInfo !== false) {
                this._initContainerInfo();
            }

        },

        
        moveEnd: function(unitType, units)
        {
            switch (unitType) {
                case Viper.DOMRange.CHARACTER_UNIT:
                case Viper.DOMRange.WORD_UNIT:
                    this.rangeObj.moveEnd(unitType, units);
                    var text = this.rangeObj.text;
                    // Remove char(13)char(10) (\r\n).
                    var match = text.match(/\r\n/g, '');
                    if (match !== null && match.length > 0) {
                        // Count all the new line characters.
                        this.rangeObj.moveEnd(Viper.DOMRange.CHARACTER_UNIT, match.length);
                    }
                break;

                case Viper.DOMRange.LINE_UNIT:
                    this._moveLine(false, units);
                break;

                default:
                    throw Error('InvalidArgumentException: unitType "' + unitType + '" not valid.');
                break;
            }//end switch

            this._initContainerInfo();

        },

        
        _moveLine: function(moveStart, units)
        {
            // Clone the range and work with cloned range.
            var clone = this.cloneRange();

            // Collapse the range.
            clone.collapse(moveStart);

            var startCoords = clone.getRangeCoords(moveStart);
            var coords      = null;
            var prevXCoord  = 0;
            var passed      = false;
            var unitType    = Viper.DOMRange.WORD_UNIT;

            // Move 2 words at a time..
            units *= 2;

            if (units < 0) {
                // Move Up.
                while (true) {
                    clone.moveStart(unitType, units);
                    coords = clone.getRangeCoords(true);
                    if (passed === false) {
                        if (coords.y < startCoords.y && coords.x <= startCoords.x) {
                            // We have found the next line and passed the start X
                            // position. Now move BACK char by char to determine
                            // a good position.
                            passed   = true;
                            units    = 1;
                            unitType = Viper.DOMRange.CHARACTER_UNIT
                        }
                    } else if (coords.x >= startCoords.x) {
                        // Found the corrext X position, make little adjustment
                        // if needed.
                        if (Math.abs(coords.x - startCoords.x) > Math.abs(startCoords.x - prevXCoord)) {
                            clone.moveStart(Viper.DOMRange.CHARACTER_UNIT, -1);
                        }

                        break;
                    } else {
                        // Update the previous X position to deterime the best
                        // spot later on.
                        prevXCoord = coords.x;
                    }//end if
                }//end while
            } else {
                // Move Down.
                while (true) {
                    clone.moveStart(unitType, units);
                    coords = clone.getRangeCoords(true);
                    if (passed === false) {
                        if (coords.y > startCoords.y && coords.x >= startCoords.x) {
                            // We have found the next line and passed the start X
                            // position. Now move BACK char by char to determine
                            // a good position.
                            passed   = true;
                            units    = -1;
                            unitType = Viper.DOMRange.CHARACTER_UNIT
                        }
                    } else if (coords.x <= startCoords.x) {
                        // Found the corrext X position, make little adjustment
                        // if needed.
                        if (Math.abs(coords.x - startCoords.x) > Math.abs(startCoords.x - prevXCoord)) {
                            clone.moveStart(Viper.DOMRange.CHARACTER_UNIT, 1);
                        }

                        break;
                    } else {
                        // Update the previous X position to deterime the best
                        // spot later on.
                        prevXCoord = coords.x;
                    }//end if
                }//end while
            }//end if

            // Collapse to the start.
            clone.collapse(true);

            if (moveStart === true) {
                // Set the start of this range to the cloned range and update the
                // start container.
                this.rangeObj.setEndPoint(Viper.DOMRange.START_TO_START, clone.rangeObj);
                this.startContainer = clone.startContainer;
                this.startOffset    = clone.startOffset;
            } else {
                // Set the end of this range to the start of the cloned range and
                // update the end container.
                this.rangeObj.setEndPoint(Viper.DOMRange.END_TO_START, clone.rangeObj);
                this.endContainer = clone.endContainer;
                this.endOffset    = clone.endOffset;
            }

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        
        getCommonElement: function()
        {
            var parentEl = this.rangeObj.parentElement();

            var clone = this.rangeObj.duplicate();
            clone.collapse(true);

            var startParent = clone.parentElement();

            clone = this.rangeObj.duplicate();
            clone.collapse(false);
            var endParent = clone.parentElement();

            var container = startParent;
            if (startParent !== endParent) {
                container = ViperUtil.getCommonAncestor(startParent, endParent);
            }

            var common = container;
            if (container !== parentEl) {
                common = ViperUtil.getCommonAncestor(parentEl, container);
            }

            return common;

        },

        
        getRangeCoords: function(toStart)
        {
            var clone = this.cloneRange();
            clone.collapse(toStart);

            var normalize = true;
            if (clone.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                if (clone.startOffset === 0) {
                    normalize = false;
                } else if (clone.endOffset === clone.startContainer.data.length) {
                    normalize = false;
                }
            } else {
                normalize = false;
            }

            var shy = this.shy;
            clone.insertNode(shy);

            var previous = shy.previousSibling;
            var next     = shy.nextSibling;
            var c        = ViperUtil.$(shy).position();
            var coords   = {
                x: c.left,
                y: c.top
            };

            // This block of code is a fix for yet another stupid IE bug.
            // When a span tag wraps to next line then its offsetTop is reported
            // as its parent's offsetTop. So, if we are in the same block of text
            // and the height of the span changes then we adjust the Y coord.
            if (this.startContainer === this._prevContainer) {
                var height = ViperUtil.getElementHeight(shy);
                if (this._prevHeight === null) {
                    this._prevHeight = height;
                } else if (height !== this._prevHeight) {
                    coords.y = (coords.y + height - this._prevHeight);
                }
            } else {
                this._prevHeight    = null;
                this._prevContainer = this.startContainer;
            }

            // We're done with the shy.
            ViperUtil.remove(shy);

            // We need to restore the text back to the way it was.
            if (normalize && previous) {
                if (next && next.nodeType === ViperUtil.TEXT_NODE) {
                    if (next === this.endContainer) {
                        this.endContainer = previous;
                    }

                    ViperUtil.remove(next);
                    previous.data += next.data;
                }

                this.setEnd(this.endContainer, this.endOffset);
                this.setStart(this.startContainer, this.startOffset);
            }

            return coords;

        },



        
        getBoundingClientRect: function()
        {
            return this.rangeObj.getBoundingClientRect();

        },

        getHTMLContents: function()
        {
            return this.rangeObj.htmlText.replace(/\r\n/g, '');

        },

        getHTMLContentsObj: function()
        {
            var div = Viper.document.createElement('div');
            ViperUtil.setHtml(div, this.rangeObj.htmlText);
            return div;

        },

        
        toString: function()
        {
            var text = this.rangeObj.text;

            // Remove char(13)char(10) (\r\n).
            text = text.replace(/\r\n/g, '');
            return text;

        },

        _clearRangeCache: function()
        {
            Viper.IERange._prevRange = {
                range: null,
                startContainer: null,
                endContainer: null,
                startOffset: 0,
                endOffset: 0
            };

        }

    };
})(Viper.Util, Viper.Selection);


(function(ViperUtil, ViperSelection) {
    Viper.MozRange = function(rangeObj)
    {
        ViperUtil.inherits(Viper.MozRange, Viper.DOMRange);
        Viper.DOMRange.call(this, rangeObj);

        this.startContainer          = rangeObj.startContainer;
        this.startOffset             = rangeObj.startOffset;
        this.endContainer            = rangeObj.endContainer;
        this.endOffset               = rangeObj.endOffset;
        this.collapsed               = rangeObj.collapsed;
        this.commonAncestorContainer = rangeObj.commonAncestorContainer;

        this.posSpan = Viper.document.createElement('span');

        
        Viper.DOMRange.START_TO_START = Range.START_TO_START;

        
        Viper.DOMRange.START_TO_END = Range.END_TO_START;

        
        Viper.DOMRange.END_TO_END = Range.END_TO_END;

        
        Viper.DOMRange.END_TO_START = Range.START_TO_END;

    }

    Viper.MozRange.prototype = {

        
        setStart: function(node, offset)
        {
            this.rangeObj.setStart(node, offset);

            this.startContainer = node;
            this.startOffset    = offset;

            if (this.endContainer === null) {
                this.endContainer = node;
                this.endOffset    = offset;
            }

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        
        setEnd: function(node, offset)
        {
            this.rangeObj.setEnd(node, offset);
            this.endContainer = node;
            this.endOffset    = offset;

            if (this.startContainer === null) {
                this.startContainer = node;
                this.startOffset    = offset;
            }

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        
        setStartBefore: function(node)
        {
            this.rangeObj.setStartBefore(node);
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;
            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        setStartAfter: function(node)
        {
            this.rangeObj.setStartAfter(node);
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;
            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        setEndBefore: function(node)
        {
            this.rangeObj.setEndBefore(node);
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;
            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        setEndAfter: function(node)
        {
            this.rangeObj.setEndAfter(node);
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;
            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        selectNode: function(node)
        {
            this.rangeObj.selectNode(node);

            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        selectNodeContents: function(node)
        {
            this.rangeObj.selectNodeContents(node);
            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        surroundContents: function(node)
        {
            this.rangeObj.surroundContents(node);

            this.startContainer = this.rangeObj.startContainer;
            this.startOffset    = this.rangeObj.startOffset;
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endtOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        
        collapse: function(toStart)
        {
            this.rangeObj.collapse(toStart);
            this.collapsed = true;

            if (toStart) {
                this.endContainer = this.startContainer;
                this.endOffset    = this.startOffset;
            } else {
                this.startContainer = this.endContainer;
                this.startOffset    = this.endOffset;
            }

        },

        // Range Comparisons.
        
        compareBoundaryPoints: function(how, sourceRange)
        {
            return this.rangeObj.compareBoundaryPoints(how, sourceRange.rangeObj);

        },

        // Extract Content.
        
        deleteContents: function(viperElem, defaultTagName)
        {
            var startContainer = this.startContainer;
            var startOffset    = this.startOffset;

            if (!startContainer) {
                startContainer = this.rangeObj.startContainer;
            }

            if (startContainer === this.endContainer
                && startContainer.nodeType === ViperUtil.TEXT_NODE
            ) {
                // IE11 fix. IE to removes the node from DOM when the entire contents of a textnode is deleted.
                // This fix works for the other browsers as well.
                var before = this.startContainer.data.substring(0, this.startOffset);
                var after  = this.startContainer.data.substring(this.endOffset);
                this.startContainer.data = before + after;
            } else if (startContainer === this.endContainer
                && startOffset === this.endOffset
                && ViperUtil.isBrowser('msie', '11') === true
            ) {
                // Move caret.
                this.moveCaretAway(startContainer, viperElem, defaultTagName)
                ViperUtil.remove(startContainer);
                return;
            } else {
                this.rangeObj.deleteContents();
            }

            // Because we rely on normalisation when we get call getRangeCoords()
            // we have to explicitly set the start container and offset, as using
            // then from the rangeObj will reference an element and childNode offset.
            // Normalise.
            if (startContainer.nodeType === ViperUtil.TEXT_NODE) {
                var nextSibling = startContainer.nextSibling;
                while (nextSibling) {
                    if (nextSibling && nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                        startContainer.data += nextSibling.data;
                        ViperUtil.remove(nextSibling);
                        nextSibling = startContainer.nextSibling;
                    } else {
                        break;
                    }
                }
            }

            if (viperElem && ViperUtil.isBrowser('msie', '11') === true) {
                var parent = startContainer.parentNode;
                var intree = false;
                while (parent) {
                    if (parent === viperElem) {
                        intree = true;
                        break;
                    }

                    parent = parent.parentNode;
                }

                if (!parent) {
                    var start  = null;
                    var offset = 0;
                    if (this.rangeObj.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                        start  = this.rangeObj.startContainer.childNodes[this.rangeObj.startOffset];
                        if (start.nodeType === ViperUtil.ELEMENT_NODE) {
                            var firstChild = this._getFirstSelectableChild(start);
                            if (!firstChild) {
                                if (!start.firstChild) {
                                    ViperUtil.setHtml(start, '<br />');
                                } else {
                                    ViperUtil.insertBefore(start, document.createElement('br'))
                                }

                                start = start.firstChild;
                            } else {
                                start = firstChild;
                            }
                        }
                    } else {
                        start = this.rangeObj.startContainer;
                    }

                    this.setStart(start, offset);
                    this.collapse(true);
                    this._setCommonAncestorContainer();
                    return;
                }
            }

            this.setStart(startContainer, startOffset);
            this.collapse(true);

            this._setCommonAncestorContainer();

        },

        
        extractContents: function()
        {
            return this.rangeObj.extractContents();

        },

        createDocumentFragment: function(str)
        {
            var fragment = null;
            if (!this.rangeObj.createContextualFragment) {
                var fragment  = document.createDocumentFragment();
                var div       = document.createElement('div');
                div.innerHTML = str;

                // Add the children of the div to fragment.
                var c = div.childNodes.length;
                for (var i = 0; i < c; i++) {
                    var child = div.childNodes[i].cloneNode(true);
                    fragment.appendChild(child);
                }
            } else {
                fragment = this.rangeObj.createContextualFragment(str);
            }

            return fragment;

        },

        
        cloneContents: function()
        {
            return this.rangeObj.cloneContents();

        },

        // Inserting.
        
        insertNode: function(node)
        {
            if (this.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                if (ViperUtil.isStubElement(this.startContainer) === true) {
                    // HIERARCHY_REQUEST_ERR: Raised if the container of the start
                    // of the Range is of a type that does not allow children of the
                    // type of node.
                    throw Error('HIERARCHY_REQUEST_ERR');
                }
            }

            this.rangeObj.insertNode(node);

            if (node.previousSibling && node.previousSibling.nodeType === ViperUtil.TEXT_NODE) {
                if (node.previousSibling.data === '') {
                    ViperUtil.remove(node.previousSibling);
                }
            }

            if (node.nextSibling && node.nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                if (node.nextSibling.data === '') {
                    ViperUtil.remove(node.nextSibling);
                }
            }

            this.startContainer = this.rangeObj.startContaier;
            this.startOffset    = this.rangeObj.startOffset;
            this.endContainer   = this.rangeObj.endContainer;
            this.endOffset      = this.rangeObj.endOffset;

            this._setCollapsed();
            this._setCommonAncestorContainer();

        },

        // Misc.
        
        cloneRange: function()
        {
            var clone = this.rangeObj.cloneRange();
            return new Viper.MozRange(clone);

        },

        
        toString: function()
        {
            return this.rangeObj.toString();

        },

        
        detach: function()
        {
            this.rangeObj.detach();

        },

        comparePoint: function(node, offset)
        {
            return this.rangeObj.comparePoint(node, offset);

        },


        // Private helper methods for W3CRange Standard.
        _setCommonAncestorContainer: function()
        {
            this.commonAncestorContainer = this.rangeObj.commonAncestorContainer;

        },

        _setCollapsed: function()
        {
            if (this.startContainer === this.endContainer
                && this.startOffset === this.endOffset
            ) {
                this.collapsed = true;
            } else {
                this.collapsed = false;
            }

        },

        // Extensions to the W3CRange standard.
        getCommonElement: function()
        {
            if (this.commonAncestorContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                return this.commonAncestorContainer;
            }

            return this.commonAncestorContainer.parentNode;

        },

        
        getRangeCoords: function(toStart)
        {
            var clone = this.rangeObj.cloneRange();
            clone.collapse(toStart);

            var normalize = true;
            if (clone.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                if (clone.startOffset === 0) {
                    if (clone.startContainer.previousSibling && clone.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE) {
                        normalize = false;
                    }
                }
            } else {
                normalize = false;
            }

            var posSpan = this.posSpan;
            clone.insertNode(posSpan);

            var previous = posSpan.previousSibling;
            var next     = posSpan.nextSibling;
            var c        = ViperUtil.$(posSpan).position();
            var coords   = {
                x: c.left,
                y: c.top
            };

            // We're done with the posSpan.
            ViperUtil.remove(posSpan);

            // We need to restore the text back to the way it was.
            if (normalize) {
                previous.data += next.data;
                ViperUtil.remove(next);

                this.setEnd(this.endContainer, this.endOffset);
                this.setStart(this.startContainer, this.startOffset);
            }

            return coords;

        },

        moveStart: function(unitType, units)
        {
            if (units === 0) {
                throw Error('InvalidArgumentException: units cannot be 0');
            }

            switch (unitType) {
                case Viper.DOMRange.CHARACTER_UNIT:
                    if (units > 0) {
                        this._moveCharRight(true, units);
                    } else {
                        this._moveCharLeft(true, units);
                    }
                break;

                case Viper.DOMRange.LINE_UNIT:
                    if (units > 0) {
                        this._moveLineDown(true);
                    } else {
                        this._moveLineUp(true);
                    }
                break;

                case Viper.DOMRange.WORD_UNIT:
                default:
                    // Do nothing.
                break;
            }//end switch

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        moveEnd: function(unitType, units)
        {
            if (units === 0) {
                throw Error('InvalidArgumentException: units cannot be 0');
            }

            switch (unitType) {
                case Viper.DOMRange.CHARACTER_UNIT:
                    if (units > 0) {
                        this._moveCharRight(false, units);
                    } else {
                        this._moveCharLeft(false, units);
                    }
                break;

                case Viper.DOMRange.LINE_UNIT:
                    if (units > 0) {
                        this._moveLineDown(false);
                    } else {
                        this._moveLineUp(false);
                    }
                break;

                case Viper.DOMRange.WORD_UNIT:
                default:
                    // Do nothing.
                break;
            }//end switch

            this._setCommonAncestorContainer();
            this._setCollapsed();

        },

        _setRange: function(start, container, offset)
        {
            if (start) {
                this.setStart(container, offset);
            } else {
                this.setEnd(container, offset);
            }

        },

        _moveCharLeft: function(moveStart, units)
        {
            var container, offset;

            if (moveStart) {
                container = this.startContainer;
                offset    = this.startOffset;
            } else {
                container = this.endContainer;
                offset    = this.endOffset;
            }

            offset += units;

            if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                if (container.hasChildNodes()) {
                    // If the start or end container is an element then we are referencing
                    // a node within the element. So we want to force the selection of
                    // the last char in the previous container, so set offset to 0.
                    container = container.childNodes[offset];
                    offset    = 0;
                }
            }

            if (offset < 0) {
                // We need to move to a previous selectable container.
                while (offset < 0) {
                    var skippedBlockElem = [];
                    container = this.getPreviousContainer(container, skippedBlockElem);
                    if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                        continue;
                    }

                    offset = container.data.length;

                    // If the new container is inside a non-block element then we
                    // need to position the caret before the last character.
                    // E.g. <strong>Tes|t</strong>*ing, where * is the original pos
                    // and | is after moving to left. This is not the case for block
                    // elements (e.g. P tag), caret needs to be positioned after the
                    // last char.
                    if (container.nodeType === ViperUtil.TEXT_NODE
                        && skippedBlockElem.length === 0
                    ) {
                        offset--;
                    }
                }//end while
            }//end if

            this._setRange(moveStart, container, offset);

        },

        
        getStartOffset: function(incSpaces)
        {
            if (incSpaces === true) {
                return this.startOffset;
            }

            var spaces    = 0;
            var container = this.startContainer;
            var cc        = container.data.charCodeAt(0);
            while (cc === 10 || cc === 32) {
                spaces++;
                cc = container.data.charCodeAt(spaces);
            }

            var offset = (this.startOffset - spaces);

            return offset;

        },

        _getNextTextNode: function(container)
        {
            if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                if (container.childNodes.length !== 0) {
                    return this._getFirstSelectableChild(container);
                }
            }

            container = this.getNextContainer(container);
            if (container.nodeType === ViperUtil.TEXT_NODE) {
                return container;
            }

            return this._getNextTextNode(container);

        },

        _moveCharRight: function(moveStart, units)
        {
            var container, offset;

            if (moveStart) {
                container = this.startContainer;
                offset    = this.startOffset;
            } else {
                container = this.endContainer;
                offset    = this.endOffset;
            }

            if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                container = container.childNodes[offset];
                if (container.nodeType !== ViperUtil.TEXT_NODE) {
                    container = this._getNextTextNode(container);
                }

                offset = units;
            } else {
                offset += units;
            }

            var diff = (offset - container.data.length);
            if (diff > 0) {
                var skippedBlockElem = [];
                // We need to move to the next selectable container.
                while (diff > 0) {
                    container = this.getNextContainer(container, skippedBlockElem);
                    if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                        continue;
                    }

                    if (container.data.length >= diff) {
                        // We found a container with enough content to select.
                        break;
                    } else if (container.data.length > 0) {
                        // Container does not have enough content,
                        // find the next one.
                        diff -= container.data.length;
                    }
                }

                offset = 0;

                // If the new container is inside a non-block element then we
                // need to position the caret before the last character.
                // E.g. <strong>Tes|t</strong>*ing, where * is the original pos
                // and | is after moving to left. This is not the case for block
                // elements (e.g. P tag), caret needs to be positioned after the
                // last char.
                if (container.nodeType === ViperUtil.TEXT_NODE
                    && skippedBlockElem.length === 0
                ) {
                    offset++;
                }
            }//end if

            this._setRange(moveStart, container, offset);

        },

        _filterWords: function(words)
        {
            var wc     = words.length;
            var fwords = [];
            for (var i = 0; i < wc; i++) {
                if (words[i].length > 0) {
                    fwords.push(words[i]);
                }
            }

            return fwords;

        },

        _moveLineUp: function(moveStart)
        {
            var container = null;
            var offset    = null;
            if (moveStart) {
                container = this.startContainer;
                offset    = this.startOffset;
            } else {
                container = this.endContainer;
                offset    = this.endOffset;
            }

            if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                container = this.getPreviousContainer(container);
            }

            var words       = container.data.substr(offset).split(/\s+/);
            var startCoords = this.getRangeCoords(moveStart);
            var coords      = null;
            var prevXCoord  = 0;
            var nextLine    = 0;
            var wordLen     = 0;
            var prevYCoord  = 0;
            var prevCont    = null;
            var prevOffset  = 0;

            while (true) {
                prevOffset = offset;
                prevCont   = container;
                if (nextLine === 0 && words.length > 0) {
                    // Before we hit the next line we can jump to the end of
                    // each word instead of going char by char.
                    offset -= words.pop().length;
                } else {
                    offset--;
                }

                if (offset <= 0) {
                    // We will need to look at the previous container.
                    var found = false;
                    // Found the next non empty container.
                    while (found === false) {
                        container = this.getPreviousContainer(container);
                        if (container !== null && container.nodeType === ViperUtil.TEXT_NODE && container.data.length !== 0) {
                            found = true;
                        }
                    }

                    offset = container.data.length;
                }

                if (moveStart) {
                    this.setStart(container, offset);
                } else {
                    this.setEnd(container, offset);
                }

                coords = this.getRangeCoords(moveStart);

                if (startCoords.y !== coords.y) {
                    if (prevYCoord !== coords.y) {
                        prevYCoord = coords.y;
                        nextLine++;
                        if (nextLine > 1) {
                            if (prevCont !== container) {
                                // If previous container is different then move
                                // to the end of it.
                                prevOffset = prevCont.data.length;
                            }

                            // Go back to the last offset.
                            if (moveStart) {
                                this.setStart(prevCont, prevOffset);
                            } else {
                                this.setEnd(prevCont, prevOffset);
                            }

                            break;
                        }
                    }

                    if (coords.x <= startCoords.x) {
                        // Found the position now do a little adjustment if required.
                        if (offset < container.data.length && Math.abs(coords.x - startCoords.x) > Math.abs(prevXCoord - startCoords.x)) {
                            // Go back one offset.
                            offset++;
                            if (moveStart) {
                                this.setStart(container, offset);
                            } else {
                                this.setEnd(container, offset);
                            }
                        }

                        break;
                    } else {
                        prevXCoord = coords.x;
                    }
                }//end if
            }//end while

        },

        _moveLineDown: function(moveStart)
        {
            var container = null;
            var offset    = null;
            if (moveStart) {
                container = this.startContainer;
                offset    = this.startOffset;
            } else {
                container = this.endContainer;
                offset    = this.endOffset;
            }

            if (container.nodeType === ViperUtil.ELEMENT_NODE) {
                container = this.getNextContainer(container);
            }

            var words       = container.data.substr(offset).split(/\s+/);
            var startCoords = this.getRangeCoords(moveStart);
            var coords      = null;
            var prevXCoord  = 0;
            var nextLine    = 0;
            var wordLen     = 0;
            var prevYCoord  = 0;
            var prevCont    = null;
            var prevOffset  = 0;
            while (true) {
                prevOffset = offset;
                prevCont   = container;
                if (nextLine === 0 && words.length > 0) {
                    // Before we hit the next line we can jump to the end of
                    // each word instead of going char by char.
                    offset += words.shift().length;
                } else {
                    offset++;
                }

                if (offset >= container.data.length) {
                    // We will need to look at the next container.
                    var found = false;
                    // Found the next non empty container.
                    while (found === false) {
                        container = this.getNextContainer(container);
                        if (container.data.length !== 0) {
                            found = true;
                        }
                    }

                    offset = 0;
                }

                if (moveStart) {
                    this.setStart(container, offset);
                } else {
                    this.setEnd(container, offset);
                }

                coords = this.getRangeCoords(moveStart);

                if (startCoords.y !== coords.y) {
                    if (prevYCoord !== coords.y) {
                        prevYCoord = coords.y;
                        nextLine++;
                        if (nextLine > 1) {
                            if (prevCont !== container) {
                                // If previous container is different then move
                                // to the end of it.
                                prevOffset = prevCont.data.length;
                            }

                            // Go back to the last offset.
                            if (moveStart) {
                                this.setStart(prevCont, prevOffset);
                            } else {
                                this.setEnd(prevCont, prevOffset);
                            }

                            break;
                        }
                    }

                    if (coords.x >= startCoords.x) {
                        // Found the position now do a little adjustment
                        // if required.
                        if (offset > 1 && Math.abs(coords.x - startCoords.x) > Math.abs(prevXCoord - startCoords.x)) {
                            // Go back one offset.
                            offset--;
                            if (moveStart) {
                                this.setStart(container, offset);
                            } else {
                                this.setEnd(container, offset);
                            }
                        }

                        break;
                    } else {
                        prevXCoord = coords.x;
                    }
                }//end if
            }//end while

        },

        getHTMLContents: function(clonedSelection)
        {
            if (this.startContainer === this.endContainer
                && this.startOffset === 0
                && this.endOffset === 0
                && this.startContainer.nodeType !== ViperUtil.TEXT_NODE
                && this.collapsed === true
                && ViperUtil.isBrowser('msie', '11') === true
                && ViperUtil.isStubElement(this.startContainer) === false
            ) {
                var clone = this.rangeObj.cloneRange();
                var firstSel = this._getFirstSelectableChild(clone.startContainer);
                var lastSel  = this._getLastSelectableChild(clone.startContainer);
                if (firstSel && lastSel) {
                    clone.setStart(firstSel, 0);
                    clone.setEnd(lastSel, lastSel.data.length);
                    clonedSelection = clone.cloneContents();
                }

            } else if (!clonedSelection) {
                clonedSelection = this.rangeObj.cloneContents();
            }

            var div = Viper.document.createElement('div');
            div.appendChild(clonedSelection.cloneNode(true));
            return div.innerHTML;

        },

        getHTMLContentsObj: function()
        {
            return this.rangeObj.cloneContents();

        }
    };

})(Viper.Util, Viper.Selection);


(function(ViperUtil, ViperSelection) {
    var _plugins = {};

    Viper.PluginManager = function(viper)
    {
        this.viper           = viper;
        this._plugins        = null;
        this._pluginSettings = {};
        this._pluginSets     = {};

    }

    
    Viper.PluginManager.addPlugin = function(pluginName, pluginObj, inherits)
    {
        // Add the plugin information to private var that is shared by multiple Viper instances.
        // Inheritance of plugins are done when PluginManager is initialised.
        _plugins[pluginName] = {
            obj: pluginObj,
            inherits: inherits
        };

    };

    Viper.PluginManager.getClass = function(pluginName)
    {
        return _plugins[pluginName].obj;

    };

    Viper.PluginManager.prototype = {

        getPluginNames: function()
        {
            var plugins = [];
            for (var name in this._plugins) {
                plugins.push(name);
            }

            return plugins;

        },

        setPlugins: function(plugins, pluginSetName)
        {
            if (this._plugins) {
                for (var plugin in this._plugins) {
                    this.removePlugin(plugin);
                }
            }

            if (!pluginSetName) {
                pluginSetName = '*';
            }

            this._pluginSets[pluginSetName] = plugins;
            this._pluginSettings = {};
            this._plugins        = {};

            var c = plugins.length;
            for (var i = 0; i < c; i++) {
                var pluginName     = '';
                var pluginSettings = null;
                if (typeof plugins[i] === 'object') {
                    pluginName     = plugins[i].name;
                    pluginSettings = plugins[i].settings;
                } else {
                    pluginName = plugins[i];
                }

                this._usePlugin(pluginName, pluginSettings, true);
            }//end for

            // Call the start method of the plugins.
            for (var pluginName in this._plugins) {
                if (this._plugins[pluginName].init) {
                    this._plugins[pluginName].init();
                }
            }

        },

        createPluginSet: function(pluginSetName, plugins)
        {
            this._pluginSets[pluginSetName] = plugins;

        },

        usePluginSet: function(pluginSetName)
        {
            if (!this._pluginSets[pluginSetName]) {
                console.error('Invalid plugin set: ' + pluginSetName);
                return;
            }

            this.setPlugins(this._pluginSets[pluginSetName], pluginSetName);

        },

        usePlugin: function(pluginName, settings)
        {
            this._usePlugin(pluginName, settings);

        },

        _usePlugin: function(pluginName, settings, batch)
        {
            if (!_plugins[pluginName]) {
                return;
            }

            // If this is the first time the plugin is being initialised apply inheritance if needed.
            if (_plugins[pluginName].inherits && _plugins[pluginName].inherited !== true) {
                ViperUtil.inherits(_plugins[pluginName].obj, _plugins[_plugins[pluginName].inherits].obj);
                _plugins[pluginName].inherited = true;
            }

            var plugin = new _plugins[pluginName].obj(this.viper);
            this._plugins[pluginName] = plugin;

            // Set plugin settings.
            if (ViperUtil.isset(settings) === true) {
                pluginObj.setSettings(settings);
            } else if (this._pluginSettings[pluginName]) {
                pluginObj.setSettings(this._pluginSettings[pluginName]);
            }

            if (batch !== true) {
                pluginObj.init();
            }

        },

        
        removePlugin: function(pluginName)
        {
            if (this._plugins[pluginName]) {

                // Call the remove fn of the plugin incase it needs to do cleanup.
                if (ViperUtil.isFn(this._plugins[pluginName].remove) === true) {
                    this._plugins[pluginName].remove();
                }

                // Remove registered callbacks.
                this.viper.removeCallback(null, pluginName);

                this.viper.fireCallbacks('PluginManager:pluginRemoved', pluginName);

                delete this._plugins[pluginName];
            }

        },

        
        removePlugins: function(pluginNames)
        {
            if (!pluginNames) {
                for (var pluginName in this._plugins) {
                    this.removePlugin(pluginName);
                }
            } else {
                var c = pluginNames.length;
                for (var i = 0; i < c; i++) {
                    this.removePlugin(pluginNames[i]);
                }
            }

        },

        
        getPlugin: function(name)
        {
            return this._plugins[name];

        },

        getPluginObject: function(name)
        {
            return _plugins[name].obj;

        },

        getPlugins: function()
        {
            return this._plugins;

        },

        setPluginSettings: function(pluginName, settings)
        {
            if (this._plugins[pluginName]) {
                this._plugins[pluginName].setSettings(settings);
            }

            this._pluginSettings[pluginName] = settings;

        },

        disablePlugin: function(name)
        {
            if (this._plugins[name].disable) {
                this._plugins[name].disable();
            }

        },

        getPluginForElement: function(element)
        {
            for (var i in this._plugins) {
                if (this._plugins[i].isPluginElement) {
                    if (this._plugins[i].isPluginElement(element) === true) {
                        return i;
                    }
                }
            }

            return false;

        },

        isSpecialElement: function(element)
        {
            for (var i in this._plugins) {
                if (this._plugins[i].isSpecialElement) {
                    if (this._plugins[i].isSpecialElement(element) === true) {
                        return true;
                    }
                }
            }

            return false;

        },

    };

})(Viper.Util, Viper.Selection);



(function(ViperUtil, ViperSelection) {
    Viper.HistoryManager = function(viper)
    {
        this.viper = viper;

        this.undoHistory    = [];
        this.redoHistory    = [];
        this.batchCount     = 0;
        this.batchTask      = null;
        this.historyStore   = {};
        this._activeElement = null;
        this.historyLimit   = 30;
        this._ignoreAdd     = false;
        this._maxChars      = 50;
        this._charCount     = 0;
        this._lastAction    = null;

    }

    Viper.HistoryManager.prototype = {

        
        add: function(source, action)
        {
            if (this._ignoreAdd === true) {
                return;
            }

            // If a sub element is active then do not add this change.
            if (this.viper._subElementActive === true) {
                return;
            }

            try {
                var range = this.viper.getCurrentRange();
                if (this.viper.rangeInViperBounds(range) === false) {
                    // Set the range to be the first selectable element of Viper element.
                    var child = range._getFirstSelectableChild(this.viper.getViperElement());
                    if (!child) {
                        range = null;
                    } else {
                        try {
                            range.setStart(child, 0);
                            range.collapse(true);
                        } catch (e) {
                            range = null;
                        }
                    }
                }
            } catch (e) {
                range = null;
            }

            if (!range) {
                var task  = {
                    content: this.viper.getRawHTML(),
                    range: null
                };
            } else {
                var startContainer = range.startContainer;
                if (startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && startContainer.childNodes[range.startOffset]
                    && startContainer.childNodes[range.startOffset].nodeType === ViperUtil.ELEMENT_NODE
                    && range.collapsed === true
                ) {
                    // When Viper is initialised and the element is empty the range might be set as the
                    // First block element, if it has child text node use that instead.
                    var child = range._getFirstSelectableChild(startContainer.childNodes[range.startOffset]);
                    if (child) {
                        range.setStart(child, 0);
                        range.collapse(true);
                    }
                }

                var task  = {
                    content: this.viper.getRawHTML(),
                    range: {
                        startContainer: ViperUtil.getXPath(range.startContainer),
                        endContainer: ViperUtil.getXPath(range.endContainer),
                        startOffset: range.startOffset,
                        endOffset: range.endOffset,
                        collapsed: range.collapsed
                    }
                };
            }

            var modify = false;
            if (action === 'text_change' && this._lastAction === action) {
                if (this._charCount < this._maxChars) {
                    modify = true;
                } else {
                    this._charCount = 0;
                }

                this._charCount++;
            } else {
                this._charCount = 0;
            }

            this._lastAction = action;

            // If batching is active then do not add the task to undoHistory.
            if (this.batchTask === null) {
                if (modify === true) {
                    this.undoHistory[(this.undoHistory.length - 1)] = task;
                } else {
                    this.undoHistory.push(task);
                    if (this.undoHistory.length > this.historyLimit) {
                        this.undoHistory.shift();
                    }
                }

                // Reset the redo history.
                this.redoHistory = [];
            } else {
                this.batchTask = task;
            }

            this.viper.fireCallbacks('ViperHistoryManager:add');

        },

        
        undo: function()
        {
            if (this.viper._subElementActive === true) {
                return;
            }

            var undoLength = this.undoHistory.length;
            if (undoLength <= 1) {
                return;
            }

            this.viper.fireCallbacks('ViperHistoryManager:beforeUndo');

            // Get the current state of the content and add it to redo list.
            var range        = this.viper.getCurrentRange();

            var startPath = null;
            var endPath   = null;

            try {
                startPath = ViperUtil.getXPath(range.startContainer);
                endPath   = ViperUtil.getXPath(range.endContainer);
            } catch(e) {}

            var currentState = {
                content: this.viper.getRawHTML(),
                range: {
                    startContainer: startPath,
                    endContainer: endPath,
                    startOffset: range.startOffset,
                    endOffset: range.endOffset,
                    collapsed: range.collapsed
                }
            };

            // Add this undo to redo.
            this.redoHistory.push(currentState);

            this.undoHistory.pop();

            if (this.undoHistory.length > 0) {
                task = this.undoHistory[(this.undoHistory.length - 1)];
            }

            // Set the contents.
            this.viper.setRawHTML(task.content);

            this._selectTaskRange(task);
            this.viper.highlightToSelection();

            // Fire nodesChanged event.
            this._ignoreAdd = true;
            this.viper.resetViperRange(null);
            this.viper.fireNodesChanged([this.viper.getViperElement()]);
            this.viper.fireCallbacks('ViperHistoryManager:undo');
            this.viper.fireSelectionChanged();
            this._ignoreAdd  = false;
            this._lastAction = null;

        },

        redo: function()
        {
            if (this.viper._subElementActive === true) {
                return;
            }

            if (this.redoHistory.length === 0) {
                return;
            }

            var task = this.redoHistory.pop();

            // Add this redo to undo.
            this.undoHistory.push(task);

            // Set the contents.
            this.viper.setRawHTML(task.content);

            this._selectTaskRange(task);

            this.viper.highlightToSelection();

            // Fire nodesChanged event.
            this._ignoreAdd = true;
            this.viper.resetViperRange(null);
            this.viper.fireNodesChanged([this.viper.getViperElement()]);
            this.viper.fireCallbacks('ViperHistoryManager:redo');
            this.viper.fireSelectionChanged();
            this._ignoreAdd  = false;
            this._lastAction = null;

            return this.redoHistory.length;

        },

        
        clear: function()
        {
            this.undoHistory = [];
            this.redoHistory = [];
            this.batchCount  = 0;
            this.batchTask   = null;
            this._ignoreAdd  = false;
            this._lastAction = null;
            this._charCount  = 0;

            this.viper.fireCallbacks('ViperHistoryManager:clear');

        },

        setActiveElement: function(elem)
        {
            if (this._activeElement) {
                if (this.historyStore[this._activeElement] && this.historyStore[this._activeElement].element !== elem) {
                    // There is an active history alrady, save it.
                    this._saveHistory(this._activeElement);
                }
            }

            var self   = this;
            var loaded = false;
            ViperUtil.foreach(this.historyStore, function(key) {
                if (self.historyStore[key].element === elem) {
                    self._loadHistory(key);
                    loaded = true;
                    return false;
                }
            });

            if (loaded === false) {
                // Need to add a new historyStore.
                var key = ViperUtil.getUniqueId();
                this.historyStore[key] = {
                    undo: [],
                    redo: [],
                    element: elem
                };

                this._loadHistory(key);

                // Add the initial content.
                this.add();
            }

        },

        _selectTaskRange: function(task)
        {
            if (!task || !task.range) {
                return;
            }

            // Select.
            try {
                var startContainer = ViperUtil.getNodeFromXPath(task.range.startContainer);
                var endContainer   = ViperUtil.getNodeFromXPath(task.range.endContainer);
                var range = this.viper.getCurrentRange();
                range.setEnd(endContainer, task.range.endOffset);
                range.setStart(startContainer, task.range.startOffset);
                range.setEnd(endContainer, task.range.endOffset);

                if (task.range.collapsed === true) {
                    range.collapse(true);
                }

                ViperSelection.addRange(range);
            } catch (e) {}

        },

        _loadHistory: function(key)
        {
            if (this.historyStore[key]) {
                this._activeElement   = key;
                this.undoHistory      = this.historyStore[key].undo;
                this.redoHistory      = this.historyStore[key].redo;
                this.batchTask            = null;
                this.batchCount       = 0;
            }

        },

        _saveHistory: function(key)
        {
            if (this.historyStore[key]) {
                this.historyStore[key].undo = this.undoHistory;
                this.historyStore[key].redo = this.redoHistory;
            }

        },

        
        begin: function()
        {
            this.batchCount++;
            if (this.batchTask === null) {
                 // Set batch to true so that add() will add the task to this.batch.
                this.batchTask = true;
            }

        },

        
        end: function()
        {
            this.batchCount--;
            if (this.batchCount === 0 && this.batchTask !== null) {
                this.batchTask = null;
                if (this.batchTask !== true) {
                    this.add();
                }
            }

        },

        getUndoCount: function()
        {
            return this.undoHistory.length;

        },

        getRedoCount: function()
        {
            return this.redoHistory.length;

        }

    };

})(Viper.Util, Viper.Selection);

(function(ViperUtil, ViperSelection) {
    Viper.KeyboardHandler = function(viper)
    {
        this._viper           = viper;
        this._preventKeyPress = false;

        // When enter key is pressed at the end of these tags, the plugin will handle the
        // enter event instead of the browser.
        this._tagList = ('p|div|h1|h2|h3|h4|h5|h6|blockquote|section|main|article|aside').split('|');

        // These elements are not to be removed when whole of their content is selected and deleted.
        this._keepContainerList = ('td|th').split('|');

        // Make sure Viper fires the keyDown event for ENTER.
        this._viper.addSpecialKey(13);
    }

    Viper.KeyboardHandler.prototype = {
        init: function() {
            var self            = this;
            var elem            = this._viper.getViperElement();
            var namespace       = this._viper.getEventNamespace();
            var isKeyboardEvent = false;

            // Add key events. Note that there is a known issue with IME keyboard events
            // see https://bugzilla.mozilla.org/show_bug.cgi?id=354358. This effects
            // change tracking while using Korean, Chinese etc.
            ViperUtil.addEvent(elem, 'keypress.' + namespace, function(e) {
                isKeyboardEvent = true;
                return self.keyPress(e);
            });

            ViperUtil.addEvent(elem, 'keydown.' + namespace, function(e) {
                isKeyboardEvent = true;
                return self.keyDown(e);
            });

            // This keydown event will make sure that any selection started outside of Viper element and ended inside
            // Viper element is not going to trigger browser's 'back button'.
            ViperUtil.addEvent(Viper.document, 'keydown.' + namespace, function(e) {
                isKeyboardEvent = true;
                if (e.which === 8 || e.which === 46) {
                    var range = self._viper.getCurrentRange();
                    if (self._viper.isOutOfBounds(range.startContainer) === true
                        ^ self._viper.isOutOfBounds(range.endContainer) === true
                    ) {
                        ViperUtil.preventDefault(e);
                        return false;
                    }
                }
            });

            ViperUtil.addEvent(elem, 'keyup.' + namespace, function(e) {
                isKeyboardEvent = false;
                return self.keyUp(e);
            });

            Viper.Util.addEvent(elem, 'input.' + namespace, function(e) {
                if (isKeyboardEvent === false) {
                    // Browser's spellchecker correction fires this event. But this event also fires for
                    // keydown, keyup and keypress.
                    self._viper.contentChanged();
                }
            });

            this._viper.registerCallback('ViperFormatPlugin:formatChanged', 'KeyboardHandler', function(type) {
                if (type === 'pre') {
                    self.cleanPreTags();
                }
            });
        },

        
        keyPress: function(e)
        {
            if (this._preventKeyPress === true || this._viper.isEnabled() !== true) {
                this._preventKeyPress = false;
                return true;
            }

            var returnValue = this._viper.fireCallbacks('Viper:keyPress', e);
            if (returnValue === false) {
                ViperUtil.preventDefault(e);
                return false;
            }

            var viperElement = this._viper.getViperElement();

            if (ViperUtil.isInputKey(e) === true) {
                this._viper.fireCallbacks('Viper:charInsert', String.fromCharCode(e.which));

                var resetContent = false;
                var range        = this._viper.getCurrentRange();
                if (range.startOffset === 0
                    && range.endContainer === viperElement
                    && range.endOffset === (viperElement.childNodes.length - 1)
                    && range.startContainer === range._getFirstSelectableChild(viperElement)
                ) {
                    resetContent = true;
                } else if (ViperUtil.isBrowser('msie') === true
                    && range.endContainer === viperElement
                    && range.endOffset === 0
                    && range.startOffset === 0
                    && range.startContainer === range._getFirstSelectableChild(viperElement)
                ) {
                    resetContent = true;
                } else if (range.startOffset === 0
                    && range.endContainer === range._getLastSelectableChild(viperElement)
                    && range.endOffset === range.endContainer.data.length
                    && range.startContainer === range._getFirstSelectableChild(viperElement)
                ) {
                    resetContent = true;
                } else if (range.startOffset === 0
                    && range.startContainer === range.endContainer
                    && range.startContainer === viperElement
                    && range.endOffset >= viperElement.childNodes.length
                ) {
                    resetContent = true;
                }//end if

                var nodeSelection = null;
                if (resetContent !== true) {
                    nodeSelection = range.getNodeSelection(range, true);
                    if (nodeSelection && nodeSelection === viperElement) {
                        resetContent = true;
                    }
                }

                if (resetContent === true) {
                    var tagName = this._viper.getDefaultBlockTag();
                    if (viperElement.childNodes.length === 1 && ViperUtil.isBlockElement(viperElement.childNodes[0]) === true) {
                        // There is only one block element in the content so use its tag
                        // name.
                        tagName = ViperUtil.getTagName(viperElement.childNodes[0]);
                    }

                    // The whole content is selected and a char is being
                    // typed. Remove the whole content of the editable element.
                    if (!tagName) {
                        ViperUtil.setHtml(viperElement, '');
                    } else {
                        ViperUtil.setHtml(viperElement, '<' + tagName + '>&nbsp;</' + tagName + '>');
                        range.setStart(range._getFirstSelectableChild(viperElement), 0);
                    }

                    range.collapse(true);
                    ViperSelection.addRange(range);
                } else {
                    if (nodeSelection && ViperUtil.isBlockElement(nodeSelection) === true && String.fromCharCode(e.which) !== '') {
                        switch (ViperUtil.getTagName(nodeSelection)) {
                            case 'table':
                            case 'ul':
                            case 'ol':
                                // Must create a new tag before setting the content.
                                var defaultTagName = this._viper.getDefaultBlockTag();
                                var defTag         = null;
                                if (defaultTagName !== '') {
                                    defTag = document.createElement(defaultTagName);
                                    ViperUtil.setHtml(defTag, String.fromCharCode(e.which));
                                } else {
                                    defTag = document.createTextNode(String.fromCharCode(e.which));
                                }

                                ViperUtil.insertAfter(nodeSelection, defTag);
                                ViperUtil.remove(nodeSelection);
                                range.setStart(defTag, 1);
                                range.collapse(true);
                            break;

                            case 'tfooter':
                            case 'tbody':
                            case 'thead':
                            case 'tr':
                            case 'li':
                                // Tags that can be handled by browser.
                            return true;

                            break;

                            default:
                                var textNode = document.createTextNode(String.fromCharCode(e.which));

                                if (ViperUtil.isStubElement(nodeSelection) === true) {
                                    ViperUtil.insertBefore(nodeSelection, textNode);
                                    ViperUtil.remove(nodeSelection);
                                } else {
                                    // Set the content of the existing tag.
                                    ViperUtil.setHtml(nodeSelection, '');

                                    if (ViperUtil.isTag(nodeSelection, 'blockquote') === true) {
                                        // Blockquote must have at least one P tag.
                                        var quoteP = document.createElement('p');
                                        nodeSelection.appendChild(quoteP);
                                        nodeSelection = quoteP;
                                    }

                                    nodeSelection.appendChild(textNode);
                                }

                                range.setStart(textNode, 1);
                                range.collapse(true);
                            break;
                        }//end switch

                        ViperSelection.addRange(range);
                        this._viper.fireNodesChanged([textNode]);
                        return false;
                    } else if (range.startContainer === range.endContainer
                        && ViperUtil.isTag(range.startContainer, 'br') === true
                        && range.collapsed === true
                        && range.startOffset === 0
                    ) {
                        // IE text insert when BR tag is selected.
                        var textNode = document.createTextNode(String.fromCharCode(e.which));
                        ViperUtil.insertBefore(range.startContainer, textNode);
                        ViperUtil.remove(range.startContainer);
                        range.setStart(textNode, 1);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.fireNodesChanged([textNode]);
                        return false;
                    } else if (range.startContainer === range.endContainer
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.collapsed === true
                        && range.startOffset === range.startContainer.data.length
                    ) {
                        if (range.startContainer.nextSibling
                            && ViperUtil.isText(range.startContainer.nextSibling) === false
                            && ViperUtil.isStubElement(range.startContainer.nextSibling) === false
                        ) {
                            // At the end of a text node with element sibling.. Insert the text to the start of the
                            // next sibling.
                            var textNode = range._getFirstSelectableChild(range.startContainer.nextSibling);
                            if (ViperUtil.isText(textNode) === true) {
                                textNode.data = String.fromCharCode(e.which) + textNode.data;
                                range.setStart(textNode, 1);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                this._viper.contentChanged();
                                return false;
                            }
                        }

                        if (range.startContainer.data.charAt(range.startOffset - 1) === ' ') {
                            // Inserting text at the end of a text node that ends with a space to prevent browser removing the
                            // space.
                            if (e.which === 32) {
                                range.startContainer.data = range.startContainer.data.substr(0, range.startOffset - 1);
                                range.startContainer.data += String.fromCharCode(160) + String.fromCharCode(160);
                            } else {
                                range.startContainer.data += String.fromCharCode(e.which);
                            }

                            range.setStart(range.startContainer, range.startContainer.data.length);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.fireNodesChanged([range.startContainer]);
                            return false;
                        } else if (range.startContainer.data.length === 0) {
                            if (range.startContainer.previousSibling
                                && range.startContainer.previousSibling.nodeType === ViperUtil.TEXT_NODE
                            ) {
                                var prevSib = range.startContainer.previousSibling;
                                if (prevSib.data.charAt(prevSib.data.length - 1) === ' ') {
                                    prevSib.data += String.fromCharCode(e.which);
                                    range.setStart(prevSib, prevSib.data.length);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                    this._viper.fireNodesChanged([range.startContainer]);
                                    return false;
                                }
                            } else if (range.startContainer.parentNode
                                && ViperUtil.isBlockElement(range.startContainer.parentNode) === false
                                && ViperUtil.isEmptyElement(range.startContainer.parentNode) === true
                            ) {
                                // Parent node is empty.
                                var parentPrevSib = range.startContainer.parentNode.previousSibling;
                                if (parentPrevSib
                                    && parentPrevSib.nodeType === ViperUtil.TEXT_NODE
                                    && parentPrevSib.data.charAt(parentPrevSib.data.length - 1) === ' '
                                ) {
                                    // Parent's previous sibling has white space at the end.
                                    parentPrevSib.data += String.fromCharCode(e.which);
                                    range.setStart(parentPrevSib, parentPrevSib.data.length);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                    this._viper.fireNodesChanged([parentPrevSib]);
                                    return false;
                                }
                            }
                        }
                    }

                    var char = String.fromCharCode(e.which);
                    if (range.collapsed === true
                        && char !== ' '
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.endOffset === range.startContainer.data.length
                        && range.endOffset > 0
                        && range.startContainer.data.lastIndexOf(String.fromCharCode(160)) === (range.startContainer.data.length - 1)
                    ) {
                        // If the last character of a text node is nbsp; and a new character is being inserted then replace the nbsp
                        // with normal space.
                        range.startContainer.data = range.startContainer.data.substr(0, range.startContainer.data.length - 1);
                        range.startContainer.data += ' ' + char;
                        range.setStart(range.startContainer, range.startContainer.data.length);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.fireNodesChanged([range.startContainer]);
                        return false;
                    }

                    if (ViperUtil.isBrowser('msie', '<11') === true
                        && range.collapsed === true
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.startOffset === range.startContainer.data.length
                        && !range.startContainer.nextSibling
                    ) {
                        // Handle: <p><strong>text</strong>*</p> -> <p><strong>text</strong>new text</p>.
                        // See: KeyboardEditorPlugin.
                        var node      = range.startContainer.parentNode;
                        var foundNode = null;
                        if (ViperUtil.isTag(node, 'span') === true && ViperUtil.hasAttribute(node, 'data-viper-span') === true) {
                            foundNode = node;
                        } else {
                            while (node) {
                                if (node.nextSibling) {
                                    var nextSib = node.nextSibling;
                                    if (ViperUtil.isTag(nextSib, 'span') === true
                                        && nextSib.firstChild === nextSib.lastChild
                                        && nextSib.firstChild.nodeType === ViperUtil.TEXT_NODE
                                        && nextSib.firstChild.data.length === 0
                                    ) {
                                        foundNode = nextSibling;
                                    }

                                    break;
                                }
                                node = node.parentNode;
                            }
                        }//end if

                        if (foundNode !== null) {
                            ViperUtil.insertBefore(foundNode, foundNode.firstChild);
                            foundNode.previousSibling.data = String.fromCharCode(e.which);
                            range.setEnd(foundNode.previousSibling, 1);
                            range.collapse(false);
                            ViperSelection.addRange(range);
                            ViperUtil.remove(foundNode);
                            return false;
                        }
                    }

                    var startNode = range.getStartNode();
                    if (e.which !== 0
                        && range.startContainer === range.endContainer
                        && range.collapsed === true
                        && (range.startOffset === 0 || (ViperUtil.isBrowser('safari') === true && range.startOffset === 1 && ViperUtil.isText(range.startContainer) === true && range.startContainer.data.charAt(0) === ' '))
                    ) {
                        var textContainer = null;
                        if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                            if (range.startContainer.childNodes[range.startOffset]
                                && range.startContainer.childNodes[range.startOffset]
                                && range.startContainer.childNodes[range.startOffset].nodeType === ViperUtil.TEXT_NODE
                            ) {
                                textContainer = range.startContainer.childNodes[range.startOffset];
                            }
                        } else {
                            textContainer = range.startContainer;
                        }

                        if (textContainer && textContainer.nodeType === ViperUtil.TEXT_NODE) {
                            if (textContainer.previousSibling
                                && ViperUtil.isStubElement(textContainer.previousSibling) === false
                                && ViperUtil.isText(textContainer.previousSibling) === false
                                && ViperUtil.isBrowser('firefox') === true
                            ) {
                                // Firefox needs to insert the character to the previous sibling.
                                // <p>text<strong>insert text here</strong>* more text</p> ->
                                // <p>text<strong>insert text hereNEW*</strong> more text</p>.
                                var prevCont = range._getLastSelectableChild(textContainer.previousSibling);
                                if (ViperUtil.isText(prevCont) === true) {
                                    prevCont.data += char;
                                    range.setStart(prevCont, prevCont.data.length);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                    this._viper.fireNodesChanged([textContainer]);
                                    return false;
                                }

                            }

                            // At the start of a text node with an element sibling. Make sure character is inserted in this
                            // text node.
                            // Also make sure that there is no non breaking space at the start text node followed by a non
                            // space character.
                            if (textContainer.data.length > 1
                                && (textContainer.data.charCodeAt(0) === 160 || textContainer.data.charCodeAt(0) === 32)
                                && textContainer.data[1] !== ' '
                            ) {
                                if (char === ' ') {
                                    char = String.fromCharCode(160);
                                } else {
                                    textContainer.data = ' ' + textContainer.data.substr(1);
                                }
                            } else if (!textContainer.previousSibling) {
                                var parent = textContainer.parentNode;
                                while (!parent.previousSibling && ViperUtil.isBlockElement(parent) === false) {
                                    if (parent === viperElement) {
                                        break;
                                    }

                                    parent = parent.parentNode;
                                }

                                if (ViperUtil.isText(parent.previousSibling) === true) {
                                    if (parent.previousSibling.data.length === 0
                                        && ViperUtil.isBrowser('safari') === true
                                    ) {
                                        parent.previousSibling.data = char;
                                        range.setStart(parent.previousSibling, 1);
                                        range.collapse(true);
                                        ViperSelection.addRange(range);
                                        this._viper.fireNodesChanged([textContainer]);
                                        return false;
                                    }
                                } else if (char === ' ') {
                                    char = String.fromCharCode(160);
                                }
                            }

                            textContainer.data = char + textContainer.data;
                            range.setStart(textContainer, 1);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.fireNodesChanged([textContainer]);
                            return false;
                        } else if (ViperUtil.isTag(startNode, 'br') === true) {
                            // Handle: <div>*<br/><ul><li>aaa</li></ul></div>.
                            var textNode = document.createTextNode(char);
                            ViperUtil.insertBefore(startNode, textNode);
                            range.setStart(textNode, 1);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.fireNodesChanged([textNode]);
                            return false;
                        }
                    } else if (ViperUtil.isBrowser('msie', '<11') === true
                        && range.collapsed === true
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.startOffset > 0
                        && range.startOffset < range.startContainer.data.length
                        && char !== ' '
                    ) {
                        var data = range.startContainer.data;

                        // Character being inserted.
                        if (data.charCodeAt(range.startOffset) === 160
                            && (data.charCodeAt(range.startOffset + 1) !== 160 && data.charCodeAt(range.startOffset + 1) !== 32)
                        ) {
                            // Convert non breaking space to normal space.
                            // E.g. <p>t | ext.</p>.
                            var data = range.startContainer.data;

                            if (data.charCodeAt(range.startOffset - 1) === 160
                                && (data.charCodeAt(range.startOffset - 2) !== 160 && data.charCodeAt(range.startOffset - 2) !== 32)
                            ) {
                                // Previous character is nbsp as well, change it.
                                data = data.substr(0, range.startOffset - 1) + ' ';
                            } else {
                                data = data.substr(0, range.startOffset);
                            }

                            data += ' ' + range.startContainer.data.substr(range.startOffset + 1);
                            range.startContainer.data = data;
                            range.setStart(range.startContainer, range.startOffset);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                        }
                    } else if (ViperUtil.isBrowser('chrome') === true) {
                        if (ViperUtil.rangeInDiffBlocks(range) === true) {
                            // Chrome adds extra styles and tags like span, font etc when range is in two different block
                            // tags and a character is typed.
                            this.handleDelete({which: 8, keyCode: 8, preventDefault:function() {}});
                        }
                    } else if (ViperUtil.isText(range.startContainer) === true
                        && range.collapsed === true
                    ) {
                        // Text node and range is collapsed.
                        if (range.startOffset > 0) {
                            if (char !== ' '
                                && (range.startContainer.data.charCodeAt(range.startOffset - 1) === 32 || range.startContainer.data.charCodeAt(range.startOffset - 1) === 160)
                                && (range.startContainer.data.charCodeAt(range.startOffset) === 160 || range.startContainer.data.charCodeAt(range.startOffset) === 32)
                            ) {
                                // New character is being inserted in between two spaces, convert the nbsp to normal space.
                                range.startContainer.data = range.startContainer.data.substr(0, range.startOffset - 1) + ' ' + char + ' ' + range.startContainer.data.substr(range.startOffset + 1);
                                range.setStart(range.startContainer, range.startOffset + 1);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                this._viper.fireNodesChanged([range.startContainer]);
                                return false;
                            }
                        }
                    } else if (ViperUtil.isText(range.startContainer) === false && range.collapsed === true && char !== ' ') {
                        var startNode = range.getStartNode();
                        if (ViperUtil.isText(startNode) === true) {
                            // At the start of a text node.
                            if (ViperUtil.isText(startNode.previousSibling) === true) {
                                var prevSib = startNode.previousSibling;
                                var prevLen  = prevSib.data.length;
                                // Previous sibling is also a text node. Join these nodes and insert character in between.
                                if (prevSib.data.charCodeAt(prevLen - 1) === 160) {
                                    // Fix space.
                                    prevSib.data = prevSib.data.substr(0, (prevLen - 1)) + ' ';
                                }

                                prevSib.data += char + startNode.data;
                                ViperUtil.remove(startNode);
                                range.setStart(prevSib, prevLen + 1);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                this._viper.fireNodesChanged([prevSib]);
                                return false;
                            }
                        }
                    }
                }//end if

                var self = this;
                setTimeout(function() {
                    self._viper.fireNodesChanged([range.startContainer]);
                }, 5);

                return true;
            }//end if

            return true;

        },

        keyUp: function(e)
        {
            if (this._viper.fireCallbacks('Viper:keyUp', e) === false) {
                ViperUtil.preventDefault(e);
                return false;
            }

            if (e.which === ViperUtil.DOM_VK_BACKSPACE) {
                // Check if the content is now empty.
                var html = ViperUtil.getHtml(this._viper.element);
                if (!html || html === '<br>') {
                    ViperUtil.setHtml(this._viper.element, '');
                    this._viper.initEditableElement();
                }
            }

            if (e.which >= 37 && e.which <= 40) {
                // Handle the case where selecting whole content and pressing arrow keys puts the caret outside of the
                // first/last selected element. E.g. <p>test</p>*.
                var range = this._viper.getCurrentRange();
                if (e.which >= 39
                    && range.startContainer === range.endContainer
                    && range.startOffset === range.endOffset
                    && range.endOffset >= range.startContainer.childNodes.length
                ) {
                    // Right and down arrow keys.
                    var lastSelectable = range._getLastSelectableChild(range.startContainer.childNodes[range.endOffset - 1]);
                    if (lastSelectable && lastSelectable.nodeType === ViperUtil.TEXT_NODE) {
                        range.setStart(lastSelectable, lastSelectable.data.length);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }
                } else if (e.which <= 38
                    && range.startOffset === 0
                    && range.startOffset === range.endOffset
                    && range.startContainer === range.endContainer
                    && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && ViperUtil.isStubElement(range.startContainer.childNodes[range.startOffset]) === false
                ) {
                    // Left and up arrow keys.
                    var firstSelectable = range._getFirstSelectableChild(range.startContainer.childNodes[range.startOffset]);
                    range.setStart(firstSelectable, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }
            }

            // Shift, Control, Alt, Caps lock, esc, CMD.
            var ignoredKeys = [16, 17, 18, 20, 27, 91];
            if ((this._keyDownRangeCollapsed === false && ViperUtil.inArray(e.which, ignoredKeys) === false)
                && (e.ctrlKey === false && e.metaKey === false)
                || e.which === 8
                || e.which === 46
                || (e.which >= 37 && e.which <= 40)
            ) {
                 this._viper.fireSelectionChanged();
            }

            this._keyDownRangeCollapsed = true;

        },

        
        _keyDownRangeCollapsed: true,

        
        keyDown: function(e)
        {
            this._viper.resetViperRange(null);
            var range        = this._viper.getCurrentRange();

            if (this._keyDownRangeCollapsed === true) {
                this._keyDownRangeCollapsed = range.collapsed;
            }

            if (ViperUtil.isKey(e, 'ENTER') === true) {
                return this.handleEnter();
            } else if (ViperUtil.isKey(e, 'SHIFT+ENTER') === true) {
                return this.handleSoftEnter(e);
            } else if (ViperUtil.isKey(e, 'DELETE') === true || ViperUtil.isKey(e, 'BACKSPACE') === true) {
                return this.handleDelete(e);
            }

            var returnValue = this._viper.fireCallbacks('Viper:keyDown', e);
            if (returnValue === false) {
                ViperUtil.preventDefault(e);
                return false;
            }

            if ((e.ctrlKey === false && e.which === 17)
                && (e.altKey === false && e.which !== 18)
                && (e.shiftKey === false && e.which !== 16)
                && (e.metaKey === false && e.which !== 224)
                && e.which !== 27
            ) {
                // Nothing special about this key let the browser handle it unless
                // the track changes is activated or no plugin is direcly modifying it.
                if (this._viper.isSpecialKey(e) === false) {
                    if (ViperUtil.isBrowser('firefox') === true) {
                        this._firefoxKeyDown(e);
                    } else if ((ViperUtil.isKey(e, 'backspace') === true || ViperUtil.isKey(e, 'delete') === true)
                        && (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true || ViperUtil.isBrowser('msie') === true)
                    ) {
                        // Webkit does not fire keypress event for delete and backspace keys..
                        this._viper.contentChanged(true);
                    } else if (ViperUtil.isBrowser('msie', '10') === true) {
                        // Strange issue with IE10.. If a paragraph has only an anchor tag and caret is at the end
                        // of this anchor tag then typing any chracter removes the whole tag...
                        if (range.startContainer
                            && range.startContainer === range.endContainer
                            && range.startOffset === 0
                            && range.endOffset === range.startOffset
                            && ViperUtil.isBlockElement(range.startContainer) === true
                            && ViperUtil.isTag(range.startContainer.firstChild, 'a') === true
                        ) {
                            var newTextNode = document.createTextNode('');
                            ViperUtil.insertAfter(range.startContainer.firstChild, newTextNode);
                            range.setStart(newTextNode, 0);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                        }
                    }

                    var self = this;
                    setTimeout(function() {
                        self._viper.fireSelectionChanged(null, true);
                    }, 10);

                    return true;
                }//end if
            } else if ((e.which === 65 && (e.metaKey === true || e.ctrlKey === true))
                || ((e.which >= 37 && e.which <= 40) && (e.metaKey === true || e.ctrlKey === true) && e.shiftKey === true)
            ) {
                // CMD/CTRL + A, CMD + SHIF + <arrow keys> needs to fire selection changed as they do not fire key up event.
                var self = this;
                setTimeout(function() {
                    self._viper.fireSelectionChanged();
                }, 10);
                return true;
            }//end if

        },

        _firefoxKeyDown: function(e)
        {
            if (e.which >= 37 && e.which <= 40) {
                // Handle the case where selecting whole content and pressing right arrow key puts the caret outside of the
                // last selected element. E.g. <p>test</p>*.
                var range = this._viper.getCurrentRange();
                if (e.which >= 39
                    && range.startContainer === range.endContainer
                    && range.startOffset === 0
                    && range.endOffset >= range.startContainer.childNodes.length
                ) {
                    var lastSelectable = range._getLastSelectableChild(range.startContainer.childNodes[range.endOffset - 1]);
                    if (lastSelectable && lastSelectable.nodeType === ViperUtil.TEXT_NODE) {
                        range.setStart(lastSelectable, lastSelectable.data.length);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }
                }

                // Arrow keys.
                return;
            }

            var range = this._viper.getCurrentRange();
            var elem  = this._viper.getViperElement();
            if (elem.childNodes.length === 0
                || (elem.childNodes.length === 1 && ViperUtil.isTag(elem.childNodes[0], 'br') === true)
                || (elem === range.startContainer && elem === range.endContainer && range.startOffset === 0 && range.endOffset >= range.endContainer.childNodes.length)
            ) {
                var tagName = this._viper.getDefaultBlockTag();
                if (elem.childNodes.length === 1 && ViperUtil.isBlockElement(elem.childNodes[0]) === true) {
                    tagName = ViperUtil.getTagName(elem.childNodes[0]);
                }

                var textNode = document.createTextNode('');
                if (!tagName) {
                    ViperUtil.setHtml(this._viper.element, '');
                    this._viper.element.appendChild(textNode);
                } else {
                    ViperUtil.setHtml(this._viper.element, '<' + tagName + '></' + tagName + '>');
                    this._viper.element.firstChild.appendChild(textNode);
                }

                range.setStart(textNode, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
            } else {
                var startNode = range.getStartNode();
                var endNode   = range.getEndNode();
                if (startNode
                    && startNode === endNode
                    && startNode.nodeType === ViperUtil.ELEMENT_NODE
                    && startNode.parentNode === this._viper.element
                    && range.startOffset === 0
                ) {
                    var firstChild = range._getFirstSelectableChild(startNode);
                    if (firstChild) {
                        range.setStart(firstChild, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }
                }
            }

            // When element is empty Firefox puts <br _moz_dirty="" type="_moz">
            // in to the element which stops text typing, so remove the br tag
            // and add an empty text node and set the range to that node.
            if (range.startContainer === range.endContainer
                && ViperUtil.isTag(range.startContainer, 'br') === true) {
                var textNode = document.createTextNode('');
                ViperUtil.insertAfter(range.startContainer, textNode);
                ViperUtil.remove(range.startContainer);
                range.setStart(textNode, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
            }

        },

        handleEnter: function(returnFirstBlock)
        {
            this._viper.fireCallbacks('Viper:beforeEnter');

            var defaultTagName = this._viper.getDefaultBlockTag();
            var self           = this;
            var range          = this._viper.getCurrentRange();
            var endNode        = range.getEndNode();
            var startNode      = range.getStartNode();
            var viperElem      = this._viper.getViperElement();

            if (!endNode) {
                if (startNode) {
                    endNode = startNode;
                } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && !range.startContainer.childNodes[range.startOffset]
                    && range.startContainer.childNodes[(range.startOffset - 1)]
                ) {
                    endNode = range.startContainer.childNodes[(range.startOffset - 1)];
                } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && range.startContainer.childNodes.length === 0
                    && !endNode
                ) {
                    endNode = range.startContainer;
                }
            }

            try {
                if (!startNode && !endNode && range.collapsed === true && ViperUtil.isTag(range.startContainer, 'br') === true) {
                    startNode = range.startContainer;
                    endNode   = startNode;
                }

                if (endNode
                    && endNode.nodeType === ViperUtil.TEXT_NODE
                    && ViperUtil.trim(ViperUtil.trim(endNode.data)).replace(String.fromCharCode(160), '') === ''
                ) {
                    endNode.data = '';
                    if (range.startContainer === endNode && range.collapsed === true && range.startOffset > 0) {
                        range.setStart(endNode, 0);
                        range.collapse(true);
                    }
                }
            } catch (e) {
                // IE error catch...
                return;
            }

            // Break out of blockquote tag when enter is pressed twice at the start, end and middle of a P tag in a
            // blockquote.
            if (range.collapsed === true
                && (startNode && startNode.nodeType === ViperUtil.TEXT_NODE || ViperUtil.isTag(startNode, 'br') === true)
                && !startNode.previousSibling
                && range.startOffset === 0
                && ViperUtil.getParents(startNode, 'blockquote', this._viper.getViperElement()).length > 0
                && ViperUtil.isTag(ViperUtil.getFirstBlockParent(startNode), 'p') === true
            ) {
                // Make sure this is not the first P tag in a blockquote.
                var parentPtag = ViperUtil.getFirstBlockParent(startNode);
                var prevTag    = parentPtag.previousSibling;
                while (prevTag) {
                    if (ViperUtil.isBlockElement(prevTag) === true) {
                        break;
                    }

                    prevTag = prevTag.previousSibling;
                }

                if (prevTag) {
                    var parentBlockquote = ViperUtil.getParents(parentPtag, 'blockquote', this._viper.getViperElement())[0];
                    var newBlockquote    = parentBlockquote.cloneNode(false);

                    // Move the siblings after the current P tag to the new blockquote element.
                    if (parentPtag.nextSibling) {
                        // Do not move empty block elements.
                        while (parentPtag.nextSibling) {
                            if (this.isEmptyBlockElement(parentPtag.nextSibling) === true) {
                                ViperUtil.remove(parentPtag.nextSibling);
                            } else {
                                newBlockquote.appendChild(parentPtag.nextSibling);
                            }
                        }

                        ViperUtil.insertBefore(newBlockquote.firstChild, parentPtag);
                    } else {
                        newBlockquote.appendChild(parentPtag);
                    }

                    // If the current P tag is empty then remove it. This happens when the caret is at the end of a P
                    // tag and enter is pressed twice.
                    if (this.isEmptyBlockElement(parentPtag) === true) {
                        ViperUtil.remove(parentPtag);
                    }

                    // Final check to make sure that we do not create an empty blockquote element.
                    ViperUtil.removeEmptyNodes(newBlockquote);
                    if (this.isEmptyBlockElement(newBlockquote) === false) {
                        ViperUtil.insertAfter(parentBlockquote, newBlockquote);
                    }

                    // Create a new P tag to be placed between two blockquotes.
                    var midP = document.createElement('p');
                    midP.appendChild(document.createElement('br'));
                    ViperUtil.insertAfter(parentBlockquote, midP);

                    // Set the caret to the newly created P tag.
                    range.selectNode(midP.firstChild);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    this._viper.contentChanged();
                    return false;
                }
            }//end if

            if (ViperUtil.isTag(endNode, 'li') === true && endNode === startNode && endNode.firstChild === null) {
                var firstBlock = endNode;
            } else {
                var firstBlock = ViperUtil.getFirstBlockParent(endNode);
            }

            if (range.collapsed === true
                && ((endNode.nodeType === ViperUtil.TEXT_NODE && (range.endOffset === endNode.data.length || range.endOffset === ViperUtil.rtrim(endNode.data).length))
                || endNode.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isTag(endNode, 'br'))
                && (!endNode.nextSibling || ViperUtil.isTag(endNode.nextSibling, 'br') === true && !endNode.nextSibling.nextSibling)
                && (range._getLastSelectableChild(firstBlock, true) === endNode
                || range._getLastSelectableChild(firstBlock, true) === null && ViperUtil.isTag(endNode, 'br') === true || (endNode.nodeType === ViperUtil.TEXT_NODE && endNode.data.length === 0))
                || ViperUtil.isTag(firstBlock, 'li') === true && endNode === startNode && endNode.firstChild === null
            ) {
                if (firstBlock && !defaultTagName && firstBlock === this._viper.getViperElement()) {
                    var br = document.createElement('br');
                    this._viper.insertNodeAtCaret(br);
                    if (!br.nextSibling) {
                        ViperUtil.insertAfter(br, document.createElement('br'));
                    }

                    range.setStart(br.nextSibling, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    this._viper.contentChanged();
                    return false;
                } else if (firstBlock) {
                    var firstBlockTagName = ViperUtil.getTagName(firstBlock);
                    var handleEnter       = false;
                    var removeFirstBlock  = false;
                    if (ViperUtil.inArray(firstBlockTagName, this._tagList) === true) {
                        handleEnter = true;
                    } else if (firstBlockTagName === 'li'
                        && ViperUtil.trim(ViperUtil.getNodeTextContent(firstBlock)) === ''
                    ) {
                        if (defaultTagName === '') {
                            // Default tag name is set to nothing. Move caret after the list.
                            this.splitList(firstBlock);
                            this._viper.contentChanged();
                            return false;
                        } else if (ViperUtil.isBrowser('chrome') === true
                            || ViperUtil.isBrowser('safari') === true
                            || ViperUtil.isBrowser('msie') === true
                            || ViperUtil.isBrowser('edge') === true
                        ) {
                            handleEnter = true;
                            removeFirstBlock = true;
                        }
                    }

                    if (handleEnter === true) {
                        if (defaultTagName === '') {
                            var br = document.createElement('br');
                            ViperUtil.insertAfter(firstBlock, br);
                            range.setStart(br, 0);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.contentChanged();
                            return false;
                        }

                        var content = '<br />';
                        if (ViperUtil.isBrowser('msie', '<9') === true) {
                            content = '&nbsp;';
                        }

                        var tagName = defaultTagName;
                        var p = document.createElement(tagName);
                        ViperUtil.setHtml(p, content);

                        // If the firstBlock is a P tag and it's parent is not the
                        // Viper editable element and its the last child then move this
                        // new P tag after its parent element.
                        if (ViperUtil.isTag(firstBlock, 'p') === true
                            && firstBlock.parentNode !== this._viper.getViperElement()
                            && !firstBlock.nextSibling
                            && ViperUtil.trim(ViperUtil.getNodeTextContent(firstBlock)) === ''
                        ) {
                            ViperUtil.insertAfter(firstBlock.parentNode, p);
                            removeFirstBlock = true;
                        } else {
                            if (firstBlockTagName === 'li') {
                                if (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true || ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true) {
                                    var parentListItem = ViperUtil.getFirstBlockParent(firstBlock.parentNode);
                                    if (parentListItem && ViperUtil.isTag(parentListItem, 'li') === true) {
                                        newList = document.createElement('li');
                                        newList.appendChild(document.createElement('br'));

                                        var subList = null;
                                        while (firstBlock.nextSibling) {
                                            if (ViperUtil.isTag(firstBlock.nextSibling, 'li') === true) {
                                                if (!subList) {
                                                    subList = document.createElement(ViperUtil.getTagName(firstBlock.parentNode));
                                                    newList.appendChild(subList);
                                                }

                                                subList.appendChild(firstBlock.nextSibling);
                                            } else if (subList) {
                                                subList.appendChild(firstBlock.nextSibling);
                                            } else {
                                                newList.appendChild(firstBlock.nextSibling);
                                            }
                                        }

                                        ViperUtil.remove(firstBlock);
                                        ViperUtil.insertAfter(parentListItem, newList);
                                        range.selectNode(newList.firstChild);
                                        range.collapse(true);
                                        ViperSelection.addRange(range);
                                        this._viper.contentChanged();
                                        return false;
                                    }
                                }

                                // Need to move rest of the list items to a new
                                // list.
                                var newList = document.createElement(ViperUtil.getTagName(firstBlock.parentNode));
                                while (firstBlock.nextSibling) {
                                    newList.appendChild(firstBlock.nextSibling);
                                }

                                if (ViperUtil.getTag('li', newList).length > 0) {
                                    ViperUtil.insertAfter(firstBlock.parentNode, newList);
                                }

                                ViperUtil.insertAfter(firstBlock.parentNode, p);
                            } else {
                                ViperUtil.insertAfter(firstBlock, p);
                            }
                        }

                        if (removeFirstBlock === true) {
                            ViperUtil.remove(firstBlock);
                        }

                        if (p.firstChild.nodeType === ViperUtil.TEXT_NODE) {
                            if (ViperUtil.isBrowser('msie', '<11') === true
                                && p.firstChild.data === String.fromCharCode(160)
                            ) {
                                range.setEnd(p.firstChild, 1);
                                range.collapse(false);
                                range.moveEnd('character', -1);
                                range.collapse(false);
                            } else {
                                range.setEnd(p.firstChild, 0);
                                range.collapse(false);
                            }
                        } else {
                            range.selectNode(p.firstChild);
                            range.collapse(true);
                        }


                        ViperSelection.addRange(range);

                        this._viper.contentChanged();
                        return false;
                    }//end if
                }//end if
            }//end if

            var startNode   = range.getStartNode();
            var blockParent = null;
            if (!startNode) {
                if (range.startContainer.childNodes.length <= range.startOffset && range.startOffset !== 0) {
                    startNode = range.startContainer.childNodes[(range.startContainer.childNodes.length - 1)];
                } else {
                    startNode = range.startContainer;
                }

                if (ViperUtil.isBlockElement(startNode) === true) {
                    blockParent = startNode;
                }
            } else {
                blockParent = ViperUtil.getFirstBlockParent(startNode);
            }

            if (startNode && ViperUtil.isTag(blockParent, 'pre') === true) {
                if (startNode.parentNode === blockParent
                    && startNode.nodeType === ViperUtil.TEXT_NODE
                    && ViperUtil.trim(startNode.data) === ''
                    && (!startNode.previousSibling
                    || startNode.previousSibling.data === "\n")
                ) {
                    while (startNode.nextSibling) {
                       ViperUtil.remove(startNode.nextSibling);
                    }

                    ViperUtil.remove(startNode);
                    var p = document.createElement('p');
                    ViperUtil.setHtml(p, '<br />');
                    ViperUtil.insertAfter(blockParent, p);
                    range.selectNode(p.firstChild);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                } else {
                    this.insertTextAtRange(range, "\n");
                    this._viper.contentChanged();
                }

                return false;
            } else if ((blockParent === null || blockParent === this._viper.getViperElement()) && !defaultTagName) {
                if (startNode.nodeType === ViperUtil.TEXT_NODE
                    && startNode.data.length > (range.startOffset + 1)
                    && startNode.data.charCodeAt(range.startOffset) === 32
                ) {
                    startNode.data = startNode.data.substring(0, range.startOffset) + String.fromCharCode(160) +  startNode.data.substring(range.startOffset + 1);
                    range.setStart(startNode, range.startOffset);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }

                var br = document.createElement('br');
                if (ViperUtil.isText(range.startContainer) === true
                    && range.startOffset === range.startContainer.data.length
                    && !range.startContainer.nextSibling
                ) {
                    // handle:  test<sup>XAX XBX*</sup> test.
                    var parent = range.startContainer.parentNode;
                    while (parent !== viperElem) {
                        if (parent.nextSibling) {
                            break;
                        }

                        parent = parent.parentNode;
                    }

                    if (parent && parent !== viperElem) {
                        ViperUtil.insertAfter(parent, br);
                    }
                } else if (ViperUtil.isText(range.startContainer) === true
                    && range.startOffset === 0
                    && !range.startContainer.previousSibling
                ) {
                    // handle:  test<sup>*XAX XBX</sup> test.
                    var parent = range.startContainer.parentNode;
                    while (parent !== viperElem) {
                        if (parent.previousSibling) {
                            break;
                        }

                        parent = parent.parentNode;
                    }

                    if (parent && parent !== viperElem) {
                        ViperUtil.insertBefore(parent, br);
                    }
                } else {
                    this._viper.insertNodeAtCaret(br);
                }

                if (!br.nextSibling
                    || br.nextSibling.nodeType !== ViperUtil.TEXT_NODE
                    || br.nextSibling.data.charAt(0) === "\n"
                ) {
                    ViperUtil.insertAfter(br, document.createTextNode(''));
                }

                range.setStart(br.nextSibling, 0);
                range.collapse(true);
                ViperSelection.addRange(range);

                return false;
            } else if (ViperUtil.isBrowser('msie') === true
                && range.startOffset === 0
                && range.collapsed === true
                && ViperUtil.isTag(startNode, 'li') === true
            ) {
                if (!startNode.nextSibling || (startNode.nextSibling.nodeType === ViperUtil.TEXT_NODE && !startNode.nextSibling.nextSibling)) {
                    if (startNode.parentNode.parentNode === this._viper.getViperElement()) {
                        var p = document.createElement('p');
                        ViperUtil.setHtml(p, '&nbsp');
                        ViperUtil.insertAfter(startNode.parentNode, p);
                        range.setEnd(p.firstChild, 1);
                        range.moveEnd('character', -1);
                        range.collapse(false);
                        ViperSelection.addRange(range);

                        this._viper.fireSelectionChanged();
                        ViperUtil.remove(startNode);
                        return false;
                    }
                }
            }//end if

            var selectedNode = range.getNodeSelection();
            if (selectedNode && selectedNode === viperElem) {
                if (ViperUtil.isBrowser('msie') === true) {
                    // Let IE do it as there is no way of telling if the caret is
                    // before or after the iframe.
                    return;
                }

                var elem = document.createElement(defaultTagName);
                ViperUtil.setHtml(elem, '<br />');
                if (viperElem.firstChild) {
                    ViperUtil.insertBefore(viperElem.firstChild, elem);
                } else {
                    viperElem.appendChild(elem);
                }

                range.selectNode(elem.firstChild);
                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.fireSelectionChanged();
                return false;
            } else if (!selectedNode
                && startNode
                && startNode === endNode
                && startNode.nodeType === ViperUtil.ELEMENT_NODE
                && (ViperUtil.isBrowser('firefox') !== true || !(ViperUtil.isTag(startNode, 'br') === true && (!blockParent || ViperUtil.isTag(blockParent, 'li') === true)))
                && ViperUtil.isStubElement(startNode) === false
                && ViperUtil.isBlockElement(startNode) === true
            ) {
                var elem = document.createElement(defaultTagName);
                ViperUtil.setHtml(elem, '<br />');
                if (startNode === viperElem.lastChild) {
                    ViperUtil.insertAfter(startNode, elem);
                } else {
                    ViperUtil.insertBefore(startNode, elem);
                }

                range.selectNode(elem.firstChild);
                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.fireSelectionChanged();
                return false;
            } else if (!selectedNode
                && startNode
                && endNode
                && startNode !== endNode
                && startNode.nodeType === ViperUtil.ELEMENT_NODE
                && endNode.nodeType === ViperUtil.ELEMENT_NODE
            ) {
                var elem = document.createElement(defaultTagName);
                ViperUtil.setHtml(elem, '<br />');

                if (ViperUtil.isStubElement(endNode) === true) {
                    ViperUtil.insertAfter(startNode, elem);
                } else {
                    ViperUtil.insertAfter(endNode, elem);
                }

                range.selectNode(elem.firstChild);
                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.fireSelectionChanged();
                return false;
            } else if (ViperUtil.isBrowser('firefox') === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && endNode === startNode
                && range.startOffset === startNode.data.length
                && range.collapsed === true
                && ViperUtil.isTag(blockParent, 'li') === true
                && ViperUtil.isChildOf(ViperUtil.getFirstBlockParent(range.getNextContainer(startNode)), blockParent)
            ) {
                // There is a sublist and the range is at the end of the main list
                // item. When enter is pressed Firefox creates a new main list item
                // but the caret is placed to the start of the sub list items and
                // its not possible to move the caret to the new main list item.
                var li = document.createElement('li');
                if (!startNode.nextSibling || ViperUtil.isTag(startNode.nextSibling, 'br') === false) {
                    // Do not add extra BR tag.
                    li.appendChild(document.createElement('br'));
                }

                while (startNode.nextSibling) {
                    li.appendChild(startNode.nextSibling);
                }

                ViperUtil.insertAfter(blockParent, li);
                range.selectNode(li.firstChild);
                range.collapse(true);
                ViperSelection.addRange(range);
                return false;
            } else if (selectedNode
                && ViperUtil.isTag(selectedNode, 'li') === true
                && blockParent === selectedNode
                && startNode === endNode
                && ViperUtil.isTag(startNode, 'br') === true
                && range.collapsed === true
                && !startNode.nextSibling
            ) {
                var parentListItem = ViperUtil.getFirstBlockParent(blockParent.parentNode);
                if (parentListItem && ViperUtil.isTag(parentListItem, 'li') === true) {
                    // Pressing enter at the start of an empty sub list item should
                    // be creating a new main list item and moving all remaining
                    // sub list items to the new list item.
                    var li = document.createElement('li');
                    li.appendChild(document.createElement('br'));
                    while (startNode.nextSibling) {
                        li.appendChild(startNode.nextSibling);
                    }

                    var subList = null;
                    while (blockParent.nextSibling) {
                        if (ViperUtil.isTag(blockParent.nextSibling, 'li') === true) {
                            if (!subList) {
                                subList = document.createElement(ViperUtil.getTagName(blockParent.parentNode));
                                li.appendChild(subList);
                            }

                            subList.appendChild(blockParent.nextSibling);
                        } else if (subList) {
                            subList.appendChild(blockParent.nextSibling);
                        } else {
                            li.appendChild(blockParent.nextSibling);
                        }
                    }

                    ViperUtil.remove(blockParent);
                    ViperUtil.insertAfter(parentListItem, li);
                    range.selectNode(li.firstChild);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    return false;
                } else if (ViperUtil.isBrowser('chrome') === true) {
                    // Latest Chrome is creating DIV element with span tag when
                    // exiting a top level list (hitting enter in an empty top level list item).
                    // Create the default tag instead.
                    var elem = null;
                    if (defaultTagName) {
                        elem = document.createElement(defaultTagName);
                        elem.appendChild(document.createElement('br'));
                    } else {
                        elem = document.createElement('br');
                    }

                    ViperUtil.insertAfter(blockParent.parentNode, elem);

                    // If the list item is not the last one we need to move
                    // the rest of them to a new list.
                    var listItems = [];
                    for (var node = blockParent; node; node = node.nextSibling) {
                        if (ViperUtil.isTag(node, 'li') === true) {
                            listItems.push(node);
                        }
                    }

                    if (listItems.length > 0) {
                        var newList = document.createElement(ViperUtil.getTagName(blockParent.parentNode));
                        ViperUtil.insertAfter(elem, newList);
                        while (listItems.length > 0) {
                            newList.appendChild(listItems.shift());
                        }
                    }

                    ViperUtil.remove(blockParent);

                    if (defaultTagName) {
                        range.selectNode(elem.firstChild);
                    } else {
                        range.selectNode(elem);
                    }

                    range.collapse(true);
                    ViperSelection.addRange(range);
                    return false;
                }
            } else if (range.collapsed === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && startNode.data.length > (range.startOffset + 1)
                && startNode.data.charCodeAt(range.startOffset) === 32
            ) {
                // If this is a textnode, range is collapsed and the next
                // character is a space then replace it with a non breaking
                // space char to keep it at the beginning of the new container
                // that will be created.
                startNode.data = startNode.data.substring(0, range.startOffset) + String.fromCharCode(160) +  startNode.data.substring(range.startOffset + 1);
                range.setStart(startNode, range.startOffset);
                range.collapse(true);
                ViperSelection.addRange(range);
            } else if ((ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('firefox') === true)
                && range.startOffset === 0
                && range.collapsed === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && startNode === range._getFirstSelectableChild(ViperUtil.getFirstBlockParent(startNode))
            ) {
                // IE11 & Firefox (only on 2nd enter) seems to have an issue with creating a new paragraph before the caret. If the caret is at the
                // start of a paragraph and enter is pressed a new paragraph is added before the original P tag.
                // However, in IE11, the innerHTML is '<br>' but firstChild of the paragraph is null..
                // We handle the creation here to prevent issues with toolbar button statuses etc.
                var parent = ViperUtil.getFirstBlockParent(startNode);
                var newEl = document.createElement(ViperUtil.getTagName(parent));
                newEl.appendChild(document.createElement('br'));

                if (ViperUtil.isBrowser('msie', '8') === true) {
                    ViperUtil.setStyle(newEl.firstChild, 'display', 'none');
                }

                ViperUtil.insertBefore(parent, newEl);
                this._viper.contentChanged(true);
                return false;
            } else if (ViperUtil.isBrowser('msie', '>=11') === true
                && startNode === endNode
                && range.collapsed === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && startNode.nextSibling === null
                && range.startOffset === startNode.data.length
                && ViperUtil.isTag(ViperUtil.getFirstBlockParent(startNode), 'li') === true
            ) {
                // End of a list item. Create a new list item.
                var li = document.createElement('li');
                ViperUtil.setHtml(li, '<br/>');
                var parentItem = ViperUtil.getFirstBlockParent(startNode);
                ViperUtil.insertAfter(parentItem, li);
                range.selectNode(li.firstChild);
                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.contentChanged();
                return false;
            } else if (startNode
                && startNode === endNode
                && ViperUtil.isStubElement(startNode) === true
                && startNode.parentNode === self._viper.getViperElement()
            ) {
                // For content like <viperElement><iframe />*</viperElement>. Where * is the caret.
                var defTag = null;
                if (defaultTagName !== '') {
                    defTag = document.createElement(defaultTagName);
                    ViperUtil.setHtml(defTag, '<br/>');
                } else {
                    defTag = document.createTextNode(' ');
                }

                ViperUtil.insertAfter(startNode, defTag);
                range.setStart(defTag, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
                return false;
            } else if (ViperUtil.isBrowser('firefox') === true
                && range.collapsed === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === startNode.data.length
                && startNode.nextSibling
                && ViperUtil.isTag(startNode.nextSibling, 'br')
                && (!startNode.nextSibling.nextSibling || ViperUtil.isTag(startNode.nextSibling.nextSibling, 'br') === false)
            ) {
                // Handle XAX*<br>XBX<br>XCX.
                // Pressing enter changes the content to: <p>XAX</p>*XBX<br>XCX.
                // By adding an extra BR we keep it in the content.
                ViperUtil.insertAfter(startNode, document.createElement('br'));
            } else if ((ViperUtil.isBrowser('msie') === true
                || ViperUtil.isBrowser('firefox') === true)
                && startNode.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === startNode.data.length
                && startNode.data.length !== 0
                && range.collapsed === true
                && startNode.nextSibling === null
                && ViperUtil.isBlockElement(startNode.parentNode) === false
            ) {
                // Handle: <p>test<strong>test*</strong>test</p>.
                // When enter is pressed make sure the new paragraph does not start with the tag.
                var parent = startNode.parentNode;
                var surroundingParents = ViperUtil.getSurroundingParents(parent, null, 'inline');
                if (surroundingParents.length > 0) {
                    parent = surroundingParents.pop();
                }

                var parentNextSibling = parent.nextSibling;
                if (!parentNextSibling || parentNextSibling.nodeType !== ViperUtil.TEXT_NODE) {
                    parentNextSibling = document.createTextNode('');
                    ViperUtil.insertAfter(parent, parentNextSibling);
                }

                range.setStart(parentNextSibling, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
            } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.collapsed === true
                && range.startOffset === (range.startContainer.data.length + 1)
                && range.startContainer.previousSibling
                && range.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE
                && (range.startContainer.nextSibling === null || ViperUtil.isTag(range.startContainer.nextSibling, 'br') === true)
                && ViperUtil.trim(range.startContainer.data) === ''
            ) {
                // Handle case where <p>text<strong>text</strong> *</p> or <p>text<strong>text</strong> *<br/></p>
                // causes caret to stay in the same paragraph.
                var parent = ViperUtil.getFirstBlockParent(range.startContainer);
                if (parent) {
                    var newParent = document.createElement(ViperUtil.getTagName(parent));
                    ViperUtil.setHtml(newParent, '<br />');
                    ViperUtil.insertAfter(parent, newParent);
                    range.setStart(newParent.firstChild, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    self._viper.fireSelectionChanged(null, true);
                    return false;
                }
            } else if ((ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true)
                && range.startOffset === 0
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range._getFirstSelectableChild(ViperUtil.getFirstBlockParent(range.startContainer)) === range.startContainer
            ) {
                // Caret is at the start of a block element and pressing enter needs to create a new element before this. and
                // leave the caret where it is.
                var parent    = ViperUtil.getFirstBlockParent(range.startContainer);
                var newParent = document.createElement(ViperUtil.getTagName(parent));
                ViperUtil.setHtml(newParent, '<br />');
                ViperUtil.insertBefore(parent, newParent);
                this._viper.contentChanged(true);
                return false;
            } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.collapsed === true
                && range.startOffset === 0
                && range.startContainer.previousSibling
                && range.startContainer.previousSibling.nodeType === ViperUtil.TEXT_NODE
                && range.startContainer.nextSibling === null
                && ViperUtil.isTag(range.startContainer, 'br') === true
            ) {
                // Handle case where <p>test test[<br/>]</p>, element ending with br and range is set to br.
                var parent = ViperUtil.getFirstBlockParent(range.startContainer);
                if (parent) {
                    var newParent = document.createElement(ViperUtil.getTagName(parent));
                    ViperUtil.setHtml(newParent, '<br />');
                    ViperUtil.insertAfter(parent, newParent);
                    range.setStart(newParent.firstChild, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    self._viper.fireSelectionChanged(null, true);
                    return false;
                }
            } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.collapsed === true
                && range.startOffset === range.startContainer.data.length
                && range.startContainer.nextSibling
                && range.startContainer.nextSibling.nodeType !== ViperUtil.TEXT_NODE
                && ViperUtil.isTag(range.startContainer.nextSibling, 'br') === false
                && ViperUtil.isBlockElement(range.startContainer.nextSibling) === false
            ) {
                // Handle <p>test *<strong>text</strong></p>.
                this.splitAtRange();
                this._viper.contentChanged();
                return false;
            } else if (range.startContainer === range.endContainer
                && defaultTagName !== ''
                && ViperUtil.isBlockElement(range.startContainer) === true
                && range.collapsed === true
                && range.startOffset === range.startContainer.childNodes.length
                && ViperUtil.isTag(range.startContainer.childNodes[(range.startOffset - 1)], 'table') === true
            ) {
                // Handle: <div>...<table>..</table>*</div>.
                var newTag = document.createElement(defaultTagName);
                ViperUtil.setHtml(newTag, '<br />');
                ViperUtil.insertAfter(range.startContainer.childNodes[(range.startOffset - 1)], newTag);
                range.setStart(newTag.firstChild, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.contentChanged();
                return false;
            }//end if


            if (range.startOffset === 0
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && (range.startContainer.previousSibling === null || (range.startContainer.previousSibling
                && range.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE))
            ) {
                // Hande enter when <p><strong>test</strong><em>*test</em></p> and  <p><strong>test</strong>*test</p>.
                this.splitAtRange();
                this._viper.contentChanged();
                return false;
            }//end if

            setTimeout(function() {
                // Fire selection changed here for enter events after a delay so that
                // range object is pointing to the new location. For example,
                // if enter was pressed at the end of a list and a new paragraph is
                // started by browser then getting range without delay would still
                // point to the empty list item. With delay it will be in the new
                // paragraph tag.
                self._viper.fireSelectionChanged(null, true);
            }, 5);

            // Let the browser handle everything else.
            return true;

        },

        handleDelete: function(e)
        {
            e = e || {which:8, keyCode:8};

            var range = this._viper.getViperRange();
            if (this._viper.fireCallbacks('Viper:beforeDelete', e) === false) {
                return false;
            }

            if (this._isWholeViperElementSelected(range) === true) {
                // The whole Viper element is selected, remove all of its content
                // and then initialise the Viper element.
                ViperUtil.setHtml(this._viper.getViperElement(), '');
                this._viper.initEditableElement();
                this._viper.contentChanged();
                return false;
            }

            if (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true) {
                // Latest Chrome versions have strange issue with all content deletion, handle it in another method.
                return this._handleDeleteForWebkit(e, range);
            }

            if (e.which === 46) {
                // Handle deletion from the right of the caret.
                return this._handleDeleteFromRight(e, range);
            }

            if (range.startOffset !== 0 && range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                if (range.collapsed === true && ViperUtil.isBrowser('msie', '<11')) {
                    // Delete 1 char in IE.... This resolves the issue where <a href="" />T* backspace here sets the
                    // range to incorrect position..
                    if (range.startOffset === 1) {
                        range.startContainer.data = '';
                        if (range.startContainer.previousSibling
                            && range.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE
                        ) {
                            var span = document.createElement('span');
                            ViperUtil.attr(span, 'data-viper-span', 'true');
                            ViperUtil.insertBefore(range.startContainer, span);
                            span.appendChild(range.startContainer);
                        } else if (!range.startContainer.previousSibling
                            && !range.startContainer.nextSibling
                            && ViperUtil.isBlockElement(range.startContainer.parentNode)
                        ) {
                            range.startContainer.parentNode.appendChild(document.createElement('br'));
                        }
                    } else {
                        range.startContainer.splitText(range.startOffset);
                        range.startContainer.data = range.startContainer.data.substring(0, range.startOffset - 1);
                        if (range.startContainer.nextSibling
                            && range.startContainer.nextSibling.nodeType === ViperUtil.TEXT_NODE
                        ) {
                            // If the range was at the end of the text node then splitText does not
                            // create a new text node.
                            range.startContainer.data += range.startContainer.nextSibling.data;
                            ViperUtil.remove(range.startContainer.nextSibling);
                        }
                    }

                    range.setStart(range.startContainer, range.startOffset - 1)
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    this._viper.contentChanged();
                    return false;
                }
            }

            var defaultTagName  = this._viper.getDefaultBlockTag();
            var viperElement    = this._viper.getViperElement();
            var firstSelectable = range._getFirstSelectableChild(viperElement);
            var startNode       = range.getStartNode();

            if (!startNode
                && range.startOffset === 0
                && range.startContainer.nodeType !== ViperUtil.TEXT_NODE
                && range.collapsed === true
                && !range.startContainer.firstChild
            ) {
                startNode = range.startContainer;
            }

            // TODO: Should use getNodeSelection to simplify this whole delete method.
            if (range.collapsed === true && e.keyCode === 8 && range.startOffset === 0) {
                if (startNode && (startNode.nodeType === ViperUtil.TEXT_NODE || ViperUtil.isTag(startNode, 'br') === true)) {
                    var skippedBlockElem = [];
                    var node      = range.getPreviousContainer(startNode, skippedBlockElem, true, true);
                    if (this._viper.isOutOfBounds(node) === true) {
                        // Range is at the start of the editable element, nothing to delete except any blank block elements.
                        if (skippedBlockElem.length > 0) {
                            for (var i = 0; i < skippedBlockElem.length; i++) {
                                if (ViperUtil.isTag(skippedBlockElem[i], 'p') === true) {
                                    ViperUtil.remove(skippedBlockElem[i]);
                                }
                            }
                        } else if (startNode.nodeType !== ViperUtil.TEXT_NODE || startNode.data.length === 0) {
                            node = range.getNextContainer(startNode, skippedBlockElem, true, true);
                            if (node && this._viper.isOutOfBounds(node) === false) {
                                ViperUtil.remove(ViperUtil.getSurroundingParents(startNode));
                                range.setStart(node, 0);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }
                        } else {
                            var nonSelectableElements = ViperUtil.getElementsBetween(viperElement, startNode);
                            ViperUtil.remove(nonSelectableElements);
                        }

                        if (((startNode.nodeType === ViperUtil.TEXT_NODE
                            && ViperUtil.trim(startNode.data).length === 0)
                            || ViperUtil.isTag(startNode, 'br') === true)
                            && ViperUtil.isTag(startNode.parentNode, 'li') === true
                            && ViperUtil.getTag('li', startNode.parentNode.parentNode).length === 1
                        ) {
                            // If the list item is the first container in the content and its being removed and its the
                            // only list item then remove the list element.
                            if (startNode.parentNode.parentNode.parentNode === this._viper.getViperElement()
                                && startNode.parentNode.parentNode.nextSibling === null
                                && startNode.parentNode.parentNode.previousSibling === null
                            ) {
                                // This list is the only element in the content, initialise the content
                                // after removing the list.
                                ViperUtil.remove(startNode.parentNode.parentNode);
                                this._viper.initEditableElement();
                            } else {
                                this._viper.moveCaretAway(startNode.parentNode.parentNode, true);
                                ViperUtil.remove(startNode.parentNode.parentNode);
                            }

                            this._viper.contentChanged();
                        }

                        return false;
                    }
                }
            }

            if (this._isWholeViperElementSelected(range) === true) {
                // The whole Viper element is selected, remove all of its content
                // and then initialise the Viper element.
                ViperUtil.setHtml(viperElement, '');
                this._viper.initEditableElement();
                this._viper.contentChanged();
                return false;
            } else if (ViperUtil.isBrowser('msie') === true) {
                var rangeClone = range.cloneRange();

                if (ViperUtil.isBrowser('msie', '>=11') === true) {
                    // Check if the previous sibling of a parent is HR element and then remove it if found.
                    var startElem = startNode;
                    var foundSib  = false;
                    while (startElem) {
                        for (var node = startElem.previousSibling; node; node = node.previousSibling) {
                            if (node.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isTag(node, 'hr') === true) {
                                // Found the HR element, remove it.
                                ViperUtil.remove(node);
                                this._viper.contentChanged();
                                return false;
                            } else if (node.nodeType !== ViperUtil.TEXT_NODE || ViperUtil.trim(node.data).length !== 0) {
                                // Not an empty text node or another node type, no need to continue.
                                foundSib = true;
                                break;
                            }
                        }

                        if (foundSib === true) {
                            break;
                        }

                        startElem = startElem.parentNode;
                    }
                } else {
                    // Remove HR elements in <IE11..
                    rangeClone.moveStart('character', -2);
                    if (ViperUtil.trim(rangeClone.getHTMLContents()) === '<HR>') {
                        range.moveStart('character', -2);
                        range.deleteContents();
                        return;
                    }
                }

                if (range.startContainer
                    && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                    && range.endContainer
                    && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                    && range.startOffset === 0
                    && range.endOffset === range.endContainer.data.length
                ) {
                    // Remove a whle list element. IE seems to remove the list
                    // items but not the UL/OL element...
                    var parentLists = ViperUtil.getParents(range.startContainer, 'ul,ol', this._viper.getViperElement());
                    while (parentLists.length > 0) {
                        var parentList = parentLists.shift();
                        var firstSelectable = range._getFirstSelectableChild(parentList);
                        var lastSelectable  = range._getLastSelectableChild(parentList);
                        if (firstSelectable === range.startContainer
                            && lastSelectable === range.endContainer
                        ) {
                            var newSelectable = range.getNextContainer(lastSelectable, null, true);
                            if (!newSelectable || this._viper.isOutOfBounds(newSelectable) === true) {
                                newSelectable = range.getPreviousContainer(firstSelectable, null, true);
                                if (newSelectable) {
                                    ViperUtil.remove(parentList);
                                    range.setEnd(newSelectable, newSelectable.data.length);
                                    range.collapse(false);
                                    ViperSelection.addRange(range);
                                }
                            } else {
                                ViperUtil.remove(parentList);
                                range.setEnd(newSelectable, 0);
                                range.collapse(false);
                                ViperSelection.addRange(range);
                            }

                            this._viper.contentChanged();

                            return false;
                        }//end if
                    }//end if
                }//end if
            }

            if (range.startOffset === 0
                && range.collapsed === true
                && startNode.nodeType === ViperUtil.TEXT_NODE
            ) {
                var firstBlock = ViperUtil.getFirstBlockParent(startNode);
                if (firstBlock
                    && range._getFirstSelectableChild(firstBlock) === startNode
                    && firstBlock.previousElementSibling
                    && ViperUtil.isStubElement(firstBlock.previousElementSibling) === true
                ) {
                    // Firefox does not handle deletion at the start of a block element
                    // very well when the previous sibling is a stub element (e.g. HR).
                    ViperUtil.remove(firstBlock.previousElementSibling);
                    this._viper.contentChanged();
                    return false;
                } else if (e.keyCode === 8
                    && range.collapsed === true
                    && startNode.nodeType === ViperUtil.TEXT_NODE
                    && (range.startOffset === 0 || (range.startOffset === 1 && startNode.data.charAt(0) === ' '))
                    && (!startNode.previousSibling || ViperUtil.isTag(startNode.previousSibling, 'br') === true)
                ) {
                    // At the start of an element. Check to see if the previous
                    // element is a part of another block element. If it is then
                    // join these elements.
                    var prevSelectable = range.getPreviousContainer(startNode, null, true, true);
                    var currentParent  = ViperUtil.getFirstBlockParent(startNode);
                    var prevParent     = ViperUtil.getFirstBlockParent(prevSelectable);
                    if (currentParent !== prevParent && this._viper.isOutOfBounds(prevSelectable) === false) {
                        // Check if there are any other elements in between.
                        var elemsBetween = ViperUtil.getElementsBetween(prevParent, currentParent);
                        if (elemsBetween.length > 0 && elemsBetween[0].nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(elemsBetween[0].data)) === false) {
                            // There is at least one non block element in between.
                            // Remove it.
                            ViperUtil.remove(elemsBetween[(elemsBetween.length - 1)]);
                        } else {
                            // If prev parent has BR as last child, remove it.
                            if (prevParent.lastChild && ViperUtil.isTag(prevParent.lastChild, 'br') === true) {
                                ViperUtil.remove(prevParent.lastChild);
                            }

                            if (currentParent.lastChild && ViperUtil.isTag(currentParent.lastChild, 'br') === true) {
                                ViperUtil.remove(currentParent.lastChild);
                            }

                            var firstChild = currentParent.firstChild;
                            while (currentParent.firstChild) {
                                prevParent.appendChild(currentParent.firstChild);
                            }

                            if (ViperUtil.isTag(currentParent, ['td', 'th']) === false) {
                                ViperUtil.remove(currentParent);
                            }

                            if (prevSelectable.nodeType === ViperUtil.TEXT_NODE) {
                                range.setEnd(prevSelectable, prevSelectable.data.length);
                            } else if (prevSelectable.parentNode === null || ViperUtil.isStubElement(prevSelectable) === true) {
                                // Prev selectable was most likely a BR tag that got removed.
                                if (firstChild.nodeType === ViperUtil.TEXT_NODE) {
                                    range.setEnd(firstChild, 0);
                                } else {
                                    range.selectNode(firstChild);
                                }
                            } else {
                                range.selectNode(prevSelectable);
                            }

                            range.collapse(false);
                            ViperSelection.addRange(range);
                        }

                        this._viper.contentChanged();

                        return false;
                    } //end if
                }//end if
            } else if (range.startOffset === 0
                && range.collapsed === false
                && ViperUtil.isBrowser('msie') !== true
            ) {
                // Chrome has issues with removing list items from lists.
                var startNode = range.getStartNode();
                var endNode   = range.getEndNode();

                // First issue is, if a whole list item is selected, it removes the li
                // and it adds a span tag in place of it, creating invalid HTML and
                // causing all sorts of issues. It should only remove the list item
                // contents and leave the list item un touched..
                if (startNode === endNode
                    && startNode.nodeType === ViperUtil.TEXT_NODE
                    && ViperUtil.isTag(startNode.parentNode, 'li') === true
                    && startNode.data.length === range.endOffset
                ) {
                    ViperUtil.setHtml(startNode.parentNode, '<br />');
                    this._viper.contentChanged();
                    return false;
                } else if ((ViperUtil.isTag(range.commonAncestorContainer, 'ul') || ViperUtil.isTag(range.commonAncestorContainer, 'ol'))) {
                    // Second issue is with removing multiple list items.
                    if (endNode.data.length === range.endOffset) {
                        var endItem = ViperUtil.getParents(endNode, 'li')[0];
                        if (endNode === range._getLastSelectableChild(endItem)) {
                            // Whole list item is selected.
                            // Get the start list item and all other list items until
                            // the end list item.
                            var startItem = ViperUtil.getParents(startNode, 'li')[0];
                            if (startNode === range._getFirstSelectableChild(startItem)) {
                                var elements = ViperUtil.getElementsBetween(startItem, endItem);
                                elements.push(startItem, endItem);

                                var parent = startItem.parentNode;
                                this._viper.moveCaretAway(startItem, true);

                                // Remove list items.
                                ViperUtil.remove(elements);

                                // Remove the list element (ul,ol) if its now empty.
                                if (ViperUtil.getTag('li', parent).length === 0) {
                                    ViperUtil.remove(parent);
                                }

                                this._viper.contentChanged();
                                return false;
                            }//end if
                        }//end if
                    }//end if
                }//end if
            } else if (range.startOffset === 0
                && range.collapsed === true
                && range.startContainer === range.endContainer
                && e.keyCode === 8
                && (ViperUtil.elementIsEmpty(range.startContainer) === true || ViperUtil.getHtml(range.startContainer) === '<br>')
            ) {
                if ((ViperUtil.isTag(range.startContainer, 'br') !== true
                    || (ViperUtil.isTag(range.startContainer.parentNode, 'td') === false
                    && ViperUtil.isTag(range.startContainer.parentNode, 'th') === false))
                    && (ViperUtil.isTag(range.startContainer, 'td') === false
                        && ViperUtil.isTag(range.startContainer, 'th') === false)
                ) {
                    var skippedBlockElem = [];
                    var endCont = range.endContainer;
                    var node    = range.getPreviousContainer(range.startContainer, skippedBlockElem, true, true);
                    var isList  = false;

                    var startOffset = 0;
                    if (!node || ViperUtil.isChildOf(node, this._viper.element) === false) {
                        if (skippedBlockElem.length > 0) {
                            for (var i = 0; i < skippedBlockElem.length; i++) {
                                if (ViperUtil.isTag(skippedBlockElem[i], 'p') === true) {
                                    ViperUtil.remove(skippedBlockElem[i]);
                                }
                            }
                        }

                        node = endCont;
                        if (ViperUtil.isTag(node, 'li') === false) {
                            return false;
                        } else {
                            isList = true;
                        }
                    } else if (node.nodeType === ViperUtil.TEXT_NODE) {
                        startOffset = node.data.length;
                        if (endCont.previousSibling !== null && ViperUtil.isBlockElement(endCont.previousSibling) === false && node.data.length > 0) {
                            startOffset--;
                            node.data = node.data.substr(0, startOffset);
                        }
                    }

                    range.setEnd(node, startOffset);
                    range.collapse(false);
                    ViperSelection.addRange(range);

                    if (endCont
                        && endCont.nodeType === ViperUtil.ELEMENT_NODE
                        && (ViperUtil.isTag(endCont, 'td') === true || ViperUtil.isTag(endCont, 'th') === true)
                    ) {
                        return;
                    }

                    var parent = endCont.parentNode;
                    ViperUtil.remove(endCont);
                    while (parent.childNodes.length === 0) {
                        if (parent === viperElement) {
                            break;
                        }

                        var remove = parent;
                        parent = parent.parentNode;
                        ViperUtil.remove(remove);
                    }

                    if (isList && parent === this._viper.getViperElement()) {
                        node = range._getFirstSelectableChild(parent, true);
                        if (!node) {
                            this._viper.initEditableElement();
                            node = range._getFirstSelectableChild(parent, true);
                        }
                    }

                    range.setEnd(node, startOffset);
                    range.collapse(false);
                    ViperSelection.addRange(range);

                    this._viper.contentChanged();
                    return false;
                } else if (!range.startContainer.previousSibling) {
                    return false;
                } else if (ViperUtil.isTag(range.startContainer, ['td', 'th']) === true) {
                    return false;
                }
            }

            var nodeSelection = range.getNodeSelection();
            if (nodeSelection && ViperUtil.isBlockElement(nodeSelection) === true) {
                // A block element is selected.
                if (ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), this._keepContainerList) === true) {
                    // Cannot remove this parent, clear contents instead.
                    ViperUtil.setHtml(nodeSelection, '<br/>');
                    range.setStart(nodeSelection, 0);
                    range.collapse(true);
                } else {
                    this._viper.moveCaretAway(nodeSelection, true);
                    ViperUtil.remove(nodeSelection);
                }

                this._viper.contentChanged();
                return false;
            }

            if (range.collapsed === true) {
                // Range collapsed.
                if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE) {
                    // Container is an element node.
                    var childCount = range.startContainer.childNodes.length;
                    if (range.startOffset === childCount || range.startOffset === (childCount - 1)) {
                        // Range is outside of childNodes count.
                        var lastChild = range.startContainer.childNodes[(childCount - 1)];
                        var textNode  = null;

                        // Find the relevant text node.
                        if (ViperUtil.isStubElement(ViperUtil.getSurroundedChildren(range.startContainer).pop()) === true) {
                            // Remove the whole element.
                            textNode = range.getPreviousContainer(range.startContainer);
                            ViperUtil.remove(range.startContainer);
                            if (textNode) {
                                range.setStart(textNode, textNode.data.length);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }

                            this._viper.contentChanged();
                            return false;
                        } else if (ViperUtil.isStubElement(lastChild) === true) {
                            // For stub elements get the previous container.
                            textNode = range.getPreviousContainer(lastChild);
                            ViperUtil.remove(lastChild);
                            if (textNode) {
                                range.setStart(textNode, textNode.data.length);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }

                            this._viper.contentChanged();
                            return false;
                        } else if (lastChild.nodeType === ViperUtil.ELEMENT_NODE) {
                            // Node with content, get the last selectable child.
                            textNode = range._getLastSelectableChild(lastChild);
                        } else if (lastChild.nodeType === ViperUtil.TEXT_NODE) {
                            // Text node.
                            if (lastChild.data.length > 0) {
                                textNode = lastChild
                            } else {
                                // Empty text node, get previousContainer.
                                textNode = range.getPreviousContainer(lastChild);
                            }
                        }

                        if (textNode) {
                            textNode.data = textNode.data.substr(0, (textNode.data.length - 1));
                            range.setStart(textNode, textNode.data.length);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.contentChanged();
                            return false;
                        }
                    }
                } else {
                    // Text node.
                    if (range.startOffset > 0) {
                        // Delete a character from left.
                        var textNode = range.startContainer;
                        textNode.data = textNode.data.substr(0, range.startOffset - 1) + textNode.data.substr(range.startOffset);

                        // Normalise text nodes.
                        this._normaliseNextNodes(textNode);

                        if (textNode.data === ' '
                            && textNode.nextSibling === null
                            && textNode.previousSibling
                            && ViperUtil.isTag(textNode.previousSibling, 'br') === true
                        ) {
                            // Handle case: <td>text <strong>text</strong><br> t*</td>. This will cause "line" to collapse
                            // which causes caret to appear between previous line and the line where delete happened.
                            // To prevent that add a BR at the end of the container and remove the space as its not
                            // visible.
                            textNode.data = '';
                            var br        = document.createElement('br');
                            textNode.parentNode.appendChild(br);
                            range.setStart(textNode, 0);
                        } else {
                            range.setStart(textNode, range.startOffset - 1);
                        }

                        range.collapse(true);

                        if (textNode.data.length === 0
                            && textNode.nextSibling === null
                            && textNode.previousSibling === null
                            && ViperUtil.isBlockElement(textNode.parentNode) === true
                        ) {
                            // The last character of this text node was deleted and now the block parent has no content.
                            // Add a BR to keep the blockelement 'selectable'.
                            var br = document.createElement('br');
                            textNode.parentNode.appendChild(br);
                        }

                        ViperSelection.addRange(range);
                        this._viper.contentChanged();
                        return false;
                    } else {
                        this._normaliseNextNodes(range.startContainer);

                        // At the beginning of text node.
                        if (range.startContainer.previousSibling === null
                            && (range.startContainer.nextSibling === null || ViperUtil.isTag(range.startContainer.nextSibling, 'br') === true)
                        ) {
                            // This is the only node in the parent.
                            // Set the range before the parent and remove it.
                            var parent            = range.startContainer.parentNode;
                            var previousContainer = range.getPreviousContainer(range.startContainer);
                            if (previousContainer) {
                                // Remove last character.
                                previousContainer.data = previousContainer.data.substr(0, previousContainer.data.length - 1);
                                range.setStart(previousContainer, previousContainer.data.length);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                ViperUtil.remove(parent);
                                this._viper.contentChanged();
                                return false;
                            }
                        } else if (this._viper.isSpecialElement(range.startContainer.previousSibling) === true
                            || ViperUtil.isStubElement(range.startContainer.previousSibling) === true
                            || ViperUtil.isStubElement(ViperUtil.getSurroundedChildren(range.startContainer.previousSibling).pop()) === true
                        ) {
                            // Previous sibling is a stub element (img, br, hr etc).
                            var node = range.startContainer.previousSibling;
                            var surroundingParents = ViperUtil.getSurroundingParents(node);
                            if (surroundingParents.length > 0) {
                                node = ViperUtil.remove(surroundingParents.pop());
                            }

                            ViperUtil.remove(node);
                            this._viper.contentChanged();
                            return false;
                        } else {
                            var previousContainer = range.getPreviousContainer(range.startContainer);
                            if (previousContainer) {
                                if (this._viper.isOutOfBounds(previousContainer) === true) {
                                    if (range.startContainer.previousSibling) {
                                        ViperUtil.remove(range.startContainer.previousSibling);
                                        this._viper.contentChanged(true);
                                        return false;
                                    }
                                } else {
                                    if (previousContainer.nodeType === ViperUtil.TEXT_NODE) {
                                        range.setStart(previousContainer, previousContainer.data.length);
                                    } else if (ViperUtil.isStubElement(previousContainer) === true) {
                                        // Handle case <p>text<strong>text</strong><br/>*</p>.
                                        ViperUtil.remove(previousContainer);
                                        this._viper.contentChanged(true);
                                        return false;
                                    } else {
                                        range.setStart(previousContainer, 0);
                                    }

                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                    return;
                                }
                            }
                        }
                    }
                }
            } else {
                // Selection.
                if (range.startContainer === range.endContainer) {
                    // Same container.
                    if (range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                        // Text node selection. Modify node content.
                        var textNode = range.startContainer;
                        if (range.startOffset === 0 && range.endOffset === textNode.data.length) {
                            // The whole textnode is selected.
                            // Clear the contents of the text node.
                            textNode.data = '';

                            if (ViperUtil.isEmptyElement(textNode.parentNode) === true) {
                                // Parent is now empty.
                                var parent = textNode.parentNode;
                                if (ViperUtil.isBlockElement(parent) === true) {
                                    this._viper.moveCaretAway(parent, true);
                                    ViperUtil.remove(parent);
                                    this._viper.contentChanged();
                                    return false;
                                } else if (parent.previousSibling && parent.previousSibling.nodeType === ViperUtil.TEXT_NODE) {
                                    textNode = parent.previousSibling;
                                } else {
                                    ViperUtil.insertBefore(parent, textNode)
                                }

                                range.setStart(textNode, textNode.data.length);
                                range.collapse(true);

                                ViperUtil.remove(parent);
                            }

                            this._viper.contentChanged();
                            return false;
                        }
                    }
                } else {
                    // Different start and end containers.
                    if (range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                        // Start container is text node.
                        if (range.endContainer.nodeType === ViperUtil.TEXT_NODE) {
                            if (this._deleteFromDifferentBlockParents(range) === false) {
                                // Delete op was handled.
                                return false;
                            }

                            // And the end container is text node.
                            var container = null;
                            var offset    = 0;
                            if (range.startOffset === 0) {
                                // Selection is at the start of this text node and the end container is different.
                                // This means the startContainer will be removed, therfore use endContainer unless it is also empty.
                                if (range.endOffset === range.endContainer.data.length) {
                                    // Both the start container and the end container will be removed.
                                    container = document.createTextNode('');
                                    ViperUtil.insertBefore(range.startContainer, container);
                                    offset = 0;
                                } else {
                                    // The endContainer will remain after deletion use it to set the range.
                                    container = range.endContainer;
                                    offset    = 0;
                                }
                            } else {
                                container = range.startContainer;
                                offset    = range.startOffset;
                            }

                            // Let browser delete the contents but adjust the range after.
                            var self = this;
                            setTimeout(function () {
                                if (container.data.length === 0 && container.parentNode.childNodes.length === 1 && ViperUtil.isBlockElement(container.parentNode) === false) {
                                    var parent = container.parentNode;
                                    ViperUtil.insertBefore(container.parentNode, container);
                                    ViperUtil.remove(parent);
                                }

                                if (ViperUtil.isText(container.previousSibling) === true) {
                                    container = container.previousSibling;
                                    offset    = container.data.length;
                                    ViperUtil.normaliseTextNodeSiblings(container);
                                }

                                range.setStart(container, offset);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }, 10);
                        }
                    }
                }
            }

            if (ViperUtil.isBrowser('msie') === true
                && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === range.endContainer.data.length
                && range.startOffset === 0
                && range.endContainer !== range.startContainer
                && ViperUtil.getFirstBlockParent(range.startContainer) !== ViperUtil.getFirstBlockParent(range.endContainer)
                && range._getFirstSelectableChild(ViperUtil.getFirstBlockParent(range.startContainer)) === range.startContainer
                && range._getLastSelectableChild(ViperUtil.getFirstBlockParent(range.endContainer)) === range.endContainer
            ) {
                // Handle: <p><strong>*test</strong>test</p><p>test</p>, <p><strong>test</strong>test</p><p>test<strong>test*</strong></p>
                // In these cases once the paragraphs are removed and a new character is inserted it gets wrapped with the
                // inline tag.
                var startParent = range.startContainer.parentNode;
                if (ViperUtil.isBlockElement(startParent) === false && !startParent.previousSibling) {
                    var surroundingParents = ViperUtil.getSurroundingParents(startParent);
                    if (surroundingParents.length > 0) {
                        startParent = surroundingParents.pop();
                    }

                    var tmpNode = document.createTextNode(' ');
                    ViperUtil.insertBefore(startParent, tmpNode);
                    range.setStart(tmpNode, 0);
                }

                var endParent = range.endContainer.parentNode;
                if (ViperUtil.isBlockElement(endParent) === false && !endParent.nextSibling) {
                    var surroundingParents = ViperUtil.getSurroundingParents(endParent);
                    if (surroundingParents.length > 0) {
                        endParent = surroundingParents.pop();
                    }

                    var tmpNode = document.createTextNode(' ');
                    ViperUtil.insertAfter(endParent, tmpNode);
                    range.setEnd(tmpNode, 1);
                }

                ViperSelection.addRange(range);
            }//end if

            if (range.collapsed === false) {
                var nodeSelection = range.getNodeSelection();
                if (nodeSelection) {
                    if (nodeSelection === this._viper.getViperElement()) {
                        ViperUtil.setHtml(nodeSelection, '');
                        this._viper.initEditableElement();
                    }  else if (ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), this._keepContainerList) === true) {
                        // Remove only the contents when a whole element is selected but the element cannot be
                        // removed (e.g. TD, as it would break the layout).
                        ViperUtil.setHtml(nodeSelection, '<br/>');
                        range.setStart(nodeSelection, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.contentChanged(false, range);
                        return false;
                    } else {
                        var parents = ViperUtil.getSurroundingParents(nodeSelection, null, null, this.viperElement);
                        if (parents.length > 0) {
                            var topParent = parents.pop();
                            if (topParent === this._viper.getViperElement()) {
                                if (parents.length > 0) {
                                    nodeSelection = parents.pop();
                                }
                            } else {
                                nodeSelection = topParent;
                            }
                        }

                        range = this._viper.moveCaretAway(nodeSelection);
                        ViperUtil.remove(nodeSelection);
                        if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                            && range.startContainer.previousSibling
                            && range.startContainer.previousSibling.nodeType === ViperUtil.TEXT_NODE
                        ) {
                            // Join nodes.
                            var length = range.startContainer.previousSibling.data.length;
                            var prev   = range.startContainer.previousSibling;
                            ViperUtil.remove(range.startContainer);
                            if (prev.data.charAt(length - 1) === ' ' && range.startContainer.data.charAt(0) === ' ') {
                                // When joining nodes end and start with a space character, Webkit seems to ignore the 2nd space.
                                // Make sure 2nd space is converted to non breaking space character.
                                prev.data += String.fromCharCode(160);
                                if (range.startContainer.data.length > 1) {
                                    prev.data += range.startContainer.data.substring(1, range.startContainer.data.length);
                                }
                            } else {
                                prev.data += range.startContainer.data;
                            }

                            range.setStart(prev, length);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                        }
                    }

                    this._viper.contentChanged();
                    return false;
                }
            }//end if

            if (this._handleBackspaceAtStartOfLi(e, range) === false) {
                return false;
            }

            if (this._isStartToEndOfMultiContainerSelection(range) === true) {
                return this._removeContentFromStartToEndOfContainers(range)
            }

        },

        _normaliseNextNodes: function (textNode) {
            while (textNode.nextSibling && textNode.nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                if (textNode.nextSibling.data.length > 0) {
                    textNode.data += textNode.nextSibling.data;
                }

                ViperUtil.remove(textNode.nextSibling);
            }

        },

        _deleteFromDifferentBlockParents: function (range)
        {
            if (this._isStartToEndOfMultiContainerSelection(range) === true) {
                return this._removeContentFromStartToEndOfContainers(range);
            }

            var startParent = range.startContainer;
            var endParent   = range.endContainer;

            if (ViperUtil.isBlockElement(startParent) === false) {
                startParent = ViperUtil.getFirstBlockParent(range.startContainer);
            }

            if (ViperUtil.isBlockElement(endParent) === false) {
                endParent = ViperUtil.getFirstBlockParent(range.endContainer);
            }

            if (startParent !== endParent) {
                // Two different parents. We need to join these parents.
                // First remove all elements in between.
                range.deleteContents();

                if (range.startContainer.parentNode && ViperUtil.isEmptyElement(range.startContainer.parentNode) === true) {
                    ViperUtil.remove(range.startContainer.parentNode);
                }

                if (ViperUtil.isEmptyElement(endParent) === false) {
                    // If the startParent is empty remove it if the endParent is the viperElement.
                    if (ViperUtil.isBlank(ViperUtil.trim(ViperUtil.getHtml(startParent))) !== true
                        || endParent != this._viper.getViperElement()
                    ) {
                        // Now bring the contents of the next selectable to the
                        // start parent.
                        var nextSelectable = range.getNextContainer(range.startContainer, null, true);
                        if (this._viper.isOutOfBounds(nextSelectable) === false) {
                            var nextParent = ViperUtil.getFirstBlockParent(nextSelectable);
                            if (startParent !== nextParent) {
                                while (nextParent.firstChild) {
                                    startParent.appendChild(nextParent.firstChild);
                                }

                                if (this.canRemoveNode(nextParent) === true) {
                                    ViperUtil.remove(nextParent);
                                }
                            }
                        }
                    } else {
                        ViperUtil.remove(startParent);
                    }
                } else {
                    ViperUtil.remove(endParent);
                }

                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.contentChanged();
                return false;
            }

        },

        _handleBackspaceAtStartOfLi: function(e, range)
        {
            if (e.which === 46 || range.startOffset !== 0) {
                return;
            }

            // Handle backspace at the start of a list (LI) element.
            if (range.collapsed === true && range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                var firstBlock      = ViperUtil.getFirstBlockParent(range.startContainer);
                var firstSelectable = range._getFirstSelectableChild(firstBlock);
                if (firstBlock
                    && ViperUtil.isTag(firstBlock, 'li') === true
                    && firstSelectable === range.startContainer
                    && !firstSelectable.previousSibling
                ) {
                     // Check if there is a parent element with a selectable.
                    var prevSelectable = range.getPreviousContainer(firstSelectable, null, true, true);
                    var prevParent     = prevSelectable.parentNode;
                    if (prevSelectable && this._viper.isOutOfBounds(prevSelectable) === false) {
                        while (firstBlock.lastChild) {
                            if (ViperUtil.isText(firstBlock.lastChild) === true
                                && ViperUtil.isBlank(ViperUtil.trim(firstBlock.lastChild.data)) === true
                                && firstBlock.lastChild === firstBlock.firstChild
                            ) {
                                // If the text node is empty and its the only child then do not join it to the previous
                                // container.
                                if (firstSelectable === firstBlock.lastChild) {
                                    firstSelectable = null;
                                }

                                ViperUtil.remove(firstBlock.lastChild);
                                continue;
                            }

                            ViperUtil.insertAfter(prevSelectable, firstBlock.lastChild);
                        }

                        if (ViperUtil.isTag(prevSelectable, 'br') === true) {
                            ViperUtil.remove(prevSelectable);
                        }

                        var firstBlockParent = firstBlock.parentNode;
                        ViperUtil.remove(firstBlock);
                        if (ViperUtil.getTag('li', firstBlockParent).length === 0) {
                            ViperUtil.remove(firstBlockParent);
                        }

                        var offset = 0;
                        if (firstSelectable === null) {
                            firstSelectable = range._getLastSelectableChild(prevParent);
                            if (ViperUtil.isText(firstSelectable) === true) {
                                offset = firstSelectable.data.length;
                            }
                        }

                        range.setStart(firstSelectable, offset);
                        range.collapse(true);
                        ViperSelection.addRange(range);

                        this._viper.contentChanged(true);
                        return false;
                    } else {
                        // This is the first LI in the content. Remove it from list.
                        var defaultTagName = this._viper.getDefaultBlockTag();
                        var lastElem       = document.createTextNode('');
                        var newElement     = null;

                        ViperUtil.insertBefore(firstBlock.parentNode, lastElem);
                        while (firstBlock.firstChild) {
                            var child = firstBlock.firstChild;
                            if (ViperUtil.isTag(child, ['ul', 'ol']) === true) {
                                // Child list. It cannot be inside the block element.
                                ViperUtil.insertAfter(lastElem, child);
                                newElement = null;
                                lastElem   = child;
                            } else {
                                if (defaultTagName !== '') {
                                    if (newElement === null) {
                                        newElement = document.createElement(defaultTagName);
                                        ViperUtil.insertAfter(lastElem, newElement);
                                        lastElem = newElement;
                                    }

                                    newElement.appendChild(child);
                                } else {
                                    ViperUtil.insertAfter(lastElem, child);
                                    lastElem = child;
                                }
                            }
                        }

                        ViperUtil.remove(firstBlock);

                        range.setStart(firstSelectable, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.contentChanged(false, range);
                        return false;
                    }//end if
                }//end if
            } else if (range.collapsed === true
                && ViperUtil.isTag(range.startContainer, 'li') === true
                && ViperUtil.getHtml(range.startContainer) === ''
            ) {
                // Happens in IE8, when the list item is empty.

                var offset     = 0;
                var next       = false;
                var li         = range.startContainer;
                var list       = li.parentNode;
                var selectable = range.getPreviousContainer(li, null, true, true);

                if (!selectable || this._viper.isOutOfBounds(selectable) === true) {
                    selectable = range.getNextContainer(li, null, true, true);
                    next       = true;
                    if (!selectable || this._viper.isOutOfBounds(selectable) === true) {
                        // Create a new container.
                        var defaultTagName = this._viper.getDefaultBlockTag();
                        if (defaultTagName !== '') {
                            selectable = document.createElement(defaultTagName);
                            ViperUtil.setHtml(selectable, '&nbsp;');
                        } else {
                            selectable = document.createTextNode(' ');
                        }

                        ViperUtil.insertAfter(list, selectable);
                    }
                } else {
                    offset = selectable.data.length;
                }

                if (selectable) {
                    range.setStart(selectable, offset);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }

                ViperUtil.remove(li);

                // Check if we need to remove the whole list element.
                if (ViperUtil.getTag('li', list).length === 0) {
                    ViperUtil.remove(list);
                }

                this._viper.contentChanged(false, range);
                return false;
            }//end if

        },

        _handleDeleteFromRight: function(e, range)
        {
            if (range.collapsed !== true) {
                // If range is not collapsed then everything in the selection should be removed which is handled by
                // the browser unless its the whole Viper element selection.
                if (this._isWholeViperElementSelected(range) === true) {
                    // The whole Viper element is selected, remove all of its content
                    // and then initialise the Viper element.
                    ViperUtil.setHtml(this._viper.getViperElement(), '');
                    this._viper.initEditableElement();
                    this._viper.contentChanged();
                    return false;
                } else if (this._isStartToEndOfMultiContainerSelection(range) === true) {
                    return this._removeContentFromStartToEndOfContainers(range);
                } else {
                    var nodeSelection = range.getNodeSelection();
                    if (nodeSelection && ViperUtil.isStubElement(nodeSelection) === false) {
                        // When a block element is selected and removed in Firefox it leaves the content as <p>null char</p>.
                        // Handle the deletion here.
                        if (ViperUtil.isTag(nodeSelection, 'td') === true
                            || ViperUtil.isTag(nodeSelection, 'th') === true
                        ) {
                            // Remove only the contents.
                            ViperUtil.setHtml(nodeSelection, '<br>');
                            range.setStart(nodeSelection.firstChild);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                        } else {
                            range = this._viper.moveCaretAway(nodeSelection, true);
                            ViperUtil.remove(nodeSelection);
                            if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                                && range.startContainer.data === ' '
                                && range.startContainer.previousSibling
                                && range.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE
                            ) {
                                // If content is '<em>test</em> <strong>content</strong>' and the sourceElement is
                                // the strong tag then change the space to non breaking space to prevent caret moving in to <em>.
                                range.startContainer.data = String.fromCharCode(160);
                                range.setStart(range.startContainer, range.startContainer.data.length);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }
                        }

                        this._viper.contentChanged();
                        return false;
                    } else if (
                        !nodeSelection
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.startOffset === 0
                        && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.endOffset === 0
                        && range.startContainer !== range.endContainer
                        && ViperUtil.getFirstBlockParent(range.startContainer) === ViperUtil.getFirstBlockParent(range.endContainer)
                    ) {
                        // Handle <p>[<strong>text</strong><br />]more text</p>.
                        var startContainer = range.startContainer;
                        var endContainer   = range.endContainer;
                        var elemsBetween   = ViperUtil.getElementsBetween(startContainer, endContainer);
                        elemsBetween.push(startContainer);
                        ViperUtil.remove(elemsBetween);

                        range.setStart(endContainer, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.contentChanged();
                        return false;
                    } else if (
                        !nodeSelection
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.endOffset === range.endContainer.data.length
                    ) {
                        // Handle Firefox case: <p>text [text <strong>more text]</strong> more text</p> was resulting in
                        // <p>text <strong>*</strong> more text</p> it should be <p>text * more text</p>.
                        var self = this;
                        setTimeout(function() {
                            var range     = self._viper.getViperRange();
                            var node      = range.startContainer;
                            var rangeNode = node.previousSibling;

                            if (node.nodeType !== ViperUtil.ELEMENT_NODE) {
                                if (node.nextSibling && node.nextSibling.nodeType === ViperUtil.ELEMENT_NODE) {
                                    rangeNode = node;
                                    node = node.nextSibling;
                                } else {
                                    node = null;
                                }
                            }

                            if (node
                                && node
                                && node.nodeType === ViperUtil.ELEMENT_NODE
                                && !range._getFirstSelectableChild(node)
                            ) {
                                ViperUtil.remove(node);
                                range.setStart(rangeNode, range.startOffset);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            } else {
                                node = range.getStartNode();
                                if (node && ViperUtil.isText(node) === false && ViperUtil.elementIsEmpty(node) === true) {
                                    // Node is empty, check siblings and join text nodes if needed.
                                    var rangeNode = null;
                                    var offset    = 0;
                                    if (ViperUtil.isText(node.previousSibling) === true) {
                                        rangeNode = node.previousSibling;
                                        offset    = node.previousSibling.data.length;

                                        if (ViperUtil.isText(node.nextSibling) === true) {
                                            // Join these nodes.
                                            ViperUtil.remove(node);
                                            ViperUtil.normaliseTextNodeSiblings(node)
                                        } else {
                                            ViperUtil.remove(node);
                                        }
                                    } else if (ViperUtil.isText(node.nextSibling) === true) {
                                        rangeNode = node.nextSibling;
                                        ViperUtil.remove(node);
                                    }

                                    range.setStart(rangeNode, offset);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                }
                            }
                        }, 10);
                    }
                }

                return;
            }//end if

            // Range collapsed.
            var startNode = range.getStartNode();
            if (!startNode) {
                if (!range.startContainer
                    || range.startContainer.nodeType !== ViperUtil.ELEMENT_NODE
                    || range.startContainer !== range.endContainer
                ) {
                    return;
                }

                startNode = range.startContainer;
            }

            // Do a few range checks..
            if (startNode.nodeType === ViperUtil.ELEMENT_NODE) {
                if (range.startContainer === startNode
                    && startNode.childNodes.length === range.startOffset
                    && ViperUtil.isText(startNode.lastChild)
                ) {
                    // When the range is set after the last text node of a parent
                    // move the range to the end of the text node.
                    range.setStart(startNode.lastChild, startNode.lastChild.length);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                    startNode = startNode.lastChild;
                }
            }

            if (startNode.nodeType === ViperUtil.TEXT_NODE) {
                // In a text node.
                if (range.startOffset === startNode.data.length) {
                    // End of the text node.
                    if (this._viper.isSpecialElement(startNode.nextSibling) === true) {
                        // Remove the whole special element.
                        ViperUtil.remove(startNode.nextSibling);
                        this._viper.contentChanged();
                        return false;
                    } else if (ViperUtil.isStubElement(ViperUtil.getSurroundedChildren(startNode.nextSibling).pop()) === true) {
                        ViperUtil.remove(startNode.nextSibling);
                        this._viper.contentChanged();
                        return false;
                    } else if (ViperUtil.isStubElement(startNode.nextSibling) === true
                        && (ViperUtil.isTag(startNode.nextSibling, 'br') === false || startNode.nextSibling.nextSibling)
                    ) {
                        // If the next sibling is a BR but its not the last node then remove.
                        ViperUtil.remove(startNode.nextSibling);
                        this._viper.contentChanged();
                        return false;
                    } else if (!startNode.nextSibling) {
                        // Check if the next container is a special element.
                        var nextSelectable = range.getNextContainer(startNode, null, true, true, true);
                        if (nextSelectable && this._viper.isSpecialElement(nextSelectable.parentNode) === true) {
                            ViperUtil.remove(nextSelectable.parentNode);
                        }
                    } else {
                        // There is a next node.
                        if (ViperUtil.isTag(startNode.nextSibling, 'br') === true && !startNode.nextSibling.nextSibling) {
                            ViperUtil.remove(startNode.nextSibling);

                            var selectable = range.getNextContainer(startNode, null, true, true);
                            if (!selectable || this._viper.isOutOfBounds(selectable) === true) {
                                // Stop here nothing else to delete.
                                return false;
                            }

                            var firstBlock = ViperUtil.getFirstBlockParent(selectable);
                            if (firstBlock) {
                                // Move children.
                                var len = startNode.data.length;
                                ViperUtil.moveChildrenToElement(firstBlock, ViperUtil.getFirstBlockParent(startNode), true);
                                ViperUtil.remove(firstBlock);
                                range.setStart(startNode, len);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                this._viper.contentChanged();
                                return false;
                            }
                        }
                    }

                    // Check for HR element.
                    var foundSib  = false;
                    while (startNode) {
                        for (var node = startNode.nextSibling; node; node = node.nextSibling) {
                            if (node.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isTag(node, 'hr') === true) {
                                // Found the HR element, remove it.
                                ViperUtil.remove(node);
                                this._viper.contentChanged();
                                return false;
                            } else if (node.nodeType !== ViperUtil.TEXT_NODE || ViperUtil.trim(node.data).length !== 0) {
                                // Not an empty text node or another node type, no need to continue.
                                foundSib = true;
                                break;
                            }
                        }

                        if (foundSib === true) {
                            break;
                        } else if (ViperUtil.isTag(startNode, 'td') === true || ViperUtil.isTag(startNode, 'th') === true) {
                            return false;
                        }

                        startNode = startNode.parentNode;
                    }//end while
                } else if (range.startContainer !== startNode && range.startOffset === 0) {
                    range.setStart(startNode, 0);
                } else if (range.startOffset === 0
                    && (ViperUtil.isBrowser('msie', '<9') === true || ViperUtil.isBrowser('edge') === true)
                ) {
                    if (range.startContainer.data.length > 1) {
                        range.startContainer.data = range.startContainer.data.substr(1);
                        if (range.startContainer.data[0] === ' ') {
                            range.startContainer.data = String.fromCharCode(160) + range.startContainer.data.substr(1);
                        }

                        range.setStart(range.startContainer, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    } else {
                        var surroundingParents = ViperUtil.getSurroundingParents(range.startContainer, null, null, null, true);
                        if (surroundingParents.length > 0) {
                            var parent = surroundingParents.pop();
                            if (ViperUtil.isBlockElement(parent) === false) {
                                if (parent.nextSibling && ViperUtil.isStubElement(parent.nextSibling) === true) {
                                    ViperUtil.insertAfter(parent, document.createTextNode(''));
                                    range.setStart(parent.nextSibling, 0);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                } else {
                                    this._viper.moveCaretAway(range.startContainer);
                                }

                                ViperUtil.remove(parent);
                            } else {
                                range.startContainer.data = '';
                                range.setStart(range.startContainer, 0);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }
                        } else {
                            this._viper.moveCaretAway(range.startContainer);
                            ViperUtil.remove(range.startContainer);
                        }
                    }

                    this._viper.contentChanged();

                    return false;
                }//end if
            } else {
                // Element Node.
                var startNodeIsStub = ViperUtil.isStubElement(startNode);
                if (startNodeIsStub === false) {
                    var textNode = range._getFirstSelectableChild(startNode);
                    if (textNode) {
                        range.setStart(textNode, 0);
                    }
                } else if (ViperUtil.isTag(startNode, 'br') === true
                    && startNode.parentNode
                    && (ViperUtil.isBrowser('firefox') === true || ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true)
                ) {
                    var nextSelectable = range.getNextContainer(startNode, null, true, true);
                    if (this._viper.isOutOfBounds(nextSelectable) === true) {
                        return false;
                    }

                    if (nextSelectable) {
                        var startParent = startNode.parentNode;
                        if (startParent.childNodes.length === 1 && ViperUtil.isTag(startNode.parentNode, ['td', 'th']) === false) {
                            ViperUtil.remove(startParent);
                        } else {
                            // IE sets the range to incorrect place if this node is not removed in a timeout...
                            setTimeout(function() {
                                ViperUtil.remove(startNode);
                            }, 100);
                        }

                        range.setStart(nextSelectable, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                        this._viper.contentChanged();
                        return false;
                    } else if (startNode.parentNode.childNodes.length === 1) {
                        var tmpNode = document.createTextNode('');
                        startNode.parentNode.appendChild(tmpNode);
                        ViperUtil.remove(startNode);
                        range.setStart(tmpNode);
                    } else if (startNode.nextSibling
                        && startNode.nextSibling.nodeType === ViperUtil.TEXT_NODE
                    ) {
                        // Handle <p><strong>[delete key * 2]t</strong><br />more text</p>.
                        range.setStart(startNode.nextSibling, 0);
                        range.collapse(true);
                        ViperUtil.remove(startNode);
                        ViperSelection.addRange(range);
                        this._viper.contentChanged();
                        return false;
                    }
                } else if (startNodeIsStub === true) {
                    if (!startNode.nextSibling && ViperUtil.isTag(startNode, 'br') === true) {
                        var nextSelectable = range.getNextContainer(startNode, null, true, true);
                        if (!nextSelectable || this._viper.isOutOfBounds(nextSelectable) === true) {
                            // Most likely the last content. Do nothing.
                            return false;
                        }
                    }

                    this._viper.moveCaretAway(startNodeIsStub);
                    var surroundingParents = ViperUtil.getSurroundingParents(startNodeIsStub);
                    ViperUtil.remove(surroundingParents.pop() || startNode);
                }
            }//end if

            if (ViperUtil.isTag(startNode, 'br') === true
                && (ViperUtil.isTag(startNode.parentNode, 'td') === true
                || ViperUtil.isTag(startNode.parentNode, 'th') === true)
            ) {
                return false;
            } else if (ViperUtil.isTag(startNode.parentNode, 'li') === true
                && ViperUtil.getHtml(startNode.parentNode) === '<br>'
            ) {
                return false;
            }

            var startContainer = range.startContainer;
            if (startContainer.nodeType !== ViperUtil.TEXT_NODE) {
                var startNode = range.getStartNode();
                if (startNode && startNode.nodeType !== ViperUtil.TEXT_NODE) {
                    var nextSelectable = range.getNextContainer(startContainer, null, true, true, true);

                    if (nextSelectable) {
                        var startParent = range.startContainer;
                        var endParent   = ViperUtil.getFirstBlockParent(nextSelectable);
                        if (ViperUtil.isBlockElement(startParent) === false) {
                            startParent = ViperUtil.getFirstBlockParent(startParent);
                        }

                        if (startParent !== nextSelectable) {
                            // Handle: <p><img />*</p><p>text</p> -> <p><img />text</p>.
                            range.setEnd(nextSelectable, 0);
                            this._deleteFromDifferentBlockParents(range);
                            return false;
                        }
                    }
                }
            } else if (ViperUtil.isBrowser('msie') === true) {
                if (range.startOffset === range.startContainer.data.length
                    && range.startContainer.data.charCodeAt(range.startContainer.data.length - 1) === 160
                    && range.startContainer.nextSibling
                    && range.startContainer.nextSibling.nodeType === ViperUtil.TEXT_NODE
                    && range.startContainer.nextSibling.data[0] === ' '
                ) {
                    // Handle: <p>test * test</p> -> <p>test *test</p>.
                    range.startContainer.data = range.startContainer.data.substr(0, range.startContainer.data.length - 1) + ' ';
                } else if (!range.startContainer.nextSibling
                    && range.collapsed === true
                    && ViperUtil.isBlockElement(range.startContainer.parentNode) === true
                    && range.startContainer.data.length === 1
                ) {
                    // Insert a br element at the end.
                    range.startContainer.parentNode.appendChild(document.createElement('br'));
                }
            }

        },

        _handleDeleteForWebkit: function(e, range)
        {
            if (this._handleBackspaceAtStartOfLi(e, range) === false) {
                return false;
            }

            // This block of code is a workaround for the delete bug in Chrome.
            // See http://goo.gl/QPB0v
            if (e.keyCode === 46
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === range.startContainer.data.length
                && (!range.startContainer.nextSibling || ViperUtil.isStubElement(range.startContainer.nextSibling) === true)
            ) {
                // At the end of an element. Check to see if next available
                // element is a block.
                var nextSelectable = range.getNextContainer(range.startContainer, null, false, true);
                var currentParent  = ViperUtil.getFirstBlockParent(range.startContainer);
                var nextParent     = ViperUtil.getFirstBlockParent(nextSelectable);
                if (currentParent !== nextParent && this._viper.isOutOfBounds(nextSelectable) === false) {
                    if (ViperUtil.isTag(currentParent, 'td') === true || ViperUtil.isTag(currentParent, 'th') === true) {
                        // At the end of a cell.. Do nothing.
                        return false;
                    }

                    if (currentParent.nextSibling !== nextParent && ViperUtil.isStubElement(currentParent.nextSibling) === true) {
                        ViperUtil.remove(currentParent.nextSibling);
                        this._viper.contentChanged(true);
                        return false;
                    }

                    if (ViperUtil.isTag(currentParent.lastChild, 'br') === true) {
                        ViperUtil.remove(currentParent.lastChild);
                    }

                    while (nextParent.firstChild) {
                        currentParent.appendChild(nextParent.firstChild);
                    }

                    ViperUtil.remove(nextParent);
                    this._viper.contentChanged(true);
                    return false;
                }
            } if (e.keyCode === 46
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && ViperUtil.isTag(range.getStartNode(), 'br') === true
            ) {
                var startNode = range.getStartNode();
                if (ViperUtil.isTag(startNode.parentNode, 'td') === true || ViperUtil.isTag(startNode.parentNode, 'th') === true) {
                    if (!startNode.nextSibling) {
                        return false;
                    }
                }

                var selectable = range.getNextContainer(startNode, null, true, true);
                if (!selectable || this._viper.isOutOfBounds(selectable) === true) {
                    // Stop here nothing else to delete.
                    return false;
                }

                var parent = startNode.parentNode;
                if (!startNode.nextSibling && !startNode.previousSibling) {
                   ViperUtil.remove(startNode.parentNode);
                } else {
                    ViperUtil.remove(startNode);
                }

                if (parent.childNodes.length === 0) {
                    ViperUtil.remove(parent);
                }

                if (selectable) {
                    range.setStart(selectable, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }

                this._viper.contentChanged(true);
                return false;
            } else if (e.keyCode === 8
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && (range.startOffset === 0 || (range.startOffset === 1 && range.startContainer.data.charAt(0) === ' '))
                && (!range.startContainer.previousSibling || ViperUtil.isTag(range.startContainer.previousSibling, 'br') === true)
            ) {
                // At the start of an element. Check to see if the previous
                // element is a part of another block element. If it is then
                // join these elements.
                var prevSelectable = range.getPreviousContainer(range.startContainer, null, true, true);
                var currentParent  = ViperUtil.getFirstBlockParent(range.startContainer);
                var prevParent     = ViperUtil.getFirstBlockParent(prevSelectable);

                if (currentParent
                    && range._getFirstSelectableChild(currentParent) === range.startContainer
                    && currentParent.previousElementSibling
                    && ViperUtil.isStubElement(currentParent.previousElementSibling) === true
                ) {
                    // Previous element is a stub element, remove it.
                    ViperUtil.remove(currentParent.previousElementSibling);
                    this._viper.contentChanged();
                    return false;
                } else if (currentParent !== prevParent && this._viper.isOutOfBounds(prevSelectable) === false) {
                    // Check if there are any other elements in between.
                    var elemsBetween = ViperUtil.getElementsBetween(prevParent, currentParent);
                    var removeParent = true;
                    if (elemsBetween.length > 0) {
                        // There is at least one non block element in between. Remove it.
                        for (var i = (elemsBetween.length - 1); i >= 0; i--) {
                            var el = elemsBetween[(elemsBetween.length - 1)];
                            if (el.nodeType !== ViperUtil.TEXT_NODE || ViperUtil.trim(el.data).length !== 0 ) {
                                if (ViperUtil.isTag(el, 'blockquote') !== true && ViperUtil.isTag(prevParent, 'p') === true) {
                                    removeParent = false;
                                }

                                break;
                            }

                            ViperUtil.remove(el);
                        }
                    }

                    if (removeParent === true) {
                        while (currentParent.firstChild) {
                            prevParent.appendChild(currentParent.firstChild);
                        }

                        if (ViperUtil.isTag(currentParent, ['td', 'th']) === false) {
                            ViperUtil.remove(currentParent);
                        }

                        if (prevSelectable.nodeType === ViperUtil.TEXT_NODE) {
                            range.setStart(prevSelectable, prevSelectable.data.length);
                        } else {
                            range.setStartAfter(prevSelectable);
                        }

                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }

                    this._viper.contentChanged(true);

                    return false;
                } else if (ViperUtil.isTag(prevSelectable, 'br') === true) {
                    ViperUtil.remove(prevSelectable);
                    this._viper.contentChanged(true);
                    return false;
                }
            } else if (
                range.collapsed === false
                && range.startContainer !== range.endContainer
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
            ) {
                // This is a selection on different text nodes. Check to see
                // if these nodes are part of two different block elements.
                var nodeSelection = range.getNodeSelection();
                if (nodeSelection) {
                    if (nodeSelection === this._viper.getViperElement()) {
                        var defaultTagName = this._viper.getDefaultBlockTag();
                        if (defaultTagName !== '') {
                            ViperUtil.setHtml(nodeSelection, '');
                            this._viper.initEditableElement();
                            range = this._viper.getCurrentRange();
                        } else {
                            ViperUtil.setHtml(nodeSelection, '<br />');
                        }
                    } else {
                        var nextSelectable = range.getNextContainer(nodeSelection, null, true);
                        if (ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), this._keepContainerList) === true) {
                            // Remove only the contents when a whole element is selected but the element cannot be
                            // removed (e.g. TD, as it would break the layout).
                            ViperUtil.setHtml(nodeSelection, '<br/>');
                            range.setStart(nodeSelection, 0);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.contentChanged(true);
                            return false;
                        } else if (this._viper.isOutOfBounds(nextSelectable) === true) {
                            nextSelectable = range.getPreviousContainer(range.startContainer, null, true);
                            if (nextSelectable) {
                                range.setStart(nextSelectable, nextSelectable.data.length);
                            }
                        } else {
                            range.setStart(nextSelectable, 0);
                        }

                        ViperUtil.remove(nodeSelection);
                    }//end if
                } else if (this._isStartToEndOfMultiContainerSelection(range) === true) {
                    return this._removeContentFromStartToEndOfContainers(range);
                } else {
                    var startParent = ViperUtil.getFirstBlockParent(range.startContainer, null, true);
                    var endParent   = ViperUtil.getFirstBlockParent(range.endContainer, null, true);
                    if (startParent === endParent) {
                        // Deletion between two different parents within the same block parent. Let browser handle it.
                        this._viper.contentChanged(true);
                        return;
                    } else {
                        this._deleteFromDifferentBlockParents(range);
                    }
                }//end if

                range.collapse(true);
                ViperSelection.addRange(range);
                this._viper.contentChanged();
                return false;
            } else if (this._isWholeViperElementSelected(range) === true) {
                // The whole Viper element is selected, remove all of its content
                // and then initialise the Viper element.
                ViperUtil.setHtml(this._viper.getViperElement(), '');
                this._viper.initEditableElement();
                this._viper.contentChanged();
                return false;
            } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.startContainer === range.endContainer
                && range.startOffset === range.endOffset
                && range.startOffset === 0
            ) {
                if (ViperUtil.isTag(range.startContainer, 'li') === true
                    && ViperUtil.getTag('li', range.startContainer.parentNode).length === 1
                ) {
                    // Single empty list item being removed. Remove the whole list.
                    this._placeCaretToValidPosition(range.startContainer.parentNode, range.startContainer.parentNode);
                    ViperUtil.remove(range.startContainer.parentNode);
                    this._viper.contentChanged();
                    return false;
                }
            } else if (range.collapsed === false
                && range.getNodeSelection()
            ) {
                var nodeSelection = range.getNodeSelection();
                if (nodeSelection
                    && ViperUtil.isStubElement(nodeSelection) === false
                    && ViperUtil.isTag(nodeSelection, 'td') === false
                    && ViperUtil.isTag(nodeSelection, 'th') === false
                ) {
                    var surroundingParents = ViperUtil.getSurroundingParents(nodeSelection);
                    if (surroundingParents.length > 0) {
                        nodeSelection = surroundingParents.pop();
                    }

                    // Handle deletion of a whole bold/italic/etc tag.
                    range = this._viper.moveCaretAway(nodeSelection, e.keyCode === 46);
                    ViperUtil.remove(nodeSelection);
                    if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.startContainer.data === ' '
                        && range.startContainer.previousSibling
                        && range.startContainer.previousSibling.nodeType !== ViperUtil.TEXT_NODE
                    ) {
                        // Fix for Chrome.. If content is '<em>test</em> <strong>content</strong>' and the sourceElement is
                        // the strong tag then change the space to non breaking space to prevent caret moving in to <em>.
                        range.startContainer.data = String.fromCharCode(160);
                        range.setStart(range.startContainer, range.startContainer.data.length);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && range.startContainer.previousSibling
                        && range.startContainer.previousSibling.nodeType === ViperUtil.TEXT_NODE
                    ) {
                        // Join nodes.
                        var length = range.startContainer.previousSibling.data.length;
                        var prev   = range.startContainer.previousSibling;
                        ViperUtil.remove(range.startContainer);
                        if (prev.data.charAt(length - 1) === ' ' && range.startContainer.data.charAt(0) === ' ') {
                            // When joining nodes end and start with a space character, Webkit seems to ignore the 2nd space.
                            // Make sure 2nd space is converted to non breaking space character.
                            prev.data += String.fromCharCode(160);
                            if (range.startContainer.data.length > 1) {
                                prev.data += range.startContainer.data.substring(1, range.startContainer.data.length);
                            }
                        } else {
                            prev.data += range.startContainer.data;
                        }

                        range.setStart(prev, length);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }

                    this._viper.contentChanged();
                    return false;
                }

            }//end if

            if (e.keyCode === 8) {
                if (range.collapsed === true) {
                    if (range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                        if (this._viper.isSpecialElement(range.startContainer.parentNode) === true) {
                            var prevSib = range.startContainer.parentNode.previousSibling;
                            ViperUtil.remove(range.startContainer.parentNode);
                            if (ViperUtil.isText(prevSib) === true) {
                                var info = ViperUtil.normaliseTextNodeSiblings(prevSib);
                                range.setStart(info.textNode, info.splitOffset);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }

                            this._viper.contentChanged();
                            return false;
                        } else if (range.startOffset === 1) {
                            // Delete a character from left.
                            var textNode = range.startContainer;
                            textNode.data = textNode.data.substr(0, range.startOffset - 1) + textNode.data.substr(range.startOffset);

                            // Normalise text nodes.
                            this._normaliseNextNodes(textNode);

                            if (textNode.data.length === 0
                                && textNode.nextSibling === null
                                && textNode.previousSibling === null
                            ) {
                                if (ViperUtil.isBlockElement(textNode.parentNode) === true) {
                                    // The last character of this text node was deleted and now the block parent has no content.
                                    // Add a BR to keep the blockelement 'selectable'.
                                    var br = document.createElement('br');
                                    textNode.parentNode.appendChild(br);
                                    range.selectNode(br);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                } else if (textNode.parentNode.previousSibling
                                    && textNode.parentNode.previousSibling.nodeType === ViperUtil.TEXT_NODE
                                ) {
                                    // Remove the parent element and use the previous text node.
                                    var parent = textNode.parentNode;
                                    textNode   = textNode.parentNode.previousSibling;
                                    ViperUtil.remove(parent);

                                    if (textNode.data.charAt(textNode.data.length - 1) === ' ') {
                                        // If this text node ends with space then convert it to a non breaking space to
                                        // prevent Safari/Chrome removing the space.
                                        textNode.data = textNode.data.substr(0, textNode.data.length - 1) + String.fromCharCode(160);
                                    }

                                    range.setStart(textNode, textNode.data.length);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                }
                            } else {
                                range.setStart(textNode, range.startOffset - 1);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }

                            this._viper.contentChanged();
                            return false;
                        } else if (range.startOffset === 0) {
                            if (this._viper.isSpecialElement(range.startContainer.previousSibling) === true) {
                                ViperUtil.remove(range.startContainer.previousSibling);
                                this._viper.fireNodesChanged();
                                return false;
                            }
                        } else if (range.startOffset === range.startContainer.data.length) {
                            // End of text node.
                            if (ViperUtil.isText(range.startContainer.nextSibling) === true && ViperUtil.isBrowser('safari') === true) {
                                 // Removing the last character from text node sometimes replaces the next node's space
                                 // character with &nbsp;.
                                 var ln = (range.startContainer.data.length - 1);
                                 range.startContainer.data = range.startContainer.data.substr(0, ln);
                                 range.setStart(range.startContainer, ln);
                                 range.collapse(true);
                                 ViperSelection.addRange(range);
                                 this._viper.fireNodesChanged();
                                 return false;
                            }
                        }
                    }//end if
                }//end if
            } else {
                // Delete from right.
                if (range.collapsed === true) {
                    var startContainer = range.startContainer;
                    if (startContainer.nodeType === ViperUtil.TEXT_NODE) {
                        if (range.startOffset === 0) {
                            if (startContainer.data.length === 2 && startContainer.data.charAt(1) === ' ') {
                                // When the text node ends with a space and it will be the only remaining character in the
                                // node then replace it with non breaking space character as Webkit destroys the text node
                                // and make it appear like both 2nd last and space deleted.
                                startContainer.data = String.fromCharCode(160);
                                range.setStart(startContainer, 0);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                                this._viper.contentChanged();
                                return false;
                            } else if (startContainer.data.length === 0) {
                                if (this._viper.isSpecialElement(startContainer.nextSibling) === true) {
                                    ViperUtil.remove(startContainer.nextSibling);
                                    this._viper.contentChanged(true);
                                    return false;
                                }
                            }
                        } else if (range.startOffset === startContainer.data.length) {
                            // At the end of a text node.
                            if (this._viper.isSpecialElement(startContainer.nextSibling) === true) {
                                ViperUtil.remove(startContainer.nextSibling);
                                this._viper.contentChanged(true);
                                return false;
                            } else if (!startContainer.nextSibling) {
                                // Check if the next container is a special element.
                                var nextSelectable = range.getNextContainer(startContainer, null, true, true, true);
                                if (nextSelectable && this._viper.isSpecialElement(nextSelectable.parentNode) === true) {
                                    ViperUtil.remove(nextSelectable.parentNode);
                                    this._viper.contentChanged(true);
                                    return false;
                                }
                            }
                        } else if (range.startOffset - 1 === ViperUtil.rtrim(startContainer.data).length
                            && startContainer.data.length !== ViperUtil.rtrim(startContainer.data).length
                            && this._viper.isSpecialElement(startContainer.nextSibling) === true
                        ) {
                            ViperUtil.remove(startContainer.nextSibling);
                            range.setStart(startContainer, startContainer.data.length);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            this._viper.contentChanged();
                            return false;
                        }
                    } else {
                        var startNode = range.getStartNode();
                        if (startNode && startNode.nodeType !== ViperUtil.TEXT_NODE) {
                            var nextSelectable = range.getNextContainer(startContainer, null, true, true, true);

                            if (ViperUtil.isStubElement(startNode) === true) {
                                // Remove stub element or its surroundingParents.
                                var parents = ViperUtil.getSurroundingParents(startNode);
                                if (parents.length > 0) {
                                    startNode = parents.pop();
                                }

                                ViperUtil.remove(startNode);
                                this._viper.contentChanged();
                                return false;
                            }

                            if (nextSelectable) {
                                var startParent = range.startContainer;
                                var endParent   = ViperUtil.getFirstBlockParent(nextSelectable);
                                if (ViperUtil.isBlockElement(startParent) === false) {
                                    startParent = ViperUtil.getFirstBlockParent(startParent);
                                }

                                if (startParent !== nextSelectable) {
                                    // Handle: <p><img />*</p><p>text</p> -> <p><img />text</p>.
                                    range.setEnd(nextSelectable, 0);
                                    this._deleteFromDifferentBlockParents(range);
                                    return false;
                                }
                            }
                        }
                    }
                }
            }

            this._viper.contentChanged();

        },

        _placeCaretToValidPosition: function(startNode, endNode)
        {
            // Find a new node we can put caret in.
            var range     = this._viper.getCurrentRange();
            var newOffset = 0;
            var newSelContainer = range.getNextContainer(endNode, null, true);
            if (!newSelContainer || this._viper.isOutOfBounds(newSelContainer) === true) {
                // If out of bounds of Viper try getting the previous selectable.
                newSelContainer = range.getPreviousContainer(startNode, null, true);
                if (!newSelContainer || this._viper.isOutOfBounds(newSelContainer) === true) {
                    // No valid location. Create a new default block tag.
                    var defaultTagName = this._viper.getDefaultBlockTag();
                    newSelContainer = document.createElement('br');
                    if (defaultTagName === '') {
                        ViperUtil.insertAfter(endNode, newSelContainer);
                    } else {
                        var newElem = document.createElement(defaultTagName);
                        newElem.appendChild(newSelContainer);
                        ViperUtil.insertAfter(endNode, newElem);
                    }
                } else {
                    newOffset = newSelContainer.data.length;
                }
            }

            if (newSelContainer) {
                // Set the caret location.
                range.setStart(newSelContainer, newOffset);
                range.collapse(true);
                ViperSelection.addRange(range);
            }

        },

        splitAtRange: function(returnFirstBlock, range)
        {
            range = range || this._viper.getViperRange();

            var selectedNode = range.getNodeSelection();
            if (selectedNode && selectedNode.nodeType === ViperUtil.ELEMENT_NODE) {
                selectedNode.innerHTML = '&nbsp;';
                return selectedNode;
            }

            // If the range is not collapsed then remove the contents of the selection.
            if (range.collapsed !== true) {
                if (ViperUtil.isBrowser('chrome') === true
                    || ViperUtil.isBrowser('safari') === true
                ) {
                    range.deleteContents();
                    ViperSelection.addRange(range);
                } else {
                    this._viper.deleteRangeContent();
                    ViperSelection.addRange(this._viper.getCurrentRange());
                    range = this._viper.getViperRange();
                }
            }

            if (range.startContainer.nodeType === ViperUtil.TEXT_NODE) {
                // Find the first parent block element.
                var parent = range.startContainer.parentNode;
                if (parent === this._viper.getViperElement()) {
                    // Split the text node.
                    var newNode = range.startContainer;
                    if (range.startOffset !== 0 && range.startOffset !== range.startContainer.data.length) {
                        // Not at start or end of text node. Split text node and insert a BR tag in between.
                        newNode = range.startContainer.splitText(range.startOffset);
                        ViperUtil.insertBefore(newNode, document.createElement('br'));
                        return range.startContainer.nextSibling;
                    } else if (range.startOffset === 0) {
                        if (range.previousSibling && ViperUtil.isTag(range.previousSibling, 'br') === true) {
                            ViperUtil.remove(range.previousSibling)
                        }

                        return range.startContainer.previousSibling;
                    } else {
                        return range.startContainer;
                    }
                }

                var blockQuote = ViperUtil.getParents(range.startContainer, 'blockquote', this._viper.element);

                while (parent) {
                    if (ViperUtil.isBlockElement(parent) === true) {
                        if (blockQuote.length === 0 || ViperUtil.isTag(parent, 'blockquote') === true) {
                            break;
                        }
                    }

                    if (parent.parentNode && parent.parentNode === this._viper.element) {
                        break;
                    }

                    parent = parent.parentNode;
                }
            } else if (range.startContainer === range.endContainer
                && ViperUtil.isStubElement(range.startContainer)
                && range.startContainer.parentNode.firstChild === range.startContainer
                && range.startContainer.parentNode.lastChild === range.startContainer
            ) {
                parent = range.startContainer.parentNode;
                ViperUtil.setHtml(parent, '&nbsp;');
                range.setStart(parent.firstChild, 0);
                range.collapse(true);
            } else {
                parent = range.startContainer;
            }//end if

            // Create a new element and a document fragment with the contents of
            // the selection.
            var tag = parent.tagName.toLowerCase();

            // If the parent is not part of the editable element then we need to
            // create two new P tags.
            if (ViperUtil.isChildOf(parent, this._viper.element) === false) {
                // Find the next non block sibling.
                var node = range.endContainer;
                while (ViperUtil.isset(node.nextSibling) === true) {
                    if (ViperUtil.isBlockElement(node.nextSibling) === true) {
                        break;
                    }

                    node = node.nextSibling;
                }

                range.setEndAfter(node);

                var elem    = Viper.document.createElement('p');
                var docFrag = range.extractContents('p');

                this._viper.deleteRangeContent();
                elem.appendChild(docFrag);
                ViperUtil.insertAfter(range.startContainer, elem);
                range.collapse(true);

                // Find the previous non block sibling.
                node = range.startContainer;
                while (ViperUtil.isset(node.previousSibling) === true) {
                    if (ViperUtil.isBlockElement(node.previousSibling) === true) {
                        break;
                    }

                    node = node.previousSibling;
                }

                range.setStartBefore(node);

                var felem = Viper.document.createElement('p');
                docFrag   = range.extractContents('p');
                felem.appendChild(docFrag);
                ViperUtil.insertBefore(elem, felem);

                if (!elem.firstChild) {
                    elem.appendChild(document.createTextNode(''));
                }

                range.setStart(elem.firstChild, 0);
                range.collapse(true);
                return;
            } else if (tag === 'pre') {
                // If the text is in a PRE tag then we need to insert a new line character.
                this.insertTextAtRange(range, "\n");
                return false;
            } else if (tag === 'td' || tag === 'th') {
                // Cannot create a new TD tag so need the move td contents in to a P tag.
                var bookmark = this._viper.createBookmark(range);
                var p        = Viper.document.createElement('P');
                while (parent.firstChild) {
                    p.appendChild(parent.firstChild);
                }

                // Add the new P tag as TD's child node.
                parent.appendChild(p);

                // Update tag name and parent element.
                tag    = 'p';
                parent = p;

                // Update range.
                range = this._viper.selectBookmark(bookmark);
            }//end if

            // If the selection is at the end of text node and has no next sibling
            // then move the range out of its parent node to prevent empty tags being
            // created by range.extractContents().
            if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === range.startContainer.data.length
            ) {
                if (!range.startContainer.nextSibling) {
                    var newTextNode = Viper.document.createTextNode('');
                    ViperUtil.insertAfter(range.startContainer.parentNode, newTextNode);
                    range.setEnd(newTextNode, 0);
                    range.collapse(false);
                }
            }

            try {
                // Select everything from the current position to the end of the parent.
                range.setEndAfter(parent.lastChild);
            } catch (e) {

            }

            ViperSelection.addRange(range);

            // Need to clone the node so that its attributes are also copied.
            // This may cause ID conflicts.
            var elem    = parent.cloneNode(false);
            var docFrag = range.extractContents(tag);

            elem.appendChild(docFrag);

            // Remove DEL tags before getting the text content.
            var elemClone = ViperUtil.cloneNode(elem);
            ViperUtil.remove(ViperUtil.getTag('del', elemClone));

            if (ViperUtil.isBlank(ViperUtil.getNodeTextContent(elemClone)) === true) {
                // Do not need this empty element.
                elem = null;
            }

            if (elem === null || (elem.tagName && elem.tagName.toLowerCase() !== 'li' && ViperUtil.isBlockElement(elem) === false)) {
                // If the newly created element is not a block element then
                // create a P tag and make it the elem's parent.
                var newTag = 'p';

                // If element is in a list block then create a new list item instead of a paragraph.
                if (tag === 'li') {
                    newTag = tag;
                }

                var pelem = Viper.document.createElement(newTag);
                if (elem !== null) {
                    pelem.appendChild(elem);
                } else {
                    ViperUtil.setHtml(pelem, '&nbsp;');
                }

                elem = pelem;
            }//end if

            if (ViperUtil.elementIsEmpty(parent) === true) {
                ViperUtil.setHtml(parent, '&nbsp;');
            }

            // Insert the new element after the current parent.
            ViperUtil.insertAfter(parent, elem);

            try {
                range.setStart(elem, 0);
                range.setStart(elem, 0);
                range.moveStart('character', 1);
                range.moveStart('character', -1);
            } catch (e) {
                // Handle empty node..
            }

            range.collapse(true);
            ViperSelection.addRange(range);

            // Check the parent element contents.
            // If the parent element is now empty and its a block element
            // then add a space to it.
            if (ViperUtil.isBlockElement(parent) === true && ViperUtil.trim(ViperUtil.getHtml(parent)) === '') {
                ViperUtil.setHtml(parent, '&nbsp;');
            }

            if (returnFirstBlock === true) {
                return parent;
            }

            return false;
        },

        
        handleSoftEnter: function(e)
        {
            if (e) {
                var range     = this._viper.getCurrentRange();
                var startNode = range.getStartNode();
                if (startNode && ViperUtil.isTag(ViperUtil.getFirstBlockParent(startNode), 'pre') === true) {
                    this.insertTextAtRange(range, "\n");
                    this._viper.contentChanged();
                    return false;
                }
            }

            var node = Viper.document.createElement('br');
            this._viper.insertNodeAtCaret(node);

            if (ViperUtil.isTag(node.previousSibling, 'br') === true) {
                // The previous sibling is also a br tag and to be able to position
                // caret between these two br tags we need to insert a text node in
                // between them.
                this._viper.insertAfter(node.previousSibling, this._viper.createSpaceNode());
            } else if (!node.nextSibling && ViperUtil.isBlockElement(node.parentNode) === false) {
                ViperUtil.insertAfter(node.parentNode, node);
            } else if (!node.previousSibling && node.nextSibling && node.nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                ViperUtil.insertBefore(node.parentNode, node);
            }

            this._viper.contentChanged();
            return !this._viper.setCaretAfterNode(node);

        },

        _isWholeViperElementSelected: function(range)
        {
            return this._viper.isWholeViperElementSelected(range);

        },

        _isStartToEndOfMultiContainerSelection: function(range)
        {
            var nodeSelection = range.getNodeSelection();
            if (nodeSelection) {
                return false;
            }

            if (range.startOffset === 0
                && range.collapsed === false
                && range.startContainer !== range.endContainer
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endOffset === range.endContainer.data.length
            ) {
                var startParent     = ViperUtil.getFirstBlockParent(range.startContainer);
                var endParent       = ViperUtil.getFirstBlockParent(range.endContainer);
                var firstSelectable = range._getFirstSelectableChild(startParent);
                var lastSelectable  = range._getLastSelectableChild(endParent);
                if (firstSelectable === range.startContainer
                    && lastSelectable === range.endContainer
                ) {
                    return true;
                }
            }

            return false;

        },

        _removeContentFromStartToEndOfContainers: function(range)
        {
            // Remove content from beginning of one container to the end of another container.
            var startParent     = ViperUtil.getFirstBlockParent(range.startContainer);
            var endParent       = ViperUtil.getFirstBlockParent(range.endContainer);
            var defaultTagName  = this._viper.getDefaultBlockTag();
            var common          = ViperUtil.getCommonAncestor(startParent, endParent);

            if (common && (ViperUtil.isTag(common, 'ul') === true || ViperUtil.isTag(common, 'ol') === true)) {
                // Multiple list items selected from the same list.
                defaultTagName = 'li';
            }

            if (defaultTagName !== '') {
                var p = document.createElement(defaultTagName);
                ViperUtil.setHtml(p, '<br />');
                ViperUtil.insertBefore(startParent, p);
                ViperUtil.remove(ViperUtil.getElementsBetween(startParent, endParent));
                ViperUtil.remove(startParent);
                ViperUtil.remove(endParent);

                // If the new P tag is at the end of a UL/OL element move it after.
                if ((ViperUtil.isTag(p.parentNode, 'ul') === true || ViperUtil.isTag(p.parentNode, 'ol') === true)
                    && !p.nextSibling
                ) {
                    ViperUtil.insertAfter(p.parentNode, p);
                }

                range.setStart(p, 0);
                range.collapse(true);
            } else {
                var br = document.createElement('br');

                // Remove any extra white space only text nodes.
                var sibling = startParent.previousSibling;
                while (sibling && sibling.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(sibling.data) === '') {
                    ViperUtil.remove(sibling);
                    sibling = sibling.previousSibling;
                }

                ViperUtil.insertBefore(startParent, br);
                ViperUtil.remove(ViperUtil.getElementsBetween(startParent, endParent));
                ViperUtil.remove(startParent);
                ViperUtil.remove(endParent);
                range.setStart(br, 0);
                range.collapse(true);
            }

            ViperSelection.addRange(range);
            this._viper.contentChanged(true);

            // Prevent default action.
            return false;

        },

        insertTextAtRange: function(range, text)
        {
            var node = range.startContainer;
            // Assuming the range is collapsed already.
            if (node.nodeType === ViperUtil.TEXT_NODE) {
                // Split the text node and insert new line char.
                var newNode = node.splitText(range.startOffset);
                ViperUtil.insertBefore(newNode, document.createTextNode(text));
            } else {
                // Element node..
                node = range.startContainer.childNodes[range.startOffset];
                if (node.nodeType === ViperUtil.TEXT_NODE) {
                    // Split the text node and insert new line char.
                    var newNode = node.splitText(range.startOffset);
                    ViperUtil.insertBefore(newNode, document.createTextNode(text));
                } else {
                    newNode = document.createTextNode(text);
                    ViperUtil.insertAfter(node, newNode);
                }
            }

            if (newNode.data.length === 0) {
                newNode.data = ' ';
            }

            range.setStart(newNode, 0);
            range.collapse(true);
            ViperSelection.addRange(range);

        },

        canRemoveNode: function(node)
        {
            if (ViperUtil.inArray(ViperUtil.getTagName(node), this._keepContainerList) === true) {
                return false;
            }

            return true;

        },

        cleanPreTags: function()
        {
            var preTags       = ViperUtil.getTag('pre', this._viper.getViperElement());
            var c             = preTags.length;
            var bookmark      = null;
            var range         = this._viper.getViperRange();
            var nodeSelection = range.getNodeSelection();
            if (!nodeSelection) {
                bookmark = this._viper.createBookmark();
            }

            for (var i = 0; i < c; i++) {
                this.cleanPreTag(preTags[i]);
            }

            if (!nodeSelection) {
                this._viper.selectBookmark(bookmark);
            } else {
                range.selectNode(nodeSelection);
            }

        },

        cleanPreTag: function(pre)
        {
            if (!pre) {
                return;
            }

            var elems = ViperUtil.getTag('p,div', pre);
            var c     = elems.length;

            for (var i = 0; i < c; i++) {
                var elem = elems[i];
                while (elem.firstChild) {
                    ViperUtil.insertBefore(elem, elem.firstChild);
                }

                ViperUtil.insertBefore(elem, document.createTextNode("\n\n"));
                ViperUtil.remove(elem);
            }

            var elems = ViperUtil.getTag('br', pre);
            var c     = elems.length;

            for (var i = 0; i < c; i++) {
                var elem = elems[i];
                ViperUtil.insertBefore(elem, document.createTextNode("\n"));
                ViperUtil.remove(elem);
            }

        },

        isEmptyBlockElement: function(element)
        {
            if (ViperUtil.isBlockElement(element) === false) {
                return false;
            }

            return ViperUtil.isEmptyElement(element);

        },

        splitList: function (li)
        {
            var list = li.parentNode;

            // If there is a list item after this one then split the list in to two.
            if (ViperUtil.isTag(li.nextElementSibling, 'li') === true) {
                var listType = ViperUtil.getTagName(list);
                var newList  = document.createElement(listType);

                // Insert the new list after the current list.
                ViperUtil.insertAfter(list, newList);

                // Move nodes after the current list item to the new list.
                while (li.nextSibling) {
                    newList.appendChild(li.nextSibling);
                }
            }

            if (ViperUtil.trim(ViperUtil.getNodeTextContent(li)) === '') {
                // This list item is empty so it can be removed.
                ViperUtil.remove(li);
            }

            // Now create the spacer element. This element is inserted after the current list.
            var defaultTagName = this._viper.getDefaultBlockTag();
            var elem           = null;
            if (defaultTagName === '') {
                elem = document.createElement('br');
            } else {
                elem = document.createElement(defaultTagName);
            }

            ViperUtil.insertAfter(list, elem);

            if (defaultTagName !== '') {
                elem.appendChild(document.createElement('br'));
            }

            var range = this._viper.getViperRange();
            range.setStart(elem, 0);
            range.collapse(true);
            ViperSelection.addRange(range);
        }

    };

}) (Viper.Util, Viper.Selection);



var HTMLCSAuditor = new function()
{
    var _prefix   = 'HTMLCS-';
    var _screen   = '';
    var _standard = '';
    var _sources  = [];
    var _options  = {};
    var _doc      = null;
    var _top      = null;
    var _messages = [];
    var _page     = 1;
    var _sbWidth  = null;

    var self = this;

    this.pointerContainer = null;

    
    var buildSummaryButton = function(id, className, title, onclick) {
        var button       = _doc.createElement('div');
        button.id        = id;
        button.className = _prefix + 'button';
        button.setAttribute('title', title);

        var buttonInner       = _doc.createElement('span');
        buttonInner.className = _prefix + 'button-icon ' + _prefix + 'button-' + className;
        button.appendChild(buttonInner);

        var nbsp = _doc.createTextNode(String.fromCharCode(160));
        button.appendChild(nbsp);

        if ((onclick instanceof Function) === true) {
            button.onclick = function() {
                if (/disabled/.test(button.className) === false) {
                    onclick(button);
                }
            };
        }

        return button;
    };

    
    var buildCheckbox = function(id, title, checked, disabled, onclick) {
        if (checked === undefined) {
            checked = false;
        }

        var label   = _doc.createElement('label');
        var content = '';
        label.className = _prefix + 'checkbox';

        content    += '<span class="' + _prefix + 'checkbox-switch">';
        content    += '<span class="' + _prefix + 'checkbox-slider"></span>';
        content    += '<input id="' + id + '" type="checkbox"';

        if (checked === true) {
            content += ' checked="checked"';
            label.className += ' active';
        }

        if (disabled === true) {
            content += ' disabled="disabled"';
            label.className += ' disabled';
        }

        content += ' title="' + title + '" /></span>';

        label.innerHTML = content;

        var input = label.getElementsByTagName('input')[0];

        label.onclick = function(event) {
            if (disabled === false) {
                input.checked = !input.checked;

                if (input.checked === true) {
                    label.className += ' active';
                } else {
                    label.className = label.className.replace('active', '');
                }

                if (onclick instanceof Function === true) {
                    onclick(input);
                }
            }//end if

            return false;
        }

        return label;
    };

    
    var buildRadioButton = function(groupName, value, title, checked) {
        if (checked === undefined) {
            checked = false;
        }

        var label   = _doc.createElement('label');
        label.className = _prefix + 'radio';
        var content = '<span class="' + _prefix + 'radio-title">' + title + '</span>';
        content    += '<span class="' + _prefix + 'radio-switch">';
        content    += '<span class="' + _prefix + 'radio-slider"></span>';
        content    += '<input type="radio" name="' + _prefix + groupName + '" ';
        content    += 'class="' + _prefix + 'radiobtn"';
        content    += 'value="' + value + '"';

        if (checked === true) {
            content    += ' checked="true"';
        }

        content += ' /></span>';

        label.innerHTML = content;

        return label;
    };

    
    var buildHeaderSection = function(standard, wrapper) {
        var header       = _doc.createElement('div');
        header.className = _prefix + 'header';
        header.innerHTML = 'HTML_CodeSniffer by Squiz';
        header.setAttribute('title', 'Using standard ' + standard);

        var dragging = false;
        var prevX    = 0;
        var prevY    = 0;
        var mouseX   = 0;
        var mouseY   = 0;

        header.onmousedown = function(e) {
            e = e || window.event;

            dragging = true;
            mouseX   = e.clientX;
            mouseY   = e.clientY;
            return false;
        };

        _doc.onmousemove = function(e) {
            e = e || window.event;

            if (dragging === true) {
                var top = wrapper.offsetTop;
                var left = wrapper.offsetLeft;

                if (mouseY < e.clientY) {
                    top += (e.clientY - mouseY);
                    wrapper.style.top = top + 'px';
                } else if (mouseY > e.clientY) {
                    top -= (mouseY - e.clientY);
                    wrapper.style.top = top + 'px';
                }

                if (mouseX < e.clientX) {
                    left += (e.clientX - mouseX);
                    wrapper.style.left = left + 'px';
                } else if (mouseX > e.clientX) {
                    left -= (mouseX - e.clientX);
                    wrapper.style.left = left + 'px';
                }

                mouseX = e.clientX;
                mouseY = e.clientY;
            }//end if
        };

        _doc.onmouseup = function(e) {
            dragging = false;
        };

        var closeIcon       = _doc.createElement('div');
        closeIcon.className = _prefix + 'close';
        closeIcon.setAttribute('title', 'Close');
        closeIcon.onmousedown = function() {
            self.close.call(self);
        }

        header.appendChild(closeIcon);

        return header;
    };

    
    var buildSummarySection = function(errors, warnings, notices) {
        var summary       = _doc.createElement('div');
        summary.className = _prefix + 'summary';

        var leftPane       = _doc.createElement('div');
        leftPane.className = _prefix + 'summary-left';
        summary.appendChild(leftPane);

        var rightPane       = _doc.createElement('div');
        rightPane.className = _prefix + 'summary-right';
        summary.appendChild(rightPane);

        var leftContents = [];

        var divider = ', &#160;<span class="' + _prefix + 'divider"></span>';

        if (errors > 0) {
            var typeName = 'Errors';
            if (errors === 1) {
                typeName = 'Error';
            }
            leftContents.push('<strong>' + errors + '</strong> ' + typeName);
        }

        if (warnings > 0) {
            var typeName = 'Warnings';
            if (warnings === 1) {
                typeName = 'Warning';
            }
            leftContents.push('<strong>' + warnings + '</strong> ' + typeName);
        }

        if (notices > 0) {
            var typeName = 'Notices';
            if (notices === 1) {
                typeName = 'Notice';
            }
            leftContents.push('<strong>' + notices + '</strong> ' + typeName);
        }

        // Start lineage in left pane.
        var lineage       = _doc.createElement('ol');
        lineage.className = _prefix + 'lineage';

        // Back to summary item.
        var lineageHomeItem       = _doc.createElement('li');
        lineageHomeItem.className = _prefix + 'lineage-item';

        var lineageHomeLink       = _doc.createElement('a');
        lineageHomeLink.className = _prefix + 'lineage-link';
        lineageHomeLink.href      = 'javascript:';

        var lineageHomeSpan       = _doc.createElement('span');
        lineageHomeSpan.innerHTML = 'Home';
        lineageHomeLink.appendChild(lineageHomeSpan);

        lineageHomeLink.onmousedown = function() {
            self.run(_standard, _sources, _options);
        };

        // Issue totals.
        var lineageTotalsItem       = _doc.createElement('li');
        lineageTotalsItem.className = _prefix + 'lineage-item';
        lineageTotalsItem.innerHTML = leftContents.join(divider);

        lineageHomeItem.appendChild(lineageHomeLink);
        lineage.appendChild(lineageHomeItem);
        lineage.appendChild(lineageTotalsItem);
        leftPane.appendChild(lineage);

        rightPane.appendChild(_doc.createTextNode(String.fromCharCode(160)));

        return summary;
    };

    
    var buildDetailSummarySection = function(issue, totalIssues) {
        var summary       = _doc.createElement('div');
        summary.className = _prefix + 'summary-detail';

        var leftPane       = _doc.createElement('div');
        leftPane.className = _prefix + 'summary-left';

        var rightPane       = _doc.createElement('div');
        rightPane.className = _prefix + 'summary-right';

        // Start lineage.
        var lineage       = _doc.createElement('ol');
        lineage.className = _prefix + 'lineage';

        var lineageHomeItem       = _doc.createElement('li');
        lineageHomeItem.className = _prefix + 'lineage-item';

        var lineageHomeLink       = _doc.createElement('a');
        lineageHomeLink.className = _prefix + 'lineage-link';
        lineageHomeLink.href      = 'javascript:';

        var lineageHomeSpan       = _doc.createElement('span');
        lineageHomeSpan.innerHTML = 'Home';
        lineageHomeLink.appendChild(lineageHomeSpan);

        lineageHomeLink.onmousedown = function() {
            self.run(_standard, _sources, _options);
        };

        // Back to Report item.
        var lineageReportItem       = _doc.createElement('li');
        lineageReportItem.className = _prefix + 'lineage-item';

        var lineageReportLink       = _doc.createElement('a');
        lineageReportLink.className = _prefix + 'lineage-link';
        lineageReportLink.href      = 'javascript:';
        lineageReportLink.innerHTML = 'Report';
        lineageReportLink.setAttribute('title', 'Back to Report');

        lineageReportLink.onmousedown = function() {
            var list = _doc.querySelectorAll('.HTMLCS-inner-wrapper')[0];
            list.style.marginLeft = '0px';
            list.style.maxHeight  = null;

            summary.style.display = 'none';
            var listSummary = _doc.querySelectorAll('.HTMLCS-summary')[0];
            listSummary.style.display = 'block';
        };

        // Issue Count item.
        var lineageTotalsItem       = _doc.createElement('li');
        lineageTotalsItem.className = _prefix + 'lineage-item';
        lineageTotalsItem.innerHTML = 'Issue ' + issue + ' of ' + totalIssues;

        lineageHomeItem.appendChild(lineageHomeLink);
        lineageReportItem.appendChild(lineageReportLink);
        lineage.appendChild(lineageHomeItem);
        lineage.appendChild(lineageReportItem);
        lineage.appendChild(lineageTotalsItem);
        leftPane.appendChild(lineage);

        var buttonGroup       = _doc.createElement('div');
        buttonGroup.className = _prefix + 'button-group';

        var prevButton = buildSummaryButton(_prefix + 'button-previous-issue', 'previous', 'Previous Issue', function(target) {
            var newIssue = Number(issue) - 1;

            if (newIssue >= 1) {
                setCurrentDetailIssue(newIssue - 1);
                wrapper = summary.parentNode;
                var newSummary = buildDetailSummarySection(newIssue, totalIssues);
                wrapper.replaceChild(newSummary, summary);
                newSummary.style.display = 'block';

                var issueList = _doc.querySelectorAll('.HTMLCS-issue-detail-list')[0];
                issueList.firstChild.style.marginLeft = (parseInt(issueList.firstChild.style.marginLeft, 10) + 300) + 'px';
                pointToIssueElement(newIssue - 1);
            }//end if
        });

        var nextButton = buildSummaryButton(_prefix + 'button-next-issue', 'next', 'Next Issue', function(target) {
            var newIssue = Number(issue) + 1;

            if (newIssue <= _messages.length) {
                setCurrentDetailIssue(newIssue - 1);
                wrapper = summary.parentNode;
                var newSummary = buildDetailSummarySection(newIssue, totalIssues);
                wrapper.replaceChild(newSummary, summary);
                newSummary.style.display = 'block';

                var issueList = _doc.querySelectorAll('.HTMLCS-issue-detail-list')[0];
                issueList.firstChild.style.marginLeft = (parseInt(issueList.firstChild.style.marginLeft, 10) - 300) + 'px';
                pointToIssueElement(newIssue - 1);
            }//end if
        });

        if (issue === 1) {
            prevButton.className += ' disabled';
        }

        if (issue === totalIssues) {
            nextButton.className += ' disabled';
        }

        buttonGroup.appendChild(prevButton);
        buttonGroup.appendChild(nextButton);
        rightPane.appendChild(buttonGroup);

        summary.appendChild(leftPane);
        summary.appendChild(rightPane);

        return summary;
    };

    
    var buildIssueListSection = function(messages) {
        var issueListWidth = (Math.ceil(messages.length / 5) * 300);
        var issueList      = _doc.createElement('div');
        issueList.id        = _prefix + 'issues';
        issueList.className = _prefix + 'details';
        issueList.setAttribute('style', 'width: ' + issueListWidth + 'px');

        var listSection = _doc.createElement('ol');
        listSection.className = _prefix + 'issue-list';
        listSection.setAttribute('style', 'margin-left: 0');

        for (var i = 0; i < messages.length; i++) {
            if ((i > 0) && ((i % 5) === 0)) {
                issueList.appendChild(listSection);
                var listSection = _doc.createElement('ol');
                listSection.className = _prefix + 'issue-list';
            }

            var msg = buildMessageSummary(i, messages[i]);
            listSection.appendChild(msg);
        }

        issueList.appendChild(listSection);

        return issueList;
    };

    var buildIssueDetailSection = function(messages) {
        var issueListWidth  = (messages.length * 300);
        var issueList       = _doc.createElement('div');
        issueList.id        = _prefix + 'issues-detail';
        issueList.className = _prefix + 'details';
        issueList.setAttribute('style', 'width: ' + issueListWidth + 'px');

        var listSection = _doc.createElement('ol');
        listSection.className = _prefix + 'issue-detail-list';
        listSection.setAttribute('style', 'margin-left: 0');

        for (var i = 0; i < messages.length; i++) {
            var msg = buildMessageDetail(i, messages[i]);
            listSection.appendChild(msg);
        }

        issueList.appendChild(listSection);

        return issueList;
    };

    var buildSettingsSection = function() {
        var settingsDiv       = _doc.createElement('div');
        settingsDiv.className = _prefix + 'settings';

        var useStandardDiv = _doc.createElement('div');
        useStandardDiv.id = _prefix + 'settings-use-standard';

        var useStandardLabel       = _doc.createElement('label');
        useStandardLabel.innerHTML = 'Standards:';
        useStandardLabel.setAttribute('for', _prefix + 'settings-use-standard-select');

        var useStandardSelect       = _doc.createElement('select');
        useStandardSelect.id        = _prefix + 'settings-use-standard-select';
        useStandardSelect.innerHTML = '';

        var standards = HTMLCSAuditor.getStandardList();
        for (var i = 0; i < standards.length; i++) {
            var standard     = standards[i];
            var option       = _doc.createElement('option');
            option.value     = standard;
            option.innerHTML = window['HTMLCS_' + standard].name;

            if (standard === _standard) {
                option.selected = true;
            }

            useStandardSelect.appendChild(option);
            useStandardSelect.onchange = function() {
                _standard = this.options[this.selectedIndex].value;
                self.run(_standard, _sources, _options);
            }
        }

        var issueCountDiv = _doc.createElement('div');
        issueCountDiv.id  = _prefix + 'settings-issue-count';

        var issueCountHelpDiv       = _doc.createElement('div');
        issueCountHelpDiv.id        = _prefix + 'settings-issue-count-help';
        issueCountHelpDiv.innerHTML = 'Select the types of issues to include in the report';

        var viewReportDiv       = _doc.createElement('div');
        viewReportDiv.id        = _prefix + 'settings-view-report';
        viewReportDiv.innerHTML = 'View Report';

        viewReportDiv.onclick = function() {
            if (/disabled/.test(this.className) === false) {
                _options.show = {
                    error: _doc.getElementById(_prefix + 'include-error').checked,
                    warning: _doc.getElementById(_prefix + 'include-warning').checked,
                    notice: _doc.getElementById(_prefix + 'include-notice').checked
                }

                var wrapper    = _doc.getElementById(_prefix + 'wrapper');
                var newWrapper = self.build(_standard, _messages, _options);

                if (_options.parentElement) {
                    _options.parentElement.replaceChild(newWrapper, wrapper);
                } else {
                    newWrapper.style.left = wrapper.style.left;
                    newWrapper.style.top  = wrapper.style.top;
                    _doc.body.replaceChild(newWrapper, wrapper);
                }

                if (_options.listUpdateCallback) {
                    _options.listUpdateCallback.call(this, _messages);
                }
            }//end if
        };

        var wrapper = _doc.getElementById(_prefix + 'wrapper');
        var levels  = self.countIssues(_messages);

        // Set default show options based on the first run. Don't re-do these, let
        // the user's settings take priority, unless there is no message.
        if ((_options.show === undefined) && (_messages.length > 0)) {
            _options.show = {
                error: true,
                warning: true,
                notice: false
            }

            if ((levels.error === 0) && (levels.warning === 0)) {
                _options.show.notice = true;
            }
        }

        for (var level in levels) {
            var msgCount       = levels[level];
            var levelDiv       = _doc.createElement('div');
            levelDiv.className = _prefix + 'issue-tile ' + _prefix + level.toLowerCase();

            var levelCountDiv       = _doc.createElement('div');
            levelCountDiv.className = 'HTMLCS-tile-text';

            var content = '<strong>' + msgCount + '</strong> ' + level.substr(0, 1).toUpperCase() + level.substr(1);
            if (msgCount !== 1) {
                content += 's';
            }

            levelCountDiv.innerHTML = content;

            if (_options.show === undefined) {
                var checked  = false;
                var disabled = true;
            } else {
                var checked  = _options.show[level];
                var disabled = false;

                if (msgCount === 0) {
                    checked  = false;
                    disabled = true;
                }
            }

            var levelSwitch = buildCheckbox(_prefix + 'include-' + level, 'Toggle display of ' + level + ' messages', checked, disabled, function(input) {
                // Only change checkboxes that haven't been disabled.
                var enable = false;

                if (_doc.getElementById(_prefix + 'include-error').disabled === false) {
                    _options.show.error = _doc.getElementById(_prefix + 'include-error').checked;
                    enable = enable || _options.show.error;
                }

                if (_doc.getElementById(_prefix + 'include-warning').disabled === false) {
                    _options.show.warning = _doc.getElementById(_prefix + 'include-warning').checked;
                    enable = enable || _options.show.warning;
                }

                if (_doc.getElementById(_prefix + 'include-notice').disabled === false) {
                    _options.show.notice = _doc.getElementById(_prefix + 'include-notice').checked;
                    enable = enable || _options.show.notice;
                }

                if (enable === true) {
                    viewReportDiv.className = viewReportDiv.className.replace(/ disabled/g, '');
                } else {
                    viewReportDiv.className += ' disabled';
                }
            });

            levelDiv.appendChild(levelCountDiv);
            levelDiv.appendChild(levelSwitch);
            issueCountDiv.appendChild(levelDiv);
        }

        // Only disable if we have "currently showing" setting on.
        if (_options.show !== undefined) {
            var enable = (_options.show.error || _options.show.warning || _options.show.notice);
            if (enable === false) {
                viewReportDiv.className += ' disabled';
            }
        } else {
            viewReportDiv.className += ' disabled';
        }

        useStandardDiv.appendChild(useStandardLabel);
        useStandardDiv.appendChild(useStandardSelect);

        settingsDiv.appendChild(useStandardDiv);
        settingsDiv.appendChild(issueCountDiv);
        settingsDiv.appendChild(issueCountHelpDiv);
        settingsDiv.appendChild(viewReportDiv);

        return settingsDiv;
    };

    var buildMessageSummary = function(id, message) {
        var msg       = '';
        var typeText  = '';
        var typeClass = '';

        switch (message.type) {
            case HTMLCS.ERROR:
                typeText = 'Error';
            break;

            case HTMLCS.WARNING:
                typeText = 'Warning';
            break;

            case HTMLCS.NOTICE:
                typeText = 'Notice';
            break;

            default:
                // Not defined.
            break;
        }//end switch

        var typeClass  = typeText.toLowerCase();
        var messageMsg = message.msg;
        if (messageMsg.length > 115) {
            messageMsg = messageMsg.substr(0, 115) + '...';
        }

        var msg = _doc.createElement('li');
        msg.id  = _prefix + 'msg-' + id;

        var typeIcon       = _doc.createElement('span');
        typeIcon.className = _prefix + 'issue-type ' + _prefix + typeClass;
        typeIcon.setAttribute('title', typeText);
        msg.appendChild(typeIcon);

        var msgTitle       = _doc.createElement('span');
        msgTitle.className = _prefix + 'issue-title';
        msgTitle.innerHTML = messageMsg;
        msg.appendChild(msgTitle);

        msg.onclick = function() {
            var id = this.id.replace(new RegExp(_prefix + 'msg-'), '');
            setCurrentDetailIssue(id);

            var detailList = _doc.querySelectorAll('.HTMLCS-issue-detail-list')[0];
            detailList.className += ' ' + _prefix + 'transition-disabled';
            detailList.firstChild.style.marginLeft = (id * -300) + 'px';

            pointToIssueElement(id);

            setTimeout(function() {
                detailList.className = detailList.className.replace(new RegExp(' ' + _prefix + 'transition-disabled'), '');
            }, 500);

            var list = _doc.querySelectorAll('.HTMLCS-inner-wrapper')[0];
            list.style.marginLeft = '-300px';
            list.style.maxHeight  = '15em';

            summary = _doc.querySelectorAll('.HTMLCS-summary-detail')[0];
            var newSummary = buildDetailSummarySection(parseInt(id) + 1, _messages.length);
            summary.parentNode.replaceChild(newSummary, summary);
            newSummary.style.display = 'block';

            var oldSummary = _doc.querySelectorAll('.HTMLCS-summary')[0];
            oldSummary.style.display = 'none';
        }

        return msg;
    };

    var setCurrentDetailIssue = function(id) {
        var detailList = _doc.querySelectorAll('.HTMLCS-issue-detail-list')[0];
        var items      = detailList.getElementsByTagName('li');
        for (var i = 0; i < items.length; i++) {
            items[i].className = items[i].className.replace(new RegExp(' ' + _prefix + 'current'), '');
        }

        var currentItem = _doc.getElementById('HTMLCS-msg-detail-' + id);
        currentItem.className += ' ' + _prefix + 'current';

        if (_options.showIssueCallback) {
            _options.showIssueCallback.call(this, id);
        }
    }

    var buildMessageDetail = function(id, message, standard) {
        if (standard === undefined) {
            standard = _standard;
        }

        var typeText  = '';

        switch (message.type) {
            case HTMLCS.ERROR:
                typeText = 'Error';
            break;

            case HTMLCS.WARNING:
                typeText = 'Warning';
            break;

            case HTMLCS.NOTICE:
                typeText = 'Notice';
            break;

            default:
                // Not defined.
            break;
        }//end switch

        var typeClass     = _prefix + typeText.toLowerCase();

        var standardObj = HTMLCS.util.getElementWindow(_doc)['HTMLCS_' + standard];
        var standardObj = _top['HTMLCS_' + standard];
        var msgInfo = [];
        if (standardObj.getMsgInfo) {
            msgInfo = standardObj.getMsgInfo(message.code);
        }

        var msgDiv = _doc.createElement('li');
        msgDiv.id  = _prefix + 'msg-detail-' + id;

        var msgDetailsDiv       = _doc.createElement('div');
        msgDetailsDiv.className = _prefix + 'issue-details';

        var msgType       = _doc.createElement('span');
        msgType.className = _prefix + 'issue-type ' + typeClass;
        msgType.setAttribute('title', typeText);

        var msgTitle       = _doc.createElement('div');
        msgTitle.className = _prefix + 'issue-title';
        msgTitle.innerHTML = message.msg;

        var msgRef       = _doc.createElement('div');
        msgRef.className = _prefix + 'issue-wcag-ref';

        var refContent = '';
        for (var i = 0; i < msgInfo.length; i++) {
            refContent += '<em>' + msgInfo[i][0] + ':</em> ' + msgInfo[i][1] + '<br/>';
        }
        msgRef.innerHTML = refContent;

        msgDetailsDiv.appendChild(msgType);
        msgDetailsDiv.appendChild(msgTitle);
        msgDetailsDiv.appendChild(msgRef);
        msgDiv.appendChild(msgDetailsDiv);

        // If the item cannot be pointed to, tell them why.
        if (pointer.isPointable(message.element) === false) {
            var msgElementSource       = _doc.createElement('div');
            msgElementSource.className = _prefix + 'issue-source';
            msgDiv.appendChild(msgElementSource);

            var msgElementSourceInner       = _doc.createElement('div');
            msgElementSourceInner.className = _prefix + 'issue-source-inner-u2p';
            var msg = 'Unable to point to the element associated with this issue.';

            if (message.element.ownerDocument === null) {
                msg = 'Unable to point to this issue, as it relates to the entire document.';
            } else {
                var body = message.element.ownerDocument.getElementsByTagName('body')[0];
                if (HTMLCS.util.isInDocument(message.element) === false) {
                    msg += 'Unable to point to this element as it has been removed from the document since the report was generated.';
                } else if (HTMLCS.util.contains(body, message.element) === false) {
                    msg = 'Unable to point to this element because it is located outside the document\'s body element.';
                } else {
                    msg += 'Unable to point to this element because it is hidden from view, or does not have a visual representation.';
                }
            }

            if (msgElementSourceInner.textContent !== undefined) {
                msgElementSourceInner.textContent = msg;
            } else {
                // IE8 uses innerText instead. Oh well.
                msgElementSourceInner.innerText = msg;
            }

            msgElementSource.appendChild(msgElementSourceInner);
        }

        // Build the source view, if outerHTML exists (Firefox >= 11, Webkit, IE),
        // and applies to the particular element (ie. document doesn't have it).
        if (_options.customIssueSource) {
            var msgElementSource       = _doc.createElement('div');
            msgElementSource.className = _prefix + 'issue-source';
            msgDiv.appendChild(msgElementSource);
            _options.customIssueSource.call(this, id, message, standard, msgElementSource, msgDetailsDiv);
        } else {
            var msgElementSource       = _doc.createElement('div');
            msgElementSource.className = _prefix + 'issue-source';

            // Header row.
            var msgElementSourceHeader       = _doc.createElement('div');
            msgElementSourceHeader.className = _prefix + 'issue-source-header';

            var msgSourceHeaderText       = _doc.createElement('strong');
            msgSourceHeaderText.innerHTML = 'Code Snippet';

            var btnPointTo = buildSummaryButton(_prefix + 'button-point-to-element-' + id, 'pointer', 'Point to Element', function() {
                self.pointToElement(message.element);
            });

            msgElementSourceHeader.appendChild(msgSourceHeaderText);
            msgElementSourceHeader.appendChild(btnPointTo);
            msgElementSource.appendChild(msgElementSourceHeader);

            if (message.element.outerHTML) {
                var preText  = '';
                var postText = '';

                if (message.element.innerHTML.length > 31) {
                    var outerHTML = message.element.outerHTML.replace(message.element.innerHTML, message.element.innerHTML.substr(0, 31) + '...');
                } else {
                    var outerHTML = message.element.outerHTML;
                }

                // Find previous siblings.
                var preNode = message.element.previousSibling;
                while (preText.length <= 31) {
                    if (preNode === null) {
                        break;
                    } else {
                        if (preNode.nodeType === 1) {
                            // Element node.
                            preText = preNode.outerHTML;
                        } else if (preNode.nodeType === 3) {
                            // Text node.
                            if (preNode.textContent !== undefined) {
                                preText = preNode.textContent + preText;
                            } else {
                                preText = preNode.nodeValue + preText;
                            }
                        }

                        if (preText.length > 31) {
                            preText = '...' + preText.substr(preText.length - 31);
                        }
                    }

                    preNode = preNode.previousSibling;
                }//end while

                // Find following siblings.
                var postNode = message.element.nextSibling;
                while (postText.length <= 31) {
                    if (postNode === null) {
                        break;
                    } else {
                        if (postNode.nodeType === 1) {
                            // Element node.
                            postText += postNode.outerHTML;
                        } else if (postNode.nodeType === 3) {
                            // Text node.
                            if (postNode.textContent !== undefined) {
                                postText += postNode.textContent;
                            } else {
                                postText += postNode.nodeValue;
                            }
                        }

                        if (postText.length > 31) {
                            postText = postText.substr(0, 31) + '...';
                        }
                    }

                    postNode = postNode.nextSibling;
                }//end while

                // Actual source code, highlighting offending element.
                var msgElementSourceInner       = _doc.createElement('div');
                msgElementSourceInner.className = _prefix + 'issue-source-inner';

                var msgElementSourceMain       = _doc.createElement('strong');
                if (msgElementSourceMain.textContent !== undefined) {
                    msgElementSourceMain.textContent = outerHTML;
                } else {
                    // IE8 uses innerText instead. Oh well.
                    msgElementSourceMain.innerText = outerHTML;
                }

                msgElementSourceInner.appendChild(_doc.createTextNode(preText));
                msgElementSourceInner.appendChild(msgElementSourceMain);
                msgElementSourceInner.appendChild(_doc.createTextNode(postText));
                msgElementSource.appendChild(msgElementSourceInner);
            } else {
                // No support for outerHTML.
                var msgElementSourceInner       = _doc.createElement('div');
                msgElementSourceInner.className = _prefix + 'issue-source-not-supported';

                var nsText = 'The code snippet functionality is not supported in this browser.';

                msgElementSourceInner.appendChild(_doc.createTextNode(nsText));
                msgElementSource.appendChild(msgElementSourceInner);
            }//end if

            msgDiv.appendChild(msgElementSource);
        }//end if

        return msgDiv;
    };

    var buildNavigation = function(page, totalPages) {
        var navDiv       = _doc.createElement('div');
        navDiv.className = _prefix + 'navigation';

        var prev       = _doc.createElement('span');
        prev.className = _prefix + 'nav-button ' + _prefix + 'previous';
        prev.innerHTML = String.fromCharCode(160);

        if (page === 1) {
            prev.className += ' ' + _prefix + 'disabled';
        }

        navDiv.appendChild(prev);

        var pageNum       = _doc.createElement('span');
        pageNum.className = _prefix + 'page-number';
        pageNum.innerHTML = 'Page ' + page + ' of ' + totalPages;
        navDiv.appendChild(pageNum);

        var next       = _doc.createElement('span');
        next.className = _prefix + 'nav-button ' + _prefix + 'next';
        next.innerHTML = String.fromCharCode(160);

        if (page === totalPages) {
            next.className += ' ' + _prefix + 'disabled';
        }

        navDiv.appendChild(next);

        prev.onclick = function() {
            if (_page > 1) {
                _page--;
                if (_page === 1) {
                    prev.className += ' ' + _prefix + 'disabled';
                }
            }

            if (totalPages > 1) {
                next.className = next.className.replace(new RegExp(' ' + _prefix + 'disabled'), '');
            }

            pageNum.innerHTML = '';
            pageNum.appendChild(document.createTextNode('Page ' + _page + ' of ' + totalPages));

            var issueList = _doc.querySelectorAll('.HTMLCS-issue-list')[0];
            issueList.style.marginLeft = ((_page - 1) * -300) + 'px';
        }

        next.onclick = function() {
            if (_page < totalPages) {
                _page++;
                if (_page === totalPages) {
                    next.className += ' ' + _prefix + 'disabled';
                }
            }

            if (totalPages > 1) {
                prev.className = prev.className.replace(new RegExp(' ' + _prefix + 'disabled'), '');
            }

            pageNum.innerHTML = '';
            pageNum.appendChild(document.createTextNode('Page ' + _page + ' of ' + totalPages));

            var issueList = _doc.querySelectorAll('.HTMLCS-issue-list')[0];
            issueList.style.marginLeft = ((_page - 1) * -300) + 'px';
        }

        return navDiv;
    }

    var pointToIssueElement = function(issue) {
        var msg = _messages[Number(issue)];
        if (!msg.element) {
            return;
        }

        var btnPointTo    = _doc.getElementById(_prefix + 'button-point-to-element-' + issue);
        pointer.container = self.pointerContainer || _doc.getElementById('HTMLCS-wrapper');

        if (pointer.isPointable(msg.element) === false) {
            var myPointer = pointer.getPointer(msg.element);

            if (pointer.pointer) {
                myPointer.className += ' HTMLCS-pointer-hidden';
            }

            if (btnPointTo) {
                btnPointTo.className += ' disabled';
            }
        } else {
            if (btnPointTo) {
                btnPointTo.className =  btnPointTo.className.replace(' disabled', '');
            }

            pointer.pointTo(msg.element);
        }

    };

    var loadStandards = function(standards, callback) {
        if (standards.length === 0) {
            callback.call(this);
            return;
        }

        var standard = standards.shift();
        HTMLCS.loadStandard(standard, function() {
            loadStandards(standards, callback);
        });

    };

    
    var _includeScript = function(src, callback) {
        var script    = document.createElement('script');
        script.onload = function() {
            script.onload = null;
            script.onreadystatechange = null;

            if ((callback instanceof Function) === true) {
                callback.call(this);
            }
        };

        script.onreadystatechange = function() {
            if (/^(complete|loaded)$/.test(this.readyState) === true) {
                script.onreadystatechange = null;
                script.onload();
            }
        }

        script.src = src;

        if (document.head) {
            document.head.appendChild(script);
        } else {
            document.getElementsByTagName('head')[0].appendChild(script);
        }
    };

    this.setOption = function(name, value) {
        _options[name] = value;
    }

    this.getIssue = function(issueNumber)
    {
        return _messages[issueNumber];

    };

    this.countIssues = function(messages)
    {
        var counts = {
            error: 0,
            warning: 0,
            notice: 0
        };

        for (var i = 0; i < messages.length; i++) {
            switch (messages[i].type) {
                case HTMLCS.ERROR:
                    counts.error++;
                break;

                case HTMLCS.WARNING:
                    counts.warning++;
                break;

                case HTMLCS.NOTICE:
                    counts.notice++;
                break;
            }//end switch
        }//end for

        return counts;
    };

    this.build = function(standard, messages, options) {
        var wrapper = null;
        if (_doc) {
            var wrapper = _doc.getElementById(_prefix + 'wrapper');
        }

        var errors   = 0;
        var warnings = 0;
        var notices  = 0;

        for (var i = 0; i < messages.length; i++) {
            // Filter only the wanted error types.
            var ignore = false;
            switch (messages[i].type) {
                case HTMLCS.ERROR:
                    if (_options.show.error === false) {
                        ignore = true;
                    } else {
                        errors++;
                    }
                break;

                case HTMLCS.WARNING:
                    if (_options.show.warning === false) {
                        ignore = true;
                    } else {
                        warnings++;
                    }
                break;

                case HTMLCS.NOTICE:
                    if (_options.show.notice === false) {
                        ignore = true;
                    } else {
                        notices++;
                    }
                break;
            }//end switch

            if (ignore === true) {
                messages.splice(i, 1);
                i--;
            }
        }//end for

        _messages = messages;

        var settingsContents = '';
        var summaryContents  = '';
        var detailContents   = '';

        for (var i = 0; i < messages.length; i++) {
            if ((i % 5) === 0) {
                summaryContents += '<ol class="HTMLCS-issue-list"';

                if (i === 0) {
                    summaryContents += 'style="margin-left: 0em"';
                }

                summaryContents += '>';
            }

            summaryContents += buildMessageSummary(i, messages[i]);

            if (((i % 5) === 4) || (i === (messages.length - 1))) {
                summaryContents += '</ol>';
            }

            detailContents  += buildMessageDetail(i, messages[i], standard);
        }

        var detailWidth  = (i * 300);

        var wrapper       = _doc.createElement('div');
        wrapper.id        = _prefix + 'wrapper';
        wrapper.className = 'showing-issue-list';

        if (_options.noHeader !== true) {
            var header = buildHeaderSection(standard, wrapper);
            wrapper.appendChild(header);
        }

        var summary       = buildSummarySection(errors, warnings, notices);
        var summaryDetail = buildDetailSummarySection(1, messages.length);

        var innerWrapper       = _doc.createElement('div');
        innerWrapper.id        = _prefix + 'issues-wrapper';
        innerWrapper.className = _prefix + 'inner-wrapper';

        var issueList = buildIssueListSection(messages);
        innerWrapper.appendChild(issueList);

        var totalPages = Math.ceil(messages.length / 5);
        var navDiv     = buildNavigation(1, totalPages);
        innerWrapper.appendChild(navDiv);

        var outerWrapper       = _doc.createElement('div');
        outerWrapper.className = _prefix + 'outer-wrapper';
        outerWrapper.appendChild(innerWrapper);

        var innerWrapper       = _doc.createElement('div');
        innerWrapper.id        = _prefix + 'issues-detail-wrapper';
        innerWrapper.className = _prefix + 'inner-wrapper';

        var issueDetail = buildIssueDetailSection(messages);
        innerWrapper.appendChild(issueDetail);
        outerWrapper.appendChild(innerWrapper);

        wrapper.appendChild(summary);
        wrapper.appendChild(summaryDetail);
        wrapper.appendChild(outerWrapper);

        return wrapper;
    };

    this.buildSummaryPage = function() {
        var wrapper       = _doc.createElement('div');
        wrapper.id        = _prefix + 'wrapper';
        wrapper.className = 'showing-settings';

        if (_options.noHeader !== true) {
            var header = buildHeaderSection(_standard, wrapper);
            wrapper.appendChild(header);
        }

        var summary = buildSettingsSection();
        wrapper.appendChild(summary);

        return wrapper;
    };

    this.changeScreen = function(screen) {
        var wrapper = _doc.getElementById(_prefix + 'wrapper');

        // Remove current "showing" section, add new one, then clean up the class name.
        wrapper.className  = wrapper.className.replace(new RegExp('showing-' + _screen), '');
        wrapper.className += ' showing-' + screen;
        wrapper.className  = wrapper.className.replace(/\s+/, ' ');
        _screen = screen;
    };

    this.includeCss = function(prefix, doc) {
        if (_options.includeCss === false) {
            return;
        }

        if (doc === undefined) {
            doc = _doc;
        }

        var head     = doc.querySelector('head');
        var exLinks  = head.getElementsByTagName('link');
        var foundCss = false;
        for (var i = 0; i < exLinks.length; i++) {
            if (new RegExp(prefix + '\.css').test(exLinks[i].getAttribute('href')) === true) {
                foundCss = true;
                break;
            }
        }

        if (foundCss === false) {
            var cssLink  = doc.createElement('link');
            cssLink.rel  = 'stylesheet';
            cssLink.type = 'text/css';
            cssLink.href = _options.path + prefix + '.css';
            head.appendChild(cssLink);
        }
    }

    this.getStandardList = function() {
        var pattern   = /^HTMLCS_[^_]+$/;
        var standards = [];
        for (i in window) {
            if (pattern.test(i) === true) {
                var standard = window[i];
                if (standard.sniffs && standard.name) {
                    standards.push(i.substr(7));
                }
            }
        }

        return standards;
    };

    this.getParentElement = function() {
        var parentEl = null;
        if (_options.parentElement) {
            parentEl = _options.parentElement;
        } else if (_top.frames.length > 0) {
            var largestFrameSize = -1;
            var largestFrame     = null;

            for (var i = 0; i < _top.frames.length; i++) {
                try {
                    if (window.frames[i].frameElement.nodeName.toLowerCase() === 'frame') {
                        if (window.frames[i].document) {
                            var frameSize = window.frames[i].innerWidth * window.frames[i].innerHeight;
                            if (frameSize > largestFrameSize) {
                                largestFrameSize = frameSize;
                                largestFrame     = window.frames[i].document.body;
                            }
                        }//end if
                    }//end if
                } catch (ex) {
                    // Skip cross-domain frames. Can't do much about those.
                }//end try
            }//end for

            if (largestFrame === null) {
                // They're all iframes. Just use the main document body.
                parentEl = document.body;
            } else {
                parentEl = largestFrame;
            }
        } else {
            parentEl = document.body;
        }

        return parentEl;
    };

    this.getOwnerDocument = function() {
        var _doc = this.getParentElement();
        if (_doc.ownerDocument) {
            _doc = _doc.ownerDocument;
        };

        return _doc;
    };

    
    this.run = function(standard, source, options) {
        // Save the top window.
        _top = window;

        var standards       = this.getStandardList();
        var standardsToLoad = [];
        for (var i = 0; i < standards.length; i++) {
            if (!window['HTMLCS_' + standards[i]]) {
                standardsToLoad.push(standards[i]);
            }
        }

        if (standardsToLoad.length > 0) {
            loadStandards(standardsToLoad, function() {
                self.run(standard, source, options);
            });
            return;
        }

        if ((source === null) || (source === undefined)) {
            // If not defined (or no longer existing?), check the document.
            source = [];

            if (document.querySelectorAll('frameset').length === 0) {
                source.push(document);
            };

            if (_top.frames.length > 0) {
                for (var i = 0; i < _top.frames.length; i++) {
                    try {
                        source.push(_top.frames[i].document);
                    } catch (ex) {
                        // If no access permitted to the document (eg.
                        // cross-domain), then ignore.
                    }
                }
            }
        } else if (source.nodeName) {
            // See if we are being sent a text box or text area; if so then
            // examine its contents rather than the node itself.
            if (source.nodeName.toLowerCase() === 'input') {
                if (source.hasAttribute('type') === false) {
                    // Inputs with no type default to text fields.
                    source = source.value;
                } else {
                    var inputType = source.getAttribute('type').toLowerCase();
                    if (inputType === 'text') {
                        // Text field.
                        source = source.value;
                    }
                }
            } else if (source.nodeName.toLowerCase() === 'textarea') {
                // Text area.
                source = source.value;
            }//end if
        }

        if ((source instanceof Array) === false) {
            source = [source];
        }//end if

        if (options === undefined) {
            options = {};
        }

        // Save the options at this point, so we can refresh with them.
        _standard = standard;
        _sources  = source;
        _options  = options;
        _page     = 1;
        _screen   = '';
        _messages = [];

        var parentEl = this.getParentElement();
        _doc         = this.getOwnerDocument();

        if (!_options.path) {
            _options.path = './';
        }

        if (_options.includeCss === undefined) {
            _options.includeCss = true;
        }

        if (_options.ignoreMsgCodes === undefined) {
            _options.ignoreMsgCodes = [];
        }

        this.includeCss('HTMLCS');

        var target    = _doc.getElementById(_prefix + 'wrapper');
        var newlyOpen = false;

        // Load the "processing" screen.
        var wrapper        = self.buildSummaryPage();
        wrapper.className += ' HTMLCS-processing';

        if (target) {
            wrapper.style.left = target.style.left;
            wrapper.style.top  = target.style.top;
            parentEl.replaceChild(wrapper, target);
        } else {
            // Being opened for the first time (in this frame).
            if (_options.openCallback) {
                _options.openCallback.call(this);
            }

            newlyOpen = true;
            parentEl.appendChild(wrapper);
        }

        // Process and replace with the issue list when finished.
        var _finalise = function() {
            // Before then, ignore warnings arising from the Advisor interface itself.
            for (var i = 0; i < _messages.length; i++) {
                var ignore = false;
                if (wrapper) {
                    if (wrapper === _messages[i].element) {
                        ignore = true;
                    } else if (_messages[i].element.documentElement) {
                        // Short-circuit document objects. IE doesn't like documents
                        // being the argument of contains() calls.
                        ignore = false;
                    } else if ((wrapper.contains) && (wrapper.contains(_messages[i].element) === true)) {
                        ignore = true;
                    } else if ((wrapper.compareDocumentPosition) && ((wrapper.compareDocumentPosition(_messages[i].element) & 16) > 0)) {
                        ignore = true;
                    }
                }//end if

                for (var j = 0; j < options.ignoreMsgCodes.length; j++) {
                    if (new RegExp(options.ignoreMsgCodes[j]).test(_messages[i].code) === true) {
                        ignore = true;
                        break;
                    }
                }

                if (ignore === true) {
                    _messages.splice(i, 1);
                    i--;
                }
            }//end for

            if (_options.runCallback) {
                var _newMsgs = _options.runCallback.call(this, _messages, newlyOpen);
                if ((_newMsgs instanceof Array) === true) {
                    _messages = _newMsgs;
                }
            }

            setTimeout(function() {
                var wrapper    = _doc.getElementById(_prefix + 'wrapper');
                var newWrapper = self.buildSummaryPage();

                newWrapper.style.left = wrapper.style.left;
                newWrapper.style.top  = wrapper.style.top;
                parentEl.replaceChild(newWrapper, wrapper);
            }, 400);
        };

        var _processSource = function(standard, sources) {
            var source = sources.shift();

            // Source is undefined. Keep shifting, until we find one or we run
            // out of array elements.
            while (!source) {
                if (sources.length === 0) {
                    _finalise();
                    return;
                } else {
                    source = sources.shift();
                }
            }

            HTMLCS.process(standard, source, function() {
                _messages = _messages.concat(HTMLCS.getMessages());
                if (sources.length === 0) {
                    _finalise();
                } else {
                    _processSource(standard, sources);
                }
            });
        };

        _processSource(standard, _sources.concat([]));
    };

    this.versionCheck = function(response) {
        if (response && (response.currentVersion !== null)) {
            if (response.newVersion > response.currentVersion) {
                var msgElementSource = _doc.createElement('div');
                msgElementSource.id  = _prefix + 'settings-updated-notification';
                _doc.documentElement.querySelector('.HTMLCS-settings').appendChild(msgElementSource);

                var msg = 'HTML_CodeSniffer has been updated to version ' + response.newVersion + '.';
                msg    += ' <a href="http://squizlabs.github.io/HTML_CodeSniffer/patches/' + response.newVersion + '">View the changelog</a>'

                msgElementSource.innerHTML = msg;
            }//end if
        }//end if
    };

    this.close = function() {
        if (_doc) {
            var wrapper = _doc.getElementById('HTMLCS-wrapper');

            if (wrapper) {
                var pointerEl = pointer.getPointer(wrapper);
                if (pointerEl && pointerEl.parentNode) {
                    pointerEl.parentNode.removeChild(pointerEl);
                }

                wrapper.parentNode.removeChild(wrapper);

                if (_options.closeCallback) {
                    _messages = _options.closeCallback.call(this);
                }
            }//end if
        }//end if
    };

    this.pointToElement = function(element) {
        pointer.container = self.pointerContainer || _doc.getElementById('HTMLCS-wrapper');
        pointer.pointTo(element);

    };

    this.getCurrentStandard = function() {
        return _standard;

    };

    var pointer =
    {
        pointerDim: {},
        container: null,

        getBoundingRectangle: function(element)
        {
            if (!element) {
                return null;
            }

            // Retrieve the coordinates and dimensions of the element.
            var coords     = this.getElementCoords(element);
            var dimensions = this.getElementDimensions(element);
            var result     = {
                'x1' : coords.x,
                'y1' : coords.y,
                'x2' : coords.x + dimensions.width,
                'y2' : coords.y + dimensions.height
            };
            return result;

        },

        getElementDimensions: function(element)
        {
            var result = {
                width: element.offsetWidth,
                height: element.offsetHeight
            };

            return result;

        },

        getElementCoords: function(element, absolute)
        {
            var left = 0;
            var top  = 0;

            // Get parent window coords.
            var window = HTMLCS.util.getElementWindow(element);

            if (absolute === true) {
                var topWin = window.top;
            } else {
                var topWin = window;
            }

            while (true) {
                do {
                    left += element.offsetLeft;
                    top  += element.offsetTop;
                } while (element = element.offsetParent);

                if (window === topWin) {
                    break;
                } else {
                    element = window.frameElement;
                    window  = window.parent;

                    if (element.nodeName.toLowerCase() === 'frame') {
                        // We can't go any further if we hit a proper frame.
                        break;
                    }
                }
            }//end while

            return {
                x: left,
                y: top
            };

        },

        getWindowDimensions: function(elem)
        {
            var window = HTMLCS.util.getElementWindow(elem);
            var doc    = elem.ownerDocument;

            var windowWidth  = 0;
            var windowHeight = 0;
            if (window.innerWidth) {
                // Will work on Mozilla, Opera and Safari etc.
                windowWidth  = window.innerWidth;
                windowHeight = window.innerHeight;
                // If the scrollbar is showing (it is always showing in IE) then its'
                // width needs to be subtracted from the height and/or width.
                var scrollWidth = this.getScrollbarWidth(elem);
                // The documentElement.scrollHeight.
                if (doc.documentElement.scrollHeight > windowHeight) {
                    // Scrollbar is shown.
                    if (typeof scrollWidth === 'number') {
                        windowWidth -= scrollWidth;
                    }
                }

                if (doc.body.scrollWidth > windowWidth) {
                    // Scrollbar is shown.
                    if (typeof scrollWidth === 'number') {
                        windowHeight -= scrollWidth;
                    }
                }
            } else if (doc.documentElement && (doc.documentElement.clientWidth || doc.documentElement.clientHeight)) {
                // Internet Explorer.
                windowWidth  = doc.documentElement.clientWidth;
                windowHeight = doc.documentElement.clientHeight;
            } else if (doc.body && (doc.body.clientWidth || doc.body.clientHeight)) {
                // Browsers that are in quirks mode or weird examples fall through here.
                windowWidth  = doc.body.clientWidth;
                windowHeight = doc.body.clientHeight;
            }//end if

            var result = {
                'width'  : windowWidth,
                'height' : windowHeight
            };
            return result;

        },

        getScrollbarWidth: function(elem)
        {
            if (_sbWidth !== null) {
                return _sbWidth;
            }

            doc = elem.ownerDocument;

            var wrapDiv            = null;
            var childDiv           = null;
            var widthNoScrollBar   = 0;
            var widthWithScrollBar = 0;
            // Outer scrolling div.
            wrapDiv                = doc.createElement('div');
            wrapDiv.style.position = 'absolute';
            wrapDiv.style.top      = '-1000px';
            wrapDiv.style.left     = '-1000px';
            wrapDiv.style.width    = '100px';
            wrapDiv.style.height   = '50px';
            // Start with no scrollbar.
            wrapDiv.style.overflow = 'hidden';

            // Inner content div.
            childDiv              = doc.createElement('div');
            childDiv.style.width  = '100%';
            childDiv.style.height = '200px';

            // Put the inner div in the scrolling div.
            wrapDiv.appendChild(childDiv);
            // Append the scrolling div to the doc.
            _doc.body.appendChild(wrapDiv);

            // Width of the inner div sans scrollbar.
            widthNoScrollBar = childDiv.offsetWidth;
            // Add the scrollbar.
            wrapDiv.style.overflow = 'auto';
            // Width of the inner div width scrollbar.
            widthWithScrollBar = childDiv.offsetWidth;

            // Remove the scrolling div from the doc.
            doc.body.removeChild(doc.body.lastChild);

            // Pixel width of the scroller.
            var scrollBarWidth = (widthNoScrollBar - widthWithScrollBar);

            // Set the auditor-level variable so we don't have to run this again.
            _sbWidth = scrollBarWidth;
            return scrollBarWidth;

        },

        getScrollCoords: function(elem)
        {
            var window = HTMLCS.util.getElementWindow(elem);
            doc        = elem.ownerDocument;

            var scrollX = 0;
            var scrollY = 0;
            if (window.pageYOffset) {
                // Mozilla, Firefox, Safari and Opera will fall into here.
                scrollX = window.pageXOffset;
                scrollY = window.pageYOffset;
            } else if (doc.body && (doc.body.scrollLeft || doc.body.scrollTop)) {
                // This is the DOM compliant method of retrieving the scroll position.
                // Safari and OmniWeb supply this, but report wrongly when the window
                // is not scrolled. They are caught by the first condition however, so
                // this is not a problem.
                scrollX = doc.body.scrollLeft;
                scrollY = doc.body.scrollTop;
            } else {
                // Internet Explorer will get into here when in strict mode.
                scrollX = doc.documentElement.scrollLeft;
                scrollY = doc.documentElement.scrollTop;
            }

            var coords = {
                x: scrollX,
                y: scrollY
            };
            return coords;

        },

        isPointable: function(elem) {
            // If the specified elem is not in the DOM then we cannot point to it.
            // Also, cannot point to the document itself.
            if (elem.ownerDocument === null) {
                return false;
            }

            // Check whether the element is in the document, by looking up its
            // DOM tree for a document object.
            var parent = elem.parentNode;
            while (parent && parent.ownerDocument) {
                parent = parent.parentNode;
            }//end while

            // If we didn't hit a document, the element must not be in there.
            if (parent === null) {
                return false;
            }

            // Do not point to elem if its hidden. Use computed styles.
            if (HTMLCS.util.isHidden(elem) === true) {
                return false;
            }

            if (this.getPointerDirection(elem) === null) {
                return false;
            }

            return true;
        },

        getPointerDirection: function(elem) {
            var direction = null;

            // Get element coords.
            var rect      = this.getBoundingRectangle(elem);
            var myPointer = this.getPointer(elem);
            var doc       = elem.ownerDocument;

            myPointer.className  = myPointer.className.replace('HTMLCS-pointer-hidden', '');
            myPointer.className += ' HTMLCS-pointer-hidden-block';

            this.pointerDim.height = 62;
            this.pointerDim.width  = 62;

            var bounceHeight = 20;

            // Determine where to show the arrow.
            var winDim = this.getWindowDimensions(elem);
            var window = HTMLCS.util.getElementWindow(elem);

            var scrollY = Math.max(0, Math.min(rect.y1 - 100, doc.documentElement.offsetHeight - winDim.height));

            // Try to position the pointer.
            if ((rect.y1 - this.pointerDim.height - bounceHeight) > scrollY) {
                // Arrow direction down.
                direction = 'down';
            } else if ((rect.y2 + this.pointerDim.height) < (winDim.height - scrollY)) {
                // Up.
                direction = 'up';
            } else if ((rect.x2 + this.pointerDim.width) < winDim.width) {
                // Left.
                direction = 'left';
            } else if ((rect.x1 - this.pointerDim.width) > 0) {
                // Right.
                direction = 'right';
            }

            myPointer.className  = myPointer.className.replace('HTMLCS-pointer-hidden-block', '');
            myPointer.className += ' HTMLCS-pointer-hidden';

            return direction;
        },

        pointTo: function(elem) {
            // Do not point to elem if its hidden.
            if (elem.ownerDocument) {
                var doc = elem.ownerDocument;
            } else {
                var doc = elem;
            }

            var oldPointer = doc.getElementById('HTMLCS-pointer');
            if (oldPointer) {
                oldPointer.parentNode.removeChild(oldPointer);
            }

            if (this.isPointable(elem) === false) {
                return;
            }

            // Get element coords.
            var topWin = HTMLCS.util.getElementWindow(elem).top;
            var winDim = this.getWindowDimensions(topWin.document.documentElement);

            var direction = this.getPointerDirection(elem);
            var myPointer = this.getPointer(elem);

            myPointer.className  = myPointer.className.replace('HTMLCS-pointer-hidden-block', '');
            if (direction === null) {
                myPointer.className += ' HTMLCS-pointer-hidden';
            } else {
                var isFixed = false;
                if (HTMLCS.util.style(elem).position === 'fixed') {
                    var isFixed = true;
                }

                var parent = elem.parentNode;
                while (parent.ownerDocument) {
                    if (HTMLCS.util.style(parent).position === 'fixed') {
                        isFixed = true;
                        break;
                    }

                    parent = parent.parentNode;
                }//end while

                if (isFixed === true) {
                    myPointer.style.position = 'fixed';
                } else {
                    myPointer.style.position = 'absolute';

                    var rect    = this.getElementCoords(elem, true);
                    var window  = HTMLCS.util.getElementWindow(elem);
                    var targetY = Math.max(rect.y - 100, 0);

                    while (targetY >= 0) {
                        window.scrollTo(0, targetY);
                        var scrollCoords = this.getScrollCoords(window.document.documentElement);

                        targetY -= scrollCoords.y;
                        targetY  = Math.max(targetY, 0);

                        if (window === topWin) {
                            break;
                        } else {
                            window = window.parent;
                        }
                    }//end while
                }//end if

                this.showPointer(elem, direction);
            }
        },

        getPointer: function(targetElement) {
            try {
                var doc = targetElement.ownerDocument;
                HTMLCSAuditor.includeCss('HTMLCS', doc);
                var c = 'HTMLCS';

                var myPointer = doc.getElementById(c + '-pointer');
                if (!myPointer) {
                    myPointer = doc.createElement('div');
                    myPointer.id        = c + '-pointer';
                    myPointer.className = c + '-pointer ' + c + '-pointer-hidden';
                    doc.body.appendChild(myPointer);
                }
            } catch (ex) {
                // Can't get to owner document due to unsafe access.
            }

            return myPointer;
        },

        showPointer: function(elem, direction) {
            var c = 'HTMLCS';

            var myPointer = this.getPointer(elem);
            this._removeDirectionClasses(myPointer);
            myPointer.className += ' ' + c + '-pointer-' + direction;
            myPointer.className  = myPointer.className.replace(c + '-pointer-hidden', '');

            var rect         = this.getBoundingRectangle(elem);
            var top          = 0;
            var left         = 0;
            var bounceHeight = 20;
            switch (direction) {
                case 'up':
                    bounceHeight = (-bounceHeight);
                    top          = rect.y2;
                    if ((rect.x2 - rect.x1) < 250) {
                        left = (this.getRectMidPnt(rect) - (this.pointerDim.width / 2));
                    } else {
                        left = rect.x1;
                    }
                break;

                case 'down':
                default:
                    top = (rect.y1 - this.pointerDim.height);
                    if ((rect.x2 - rect.x1) < 250) {
                        left = (this.getRectMidPnt(rect) - (this.pointerDim.width / 2));
                    } else {
                        left = rect.x1;
                    }
                break;

                case 'left':
                    left = rect.x2;
                    top  = (this.getRectMidPnt(rect, true) - (this.pointerDim.height / 2));
                break;

                case 'right':
                    bounceHeight = (-bounceHeight);
                    left         = (rect.x1 - this.pointerDim.width);
                    top          = (this.getRectMidPnt(rect, true) - (this.pointerDim.height / 2));
                break;

            }//end switch

            var frameScroll = this.getScrollCoords(elem);

            myPointer.style.top  = top  + 'px';
            myPointer.style.left = left + 'px';

            // Check if the help window is under the pointer then re-position it.
            // Unless it is an element within the HTMLCS pop-up.
            var coords    = this.getBoundingRectangle(this.container);
            rect          = this.getBoundingRectangle(myPointer);
            var posOffset = 20;
            var newPos    = null;
            var midX      = (rect.x1 + ((rect.x2 - rect.x1) / 2));
            var midY      = (rect.y1 + ((rect.y2 - rect.y1) / 2));

            if (HTMLCS.util.style(myPointer).position !== 'fixed') {
                midY -= frameScroll.y;
            }

            if (coords.x1 <= midX
                && coords.x2 >= midX
                && coords.y1 <= midY
                && coords.y2 >= midY
            ) {
                var self = this;

                this.container.className += ' HTMLCS-translucent';
                setTimeout(function() {
                    self.container.className = self.container.className.replace('HTMLCS-translucent', '');
                }, 4000);
            }

            this.bounce(myPointer, function() {
                setTimeout(function() {
                    if (myPointer.parentNode) {
                        myPointer.parentNode.removeChild(myPointer);
                    }
                }, 1500);
            }, direction);

        },

        bounce: function(myPointer, callback, direction)
        {
            var currentDirection = direction;
            var initialPos       = 0;
            var style            = '';
            var initalPosOffset  = 0;
            var dist             = 30;
            var maxBounce        = 5;

            switch (direction) {
                case 'up':
                    currentDirection = direction + '-op';
                    initalPosOffset  = dist;
                case 'down':
                    style = 'top';
                break;

                case 'left':
                    currentDirection = direction + '-op';
                    initalPosOffset  = dist;
                case 'right':
                    style = 'left';
                break;
            }

            initialPos = (Number(myPointer.style[style].replace('px', '')) + initalPosOffset);

            var currentPos = initialPos;
            var lowerLimit = (initialPos - dist);
            var bounces    = 0;

            var i = setInterval(function() {
                if (currentDirection === direction) {
                    currentPos--;
                    myPointer.style[style] = currentPos + 'px';
                    if (currentPos < lowerLimit) {
                        currentDirection = direction + '-op';
                        if (bounces === maxBounce && initalPosOffset !== 0) {
                            clearInterval(i);
                            callback.call(this);
                            return;
                        }
                    }

                } else {
                    currentPos++;
                    myPointer.style[style] = currentPos + 'px';

                    if (currentPos >= initialPos) {
                        currentDirection = direction;
                        bounces++;

                        if (bounces === maxBounce && initalPosOffset === 0) {
                            clearInterval(i);
                            callback.call(this);
                            return;
                        }
                    }
                }
            }, 10);

        },

        getRectMidPnt: function(rect, height) {
            var midPnt = 0;
            if (height === true) {
                midPnt = (rect.y1 + ((rect.y2 - rect.y1) / 2));
            } else {
                midPnt = (rect.x1 + ((rect.x2 - rect.x1) / 2));
            }

            return midPnt;
        },

        _removeDirectionClasses: function(myPointer) {
            var c = 'HTMLCS';
            var d = ['down', 'up', 'left', 'right'];
            var l = d.length;
            for (var i = 0; i < l; i++) {
                myPointer.className = myPointer.className.replace(c + '-pointer-' + d[i], '');
            }
        }

    }

};



var HTMLCS = new function()
{
    var _standards    = {};
    var _sniffs       = [];
    var _tags         = {};
    var _standard     = null;
    var _currentSniff = null;

    var _messages     = [];
    var _msgOverrides = {};

    
    this.ERROR   = 1;
    this.WARNING = 2;
    this.NOTICE  = 3;

    
    this.process = function(standard, content, callback, failCallback) {
        // Clear previous runs.
        _standards    = {};
        _sniffs       = [];
        _tags         = {};
        _standard     = null;

        if (!content) {
            return false;
        }

        if (_standards[_getStandardPath(standard)]) {
            HTMLCS.run(callback, content);
        } else {
            this.loadStandard(standard, function() {
                HTMLCS.run(callback, content);
            }, failCallback);
        }
    };

    
    this.loadStandard = function(standard, callback, failCallback) {
        if (!standard) {
            return false;
        }

        _includeStandard(standard, function() {
            _standard = standard;
            callback.call(this);
        }, failCallback);
    };

    
    this.run = function(callback, content) {
        var element      = null;
        var loadingFrame = false;
        if (typeof content === 'string') {
            loadingFrame = true;
            var elementFrame = document.createElement('iframe');
            elementFrame.style.display = 'none';
            elementFrame = document.body.insertBefore(elementFrame, null);

            if (elementFrame.contentDocument) {
                element = elementFrame.contentDocument;
            } else if (element.contentWindow) {
                element = elementFrame.contentWindow.document;
            }

            elementFrame.load = function() {
                this.onreadystatechange = null;
                this.onload = null;

                if (HTMLCS.isFullDoc(content) === false) {
                    element = element.getElementsByTagName('body')[0];
                    var div = element.getElementsByTagName('div')[0];
                    if (div && (div.id === '__HTMLCS-source-wrap')) {
                        div.id  = '';
                        element = div;
                    }
                }

                var elements = _getAllTags(element);
                elements.unshift(element);
                _run(elements, element, callback);
            }

            // Satisfy IE which doesn't like onload being set dynamically.
            elementFrame.onreadystatechange = function() {
                if (/^(complete|loaded)$/.test(this.readyState) === true) {
                    this.onreadystatechange = null;
                    this.load();
                }
            }

            elementFrame.onload = elementFrame.load;

            if ((HTMLCS.isFullDoc(content) === false) && (content.indexOf('<body') === -1)) {
                element.write('<div id="__HTMLCS-source-wrap">' + content + '</div>');
            } else {
                element.write(content);
            }

            element.close();
        } else {
            element = content;
        }

        if (!element) {
            callback.call(this);
            return;
        }

        callback  = callback || function() {};
        _messages = [];

        // Get all the elements in the parent element.
        // Add the parent element too, which will trigger "_top" element codes.
        var elements = _getAllTags(element);
        elements.unshift(element);

        // Run the sniffs.
        if (loadingFrame === false) {
            _run(elements, element, callback);
        }
    };

    
    this.isFullDoc = function(content) {
        var fullDoc = false;
        if (typeof content === 'string') {
            if (content.toLowerCase().indexOf('<html') !== -1) {
                fullDoc = true;
            } else if ((content.toLowerCase().indexOf('<head') !== -1) && (content.toLowerCase().indexOf('<body') !== -1)) {
                fullDoc = true;
            }
        } else {
            // If we are the document, or the document element.
            if ((content.nodeName.toLowerCase() === 'html') || (content.documentElement)) {
                fullDoc = true;
            }
        }

        return fullDoc;
    }

    
    this.addMessage = function(type, element, msg, code, data) {
        code = _getMessageCode(code);

        _messages.push({
            type: type,
            element: element,
            msg: _msgOverrides[code] || msg,
            code: code,
            data: data
        });
    };

    
    this.getMessages = function() {
        return _messages.concat([]);
    };

    
    var _run = function(elements, topElement, callback) {
        var topMsgs = [];
        while (elements.length > 0) {
            var element = elements.shift();

            if (element === topElement) {
                var tagName = '_top';
            } else {
                var tagName = element.tagName.toLowerCase();
            }

            // First check whether any "top" messages need to be shifted off for this
            // element. If so, dump off into the main messages.
            for (var i = 0; i < topMsgs.length;) {
                if (element === topMsgs[i].element) {
                    _messages.push(topMsgs[i]);
                    topMsgs.splice(i, 1);
                } else {
                    i++;
                }
            }//end for

            if (_tags[tagName] && _tags[tagName].length > 0) {
                _processSniffs(element, _tags[tagName].concat([]), topElement);

                // Save "top" messages, and reset the messages array.
                if (tagName === '_top') {
                    topMsgs   = _messages;
                    _messages = [];
                }
            }
        }//end while

        if (callback instanceof Function === true) {
            callback.call(this);
        }
    };

    
    var _processSniffs = function(element, sniffs, topElement, callback) {
        while (sniffs.length > 0) {
            var sniff     = sniffs.shift();
            _currentSniff = sniff;

            if (sniff.useCallback === true) {
                // If the useCallback property is set:
                // - Process the sniff.
                // - Recurse into ourselves with remaining sniffs, with no callback.
                // - Clear out the list of sniffs (so they aren't run again), so the
                //   callback (if not already recursed) can run afterwards.
                sniff.process(element, topElement, function() {
                    _processSniffs(element, sniffs, topElement);
                    sniffs = [];
                });
            } else {
                // Process the sniff.
                sniff.process(element, topElement);
            }
        }//end while

        if (callback instanceof Function === true) {
            callback.call(this);
        }
    };

    
    var _includeStandard = function(standard, callback, failCallback, options) {
        if (standard.indexOf('http') !== 0) {
            standard = _getStandardPath(standard);
        }//end id

        // See if the ruleset object is already included (eg. if minified).
        var parts   = standard.split('/');
        var ruleSet = window['HTMLCS_' + parts[(parts.length - 2)]];
        if (ruleSet) {
            // Already included.
            _registerStandard(standard, callback, failCallback, options);
        } else {
            _includeScript(standard, function() {
                // Script is included now register the standard.
                _registerStandard(standard, callback, failCallback, options);
            }, failCallback);
        }//end if
    };

    
    var _registerStandard = function(standard, callback, failCallback, options) {
        // Get the object name.
        var parts = standard.split('/');

        // Get a copy of the ruleset object.
        var oldRuleSet = window['HTMLCS_' + parts[(parts.length - 2)]];
        var ruleSet    = {};

        for (var x in oldRuleSet) {
            if (oldRuleSet.hasOwnProperty(x) === true) {
                ruleSet[x] = oldRuleSet[x];
            }
        }

        if (!ruleSet) {
            return false;
        }

        _standards[standard] = ruleSet;

        // Process the options.
        if (options) {
            if (options.include && options.include.length > 0) {
                // Included sniffs.
                ruleSet.sniffs = options.include;
            } else if (options.exclude) {
                // Excluded sniffs.
                for (var i = 0; i < options.exclude.length; i++) {
                    var index = ruleSet.sniffs.find(options.exclude[i]);
                    if (index >= 0) {
                        ruleSet.sniffs.splice(index, 1);
                    }
                }
            }
        }//end if

        // Register the sniffs for this standard.
        var sniffs = ruleSet.sniffs.slice(0, ruleSet.sniffs.length);
        _registerSniffs(standard, sniffs, callback, failCallback);
    };

    
    var _registerSniffs = function(standard, sniffs, callback, failCallback) {
        if (sniffs.length === 0) {
            callback.call(this);
            return;
        }

        // Include and register sniffs.
        var sniff = sniffs.shift();
        _loadSniffFile(standard, sniff, function() {
            _registerSniffs(standard, sniffs, callback, failCallback);
        }, failCallback);
    };

    
    var _loadSniffFile = function(standard, sniff, callback, failCallback) {
        if (typeof sniff === 'string') {
            var sniffObj = _getSniff(standard, sniff);
            var cb       = function() {
                _registerSniff(standard, sniff);
                callback.call(this);
            }

            // Already loaded.
            if (sniffObj) {
                cb();
            } else {
                _includeScript(_getSniffPath(standard, sniff), cb, failCallback);
            }
        } else {
            // Including a whole other standard.
            _includeStandard(sniff.standard, function() {
                if (sniff.messages) {
                    // Add message overrides.
                    for (var msg in sniff.messages) {
                        _msgOverrides[msg] = sniff.messages[msg];
                    }
                }

                callback.call(this);
            }, failCallback, {
                exclude: sniff.exclude,
                include: sniff.include
            });
        }
    };

    
    var _registerSniff = function(standard, sniff) {
        // Get the sniff object.
        var sniffObj = _getSniff(standard, sniff);
        if (!sniffObj) {
            return false;
        }

        // Call the register method of the sniff, it should return an array of tags.
        if (sniffObj.register) {
            var watchedTags = sniffObj.register();
        }

        if (watchedTags && watchedTags.length > 0) {
            for (var i = 0; i < watchedTags.length; i++) {
                if (!_tags[watchedTags[i]]) {
                    _tags[watchedTags[i]] = [];
                }

                _tags[watchedTags[i]].push(sniffObj);
            }
        }

        _sniffs.push(sniffObj);
    };

    
    var _getSniffPath = function(standard, sniff) {
        var parts = standard.split('/');
        parts.pop();
        var path = parts.join('/') + '/Sniffs/' + sniff.replace(/\./g, '/') + '.js';
        return path;
    };

    
    var _getStandardPath = function(standard)
    {
        // Get the include path of a local standard.
        var scripts = document.getElementsByTagName('script');
        var path    = null;

        // Loop through all the script tags that exist in the document and find the one
        // that has included this file.
        for (var i = 0; i < scripts.length; i++) {
            if (scripts[i].src) {
                if (scripts[i].src.match(/HTMLCS\.js/)) {
                    // We have found our appropriate <script> tag that includes
                    // this file, we can extract the path.
                    path = scripts[i].src.replace(/HTMLCS\.js/,'');
                    break;
                }
            }
        }

        return path + 'Standards/' + standard + '/ruleset.js';

    };

    
    var _getSniff = function(standard, sniff) {
        var name = 'HTMLCS_';
        name    += _standards[standard].name + '_Sniffs_';
        name    += sniff.split('.').join('_');

        if (!window[name]) {
            return null;
        }

        window[name]._name = sniff;
        return window[name];
    };

    
    var _getMessageCode = function(code) {
        code = _standard + '.' + _currentSniff._name + '.' + code;
        return code;
    };

    
    var _includeScript = function(src, callback, failCallback) {
        var script    = document.createElement('script');
        script.onload = function() {
            script.onload = null;
            script.onreadystatechange = null;
            callback.call(this);
        };

        script.onerror = function() {
            script.onload = null;
            script.onreadystatechange = null;
            if (failCallback) {
                failCallback.call(this);
            }
        };

        script.onreadystatechange = function() {
            if (/^(complete|loaded)$/.test(this.readyState) === true) {
                script.onreadystatechange = null;
                script.onload();
            }
        }

        script.src = src;

        if (document.head) {
            document.head.appendChild(script);
        } else {
            document.getElementsByTagName('head')[0].appendChild(script);
        }
    };

    
    var _getAllTags = function(element) {
        element      = element || document;
        var elements = element.getElementsByTagName('*');

        // Convert to array. We can't use array features on a NodeList.
        var elArray = [];
        for (var i = 0; i < elements.length; i++) {
            elArray.push(elements[i]);
        }

        return elArray;
    };

    this.util = new function() {
        
        this.trim = function(string) {
            return string.replace(/^\s*(.*)\s*$/g, '$1');
        };

        
        this.isStringEmpty = function(string) {
            if (typeof string !== 'string') {
                return true;
            }

            var empty = true;

            if (string.indexOf(String.fromCharCode(160)) !== -1) {
                // Has an NBSP, therefore cannot be empty.
                empty = false;
            } else if (/^\s*$/.test(string) === false) {
                // Not spacing.
                empty = false;
            }

            return empty;
        };

        
        this.getElementWindow = function(element)
        {
            if (element.ownerDocument) {
                var doc = element.ownerDocument;
            } else {
                var doc = element;
            }

            var window = null;
            if (doc.defaultView) {
                window = doc.defaultView;
            } else {
                window = doc.parentWindow;
            }

            return window;

        };

        
        this.style = function(element) {
            var computedStyle = null;
            var window        = this.getElementWindow(element);

            if (element.currentStyle) {
                computedStyle = element.currentStyle;
            } else if (window.getComputedStyle) {
                computedStyle = window.getComputedStyle(element, null);
            }

            return computedStyle;
        };

        
        this.isHidden = function(element) {
            var hidden = false;

            // Do not point to elem if its hidden. Use computed styles.
            var style = this.style(element);
            if (style !== null) {
                if ((style.visibility === 'hidden') || (style.display === 'none')) {
                    hidden = true;
                }

                if ((parseInt(style.left, 10) + parseInt(style.width, 10)) < 0) {
                    hidden = true;
                }

                if ((parseInt(style.top, 10) + parseInt(style.height, 10)) < 0) {
                    hidden = true;
                }
            }

            return hidden;
        };

        
        this.isDisabled = function(element) {
            var disabled = false;

            // Do not point to elem if its hidden. Use computed styles.
            if ((element.disabled === true) || (element.getAttribute('aria-disabled') === 'true')) {
                disabled = true;
            }

            return disabled;
        };

        
        this.isInDocument = function(element) {
            // Check whether the element is in the document, by looking up its
            // DOM tree for a document object.
            var parent = element.parentNode;
            while (parent && parent.ownerDocument) {
                parent = parent.parentNode;
            }//end while

            // If we didn't hit a document, the element must not be in there.
            if (parent === null) {
                return false;
            }

            return true;
        };

        
        this.contains = function(parent, child) {
            var contained = false;

            // If the parent and the child are the same, they can't contain each
            // other.
            if (parent !== child) {
                if (!parent.ownerDocument) {
                    // Parent is the document. Short-circuiting because contains()
                    // doesn't exist on the document element.
                    // We check whether the child can be contained, and whether the
                    // child is in the same document as the parent.
                    if ((child.ownerDocument) && (child.ownerDocument === parent)) {
                        contained = true;
                    }
                } else {
                    if ((parent.contains) && (parent.contains(child) === true)) {
                        contained = true;
                    } else if ((parent.compareDocumentPosition) && ((parent.compareDocumentPosition(child) & 16) > 0)) {
                        contained = true;
                    }
                }//end if
            }//end if

            return contained;
        };

        
        this.isLayoutTable = function(table) {
            var th = table.querySelector('th');
            if (th === null) {
                return true;
            }

            return false;
        };

        
        this.contrastRatio = function(colour1, colour2) {
            var ratio = (0.05 + this.relativeLum(colour1)) / (0.05 + this.relativeLum(colour2));
            if (ratio < 1) {
                ratio = 1 / ratio;
            }

            return ratio;
        };

        
        this.relativeLum = function(colour) {
            if (colour.charAt) {
                var colour = this.colourStrToRGB(colour);
            }

            var transformed = {};
            for (var x in colour) {
                if (colour[x] <= 0.03928) {
                    transformed[x] = colour[x] / 12.92;
                } else {
                    transformed[x] = Math.pow(((colour[x] + 0.055) / 1.055), 2.4);
                }
            }//end for

            var lum = ((transformed.red * 0.2126) + (transformed.green * 0.7152) + (transformed.blue * 0.0722));
            return lum;
        }

        
        this.colourStrToRGB = function(colour) {
            colour = colour.toLowerCase();

            if (colour.substring(0, 3) === 'rgb') {
                // rgb[a](0, 0, 0[, 0]) format.
                var matches = /^rgba?\s*\((\d+),\s*(\d+),\s*(\d+)([^)]*)\)$/.exec(colour);
                colour = {
                    red: (matches[1] / 255),
                    green: (matches[2] / 255),
                    blue: (matches[3] / 255)
                }
            } else {
                // Hex digit format.
                if (colour.charAt(0) === '#') {
                    colour = colour.substr(1);
                }

                if (colour.length === 3) {
                    colour = colour.replace(/^(.)(.)(.)$/, '$1$1$2$2$3$3');
                }

                colour = {
                    red: (parseInt(colour.substr(0, 2), 16) / 255),
                    green: (parseInt(colour.substr(2, 2), 16) / 255),
                    blue: (parseInt(colour.substr(4, 2), 16) / 255)
                };
            }

            return colour;
        };

        
        this.RGBtoColourStr = function(colour) {
            colourStr = '#';
            colour.red   = Math.round(colour.red * 255);
            colour.green = Math.round(colour.green * 255);
            colour.blue  = Math.round(colour.blue * 255);

            if ((colour.red % 17 === 0) && (colour.green % 17 === 0) && (colour.blue % 17 === 0)) {
                // Reducible to three hex digits.
                colourStr += (colour.red / 17).toString(16);
                colourStr += (colour.green / 17).toString(16);
                colourStr += (colour.blue / 17).toString(16);
            } else {
                if (colour.red < 16) {
                    colourStr += '0';
                }
                colourStr += colour.red.toString(16);

                if (colour.green < 16) {
                    colourStr += '0';
                }
                colourStr += colour.green.toString(16);

                if (colour.blue < 16) {
                    colourStr += '0';
                }
                colourStr += colour.blue.toString(16);
            }

            return colourStr;
        };

        
        this.sRGBtoHSV = function(colour) {
            // If this is a string, then convert to a colour structure.
            if (colour.charAt) {
                colour = this.colourStrToRGB(colour);
            }

            var hsvColour = {
                hue: 0,
                saturation: 0,
                value: 0
            };

            var maxColour = Math.max(colour.red, colour.green, colour.blue);
            var minColour = Math.min(colour.red, colour.green, colour.blue);
            var chroma    = maxColour - minColour;

            if (chroma === 0) {
                hsvColour.value = colour.red;
            } else {
                hsvColour.value = maxColour;
                if (maxColour === colour.red) {
                    hsvColour.hue = ((colour.green - colour.blue) / chroma);
                } else if (maxColour === colour.green) {
                    hsvColour.hue = (2.0 + ((colour.blue - colour.red) / chroma));
                } else {
                    hsvColour.hue = (4.0 + ((colour.red - colour.green) / chroma));
                }//end if

                hsvColour.hue = (hsvColour.hue * 60.0);
                if (hsvColour.hue >= 360.0) {
                    hsvColour.hue -= 360.0;
                }

                hsvColour.saturation = chroma / hsvColour.value;
            }//end if

            return hsvColour;
        };

        
        this.HSVtosRGB = function(hsvColour) {
            var colour = {
                red: 0,
                green: 0,
                blue: 0
            };

            if (hsvColour.saturation === 0) {
                colour.red = hsvColour.value;
                colour.green = hsvColour.value;
                colour.blue = hsvColour.value;
            } else {
                var chroma      = hsvColour.value * hsvColour.saturation;
                var minColour   = hsvColour.value - chroma;
                var interHue    = hsvColour.hue / 60.0;
                var interHueMod = interHue - 2 * (Math.floor(interHue / 2));
                var interCol    = chroma * (1 - Math.abs(interHueMod - 1));

                switch(Math.floor(interHue)) {
                    case 0:
                        colour.red   = chroma;
                        colour.green = interCol;
                    break;

                    case 1:
                        colour.green = chroma;
                        colour.red   = interCol;
                    break;

                    case 2:
                        colour.green = chroma;
                        colour.blue  = interCol;
                    break;

                    case 3:
                        colour.blue  = chroma;
                        colour.green = interCol;
                    break;

                    case 4:
                        colour.blue = chroma;
                        colour.red  = interCol;
                    break;

                    case 5:
                        colour.red  = chroma;
                        colour.blue = interCol;
                    break;
                }//end switch

                colour.red   = (colour.red + minColour);
                colour.green = (colour.green + minColour);
                colour.blue  = (colour.blue + minColour);
            }//end if

            return colour;
        };

        
        this.getElementTextContent = function(element, includeAlt)
        {
            if (includeAlt === undefined) {
                includeAlt = true;
            }

            var element = element.cloneNode(true);
            var nodes  = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                nodes.push(element.childNodes[i]);
            }

            var text = [];
            while (nodes.length > 0) {
                var node = nodes.shift();

                // If it's an element, add any sub-nodes to the process list.
                if (node.nodeType === 1) {
                    if (node.nodeName.toLowerCase() === 'img') {
                        // If an image, include the alt text unless we are blocking it.
                        if ((includeAlt === true) && (node.hasAttribute('alt') === true)) {
                            text.push(node.getAttribute('alt'));
                        }
                    } else {
                        for (var i = 0; i < node.childNodes.length; i++) {
                            nodes.push(node.childNodes[i]);
                        }
                    }
                } else if (node.nodeType === 3) {
                    // Text node.
                    text.push(node.nodeValue);
                }
            }

            // Push the text nodes together and trim.
            text = text.join('').replace(/^\s+|\s+$/g,'');
            return text;
        };

        
        this.testTableHeaders = function(element)
        {
            var retval = {
                required: true,
                used: false,
                correct: true,
                allowScope: true,
                missingThId: [],
                missingTd: [],
                wrongHeaders: []
            }

            var rows      = element.getElementsByTagName('tr');
            var tdCells   = {};
            var skipCells = [];

            // Header IDs already used.
            var headerIds = {
                rows: [],
                cols: []
            };
            var multiHeaders = {
                rows: 0,
                cols: 0
            }
            var missingIds = false;

            for (var rownum = 0; rownum < rows.length; rownum++) {
                var row    = rows[rownum];
                var colnum = 0;

                for (var item = 0; item < row.childNodes.length; item++) {
                    var cell = row.childNodes[item];
                    if (cell.nodeType === 1) {
                        // Skip columns that are skipped due to rowspan.
                        if (skipCells[rownum]) {
                            while (skipCells[rownum][0] === colnum) {
                                skipCells[rownum].shift();
                                colnum++;
                            }
                        }

                        var nodeName = cell.nodeName.toLowerCase();
                        var rowspan  = Number(cell.getAttribute('rowspan')) || 1;
                        var colspan  = Number(cell.getAttribute('colspan')) || 1;

                        // If rowspanned, mark columns as skippable in the following
                        // row(s).
                        if (rowspan > 1) {
                            for (var i = rownum + 1; i < rownum + rowspan; i++) {
                                if (!skipCells[i]) {
                                    skipCells[i] = [];
                                }

                                for (var j = colnum; j < colnum + colspan; j++) {
                                    skipCells[i].push(j);
                                }
                            }
                        }

                        if (nodeName === 'th') {
                            var id = (cell.getAttribute('id') || '');

                            // Save the fact that we have a missing ID on the header.
                            if (id === '') {
                                retval.correct = false;
                                retval.missingThId.push(cell);
                            }

                            if ((rowspan > 1) && (colspan > 1)) {
                                // Multi-column AND multi-row header. Abandon all hope,
                                // As it must span across more than one row+column
                                retval.allowScope = false;
                            } else if (retval.allowScope === true) {
                                // If we haven't had a th in this column (row) yet,
                                // record it. if we find another th in this column (row),
                                // record that has multi-ths. If we already have a column
                                // (row) with multi-ths, we cannot use scope.
                                if (headerIds.cols[colnum] === undefined) {
                                    headerIds.cols[colnum] = 0;
                                }

                                if (headerIds.rows[rownum] === undefined) {
                                    headerIds.rows[rownum] = 0;
                                }

                                headerIds.rows[rownum] += colspan;
                                headerIds.cols[colnum] += rowspan;
                            }//end if
                        } else if ((nodeName === 'td')) {
                            if ((cell.hasAttribute('headers') === true) && (/^\s*$/.test(cell.getAttribute('headers')) === false)) {
                                retval.used = true;
                            }
                        }//end if

                        colnum += colspan;
                    }//end if
                }//end for
            }//end for

            for (var i = 0; i < headerIds.rows.length; i++) {
                if (headerIds.rows[i] > 1) {
                    multiHeaders.rows++;
                }
            }

            for (var i = 0; i < headerIds.cols.length; i++) {
                if (headerIds.cols[i] > 1) {
                    multiHeaders.cols++;
                }
            }

            if ((multiHeaders.rows > 1) || (multiHeaders.cols > 1)) {
                retval.allowScope = false;
            } else if ((retval.allowScope === true) && ((multiHeaders.rows === 0) || (multiHeaders.cols === 0))) {
                // If only one column OR one row header.
                retval.required = false;
            }//end if

            // Calculate expected heading IDs. If they are not there or incorrect, flag
            // them.
            var cells = HTMLCS.util.getCellHeaders(element);
            for (var i = 0; i < cells.length; i++) {
                var cell     = cells[i].cell;
                var expected = cells[i].headers;

                if (cell.hasAttribute('headers') === false) {
                    retval.correct = false;
                    retval.missingTd.push(cell);
                } else {
                    var actual = (cell.getAttribute('headers') || '').split(/\s+/);
                    if (actual.length === 0) {
                        retval.correct = false;
                        retval.missingTd.push(cell);
                    } else {
                        actual = ' ' + actual.sort().join(' ') + ' ';
                        actual = actual.replace(/\s+/g, ' ').replace(/(\w+\s)\1+/g, '$1').replace(/^\s*(.*?)\s*$/g, '$1');
                        if (expected !== actual) {
                            retval.correct = false;
                            var val = {
                                element: cell,
                                expected: expected,
                                actual: (cell.getAttribute('headers') || '')
                            }
                            retval.wrongHeaders.push(val);
                        }
                    }//end if
                }//end if
            }//end for

            return retval;
        };

        
        this.getCellHeaders = function(table) {
            if (typeof table !== 'object') {
                return null;
            } else if (table.nodeName.toLowerCase() !== 'table') {
                return null;
            }


            var rows       = table.getElementsByTagName('tr');
            var skipCells  = [];
            var headingIds = {
                rows: {},
                cols: {}
            };

            // List of cells and headers. Each item should be a two-property object:
            // a "cell" object, and a normalised string of "headers".
            var cells = [];

            // Now determine the row and column headers for the table.
            // Go through once, first finding the th's to load up the header names,
            // then finding the td's to dump them off.
            var targetNodeNames = ['th', 'td'];
            for (var k = 0; k < targetNodeNames.length; k++) {
                var targetNode = targetNodeNames[k];
                for (var rownum = 0; rownum < rows.length; rownum++) {
                    var row    = rows[rownum];
                    var colnum = 0;

                    for (var item = 0; item < row.childNodes.length; item++) {
                        var thisCell = row.childNodes[item];
                        if (thisCell.nodeType === 1) {
                            // Skip columns that are skipped due to rowspan.
                            if (skipCells[rownum]) {
                                while (skipCells[rownum][0] === colnum) {
                                    skipCells[rownum].shift();
                                    colnum++;
                                }
                            }

                            var nodeName = thisCell.nodeName.toLowerCase();
                            var rowspan  = Number(thisCell.getAttribute('rowspan')) || 1;
                            var colspan  = Number(thisCell.getAttribute('colspan')) || 1;

                            // If rowspanned, mark columns as skippable in the following
                            // row(s).
                            if (rowspan > 1) {
                                for (var i = rownum + 1; i < rownum + rowspan; i++) {
                                    if (!skipCells[i]) {
                                        skipCells[i] = [];
                                    }

                                    for (var j = colnum; j < colnum + colspan; j++) {
                                        skipCells[i].push(j);
                                    }
                                }
                            }

                            if (nodeName === targetNode) {
                                if (nodeName === 'th') {
                                    // Build up the cell headers.
                                    var id = (thisCell.getAttribute('id') || '');

                                    for (var i = rownum; i < rownum + rowspan; i++) {
                                        headingIds.rows[i] = headingIds.rows[i] || {
                                            first: colnum,
                                            ids: []
                                        };
                                        headingIds.rows[i].ids.push(id);
                                    }

                                    for (var i = colnum; i < colnum + colspan; i++) {
                                        headingIds.cols[i] = headingIds.cols[i] || {
                                            first: rownum,
                                            ids: []
                                        };
                                        headingIds.cols[i].ids.push(id);
                                    }
                                } else if (nodeName === 'td') {
                                    // Dump out the headers and cells.
                                    var exp = [];
                                    for (var i = rownum; i < rownum + rowspan; i++) {
                                        for (var j = colnum; j < colnum + colspan; j++) {
                                            if ((headingIds.rows[i]) && (j >= headingIds.rows[i].first)) {
                                                exp = exp.concat(headingIds.rows[i].ids);
                                            }

                                            if ((headingIds.cols[j]) && (i >= headingIds.cols[j].first)) {
                                                exp = exp.concat(headingIds.cols[j].ids);
                                            }
                                        }//end for
                                    }//end for

                                    if (exp.length > 0) {
                                        exp = ' ' + exp.sort().join(' ') + ' ';
                                        exp = exp.replace(/\s+/g, ' ').replace(/(\w+\s)\1+/g, '$1').replace(/^\s*(.*?)\s*$/g, '$1');
                                        cells.push({
                                            cell: thisCell,
                                            headers: exp
                                        });
                                    }
                                }
                            }

                            colnum += colspan;
                        }//end if
                    }//end for
                }//end for
            }//end for

            // Build the column and row headers that we expect.
            return cells;
        };
    };

};



window.HTMLCS_Section508 = {
    name: 'Section508',
    description: 'U.S. Section 508 Standard',
    sniffs: [
        'A',
        'B',
        'C',
        'D',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P'
    ],
    getMsgInfo: function(code) {
        var msgCodeParts  = code.split('.', 3);
        var paragraph     = msgCodeParts[1].toLowerCase();

        var retval = [
            ['Section', '1194.22 (' + paragraph + ')']
        ];

        return retval;
    }
};



var HTMLCS_Section508_Sniffs_A = {
    
    register: function()
    {
        return [
            'img',
            'input',
            'area',
            'object',
            'applet',
            'bgsound',
            'audio'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            this.addNullAltTextResults(top);
            this.addMediaAlternativesResults(top);
        } else {
            var nodeName = element.nodeName.toLowerCase();
            if ((nodeName === 'object') || (nodeName === 'bgsound') || (nodeName === 'audio')) {
                // Audio transcript notice. Yes, this is in A rather than B, since
                // audio is not considered "multimedia" (roughly equivalent to a
                // "synchronised media" presentation in WCAG 2.0). It is non-text,
                // though, so a transcript is required.
                HTMLCS.addMessage(HTMLCS.NOTICE, element, 'For multimedia containing audio only, ensure an alternative is available, such as a full text transcript.', 'Audio');
            }
        }
    },

    
    testNullAltText: function(top)
    {
        var errors = {
            img: {
                generalAlt: [],
                missingAlt: [],
                ignored: [],
                nullAltWithTitle: [],
                emptyAltInLink: []
            },
            inputImage: {
                generalAlt: [],
                missingAlt: []
            },
            area: {
                generalAlt: [],
                missingAlt: []
            }
        };

        elements = top.querySelectorAll('img, area, input[type="image"]');

        for (var el = 0; el < elements.length; el++) {
            var element = elements[el];

            var nodeName      = element.nodeName.toLowerCase();
            var linkOnlyChild = false;
            var missingAlt    = false;
            var nullAlt       = false;

            if (element.parentNode.nodeName.toLowerCase() === 'a') {
                var prevNode = this._getPreviousSiblingElement(element, null);
                var nextNode = this._getNextSiblingElement(element, null);

                if ((prevNode === null) && (nextNode === null)) {
                    var textContent = element.parentNode.textContent;

                    if (element.parentNode.textContent !== undefined) {
                        var textContent = element.parentNode.textContent;
                    } else {
                        // Keep IE8 happy.
                        var textContent = element.parentNode.innerText;
                    }

                    if (HTMLCS.util.isStringEmpty(textContent) === true) {
                        linkOnlyChild = true;
                    }
                }
            }//end if

            if (element.hasAttribute('alt') === false) {
                missingAlt = true;
            } else if (!element.getAttribute('alt') || HTMLCS.util.isStringEmpty(element.getAttribute('alt')) === true) {
                nullAlt = true;
            }

            // Now determine which test(s) should fire.
            switch (nodeName) {
                case 'img':
                    if ((linkOnlyChild === true) && ((missingAlt === true) || (nullAlt === true))) {
                        // Img tags cannot have an empty alt text if it is the
                        // only content in a link (as the link would not have a text
                        // alternative).
                        errors.img.emptyAltInLink.push(element.parentNode);
                    } else if (missingAlt === true) {
                        errors.img.missingAlt.push(element);
                    } else if (nullAlt === true) {
                        if ((element.hasAttribute('title') === true) && (HTMLCS.util.isStringEmpty(element.getAttribute('title')) === false)) {
                            // Title attribute present and not empty. This is wrong when
                            // an image is marked as ignored.
                            errors.img.nullAltWithTitle.push(element);
                        } else {
                            errors.img.ignored.push(element);
                        }
                    } else {
                        errors.img.generalAlt.push(element);
                    }
                break;

                case 'input':
                    // Image submit buttons.
                    if ((missingAlt === true) || (nullAlt === true)) {
                        errors.inputImage.missingAlt.push(element);
                    } else {
                        errors.inputImage.generalAlt.push(element);
                    }
                break;

                case 'area':
                    // Area tags in a client-side image map.
                    if ((missingAlt === true) || (nullAlt === true)) {
                        errors.area.missingAlt.push(element);
                    } else {
                        errors.inputImage.generalAlt.push(element);
                    }
                break;

                default:
                    // No other tags defined.
                break;
            }//end switch
        }//end for

        return errors;
    },

    
    addNullAltTextResults: function(top)
    {
        var errors = this.testNullAltText(top);

        for (var i = 0; i < errors.img.emptyAltInLink.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.emptyAltInLink[i], 'Img element is the only content of the link, but is missing alt text. The alt text should describe the purpose of the link.', 'Img.EmptyAltInLink');
        }

        for (var i = 0; i < errors.img.nullAltWithTitle.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.nullAltWithTitle[i], 'Img element with empty alt text must have absent or empty title attribute.', 'Img.NullAltWithTitle');
        }

        for (var i = 0; i < errors.img.ignored.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.img.ignored[i], 'Img element is marked so that it is ignored by Assistive Technology.', 'Img.Ignored');
        }

        for (var i = 0; i < errors.img.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.missingAlt[i], 'Img element missing an alt attribute. Use the alt attribute to specify a short text alternative.', 'Img.MissingAlt');
        }

        for (var i = 0; i < errors.img.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.img.generalAlt[i], 'Ensure that the img element\'s alt text serves the same purpose and presents the same information as the image.', 'Img.GeneralAlt');
        }

        for (var i = 0; i < errors.inputImage.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.inputImage.missingAlt[i], 'Image submit button missing an alt attribute. Specify a text alternative that describes the button\'s function, using the alt attribute.', 'InputImage.MissingAlt');
        }

        for (var i = 0; i < errors.inputImage.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.inputImage.generalAlt[i], 'Ensure that the image submit button\'s alt text identifies the purpose of the button.', 'InputImage.GeneralAlt');
        }

        for (var i = 0; i < errors.area.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.area.missingAlt[i], 'Area element in an image map missing an alt attribute. Each area element must have a text alternative that describes the function of the image map area.', 'Area.MissingAlt');
        }

        for (var i = 0; i < errors.area.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.area.generalAlt[i], 'Ensure that the area element\'s text alternative serves the same purpose as the part of image map image it references.', 'Area.GeneralAlt');
        }
    },

    testMediaTextAlternatives: function(top)
    {
        var errors = {
            object: {
                missingBody: [],
                generalAlt: []
            },
            applet: {
                missingBody: [],
                missingAlt: [],
                generalAlt: []
            }
        };

        var elements = top.querySelectorAll('object');

        for (var el = 0; el < elements.length; el++) {
            var element  = elements[el];
            var nodeName = element.nodeName.toLowerCase();

            var childObject = element.querySelector('object');

            // If we have an object as our alternative, skip it. Pass the blame onto
            // the child.
            if (childObject === null) {
                var textAlt = HTMLCS.util.getElementTextContent(element, true);
                if (textAlt === '') {
                    errors.object.missingBody.push(element);
                } else {
                    errors.object.generalAlt.push(element);
                }
            }//end if
        }//end if

        var elements = top.querySelectorAll('applet');

        for (var el = 0; el < elements.length; el++) {
            // Test firstly for whether we have an object alternative.
            var childObject = element.querySelector('object');
            var hasError    = false;

            // If we have an object as our alternative, skip it. Pass the blame onto
            // the child. (This is a special case: those that don't understand APPLET
            // may understand OBJECT, but APPLET shouldn't be nested.)
            if (childObject === null) {
                var textAlt = HTMLCS.util.getElementTextContent(element, true);
                if (HTMLCS.util.isStringEmpty(textAlt) === true) {
                    errors.applet.missingBody.push(element);
                    hasError = true;
                }
            }//end if

            var altAttr = element.getAttribute('alt') || '';
            if (HTMLCS.util.isStringEmpty(altAttr) === true) {
                errors.applet.missingAlt.push(element);
                hasError = true;
            }

            if (hasError === false) {
                // No error? Remind of obligations about equivalence of alternatives.
                errors.applet.generalAlt.push(element);
            }
        }//end if

        return errors;
    },

    
    addMediaAlternativesResults: function(top)
    {
        var errors = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_1_1_1_1.testMediaTextAlternatives(top);

        for (var i = 0; i < errors.object.missingBody.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.object.missingBody[i], 'Object elements must contain a text alternative after all other alternatives are exhausted.', 'Object.MissingBody');
        }

        for (var i = 0; i < errors.object.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.object.generalAlt[i], 'Check that short (and if appropriate, long) text alternatives are available for non-text content that serve the same purpose and present the same information.', 'Object.GeneralAlt');
        }

        for (var i = 0; i < errors.applet.missingBody.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.applet.missingBody[i], 'Applet elements must contain a text alternative in the element\'s body, for browsers without support for the applet element.', 'Applet.MissingBody');
        }

        for (var i = 0; i < errors.applet.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.applet.missingAlt[i], 'Applet elements must contain an alt attribute, to provide a text alternative to browsers supporting the element but are unable to load the applet.', 'Applet.MissingAlt');
        }

        for (var i = 0; i < errors.applet.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.applet.generalAlt[i], 'Check that short (and if appropriate, long) text alternatives are available for non-text content that serve the same purpose and present the same information.', 'Applet.GeneralAlt');
        }
    }
};



var HTMLCS_Section508_Sniffs_B = {
    
    register: function()
    {
        return [
            'object',
            'applet',
            'embed',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'For multimedia containing video, ensure a synchronised audio description or text alternative for the video portion is provided.', 'Video');
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'For multimedia containing synchronised audio and video, ensure synchronised captions are provided for the audio portion.', 'Captions');

    }
};



var HTMLCS_Section508_Sniffs_C = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Ensure that any information conveyed using colour alone is also available without colour, such as through context or markup.', 'Colour');

    }
};



var HTMLCS_Section508_Sniffs_D = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Ensure that content is ordered in a meaningful sequence when linearised, such as when style sheets are disabled.', 'Linearised');
            this.testPresentationMarkup(top);
            this.testHeadingOrder(top);

            // Look for any script elements, and fire off another notice regarding
            // potentially hidden text (eg. "click to expand" sections). For instance,
            // such text should be stored semantically in the page, not loaded into
            // a container through AJAX (and thus not accessible with scripting off).
            var hasScript = top.querySelectorAll('script, link[rel="stylesheet"]');
            if (hasScript.length > 0) {
                HTMLCS.addMessage(HTMLCS.NOTICE, top, 'If content is hidden and made visible using scripting (such as "click to expand" sections), ensure this content is readable when scripts and style sheets are disabled.', 'HiddenText');
            }
        }
    },

    
    testPresentationMarkup: function(top)
    {
        // Presentation tags that should have no place in modern HTML.
        var tags = top.querySelectorAll('b, i, u, s, strike, tt, big, small, center, font');

        for (var i = 0; i < tags.length; i++) {
            var msgCode = 'PresMarkup.' + tags[i].nodeName.substr(0, 1).toUpperCase() + tags[i].nodeName.substr(1).toLowerCase();
            HTMLCS.addMessage(HTMLCS.WARNING, tags[i], 'Semantic markup should be used to mark emphasised or special text so that it can be programmatically determined.', msgCode);
        }

        // Align attributes, too.
        var tags = top.querySelectorAll('*[align]');

        for (var i = 0; i < tags.length; i++) {
            var msgCode = 'PresMarkup.AlignAttr';
            HTMLCS.addMessage(HTMLCS.WARNING, tags[i], 'Semantic markup should be used to mark emphasised or special text so that it can be programmatically determined.', msgCode);
        }
    },

    testHeadingOrder: function(top) {
        var lastHeading = 0;
        var headings    = top.querySelectorAll('h1, h2, h3, h4, h5, h6');

        for (var i = 0; i < headings.length; i++) {
            var headingNum = parseInt(headings[i].nodeName.substr(1, 1));
            if (headingNum - lastHeading > 1) {
                var exampleMsg = 'should be an h' + (lastHeading + 1) + ' to be properly nested';
                if (lastHeading === 0) {
                    // If last heading is empty, we are at document top and we are
                    // expecting a H1, generally speaking.
                    exampleMsg = 'appears to be the primary document heading, so should be an h1 element';
                }

                HTMLCS.addMessage(HTMLCS.ERROR, headings[i], 'The heading structure is not logically nested. This h' + headingNum + ' element ' + exampleMsg + '.', 'HeadingOrder');
            }

            lastHeading = headingNum;
        }
    }

};



var HTMLCS_Section508_Sniffs_G = {
    
    register: function()
    {
        return ['table'];

    },

    
    process: function(element, top)
    {
        // If no table headers, emit notice about the table.
        if (HTMLCS.util.isLayoutTable(element) === true) {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'This table has no headers. If this is a data table, ensure row and column headers are identified using th elements.', 'TableHeaders');
        }
    }

};



var HTMLCS_Section508_Sniffs_H = {
    
    register: function()
    {
        return ['table'];

    },

    
    process: function(table, top)
    {
        var headersAttr = HTMLCS.util.testTableHeaders(table);

        // Incorrect usage of headers - error; emit always.
        for (var i = 0; i < headersAttr.wrongHeaders.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, headersAttr.wrongHeaders[i].element, 'Incorrect headers attribute on this td element. Expected "' + headersAttr.wrongHeaders[i].expected + '" but found "' + headersAttr.wrongHeaders[i].actual + '"', 'IncorrectHeadersAttr');
        }

        // Errors where headers are compulsory.
        if ((headersAttr.required === true) && (headersAttr.allowScope === false)) {
            if (headersAttr.used === false) {
                // Headers not used at all, and they are mandatory.
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'The relationship between td elements and their associated th elements is not defined. As this table has multiple levels of th elements, you must use the headers attribute on td elements.', 'MissingHeadersAttrs');
            } else {
                // Missing TH IDs - error; emit at this stage only if headers are compulsory.
                if (headersAttr.missingThId.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all th elements in this table contain an id attribute. These cells should contain ids so that they may be referenced by td elements\' headers attributes.', 'MissingHeaderIds');
                }

                // Missing TD headers attributes - error; emit at this stage only if headers are compulsory.
                if (headersAttr.missingTd.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all td elements in this table contain a headers attribute. Each headers attribute should list the ids of all th elements associated with that cell.', 'IncompleteHeadersAttrs');
                }
            }//end if
        }//end if
    }

};



var HTMLCS_Section508_Sniffs_I = {
    
    register: function()
    {
        return [
            'frame',
            'iframe',
            'object'
        ];

    },

    
    process: function(element, top)
    {
        var nodeName   = element.nodeName.toLowerCase();
        var hasTitle   = element.hasAttribute('title');
        var titleEmpty = true;

        if (hasTitle === true) {
            titleEmpty = HTMLCS.util.isStringEmpty(element.getAttribute('title'));
        }

        if (titleEmpty === true) {
            HTMLCS.addMessage(HTMLCS.ERROR, top, 'This ' + nodeName + ' element is missing title text. Frames should be titled with text that facilitates frame identification and navigation.', 'Frames');
        }
    }
};



var HTMLCS_Section508_Sniffs_J = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // The term in Sec. 508 is "flicker" rather than flash.
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that no component of the content flickers at a rate of greater than 2 and less than 55 times per second.', 'Flicker');
    }
};



var HTMLCS_Section508_Sniffs_K = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'If this page cannot be made compliant, a text-only page with equivalent information or functionality should be provided. The alternative page needs to be updated in line with this page\'s content.', 'AltVersion');
    }

};



var HTMLCS_Section508_Sniffs_L = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            this.addProcessLinksMessages(top);
            this.testKeyboard(top);
        }
    },

    addProcessLinksMessages: function(top)
    {
        var errors = this.processLinks(top);
        for (var i = 0; i < errors.emptyNoId.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.emptyNoId[i], 'Anchor element found with no link content and no name and/or ID attribute.', 'EmptyAnchorNoId');
        }

        for (var i = 0; i < errors.placeholder.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.placeholder[i], 'Anchor element found with link content, but no href, ID, or name attribute has been supplied.', 'PlaceholderAnchor');
        }

        for (var i = 0; i < errors.noContent.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.noContent[i], 'Anchor element found with a valid href attribute, but no link content has been supplied.', 'NoContentAnchor');
        }
    },

    processLinks: function(top)
    {
        var errors   = {
            empty: [],
            emptyWithName: [],
            emptyNoId: [],
            noHref: [],
            placeholder: [],
            noContent: []
        };

        var elements = top.querySelectorAll('a');

        for (var el = 0; el < elements.length; el++) {
            var element = elements[el];

            var nameFound = false;
            var hrefFound = false;
            var content   = HTMLCS.util.getElementTextContent(element);

            if ((element.hasAttribute('title') === true) && (/^\s*$/.test(element.getAttribute('title')) === false)) {
                nameFound = true;
            } else if (/^\s*$/.test(content) === false) {
                nameFound = true;
            }

            if ((element.hasAttribute('href') === true) && (/^\s*$/.test(element.getAttribute('href')) === false)) {
                hrefFound = true;
            }

            if (hrefFound === false) {
                // No href. We don't want these because, although they are commonly used
                // to create targets, they can be picked up by screen readers and
                // displayed to the user as empty links. A elements are defined by H91 as
                // having an (ARIA) role of "link", and using them as targets are
                // essentially misusing them. Place an ID on a parent element instead.
                if (/^\s*$/.test(content) === true) {
                    // Also no content. (eg. <a id=""></a> or <a name=""></a>)
                    if (element.hasAttribute('id') === true) {
                        errors.empty.push(element);
                    } else if (element.hasAttribute('name') === true) {
                        errors.emptyWithName.push(element);
                    } else {
                        errors.emptyNoId.push(element);
                    }
                } else {
                    // Giving a benefit of the doubt here - if a link has text and also
                    // an ID, but no href, it might be because it is being manipulated by
                    // a script.
                    if ((element.hasAttribute('id') === true) || (element.hasAttribute('name') === true)) {
                        errors.noHref.push(element);
                    } else {
                        // HTML5 allows A elements with text but no href, "for where a
                        // link might otherwise have been placed, if it had been relevant".
                        // Hence, thrown as a warning, not an error.
                        errors.placeholder.push(element);
                    }
                }//end if
            } else {
                if (/^\s*$/.test(content) === true) {
                    // Href provided, but no content.
                    // We only fire this message when there are no images in the content.
                    // A link around an image with no alt text is already covered in SC
                    // 1.1.1 (test H30).
                    if (element.querySelectorAll('img').length === 0) {
                        errors.noContent.push(element);
                    }
                }//end if
            }//end if
        }//end for

        return errors;
    },

    
    testKeyboard: function(top)
    {
        // Testing for elements that have explicit attributes for mouse-specific
        // events. Note: onclick is considered keyboard accessible, as it is actually
        // tied to the default action of a link or button - not merely a click.
        var dblClickEls = top.querySelectorAll('*[ondblclick]');
        for (var i = 0; i < dblClickEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, dblClickEls[i], 'Ensure the functionality provided by double-clicking on this element is available through the keyboard.', 'DblClick');
        }

        var mouseOverEls = top.querySelectorAll('*[onmouseover]');
        for (var i = 0; i < mouseOverEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, mouseOverEls[i], 'Ensure the functionality provided by mousing over this element is available through the keyboard; for instance, using the focus event.', 'MouseOver');
        }

        var mouseOutEls = top.querySelectorAll('*[onmouseout]');
        for (var i = 0; i < mouseOutEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, mouseOutEls[i], 'Ensure the functionality provided by mousing out of this element is available through the keyboard; for instance, using the blur event.', 'MouseOut');
        }

        var mouseMoveEls = top.querySelectorAll('*[onmousemove]');
        for (var i = 0; i < mouseMoveEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, mouseMoveEls[i], 'Ensure the functionality provided by moving the mouse on this element is available through the keyboard.', 'MouseMove');
        }

        var mouseDownEls = top.querySelectorAll('*[onmousedown]');
        for (var i = 0; i < mouseDownEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, mouseDownEls[i], 'Ensure the functionality provided by mousing down on this element is available through the keyboard; for instance, using the keydown event.', 'MouseDown');
        }

        var mouseUpEls = top.querySelectorAll('*[onmouseup]');
        for (var i = 0; i < mouseUpEls.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, mouseUpEls[i], 'Ensure the functionality provided by mousing up on this element is available through the keyboard; for instance, using the keyup event.', 'MouseUp');
        }
    }

};



var HTMLCS_Section508_Sniffs_M = {
    
    register: function()
    {
        return [
            'object',
            'applet',
            'bgsound',
            'embed',
            'audio',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If external media requires a plugin or application to view, ensure a link is provided to a plugin or application that complies with Section 508 accessibility requirements for applications.', 'PluginLink');
    }

};



var HTMLCS_Section508_Sniffs_N = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName === 'form') {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If an input error is automatically detected in this form, check that the item(s) in error are identified and the error(s) are described to the user in text.', 'Errors');
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that descriptive labels or instructions (including for required fields) are provided for user input in this form.', 'Labels');
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Ensure that this form can be navigated using the keyboard and other accessibility tools.', 'KeyboardNav');
        }
    }

};



var HTMLCS_Section508_Sniffs_O = {
    
    register: function()
    {
        return [
            '_top',
            'a',
            'area'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Ensure that any common navigation elements can be bypassed; for instance, by use of skip links, header elements, or ARIA landmark roles.', 'SkipLinks');
        } else {
            if (element.hasAttribute('href') === true) {
                var href = element.getAttribute('href');
                href     = HTMLCS.util.trim(href);
                if ((href.length > 1) && (href.charAt(0) === '#')) {
                    var id = href.substr(1);

                    try {
                        var doc = top;
                        if (doc.ownerDocument) {
                            doc = doc.ownerDocument;
                        }

                        // First search for an element with the appropriate ID, then search for a
                        // named anchor using the name attribute.
                        var target = doc.getElementById(id);
                        if (target === null) {
                            target = doc.querySelector('a[name="' + id + '"]');
                        }

                        if ((target === null) || (HTMLCS.util.contains(top, target) === false)) {
                            if ((HTMLCS.isFullDoc(top) === true) || (top.nodeName.toLowerCase() === 'body')) {
                                HTMLCS.addMessage(HTMLCS.ERROR, element, 'This link points to a named anchor "' + id + '" within the document, but no anchor exists with that name.', 'NoSuchID');
                            } else {
                                HTMLCS.addMessage(HTMLCS.WARNING, element, 'This link points to a named anchor "' + id + '" within the document, but no anchor exists with that name in the fragment tested.', 'NoSuchIDFragment');
                            }
                        }
                    } catch (ex) {
                    }//end try
                }//end if
            }
        }
    }

};



var HTMLCS_Section508_Sniffs_P = {
    
    register: function()
    {
        return [
            '_top',
            'meta'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'If a timed response is required on this page, alert the user and provide sufficient time to allow them to indicate that more time is required.', 'TimeLimit');
        } else {
            if (element.hasAttribute('http-equiv') === true) {
                if ((String(element.getAttribute('http-equiv'))).toLowerCase() === 'refresh') {
                    if (/^[1-9]\d*/.test(element.getAttribute('content').toLowerCase()) === true) {
                        if (/url=/.test(element.getAttribute('content').toLowerCase()) === true) {
                            // Redirect.
                            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Meta refresh tag used to redirect to another page, with a time limit that is not zero. Users cannot control this time limit.', 'MetaRedirect');
                        } else {
                            // Just a refresh.
                            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Meta refresh tag used to refresh the current page. Users cannot control the time limit for this refresh.', 'MetaRefresh');
                        }
                    }
                }//end if
            }//end if
        }//end if
    }

};



window.HTMLCS_WCAG2A = {
    name: 'WCAG2A',
    description: 'Web Content Accessibility Guidelines (WCAG) 2.0 A',
    sniffs: [
        {
            standard: 'WCAG2AAA',
            include: [
               'Principle1.Guideline1_1.1_1_1',
               'Principle1.Guideline1_2.1_2_1',
               'Principle1.Guideline1_2.1_2_2',
               'Principle1.Guideline1_2.1_2_3',
               'Principle1.Guideline1_3.1_3_1',
               'Principle1.Guideline1_3.1_3_1_A',
               'Principle1.Guideline1_3.1_3_2',
               'Principle1.Guideline1_3.1_3_3',
               'Principle1.Guideline1_4.1_4_1',
               'Principle1.Guideline1_4.1_4_2',
               'Principle2.Guideline2_1.2_1_1',
               'Principle2.Guideline2_1.2_1_2',
               'Principle2.Guideline2_2.2_2_1',
               'Principle2.Guideline2_2.2_2_2',
               'Principle2.Guideline2_3.2_3_1',
               'Principle2.Guideline2_4.2_4_1',
               'Principle2.Guideline2_4.2_4_2',
               'Principle2.Guideline2_4.2_4_3',
               'Principle2.Guideline2_4.2_4_4',
               'Principle3.Guideline3_1.3_1_1',
               'Principle3.Guideline3_2.3_2_1',
               'Principle3.Guideline3_2.3_2_2',
               'Principle3.Guideline3_3.3_3_1',
               'Principle3.Guideline3_3.3_3_2',
               'Principle4.Guideline4_1.4_1_1',
               'Principle4.Guideline4_1.4_1_2'
            ]
        }
    ],
    getMsgInfo: function(code) {
        return HTMLCS_WCAG2AAA.getMsgInfo(code);
    }
};



window.HTMLCS_WCAG2AA = {
    name: 'WCAG2AA',
    description: 'Web Content Accessibility Guidelines (WCAG) 2.0 AA',
    sniffs: [
        {
            standard: 'WCAG2AAA',
            include: [
               'Principle1.Guideline1_1.1_1_1',
               'Principle1.Guideline1_2.1_2_1',
               'Principle1.Guideline1_2.1_2_2',
               'Principle1.Guideline1_2.1_2_4',
               'Principle1.Guideline1_2.1_2_5',
               'Principle1.Guideline1_3.1_3_1',
               'Principle1.Guideline1_3.1_3_1_A',
               'Principle1.Guideline1_3.1_3_2',
               'Principle1.Guideline1_3.1_3_3',
               'Principle1.Guideline1_4.1_4_1',
               'Principle1.Guideline1_4.1_4_2',
               'Principle1.Guideline1_4.1_4_3',
               'Principle1.Guideline1_4.1_4_3_F24',
               'Principle1.Guideline1_4.1_4_3_Contrast',
               'Principle1.Guideline1_4.1_4_4',
               'Principle1.Guideline1_4.1_4_5',
               'Principle2.Guideline2_1.2_1_1',
               'Principle2.Guideline2_1.2_1_2',
               'Principle2.Guideline2_2.2_2_1',
               'Principle2.Guideline2_2.2_2_2',
               'Principle2.Guideline2_3.2_3_1',
               'Principle2.Guideline2_4.2_4_1',
               'Principle2.Guideline2_4.2_4_2',
               'Principle2.Guideline2_4.2_4_3',
               'Principle2.Guideline2_4.2_4_4',
               'Principle2.Guideline2_4.2_4_5',
               'Principle2.Guideline2_4.2_4_6',
               'Principle2.Guideline2_4.2_4_7',
               'Principle3.Guideline3_1.3_1_1',
               'Principle3.Guideline3_1.3_1_2',
               'Principle3.Guideline3_2.3_2_1',
               'Principle3.Guideline3_2.3_2_2',
               'Principle3.Guideline3_2.3_2_3',
               'Principle3.Guideline3_2.3_2_4',
               'Principle3.Guideline3_3.3_3_1',
               'Principle3.Guideline3_3.3_3_2',
               'Principle3.Guideline3_3.3_3_3',
               'Principle3.Guideline3_3.3_3_4',
               'Principle4.Guideline4_1.4_1_1',
               'Principle4.Guideline4_1.4_1_2'
            ]
        }
    ],
    getMsgInfo: function(code) {
        return HTMLCS_WCAG2AAA.getMsgInfo(code);
    }
};



window.HTMLCS_WCAG2AAA = {
    name: 'WCAG2AAA',
    description: 'Web Content Accessibility Guidelines (WCAG) 2.0 AAA',
    sniffs: [
        'Principle1.Guideline1_1.1_1_1',
        'Principle1.Guideline1_2.1_2_1',
        'Principle1.Guideline1_2.1_2_2',
        'Principle1.Guideline1_2.1_2_4',
        'Principle1.Guideline1_2.1_2_5',
        'Principle1.Guideline1_2.1_2_6',
        'Principle1.Guideline1_2.1_2_7',
        'Principle1.Guideline1_2.1_2_8',
        'Principle1.Guideline1_2.1_2_9',
        'Principle1.Guideline1_3.1_3_1',
        'Principle1.Guideline1_3.1_3_1_AAA',
        'Principle1.Guideline1_3.1_3_2',
        'Principle1.Guideline1_3.1_3_3',
        'Principle1.Guideline1_4.1_4_1',
        'Principle1.Guideline1_4.1_4_2',
        'Principle1.Guideline1_4.1_4_3_F24',
        'Principle1.Guideline1_4.1_4_3_Contrast',
        'Principle1.Guideline1_4.1_4_6',
        'Principle1.Guideline1_4.1_4_7',
        'Principle1.Guideline1_4.1_4_8',
        'Principle1.Guideline1_4.1_4_9',
        'Principle2.Guideline2_1.2_1_1',
        'Principle2.Guideline2_1.2_1_2',
        'Principle2.Guideline2_2.2_2_2',
        'Principle2.Guideline2_2.2_2_3',
        'Principle2.Guideline2_2.2_2_4',
        'Principle2.Guideline2_2.2_2_5',
        'Principle2.Guideline2_3.2_3_2',
        'Principle2.Guideline2_4.2_4_1',
        'Principle2.Guideline2_4.2_4_2',
        'Principle2.Guideline2_4.2_4_3',
        'Principle2.Guideline2_4.2_4_5',
        'Principle2.Guideline2_4.2_4_6',
        'Principle2.Guideline2_4.2_4_7',
        'Principle2.Guideline2_4.2_4_8',
        'Principle2.Guideline2_4.2_4_9',
        'Principle3.Guideline3_1.3_1_1',
        'Principle3.Guideline3_1.3_1_2',
        'Principle3.Guideline3_1.3_1_3',
        'Principle3.Guideline3_1.3_1_4',
        'Principle3.Guideline3_1.3_1_5',
        'Principle3.Guideline3_1.3_1_6',
        'Principle3.Guideline3_2.3_2_1',
        'Principle3.Guideline3_2.3_2_2',
        'Principle3.Guideline3_2.3_2_3',
        'Principle3.Guideline3_2.3_2_4',
        'Principle3.Guideline3_2.3_2_5',
        'Principle3.Guideline3_3.3_3_1',
        'Principle3.Guideline3_3.3_3_2',
        'Principle3.Guideline3_3.3_3_3',
        'Principle3.Guideline3_3.3_3_5',
        'Principle3.Guideline3_3.3_3_6',
        'Principle4.Guideline4_1.4_1_1',
        'Principle4.Guideline4_1.4_1_2'
    ],
    getMsgInfo: function(code) {
        var principles = {
            'Principle1': {
                name: 'Perceivable',
                link: 'http://www.w3.org/TR/WCAG20/#perceivable'
               },
            'Principle2': {
                name: 'Operable',
                link: 'http://www.w3.org/TR/WCAG20/#operable'
               },
            'Principle3': {
                name: 'Understandable',
                link: 'http://www.w3.org/TR/WCAG20/#understandable'
               },
            'Principle4': {
                name: 'Robust',
                link: 'http://www.w3.org/TR/WCAG20/#robust'
               }
        }

        var msgCodeParts  = code.split('.', 5);
        var principle     = msgCodeParts[1];
        var techniques    = msgCodeParts[4].split(',');
        var techniquesStr = [];

        for (var i = 0; i < techniques.length; i++) {
            techniques[i]  = techniques[i].split('.');
            techniquesStr.push('<a href="http://www.w3.org/TR/WCAG20-TECHS/' + techniques[i][0] + '" target="_blank">' + techniques[i][0] + '</a>');
        }

        var principleStr = ['<a href="', principles[principle].link, '" target="_blank">', principles[principle].name, '</a>'].join('');
        var retval = [
            ['Principle', principleStr],
            ['Techniques', techniquesStr.join(' ')]
        ];

        return retval;
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_1_1_1_1 = {
    
    register: function()
    {
        return [
            '_top',
            'img'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            this.addNullAltTextResults(top);
            this.addMediaAlternativesResults(top);
        } else {
            var nodeName = element.nodeName.toLowerCase();

            switch (nodeName) {
                case 'img':
                    this.testLinkStutter(element);
                    this.testLongdesc(element);
                break;
            }//end if
        }//end if
    },

    
    addNullAltTextResults: function(top)
    {
        var errors = this.testNullAltText(top);

        for (var i = 0; i < errors.img.emptyAltInLink.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.emptyAltInLink[i], 'Img element is the only content of the link, but is missing alt text. The alt text should describe the purpose of the link.', 'H30.2');
        }

        for (var i = 0; i < errors.img.nullAltWithTitle.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.nullAltWithTitle[i], 'Img element with empty alt text must have absent or empty title attribute.', 'H67.1');
        }

        for (var i = 0; i < errors.img.ignored.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.img.ignored[i], 'Img element is marked so that it is ignored by Assistive Technology.', 'H67.2');
        }

        for (var i = 0; i < errors.img.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.img.missingAlt[i], 'Img element missing an alt attribute. Use the alt attribute to specify a short text alternative.', 'H37');
        }

        for (var i = 0; i < errors.img.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.img.generalAlt[i], 'Ensure that the img element\'s alt text serves the same purpose and presents the same information as the image.', 'G94.Image');
        }

        for (var i = 0; i < errors.inputImage.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.inputImage.missingAlt[i], 'Image submit button missing an alt attribute. Specify a text alternative that describes the button\'s function, using the alt attribute.', 'H36');
        }

        for (var i = 0; i < errors.inputImage.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.inputImage.generalAlt[i], 'Ensure that the image submit button\'s alt text identifies the purpose of the button.', 'G94.Button');
        }

        for (var i = 0; i < errors.area.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.area.missingAlt[i], 'Area element in an image map missing an alt attribute. Each area element must have a text alternative that describes the function of the image map area.', 'H24');
        }

        for (var i = 0; i < errors.area.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.area.generalAlt[i], 'Ensure that the area element\'s text alternative serves the same purpose as the part of image map image it references.', 'H24.2');
        }
    },

    
    testNullAltText: function(top)
    {
        var errors = {
            img: {
                generalAlt: [],
                missingAlt: [],
                ignored: [],
                nullAltWithTitle: [],
                emptyAltInLink: []
            },
            inputImage: {
                generalAlt: [],
                missingAlt: []
            },
            area: {
                generalAlt: [],
                missingAlt: []
            }
        };

        elements = top.querySelectorAll('img, area, input[type="image"]');

        for (var el = 0; el < elements.length; el++) {
            var element = elements[el];

            var nodeName      = element.nodeName.toLowerCase();
            var linkOnlyChild = false;
            var missingAlt    = false;
            var nullAlt       = false;

            if (element.parentNode.nodeName.toLowerCase() === 'a') {
                var prevNode = this._getPreviousSiblingElement(element, null);
                var nextNode = this._getNextSiblingElement(element, null);

                if ((prevNode === null) && (nextNode === null)) {
                    var textContent = element.parentNode.textContent;

                    if (element.parentNode.textContent !== undefined) {
                        var textContent = element.parentNode.textContent;
                    } else {
                        // Keep IE8 happy.
                        var textContent = element.parentNode.innerText;
                    }

                    if (HTMLCS.util.isStringEmpty(textContent) === true) {
                        linkOnlyChild = true;
                    }
                }
            }//end if

            if (element.hasAttribute('alt') === false) {
                missingAlt = true;
            } else if (!element.getAttribute('alt') || HTMLCS.util.isStringEmpty(element.getAttribute('alt')) === true) {
                nullAlt = true;
            }

            // Now determine which test(s) should fire.
            switch (nodeName) {
                case 'img':
                    if ((linkOnlyChild === true) && ((missingAlt === true) || (nullAlt === true))) {
                        // Img tags cannot have an empty alt text if it is the
                        // only content in a link (as the link would not have a text
                        // alternative).
                        errors.img.emptyAltInLink.push(element.parentNode);
                    } else if (missingAlt === true) {
                        errors.img.missingAlt.push(element);
                    } else if (nullAlt === true) {
                        if ((element.hasAttribute('title') === true) && (HTMLCS.util.isStringEmpty(element.getAttribute('title')) === false)) {
                            // Title attribute present and not empty. This is wrong when
                            // an image is marked as ignored.
                            errors.img.nullAltWithTitle.push(element);
                        } else {
                            errors.img.ignored.push(element);
                        }
                    } else {
                        errors.img.generalAlt.push(element);
                    }
                break;

                case 'input':
                    // Image submit buttons.
                    if ((missingAlt === true) || (nullAlt === true)) {
                        errors.inputImage.missingAlt.push(element);
                    } else {
                        errors.inputImage.generalAlt.push(element);
                    }
                break;

                case 'area':
                    // Area tags in a client-side image map.
                    if ((missingAlt === true) || (nullAlt === true)) {
                        errors.area.missingAlt.push(element);
                    } else {
                        errors.inputImage.generalAlt.push(element);
                    }
                break;

                default:
                    // No other tags defined.
                break;
            }//end switch
        }//end for

        return errors;
    },

    
    testLongdesc: function(element)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this image cannot be fully described in a short text alternative, ensure a long text alternative is also available, such as in the body text or through a link.', 'G73,G74');

    },

    
    testLinkStutter: function(element)
    {
        if (element.parentNode.nodeName.toLowerCase() === 'a') {
            var anchor = element.parentNode;

            // If contained by an "a" link, check that the alt text does not duplicate
            // the link text, or if no link text, check an adjacent link does not
            // duplicate it.
            var nodes = {
                anchor: {
                    href: anchor.getAttribute('href'),
                    text: HTMLCS.util.getElementTextContent(anchor, false),
                    alt: this._getLinkAltText(anchor)
                }
            }

            if (nodes.anchor.alt === null) {
                nodes.anchor.alt = '';
            }

            if ((nodes.anchor.alt !== null) && (nodes.anchor.alt !== '')) {
                if (HTMLCS.util.trim(nodes.anchor.alt).toLowerCase() === HTMLCS.util.trim(nodes.anchor.text).toLowerCase()) {
                    // H2 "Failure Example 5": they're in one link, but the alt text
                    // duplicates the link text. Trimmed and lowercased because they
                    // would sound the same to a screen reader.
                    HTMLCS.addMessage(HTMLCS.ERROR, element, 'Img element inside a link must not use alt text that duplicates the text content of the link.', 'H2.EG5');
                }
            }

            // If there is no supplementary text, try to catch H2 "Failure Examples"
            // in cases where there are adjacent links with the same href:
            // 3 - img text that duplicates link text in an adjacent link. (Screen
            //     readers will stutter.)
            // 4 - img text is blank when another link adjacent contains link text.
            //     (This leaves one link with no text at all - the two should be
            //      combined into one link.)
            if (nodes.anchor.text === '') {
                var prevLink = this._getPreviousSiblingElement(anchor, 'a', true);
                var nextLink = this._getNextSiblingElement(anchor, 'a', true);

                if (prevLink !== null) {
                    nodes.previous = {
                        href: prevLink.getAttribute('href'),
                        text: HTMLCS.util.getElementTextContent(prevLink, false),
                        alt: this._getLinkAltText(prevLink)
                    }

                    if (nodes.previous.alt === null) {
                        nodes.previous.alt = '';
                    }
                }

                if (nextLink !== null) {
                    nodes.next = {
                        href: nextLink.getAttribute('href'),
                        text: HTMLCS.util.getElementTextContent(nextLink, false),
                        alt: this._getLinkAltText(nextLink)
                    }

                    if (nodes.next.alt === null) {
                        nodes.next.alt = '';
                    }
                }

                // Test against the following link, if any.
                if (nodes.next && (nodes.next.href !== '') && (nodes.next.href !== null) && (nodes.anchor.href === nodes.next.href)) {
                    if ((nodes.next.text !== '') && (nodes.anchor.alt === '')) {
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Img element inside a link has empty or missing alt text when a link beside it contains link text. Consider combining the links.', 'H2.EG4');
                    } else if (nodes.next.text.toLowerCase() === nodes.anchor.alt.toLowerCase()) {
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Img element inside a link must not use alt text that duplicates the content of a text link beside it.', 'H2.EG3');
                    }
                }

                // Test against the preceding link, if any.
                if (nodes.previous && (nodes.previous.href !== '') && (nodes.previous.href !== null) && (nodes.anchor.href === nodes.previous.href)) {
                    if ((nodes.previous.text !== '') && (nodes.anchor.alt === '')) {
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Img element inside a link has empty or missing alt text when a link beside it contains link text. Consider combining the links.', 'H2.EG4');
                    } else if (nodes.previous.text.toLowerCase() === nodes.anchor.alt.toLowerCase()) {
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Img element inside a link must not use alt text that duplicates the content of a text link beside it.', 'H2.EG3');
                    }
                }
            }//end if
        }//end if
    },

    
    addMediaAlternativesResults: function(top)
    {
        var errors = this.testMediaTextAlternatives(top);

        for (var i = 0; i < errors.object.missingBody.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.object.missingBody[i], 'Object elements must contain a text alternative after all other alternatives are exhausted.', 'H53');
        }

        for (var i = 0; i < errors.object.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.object.generalAlt[i], 'Check that short (and if appropriate, long) text alternatives are available for non-text content that serve the same purpose and present the same information.', 'G94,G92.Object');
        }

        for (var i = 0; i < errors.applet.missingBody.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.applet.missingBody[i], 'Applet elements must contain a text alternative in the element\'s body, for browsers without support for the applet element.', 'H35.3');
        }

        for (var i = 0; i < errors.applet.missingAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.applet.missingAlt[i], 'Applet elements must contain an alt attribute, to provide a text alternative to browsers supporting the element but are unable to load the applet.', 'H35.2');
        }

        for (var i = 0; i < errors.applet.generalAlt.length; i++) {
            HTMLCS.addMessage(HTMLCS.NOTICE, errors.applet.generalAlt[i], 'Check that short (and if appropriate, long) text alternatives are available for non-text content that serve the same purpose and present the same information.', 'G94,G92.Applet');
        }
    },

    testMediaTextAlternatives: function(top)
    {
        var errors = {
            object: {
                missingBody: [],
                generalAlt: []
            },
            applet: {
                missingBody: [],
                missingAlt: [],
                generalAlt: []
            }
        };

        var elements = top.querySelectorAll('object');

        for (var el = 0; el < elements.length; el++) {
            var element  = elements[el];
            var nodeName = element.nodeName.toLowerCase();

            var childObject = element.querySelector('object');

            // If we have an object as our alternative, skip it. Pass the blame onto
            // the child.
            if (childObject === null) {
                var textAlt = HTMLCS.util.getElementTextContent(element, true);
                if (textAlt === '') {
                    errors.object.missingBody.push(element);
                } else {
                    errors.object.generalAlt.push(element);
                }
            }//end if
        }//end if

        var elements = top.querySelectorAll('applet');

        for (var el = 0; el < elements.length; el++) {
            // Test firstly for whether we have an object alternative.
            var childObject = element.querySelector('object');
            var hasError    = false;

            // If we have an object as our alternative, skip it. Pass the blame onto
            // the child. (This is a special case: those that don't understand APPLET
            // may understand OBJECT, but APPLET shouldn't be nested.)
            if (childObject === null) {
                var textAlt = HTMLCS.util.getElementTextContent(element, true);
                if (HTMLCS.util.isStringEmpty(textAlt) === true) {
                    errors.applet.missingBody.push(element);
                    hasError = true;
                }
            }//end if

            var altAttr = element.getAttribute('alt') || '';
            if (HTMLCS.util.isStringEmpty(altAttr) === true) {
                errors.applet.missingAlt.push(element);
                hasError = true;
            }

            if (hasError === false) {
                // No error? Remind of obligations about equivalence of alternatives.
                errors.applet.generalAlt.push(element);
            }
        }//end if

        return errors;
    },

    
    _getLinkAltText: function(anchor)
    {
        var anchor = anchor.cloneNode(true);
        var nodes  = [];
        for (var i = 0; i < anchor.childNodes.length; i++) {
            nodes.push(anchor.childNodes[i]);
        }

        var alt = null;
        while (nodes.length > 0) {
            var node = nodes.shift();

            // If it's an element, add any sub-nodes to the process list.
            if (node.nodeType === 1) {
                if (node.nodeName.toLowerCase() === 'img') {
                    if (node.hasAttribute('alt') === true) {
                        alt = node.getAttribute('alt');
                        if (!alt) {
                            alt = '';
                        } else {
                            // Trim the alt text.
                            alt = alt.replace(/^\s+|\s+$/g,'');
                        }

                        break;
                    }
                }
            }
        }

        return alt;
    },

    
    _getPreviousSiblingElement: function(element, tagName, immediate) {
        if (tagName === undefined) {
            tagName = null;
        }

        if (immediate === undefined) {
            immediate = false;
        }

        var prevNode = element.previousSibling;
        while (prevNode !== null) {
            if (prevNode.nodeType === 3) {
                if ((HTMLCS.util.isStringEmpty(prevNode.nodeValue) === false) && (immediate === true)) {
                    // Failed. Immediate node requested and we got text instead.
                    prevNode = null;
                    break;
                }
            } else if (prevNode.nodeType === 1) {
                // If this an element, we break regardless. If it's an "a" node,
                // it's the one we want. Otherwise, there is no adjacent "a" node
                // and it can be ignored.
                if ((tagName === null) || (prevNode.nodeName.toLowerCase() === tagName)) {
                    // Correct element, or we aren't picky.
                    break;
                } else if (immediate === true) {
                    // Failed. Immediate node requested and not correct tag name.
                    prevNode = null;
                    break;
                }

                break;
            }//end if

            prevNode = prevNode.previousSibling;
        }//end if

        return prevNode;
    },

    
    _getNextSiblingElement: function(element, tagName, immediate) {
        if (tagName === undefined) {
            tagName = null;
        }

        if (immediate === undefined) {
            immediate = false;
        }

        var nextNode = element.nextSibling;
        while (nextNode !== null) {
            if (nextNode.nodeType === 3) {
                if ((HTMLCS.util.isStringEmpty(nextNode.nodeValue) === false) && (immediate === true)) {
                    // Failed. Immediate node requested and we got text instead.
                    nextNode = null;
                    break;
                }
            } else if (nextNode.nodeType === 1) {
                // If this an element, we break regardless. If it's an "a" node,
                // it's the one we want. Otherwise, there is no adjacent "a" node
                // and it can be ignored.
                if ((tagName === null) || (nextNode.nodeName.toLowerCase() === tagName)) {
                    // Correct element, or we aren't picky.
                    break;
                } else if (immediate === true) {
                    // Failed. Immediate node requested and not correct tag name.
                    nextNode = null;
                    break;
                }

                break;
            }//end if

            nextNode = nextNode.nextSibling;
        }//end if

        return nextNode;
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_1 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'bgsound',
            'audio',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();

        if (nodeName !== 'video') {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded audio only, and is not provided as an alternative for text content, check that an alternative text version is available.', 'G158');
        }

        if ((nodeName !== 'bgsound') && (nodeName !== 'audio')) {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded video only, and is not provided as an alternative for text content, check that an alternative text version is available, or an audio track is provided that presents equivalent information.', 'G159,G166');
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_2 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded synchronised media and is not provided as an alternative for text content, check that captions are provided for audio content.', 'G87,G93');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_3 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded synchronised media and is not provided as an alternative for text content, check that an audio description of its video, and/or an alternative text version of the content is provided.', 'G69,G78,G173,G8');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_4 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains synchronised media, check that captions are provided for live audio content.', 'G9,G87,G93');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_5 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded synchronised media, check that an audio description is provided for its video content.', 'G78,G173,G8');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_6 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded synchronised media, check that a sign language interpretation is provided for its audio.', 'G54,G81');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_7 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        // Check for elements that could potentially contain video.
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains synchronised media, and where pauses in foreground audio is not sufficient to allow audio descriptions to convey the sense of pre-recorded video, check that an extended audio description is provided, either through scripting or an alternate version.', 'G8');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_8 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains pre-recorded synchronised media or video-only content, check that an alternative text version of the content is provided.', 'G69,G159');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_2_1_2_9 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'bgsound',
            'audio'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this embedded object contains live audio-only content, check that an alternative text version of the content is provided.', 'G150,G151,G157');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1 = {
    _labelNames: null,

    register: function()
    {
        return [
            '_top',
            'p',
            'div',
            'input',
            'select',
            'textarea',
            'button',
            'table',
            'fieldset',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6'
        ];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();

        if (element === top) {
            this.testPresentationMarkup(top);
            this.testEmptyDupeLabelForAttrs(top);
        } else {
            switch (nodeName) {
                case 'input':
                case 'textarea':
                case 'button':
                    this.testLabelsOnInputs(element, top);
                break;

                case 'form':
                    this.testRequiredFieldsets(element);
                break;

                case 'select':
                    this.testLabelsOnInputs(element, top);
                    this.testOptgroup(element);
                break;

                case 'p':
                case 'div':
                    this.testNonSemanticHeading(element);
                    this.testListsWithBreaks(element);
                    this.testUnstructuredNavLinks(element);
                break;

                case 'table':
                    this.testGeneralTable(element);
                    this.testTableHeaders(element);
                    this.testTableCaptionSummary(element);
                break;

                case 'fieldset':
                    this.testFieldsetLegend(element);
                break;

                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    this.testEmptyHeading(element);
                break;
            }//end switch
        }//end if
    },

    
    testEmptyDupeLabelForAttrs: function(top)
    {
        this._labelNames = {};
        var labels = top.getElementsByTagName('label');
        for (var i = 0; i < labels.length; i++) {
            if ((labels[i].getAttribute('for') !== null) || (labels[i].getAttribute('for') !== '')) {
                var labelFor = labels[i].getAttribute('for');
                if ((this._labelNames[labelFor]) && (this._labelNames[labelFor] !== null)) {
                    this._labelNames[labelFor] = null;
                } else {
                    this._labelNames[labelFor] = labels[i];

                    if (top.ownerDocument) {
                        var refNode = top.ownerDocument.getElementById(labelFor);
                    } else {
                        var refNode = top.getElementById(labelFor);
                    }

                    if (refNode === null) {
                        var level = HTMLCS.ERROR;
                        var msg   = 'This label\'s "for" attribute contains an ID that does not exist in the document.';
                        var code  = 'H44.NonExistent';
                        if ((HTMLCS.isFullDoc(top) === true) || (top.nodeName.toLowerCase() === 'body')) {
                            level = HTMLCS.WARNING;
                            msg   = 'This label\'s "for" attribute contains an ID that does not exist in the document fragment.';
                            var code  = 'H44.NonExistentFragment';
                        }
                        HTMLCS.addMessage(level, labels[i], msg, code);
                    } else {
                        var nodeName = refNode.nodeName.toLowerCase();
                        if ('input|select|textarea|button|keygen|meter|output|progress'.indexOf(nodeName) === -1) {
                            HTMLCS.addMessage(HTMLCS.WARNING, labels[i], 'This label\'s "for" attribute contains an ID for an element that is not a form control. Ensure that you have entered the correct ID for the intended element.', 'H44.NotFormControl');
                        }
                    }
                }
            }
        }//end for
    },

    
    testLabelsOnInputs: function(element, top, muteErrors)
    {
        var nodeName  = element.nodeName.toLowerCase();
        var inputType = nodeName;
        if (inputType === 'input') {
            if (element.hasAttribute('type') === true) {
                inputType = element.getAttribute('type');
            } else {
                inputType = 'text';
            }
        }

        var hasLabel = false;
        var addToLabelList = function(found) {
            if (!hasLabel) hasLabel = {};
            hasLabel[found] = true;
        };

        // Firstly, work out whether it needs a label.
        var needsLabel = false;
        var labelPos   = 'left';
        var inputType  = inputType.toLowerCase();
        if ((inputType === 'select' || inputType === 'textarea')) {
            needsLabel = true;
        } else if (/^(radio|checkbox|text|file|password)$/.test(inputType) === true) {
            needsLabel = true;
        }

        if (element.getAttribute('hidden') !== null) {
            needsLabel = false;
        }

        // Find an explicit label.
        var explicitLabel = element.ownerDocument.querySelector('label[for="' + element.id + '"]');
        if (explicitLabel) {
            addToLabelList('explicit');
        }

        // Find an implicit label.
        var implicitLabel = element.parentNode;
        if (implicitLabel && (implicitLabel.nodeName.toLowerCase() === 'label')) {
            addToLabelList('implicit');
        }

        // Find a title attribute.
        var title = element.getAttribute('title');
        if (title !== null) {
            if ((/^\s*$/.test(title) === true) && (needsLabel === true)) {
                HTMLCS.addMessage(
                    HTMLCS.WARNING,
                    element,
                    'This form control has a "title" attribute that is empty or contains only spaces. It will be ignored for labelling test purposes.',
                    'H65'
                );
            } else {
                addToLabelList('title');
            }
        }

        // Find an aria-label attribute.
        var ariaLabel = element.getAttribute('aria-label');
        if (ariaLabel !== null) {
            if ((/^\s*$/.test(ariaLabel) === true) && (needsLabel === true)) {
                HTMLCS.addMessage(
                    HTMLCS.WARNING,
                    element,
                    'This form control has an "aria-label" attribute that is empty or contains only spaces. It will be ignored for labelling test purposes.',
                    'ARIA6'
                );
            } else {
                addToLabelList('aria-label');
            }
        }

        // Find an aria-labelledby attribute.
        var ariaLabelledBy = element.getAttribute('aria-labelledby');
        if (ariaLabelledBy && (/^\s*$/.test(ariaLabelledBy) === false)) {
            var labelledByIds = ariaLabelledBy.split(/\s+/);
            var ok = true;

            // First check that all of the IDs (space separated) are present and correct.
            for (var x = 0; x < labelledByIds.length; x++) {
                var labelledByElement = element.ownerDocument.querySelector('#' + labelledByIds[x]);
                if (!labelledByElement) {
                    HTMLCS.addMessage(
                        HTMLCS.WARNING,
                        element,
                        'This form control contains an aria-labelledby attribute, however it includes an ID "' + labelledByIds[x] + '" that does not exist on an element. The aria-labelledby attribute will be ignored for labelling test purposes.',
                        'ARIA16,ARIA9'
                    );
                    ok = false;
                }
            }

            // We are all OK, add as a successful label technique.
            if (ok === true) {
                addToLabelList('aria-labelledby');
            }
        }

        if (!(muteErrors === true)) {
            if ((hasLabel !== false) && (needsLabel === false)) {
                // Note that it is okay for buttons to have aria-labelledby or
                // aria-label, or title. The former two override the button text,
                // while title is a lower priority than either: the button text,
                // and in submit/reset cases, the localised name for the words
                // "Submit" and "Reset".
                // http://www.w3.org/TR/html-aapi/#accessible-name-and-description-calculation
                if (inputType === 'hidden') {
                    HTMLCS.addMessage(
                        HTMLCS.WARNING,
                        element,
                        'This hidden form field is labelled in some way. There should be no need to label a hidden form field.',
                        'F68.Hidden'
                    );
                } else if (element.getAttribute('hidden') !== null) {
                    HTMLCS.addMessage(
                        HTMLCS.WARNING,
                        element,
                        'This form field is intended to be hidden (using the "hidden" attribute), but is also labelled in some way. There should be no need to label a hidden form field.',
                        'F68.HiddenAttr'
                    );
                }
            } else if ((hasLabel === false) && (needsLabel === true)) {
                // Needs label.
                HTMLCS.addMessage(
                    HTMLCS.ERROR,
                    element,
                    'This form field should be labelled in some way.' + ' ' +
                    'Use the label element (either with a "for" attribute or wrapped around the form field), or "title", "aria-label" or "aria-labelledby" attributes as appropriate.',
                    'F68'
                );
            }//end if
        }

        return hasLabel;
    },

    
    testPresentationMarkup: function(top)
    {
        // Presentation tags that should have no place in modern HTML.
        var tags = top.querySelectorAll('b, i, u, s, strike, tt, big, small, center, font');

        for (var i = 0; i < tags.length; i++) {
            var msgCode = 'H49.' + tags[i].nodeName.substr(0, 1).toUpperCase() + tags[i].nodeName.substr(1).toLowerCase();
            HTMLCS.addMessage(HTMLCS.WARNING, tags[i], 'Semantic markup should be used to mark emphasised or special text so that it can be programmatically determined.', msgCode);
        }

        // Align attributes, too.
        var tags = top.querySelectorAll('*[align]');

        for (var i = 0; i < tags.length; i++) {
            var msgCode = 'H49.AlignAttr';
            HTMLCS.addMessage(HTMLCS.WARNING, tags[i], 'Semantic markup should be used to mark emphasised or special text so that it can be programmatically determined.', msgCode);
        }
    },

    
    testNonSemanticHeading: function(element)
    {
        // Test for P|DIV > STRONG|EM|other inline styling, when said inline
        // styling tag is the only element in the tag. It could possibly a header
        // that should be using h1..h6 tags instead.
        var tag = element.nodeName.toLowerCase();
        if (tag === 'p' || tag === 'div') {
            var children = element.childNodes;
            if ((children.length === 1) && (children[0].nodeType === 1)) {
                var childTag = children[0].nodeName.toLowerCase();

                if (/^(strong|em|b|i|u)$/.test(childTag) === true) {
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'Heading markup should be used if this content is intended as a heading.', 'H42');
                }
            }
        }
    },

    
    testTableHeaders: function(table)
    {
        var headersAttr = HTMLCS.util.testTableHeaders(table);
        var scopeAttr   = this._testTableScopeAttrs(table);

        // Invalid scope attribute - emit always if scope tested.
        for (var i = 0; i < scopeAttr.invalid.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, scopeAttr.invalid[i], 'Table cell has an invalid scope attribute. Valid values are row, col, rowgroup, or colgroup.', 'H63.3');
        }

        // TDs with scope attributes are obsolete in HTML5 - emit warnings if
        // scope tested, but not as errors as they are valid HTML4.
        for (var i = 0; i < scopeAttr.obsoleteTd.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, scopeAttr.obsoleteTd[i], 'Scope attributes on td elements that act as headings for other elements are obsolete in HTML5. Use a th element instead.', 'H63.2');
        }

        if (headersAttr.allowScope === true) {
            if (scopeAttr.missing.length === 0) {
                // If all scope attributes are set, let them be used, even if the
                // attributes are in error. If the scope attrs are fixed, the table
                // will be legitimate.
                headersAttr.required === false;
            }
        } else {
            if (scopeAttr.used === true) {
                HTMLCS.addMessage(HTMLCS.WARNING, table, 'Scope attributes on th elements are ambiguous in a table with multiple levels of headings. Use the headers attribute on td elements instead.', 'H43.ScopeAmbiguous');
                scopeAttr = null;
            }
        }//end if

        // Incorrect usage of headers - error; emit always.
        for (var i = 0; i < headersAttr.wrongHeaders.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, headersAttr.wrongHeaders[i].element, 'Incorrect headers attribute on this td element. Expected "' + headersAttr.wrongHeaders[i].expected + '" but found "' + headersAttr.wrongHeaders[i].actual + '"', 'H43.IncorrectAttr');
        }

        // Errors where headers are compulsory.
        if ((headersAttr.required === true) && (headersAttr.allowScope === false)) {
            if (headersAttr.used === false) {
                // Headers not used at all, and they are mandatory.
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'The relationship between td elements and their associated th elements is not defined. As this table has multiple levels of th elements, you must use the headers attribute on td elements.', 'H43.HeadersRequired');
            } else {
                // Missing TH IDs - error; emit at this stage only if headers are compulsory.
                if (headersAttr.missingThId.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all th elements in this table contain an id attribute. These cells should contain ids so that they may be referenced by td elements\' headers attributes.', 'H43.MissingHeaderIds');
                }

                // Missing TD headers attributes - error; emit at this stage only if headers are compulsory.
                if (headersAttr.missingTd.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all td elements in this table contain a headers attribute. Each headers attribute should list the ids of all th elements associated with that cell.', 'H43.MissingHeadersAttrs');
                }
            }//end if
        }//end if

        // Errors where either is permitted, but neither are done properly (missing
        // certain elements).
        // If they've only done it one way, presume that that is the way they want
        // to continue. Otherwise provide a generic message if none are done or
        // both have been done incorrectly.
        if ((headersAttr.required === true) && (headersAttr.allowScope === true) && (headersAttr.correct === false) && (scopeAttr.correct === false)) {
            if ((scopeAttr.used === false) && (headersAttr.used === false)) {
                // Nothing used at all.
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'The relationship between td elements and their associated th elements is not defined. Use either the scope attribute on th elements, or the headers attribute on td elements.', 'H43,H63');
            } else if ((scopeAttr.used === false) && ((headersAttr.missingThId.length > 0) || (headersAttr.missingTd.length > 0))) {
                // Headers attribute is used, but not all th elements have ids.
                if (headersAttr.missingThId.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all th elements in this table contain an id attribute. These cells should contain ids so that they may be referenced by td elements\' headers attributes.', 'H43.MissingHeaderIds');
                }

                // Headers attribute is used, but not all td elements have headers attrs.
                if (headersAttr.missingTd.length > 0) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all td elements in this table contain a headers attribute. Each headers attribute should list the ids of all th elements associated with that cell.', 'H43.MissingHeadersAttrs');
                }
            } else if ((scopeAttr.missing.length > 0) && (headersAttr.used === false)) {
                // Scope is used rather than headers, but not all th elements have them.
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'Not all th elements in this table have a scope attribute. These cells should contain a scope attribute to identify their association with td elements.', 'H63.1');
            } else if ((scopeAttr.missing.length > 0) && ((headersAttr.missingThId.length > 0) || (headersAttr.missingTd.length > 0))) {
                // Both are used and both were done incorrectly. Provide generic message.
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'The relationship between td elements and their associated th elements is not defined. Use either the scope attribute on th elements, or the headers attribute on td elements.', 'H43,H63');
            }
        }
    },

    
    _testTableScopeAttrs: function(table)
    {
        var elements = {
            th: table.getElementsByTagName('th'),
            td: table.getElementsByTagName('td')
        };

        // Types of errors:
        // - missing:    Errors that a th does not contain a scope attribute.
        // - invalid:    Errors that the scope attribute is not a valid value.
        // - obsoleteTd: Warnings that scopes on tds are obsolete in HTML5.
        var retval = {
            used: false,
            correct: true,
            missing: [],
            invalid: [],
            obsoleteTd: []
        };

        for (var tagType in elements) {
            for (var i = 0; i < elements[tagType].length; i++) {
                var element = elements[tagType][i];

                var scope = '';
                if (element.hasAttribute('scope') === true) {
                    retval.used = true;
                    if (element.getAttribute('scope')) {
                        scope = element.getAttribute('scope');
                    }
                }

                if (element.nodeName.toLowerCase() === 'th') {
                    if (/^\s*$/.test(scope) === true) {
                        // Scope empty or just whitespace.
                        retval.correct = false;
                        retval.missing.push(element);
                    } else if (/^(row|col|rowgroup|colgroup)$/.test(scope) === false) {
                        // Invalid scope value.
                        retval.correct = false;
                        retval.invalid.push(element);
                    }
                } else {
                    if (scope !== '') {
                        // Scope attribute found on TD element. This is obsolete in
                        // HTML5. Does not make it incorrect.
                        retval.obsoleteTd.push(element);

                        // Test for an invalid scope value regardless.
                        if (/^(row|col|rowgroup|colgroup)$/.test(scope) === false) {
                            retval.correct = false;
                            retval.invalid.push(element);
                        }
                    }//end if
                }//end if
            }//end for
        }//end for

        return retval;
    },

    
    testTableCaptionSummary: function(table) {
        var summary   = table.getAttribute('summary') || '';
        var captionEl = table.getElementsByTagName('caption');
        var caption   = '';

        if (captionEl.length > 0) {
            caption = captionEl[0].innerHTML.replace(/^\s*(.*?)\s*$/g, '$1');
        }
        summary = summary.replace(/^\s*(.*?)\s*$/g, '$1');

        if (summary !== '') {
            if (HTMLCS.util.isLayoutTable(table) === true) {
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'This table appears to be used for layout, but contains a summary attribute. Layout tables must not contain summary attributes, or if supplied, must be empty.', 'H73.3.LayoutTable');
            } else {
                if (caption === summary) {
                    HTMLCS.addMessage(HTMLCS.ERROR, table, 'If this table is a data table, and both a summary attribute and a caption element are present, the summary should not duplicate the caption.', 'H39,H73.4');
                }

                HTMLCS.addMessage(HTMLCS.NOTICE, table, 'If this table is a data table, check that the summary attribute describes the table\'s organization or explains how to use the table.', 'H73.3.Check');
            }
        } else {
            if (HTMLCS.util.isLayoutTable(table) === false) {
                HTMLCS.addMessage(HTMLCS.WARNING, table, 'If this table is a data table, consider using the summary attribute of the table element to give an overview of this table.', 'H73.3.NoSummary');
            }
        }//end if

        if (caption !== '') {
            if (HTMLCS.util.isLayoutTable(table) === true) {
                HTMLCS.addMessage(HTMLCS.ERROR, table, 'This table appears to be used for layout, but contains a caption element. Layout tables must not contain captions.', 'H39.3.LayoutTable');
            } else {
                HTMLCS.addMessage(HTMLCS.NOTICE, table, 'If this table is a data table, check that the caption element accurately describes this table.', 'H39.3.Check');
            }
        } else {
            if (HTMLCS.util.isLayoutTable(table) === false) {
                HTMLCS.addMessage(HTMLCS.WARNING, table, 'If this table is a data table, consider using a caption element to the table element to identify this table.', 'H39.3.NoCaption');
            }
        }//end if
    },

    
    testFieldsetLegend: function(fieldset) {
        var legend = fieldset.querySelector('legend');

        if ((legend === null) || (legend.parentNode !== fieldset)) {
            HTMLCS.addMessage(HTMLCS.ERROR, fieldset, 'Fieldset does not contain a legend element. All fieldsets should contain a legend element that describes a description of the field group.', 'H71.NoLegend');
        }
    },

    
    testOptgroup: function(select) {
        var optgroup = select.querySelector('optgroup');

        if (optgroup === null) {
            // Optgroup isn't being used.
            HTMLCS.addMessage(HTMLCS.WARNING, select, 'If this selection list contains groups of related options, they should be grouped with optgroup.', 'H85.2');
        }
    },

    
    testRequiredFieldsets: function(form) {
        var optionInputs = form.querySelectorAll('input[type=radio], input[type=checkbox]');
        var usedNames     = {};

        for (var i = 0; i < optionInputs.length; i++) {
            var option = optionInputs[i];

            if (option.hasAttribute('name') === true) {
                var optionName = option.getAttribute('name');

                // Now find if we are in a fieldset. Stop at the top of the DOM, or
                // at the form element.
                var fieldset = option.parentNode;
                while ((fieldset.nodeName.toLowerCase() !== 'fieldset') && (fieldset !== null) && (fieldset !== form)) {
                    fieldset = fieldset.parentNode;
                }

                if (fieldset.nodeName.toLowerCase() !== 'fieldset') {
                    // Record that this name is used, but there is no fieldset.
                    fieldset = null;
                }
            }//end if

            if (usedNames[optionName] === undefined) {
                usedNames[optionName] = fieldset;
            } else if ((fieldset === null) || (fieldset !== usedNames[optionName])) {
                // Multiple names detected = should be in a fieldset.
                // Either first instance or this one wasn't in a fieldset, or they
                // are in different fieldsets.
                HTMLCS.addMessage(HTMLCS.WARNING, form, 'If these radio buttons or check boxes require a further group-level description, they should be contained within a fieldset element.', 'H71.SameName');
                break;
            }//end if
        }//end for
    },

    
    testListsWithBreaks: function(element) {
        var firstBreak = element.querySelector('br');
        var items      = [];

        // If there is a br tag, go break up the element and see what each line
        // starts with.
        if (firstBreak !== null) {
            var nodes    = [];

            // Convert child nodes NodeList into an array.
            for (var i = 0; i < element.childNodes.length; i++) {
                nodes.push(element.childNodes[i]);
            }

            var thisItem = [];
            while (nodes.length > 0) {
                var subel = nodes.shift();

                if (subel.nodeType === 1) {
                    // Element node.
                    if (subel.nodeName.toLowerCase() === 'br') {
                        // Line break. Join and trim what we have now.
                        items.push(thisItem.join(' ').replace(/^\s*(.*?)\s*$/g, '$1'));
                        thisItem = [];
                    } else {
                        // Shift the contents of the sub element in, but in reverse.
                        for (var i = subel.childNodes.length - 1; i >= 0; --i) {
                            nodes.unshift(subel.childNodes[i]);
                        }
                    }
                } else if (subel.nodeType === 3) {
                    // Text node.
                    thisItem.push(subel.nodeValue);
                }
            }//end while

            if (thisItem.length > 0) {
                items.push(thisItem.join(' ').replace(/^\s*(.*?)\s*$/g, '$1'));
            }

            for (var i = 0; i < items.length; i++) {
                if (/^[\-*]\s+/.test(items[0]) === true) {
                    // Test for "- " or "* " cases.
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This content looks like it is simulating an unordered list using plain text. If so, marking up this content with a ul element would add proper structure information to the document.', 'H48.1');
                    break;
                } if (/^\d+[:\/\-.]?\s+/.test(items[0]) === true) {
                    // Test for "1 " cases (or "1. ", "1: ", "1- ").
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This content looks like it is simulating an ordered list using plain text. If so, marking up this content with an ol element would add proper structure information to the document.', 'H48.2');
                    break;
                }
            }//end for
        }//end if
    },

    testHeadingOrder: function(top, level) {
        var lastHeading = 0;
        var headings    = top.querySelectorAll('h1, h2, h3, h4, h5, h6');

        for (var i = 0; i < headings.length; i++) {
            var headingNum = parseInt(headings[i].nodeName.substr(1, 1));
            if (headingNum - lastHeading > 1) {
                var exampleMsg = 'should be an h' + (lastHeading + 1) + ' to be properly nested';
                if (lastHeading === 0) {
                    // If last heading is empty, we are at document top and we are
                    // expecting a H1, generally speaking.
                    exampleMsg = 'appears to be the primary document heading, so should be an h1 element';
                }

                HTMLCS.addMessage(level, headings[i], 'The heading structure is not logically nested. This h' + headingNum + ' element ' + exampleMsg + '.', 'G141');
            }

            lastHeading = headingNum;
        }
    },

    
    testEmptyHeading: function(element) {
        var text = element.textContent;

        if (text === undefined) {
            text = element.innerText;
        }

        if (/^\s*$/.test(text) === true) {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Heading tag found with no content. Text that is not intended as a heading should not be marked up with heading tags.', 'H42.2');
        }
    },

    
    testUnstructuredNavLinks: function(element)
    {
        var nodeName    = element.nodeName.toLowerCase();
        var linksLength = 0;

        var childNodes  = element.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            if ((childNodes[i].nodeType === 1) && (childNodes[i].nodeName.toLowerCase() === 'a')) {
                linksLength++;
                if (linksLength > 1) {
                    break;
                }
            }
        }//end for

        if (linksLength > 1) {
            // Going to throw a warning here, mainly because we cannot easily tell
            // whether it is just a paragraph with multiple links, or a navigation
            // structure.
            var parent = element.parentNode;
            while ((parent !== null) && (parent.nodeName.toLowerCase() !== 'ul') && (parent.nodeName.toLowerCase() !== 'ol')) {
                parent = parent.parentNode;
            }

            if (parent === null) {
                HTMLCS.addMessage(HTMLCS.WARNING, element, 'If this element contains a navigation section, it is recommended that it be marked up as a list.', 'H48');
            }
        }//end if
    },

    
    testGeneralTable: function(table) {
        if (HTMLCS.util.isLayoutTable(table) === true) {
            HTMLCS.addMessage(HTMLCS.NOTICE, table, 'This table appears to be a layout table. If it is meant to instead be a data table, ensure header cells are identified using th elements.', 'LayoutTable');
        } else {
            HTMLCS.addMessage(HTMLCS.NOTICE, table, 'This table appears to be a data table. If it is meant to instead be a layout table, ensure there are no th elements, and no summary or caption.', 'DataTable');
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1_A = {
    _labelNames: null,

    register: function()
    {
        return [
            '_top'
        ];

    },

    
    process: function(element, top)
    {
        var sniff = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1;

        if (element === top) {
            sniff.testHeadingOrder(top, HTMLCS.WARNING);
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1_AAA = {
    _labelNames: null,

    register: function()
    {
        return [
            '_top'
        ];

    },

    
    process: function(element, top)
    {
        var sniff = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1;

        if (element === top) {
            sniff.testHeadingOrder(top, HTMLCS.ERROR);
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_2 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that the content is ordered in a meaningful sequence when linearised, such as when style sheets are disabled.', 'G57');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Where instructions are provided for understanding the content, do not rely on sensory characteristics alone (such as shape, size or location) to describe objects.', 'G96');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_1 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that any information conveyed using colour alone is also available in text, or through other visual cues.', 'G14,G182');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_2 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'bgsound',
            'audio',
            'video'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'If this element contains audio that plays automatically for longer than 3 seconds, check that there is the ability to pause, stop or mute the audio.', 'F23');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            var failures = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_3_Contrast.testContrastRatio(top, 4.5, 3.0);

            for (var i = 0; i < failures.length; i++) {
                var element   = failures[i].element;
                
                var decimals  = 2;
                var value     = (Math.round(failures[i].value * Math.pow(10, decimals)) / Math.pow(10, decimals));
                var required  = failures[i].required;
                var recommend = failures[i].recommendation;
                var hasBgImg  = failures[i].hasBgImage || false;
                var bgColour   = failures[i].bgColour || false;
                var isAbsolute = failures[i].isAbsolute || false;

                // If the values would look identical, add decimals to the value.
                while (required === value) {
                    decimals++;
                    value = (Math.round(failures[i].value * Math.pow(10, decimals)) / Math.pow(10, decimals));
                }
                
                if (required === 4.5) {
                    var code = 'G18';
                } else if (required === 3.0) {
                    var code = 'G145';
                }

                var recommendText = [];
                if (recommend) {
                    if (recommend.fore.from !== recommend.fore.to) {
                        recommendText.push('text colour to ' + recommend.fore.to);
                    }
                    if (recommend.back.from !== recommend.back.to) {
                        recommendText.push('background to ' + recommend.back.to);
                    }
                }//end if

                if (recommendText.length > 0) {
                    recommendText = ' Recommendation: change ' + recommendText.join(', ') + '.';
                }

                if (isAbsolute === true) {
                    code += '.Abs';
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This element is absolutely positioned and the background color can not be determined. Ensure the contrast ratio between the text and all covered parts of the background are at least ' + required + ':1.', code);
                } else if (hasBgImg === true) {
                    code += '.BgImage';
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This element\'s text is placed on a background image. Ensure the contrast ratio between the text and all covered parts of the image are at least ' + required + ':1.', code);
                } else {
                    code += '.Fail';
                    HTMLCS.addMessage(HTMLCS.ERROR, element, 'This element has insufficient contrast at this conformance level. Expected a contrast ratio of at least ' + required + ':1, but text in this element has a contrast ratio of ' + value + ':1.' + recommendText, code);
                }//end if
            }//end for
        }//end if
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_3_Contrast = {
    testContrastRatio: function (top, minContrast, minLargeContrast)
    {
        var startDate = new Date();
        var count     = 0;
        var xcount    = 0;
        var failures  = [];

        if (!top.ownerDocument) {
            var toProcess = [top.getElementsByTagName('body')[0]];
        } else {
            var toProcess = [top];
        }

        while (toProcess.length > 0) {
            var node = toProcess.shift();

            // This is an element.
            if ((node.nodeType === 1) && (HTMLCS.util.isHidden(node) === false) && (HTMLCS.util.isDisabled(node) === false)) {
                var processNode = false;
                for (var i = 0; i < node.childNodes.length; i++) {
                    // Load up new nodes, but also only process this node when
                    // there are direct text elements.
                    if (node.childNodes[i].nodeType === 1) {
                        toProcess.push(node.childNodes[i]);
                    } else if (node.childNodes[i].nodeType === 3) {
                        if (HTMLCS.util.trim(node.childNodes[i].nodeValue) !== '') {
                            processNode = true;
                        }
                    }
                }

                if (processNode === true) {
                    var style = HTMLCS.util.style(node);

                    if (style) {
                        var bgColour  = style.backgroundColor;
                        var foreColour = style.color;
                        var bgElement = node;
                        var hasBgImg  = false;
                        var isAbsolute = false;
                        
			            if (style.backgroundImage !== 'none') {
                            hasBgImg = true;
                        }
                        
                        if (style.position == 'absolute') {
                            isAbsolute = true;
                        }

                        var parent = node.parentNode;

                        // Calculate font size. Note that CSS 2.1 fixes a reference pixel
                        // as 96 dpi (hence "pixel ratio" workarounds for Hi-DPI devices)
                        // so this calculation should be safe.
                        var fontSize      = parseInt(style.fontSize, 10) * (72 / 96);
                        var minLargeSize  = 18;

                        if ((style.fontWeight === 'bold') || (parseInt(style.fontWeight, 10) >= 600)) {
                            var minLargeSize = 14;
                        }

                        var reqRatio = minContrast;
                        if (fontSize >= minLargeSize) {
                            reqRatio = minLargeContrast;
                        }

                        // Check for a solid background colour.
                        while ((bgColour === 'transparent') || (bgColour === 'rgba(0, 0, 0, 0)')) {
                            if ((!parent) || (!parent.ownerDocument)) {
                                break;
                            }

                            var parentStyle = HTMLCS.util.style(parent);
                            var bgColour    = parentStyle.backgroundColor;
                            if (parentStyle.backgroundImage !== 'none') {
                                hasBgImg = true;
                            }
                            if (parentStyle.position == 'absolute') {
                                isAbsolute = true;
                            }

                            parent = parent.parentNode;
                        }//end while

                        if (hasBgImg === true) {
                            // If we have a background image, skip the contrast ratio checks,
                            // and push a warning instead.
                            failures.push({
                                element: node,
                                colour: style.color,
                                bgColour: undefined,
                                value: undefined,
                                required: reqRatio,
                                hasBgImage: true
                            });
                            continue;
                        } else if (isAbsolute === true) {
                            failures.push({
                                element: node,
                                colour: foreColour,
                                bgColour: undefined,
                                value: undefined,
                                required: reqRatio,
                                isAbsolute: true
                            });
                        } else if ((bgColour === 'transparent') || (bgColour === 'rgba(0, 0, 0, 0)')) {
                            // If the background colour is still transparent, this is probably
                            // a fragment with which we cannot reliably make a statement about
                            // contrast ratio. Skip the element.
                            continue;
                        }

                        var contrastRatio = HTMLCS.util.contrastRatio(bgColour, style.color);



                        if (contrastRatio < reqRatio) {
                            var recommendation = this.recommendColour(bgColour, style.color, reqRatio);

                            failures.push({
                                element: node,
                                colour: style.color,
                                bgColour: bgColour,
                                value: contrastRatio,
                                required: reqRatio,
                                recommendation: recommendation
                            });
                        }//end if
                    }//end if
                }//end if
            }//end if
        }//end while

        return failures;
    },

    recommendColour: function(back, fore, target) {
        // Canonicalise the colours.
        var fore = HTMLCS.util.RGBtoColourStr(HTMLCS.util.colourStrToRGB(fore));
        var back = HTMLCS.util.RGBtoColourStr(HTMLCS.util.colourStrToRGB(back));

        var cr = HTMLCS.util.contrastRatio(fore, back);
        var foreDiff = Math.abs(HTMLCS.util.relativeLum(fore) - 0.5);
        var backDiff = Math.abs(HTMLCS.util.relativeLum(back) - 0.5);

        var recommendation = null;

        if (cr < target) {
            // Work out which colour has more room to move.
            // If they are the same, prefer changing the foreground colour.
            var multiplier = (1 + 1 / 400);
            if (foreDiff <= backDiff) {
                var change = 'back';
                var newCol = back;
                if (HTMLCS.util.relativeLum(back) < 0.5) {
                    var multiplier = (1 / multiplier);
                }
            } else {
                var change = 'fore';
                var newCol = fore;
                if (HTMLCS.util.relativeLum(fore) < 0.5) {
                    var multiplier = (1 / multiplier);
                }
            }

            var hsv     = HTMLCS.util.sRGBtoHSV(newCol);
            var chroma  = hsv.saturation * hsv.value;
            var newFore = fore;
            var newBack = back;
            var changed = false;

            var i = 0;

            while (cr < target) {
                if ((newCol === '#fff') || (newCol === '#000')) {
                    // Couldn't go far enough. Reset and try the other colour.
                    if (changed === true) {
                        // We've already switched colours, so we have to start
                        // winding back the other colour.
                        if (change === 'fore') {
                            var oldBack = newBack;
                            var j = 1;
                            while (newBack === oldBack) {
                                var newBack = this.multiplyColour(newBack, Math.pow(1 / multiplier, j));
                                j++;
                            }
                        } else {
                            var oldFore = newFore;
                            var j = 1;
                            while (newFore === oldFore) {
                                var newFore = this.multiplyColour(newFore, Math.pow(1 / multiplier, j));
                                j++;
                            }
                        }
                    } else {
                        newFore = fore;
                        newBack = back;
                        multiplier = 1 / multiplier;
                        if (change === 'fore') {
                            change = 'back';
                            var hsv = back;
                        } else {
                            change = 'fore';
                            var hsv = fore;
                        }

                        hsv     = HTMLCS.util.sRGBtoHSV(hsv);
                        chroma  = hsv.saturation * hsv.value;
                        changed = true;
                    }
                }

                i++;
                var newCol = HTMLCS.util.HSVtosRGB(hsv);
                var newCol = this.multiplyColour(newCol, Math.pow(multiplier, i));

                if (change === 'fore') {
                    var newFore = newCol;
                } else {
                    var newBack = newCol;
                }

                var cr = HTMLCS.util.contrastRatio(newFore, newBack);
            }//end while

            recommendation = {
                fore: {
                    from: fore,
                    to: newFore
                },
                back: {
                    from: back,
                    to: newBack
                }
            }
        }//end if

        return recommendation;
    },

    multiplyColour: function(colour, multiplier) {
        var hsvColour = HTMLCS.util.sRGBtoHSV(colour);
        var chroma    = hsvColour.saturation * hsvColour.value;

        // If we are starting from black, start it from #010101 instead.
        if (hsvColour.value === 0) {
            hsvColour.value = (1 / 255);
        }

        hsvColour.value = hsvColour.value * multiplier;
        if (hsvColour.value === 0) {
            hsvColour.saturation = 0;
        } else {
            hsvColour.saturation = chroma / hsvColour.value;
        }

        hsvColour.value      = Math.min(1, hsvColour.value);
        hsvColour.saturation = Math.min(1, hsvColour.saturation);

        var newColour = HTMLCS.util.RGBtoColourStr(HTMLCS.util.HSVtosRGB(hsvColour));
        return newColour;
    }
}



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_3_F24 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // Test for background/foreground stuff.
        var elements = top.querySelectorAll('*');
        for (var i = 0; i < elements.length; i++) {
            this.testColourComboFail(elements[i]);
        }
    },

    
    testColourComboFail: function(element)
    {
        var hasFg = element.hasAttribute('color');
        hasFg     = hasFg || element.hasAttribute('link');
        hasFg     = hasFg || element.hasAttribute('vlink');
        hasFg     = hasFg || element.hasAttribute('alink');
        var hasBg = element.hasAttribute('bgcolor');

        if (element.style) {
            var fgStyle = element.style.color;
            var bgStyle = element.style.background;

            if ((fgStyle !== '') && (fgStyle !== 'auto')) {
                hasFg = true;
            }

            if ((bgStyle !== '') && (bgStyle !== 'auto')) {
                hasBg = true;
            }
        }//end if

        if (hasBg !== hasFg) {
            if (hasBg === true) {
                HTMLCS.addMessage(HTMLCS.WARNING, element, 'Check that this element has an inherited foreground colour to complement the corresponding inline background colour or image.', 'F24.BGColour');
            } else {
                HTMLCS.addMessage(HTMLCS.WARNING, element, 'Check that this element has an inherited background colour or image to complement the corresponding inline foreground colour.', 'F24.FGColour');
            }
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_4 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that text can be resized without assistive technology up to 200 percent without loss of content or functionality.', 'G142');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_5 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        var imgObj = top.querySelector('img');

        if (imgObj !== null) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'If the technologies being used can achieve the visual presentation, check that text is used to convey information rather than images of text, except when the image of text is essential to the information being conveyed, or can be visually customised to the user\'s requirements.', 'G140,C22,C30.AALevel');
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_6 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            var failures = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_3_Contrast.testContrastRatio(top, 7.0, 4.5);

            for (var i = 0; i < failures.length; i++) {
                var element   = failures[i].element;
                
                var decimals  = 2;
                var value     = (Math.round(failures[i].value * Math.pow(10, decimals)) / Math.pow(10, decimals));
                var required  = failures[i].required;
                var recommend = failures[i].recommendation;
                var hasBgImg  = failures[i].hasBgImage || false;
                var isAbsolute = failures[i].isAbsolute || false;

                // If the values would look identical, add decimals to the value.
                while (required === value) {
                    decimals++;
                    value = (Math.round(failures[i].value * Math.pow(10, decimals)) / Math.pow(10, decimals));
                }

                if (required === 4.5) {
                    var code = 'G18';
                } else if (required === 7.0) {
                    var code = 'G17';
                }

                var recommendText = [];
                if (recommend) {
                    if (recommend.fore.from !== recommend.fore.to) {
                        recommendText.push('text colour to ' + recommend.fore.to);
                    }
                    if (recommend.back.from !== recommend.back.to) {
                        recommendText.push('background to ' + recommend.back.to);
                    }
                }//end if

                if (recommendText.length > 0) {
                    recommendText = ' Recommendation: change ' + recommendText.join(', ') + '.';
                }

                if (isAbsolute === true) {
                    code += '.Abs';
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This element is absolutely positioned and the background color can not be determined. Ensure the contrast ratio between the text and all covered parts of the background are at least ' + required + ':1.', code);
                } else if (hasBgImg === true) {
                    code += '.BgImage';
                    HTMLCS.addMessage(HTMLCS.WARNING, element, 'This element\'s text is placed on a background image. Ensure the contrast ratio between the text and all covered parts of the image are at least ' + required + ':1.', code);
                } else {
                    code += '.Fail';
                    HTMLCS.addMessage(HTMLCS.ERROR, element, 'This element has insufficient contrast at this conformance level. Expected a contrast ratio of at least ' + required + ':1, but text in this element has a contrast ratio of ' + value + ':1.' + recommendText, code);
                }//end if
            }//end for
        }//end if
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_7 = {
    
    register: function()
    {
        return [
            'object',
            'embed',
            'applet',
            'bgsound',
            'audio'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'For pre-recorded audio-only content in this element that is primarily speech (such as narration), any background sounds should be muteable, or be at least 20 dB (or about 4 times) quieter than the speech.', 'G56');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_8 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // This Success Criterion has five prongs, and each should be thrown as a
        // separate notice as separate techniques apply to each.
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that a mechanism is available for the user to select foreground and background colours for blocks of text, either through the Web page or the browser.', 'G148,G156,G175');
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that a mechanism exists to reduce the width of a block of text to no more than 80 characters (or 40 in Chinese, Japanese or Korean script).', 'H87,C20');
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that blocks of text are not fully justified - that is, to both left and right edges - or a mechanism exists to remove full justification.', 'C19,G172,G169');
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that line spacing in blocks of text are at least 150% in paragraphs, and paragraph spacing is at least 1.5 times the line spacing, or that a mechanism is available to achieve this.', 'G188,C21');
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that text can be resized without assistive technology up to 200 percent without requiring the user to scroll horizontally on a full-screen window.', 'H87,G146,C26');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_4_1_4_9 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        var imgObj = top.querySelector('img');

        if (imgObj !== null) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that images of text are only used for pure decoration or where a particular presentation of text is essential to the information being conveyed.', 'G140,C22,C30.NoException');
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_1_2_1_1 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // Testing for elements that have explicit attributes for mouse-specific
        // events. Note: onclick is considered keyboard accessible, as it is actually
        // tied to the default action of a link or button - not merely a click.
        if (element === top) {
            var dblClickEls = top.querySelectorAll('*[ondblclick]');
            for (var i = 0; i < dblClickEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, dblClickEls[i], 'Ensure the functionality provided by double-clicking on this element is available through the keyboard.', 'SCR20.DblClick');
            }

            var mouseOverEls = top.querySelectorAll('*[onmouseover]');
            for (var i = 0; i < mouseOverEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, mouseOverEls[i], 'Ensure the functionality provided by mousing over this element is available through the keyboard; for instance, using the focus event.', 'SCR20.MouseOver');
            }

            var mouseOutEls = top.querySelectorAll('*[onmouseout]');
            for (var i = 0; i < mouseOutEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, mouseOutEls[i], 'Ensure the functionality provided by mousing out of this element is available through the keyboard; for instance, using the blur event.', 'SCR20.MouseOut');
            }

            var mouseMoveEls = top.querySelectorAll('*[onmousemove]');
            for (var i = 0; i < mouseMoveEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, mouseMoveEls[i], 'Ensure the functionality provided by moving the mouse on this element is available through the keyboard.', 'SCR20.MouseMove');
            }

            var mouseDownEls = top.querySelectorAll('*[onmousedown]');
            for (var i = 0; i < mouseDownEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, mouseDownEls[i], 'Ensure the functionality provided by mousing down on this element is available through the keyboard; for instance, using the keydown event.', 'SCR20.MouseDown');
            }

            var mouseUpEls = top.querySelectorAll('*[onmouseup]');
            for (var i = 0; i < mouseUpEls.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, mouseUpEls[i], 'Ensure the functionality provided by mousing up on this element is available through the keyboard; for instance, using the keyup event.', 'SCR20.MouseUp');
            }
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_1_2_1_2 = {
    
    register: function()
    {
        return [
            'object',
            'applet',
            'embed'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.WARNING, element, 'Check that this applet or plugin provides the ability to move the focus away from itself when using the keyboard.', 'F10');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_2_2_2_1 = {
    
    register: function()
    {
        return ['meta'];

    },

    
    process: function(element, top)
    {
        // Meta refresh testing under H76/F41. Fails if a non-zero timeout is provided.
        // NOTE: H76 only lists criterion 3.2.5, but F41 also covers refreshes to
        // same page (no URL content), which is covered by non-adjustable timeouts
        // in criterion 2.2.1.
        if (element.hasAttribute('http-equiv') === true) {
            if ((String(element.getAttribute('http-equiv'))).toLowerCase() === 'refresh') {
                if (/^[1-9]\d*/.test(element.getAttribute('content').toLowerCase()) === true) {
                    if (/url=/.test(element.getAttribute('content').toLowerCase()) === true) {
                        // Redirect.
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Meta refresh tag used to redirect to another page, with a time limit that is not zero. Users cannot control this time limit.', 'F40.2');
                    } else {
                        // Just a refresh.
                        HTMLCS.addMessage(HTMLCS.ERROR, element, 'Meta refresh tag used to refresh the current page. Users cannot control the time limit for this refresh.', 'F41.2');
                    }
                }
            }//end if
        }//end if

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_2_2_2_2 = {
    
    register: function()
    {
        return [
            '_top',
            'blink'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If any part of the content moves, scrolls or blinks for more than 5 seconds, or auto-updates, check that there is a mechanism available to pause, stop, or hide the content.', 'SCR33,SCR22,G187,G152,G186,G191');

            var elements = top.querySelectorAll('*');
            for (var i = 0; i < elements.length; i++) {
                var computedStyle = HTMLCS.util.style(elements[i]);

                if (computedStyle) {
                    if (/blink/.test(computedStyle['text-decoration']) === true) {
                        HTMLCS.addMessage(HTMLCS.WARNING, elements[i], 'Ensure there is a mechanism available to stop this blinking element in less than five seconds.', 'F4');
                    }
                }
            }//end for
        } else if (element.nodeName.toLowerCase() === 'blink') {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Blink elements cannot satisfy the requirement that blinking information can be stopped within five seconds.', 'F47');
        }//end if

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_2_2_2_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that timing is not an essential part of the event or activity presented by the content, except for non-interactive synchronized media and real-time events.', 'G5');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_2_2_2_4 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that all interruptions (including updates to content) can be postponed or suppressed by the user, except interruptions involving an emergency.', 'SCR14');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_2_2_2_5 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this Web page is part of a set of Web pages with an inactivity time limit, check that an authenticated user can continue the activity without loss of data after re-authenticating.', 'G105,G181');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_3_2_3_1 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // The "small" flashing area is deliberately vague - users should see
        // technique G176 for more details, as the threshold depends on both the
        // size and resolution of a screen.
        // The technique gives a baseline (based on a 15-17 inch monitor read at
        // 22-26 inches, at 1024 x 768 resolution). A 10-degree field of vision is
        // approximately 341 x 256 pixels in this environment, and a flashing area
        // needs to be no more than 25% of this (not necessarily rectangular).
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that no component of the content flashes more than three times in any 1-second period, or that the size of any flashing area is sufficiently small.', 'G19,G176');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_3_2_3_2 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that no component of the content flashes more than three times in any 1-second period.', 'G19');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_1 = {
    
    register: function()
    {
        return [
            'iframe',
            'a',
            'area',
            '_top'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            this.testGenericBypassMsg(top);
        } else {
            var nodeName = element.nodeName.toLowerCase();

            switch (nodeName) {
                case 'iframe':
                    this.testIframeTitle(element);
                break;

                case 'a':
                case 'area':
                    this.testSameDocFragmentLinks(element, top);
                break;
            }
        }
    },

    
    testIframeTitle: function(element)
    {
        var nodeName = element.nodeName.toLowerCase();

        if (nodeName === 'iframe') {
            var hasTitle = false;
            if (element.hasAttribute('title') === true) {
                if (element.getAttribute('title') && (/^\s+$/.test(element.getAttribute('title')) === false)) {
                    hasTitle = true;
                }
            }

            if (hasTitle === false) {
                HTMLCS.addMessage(HTMLCS.ERROR, element, 'Iframe element requires a non-empty title attribute that identifies the frame.', 'H64.1');
            } else {
                HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that the title attribute of this element contains text that identifies the frame.', 'H64.2');
            }
        }//end if
    },

    
    testGenericBypassMsg: function(top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Ensure that any common navigation elements can be bypassed; for instance, by use of skip links, header elements, or ARIA landmark roles.', 'G1,G123,G124,H69');
    },

    
    testSameDocFragmentLinks: function(element, top)
    {
        if (element.hasAttribute('href') === true) {
            var href = element.getAttribute('href');
            href     = HTMLCS.util.trim(href);
            if ((href.length > 1) && (href.charAt(0) === '#')) {
                var id = href.substr(1);

                try {
                    var doc = top;
                    if (doc.ownerDocument) {
                        doc = doc.ownerDocument;
                    }

                    // First search for an element with the appropriate ID, then search for a
                    // named anchor using the name attribute.
                    var target = doc.getElementById(id);
                    if (target === null) {
                        target = doc.querySelector('a[name="' + id + '"]');
                    }

                    if ((target === null) || (HTMLCS.util.contains(top, target) === false)) {
                        if ((HTMLCS.isFullDoc(top) === true) || (top.nodeName.toLowerCase() === 'body')) {
                            HTMLCS.addMessage(HTMLCS.ERROR, element, 'This link points to a named anchor "' + id + '" within the document, but no anchor exists with that name.', 'G1,G123,G124.NoSuchID');
                        } else {
                            HTMLCS.addMessage(HTMLCS.WARNING, element, 'This link points to a named anchor "' + id + '" within the document, but no anchor exists with that name in the fragment tested.', 'G1,G123,G124.NoSuchIDFragment');
                        }
                    }
                } catch (ex) {
                }//end try
            }//end if
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_2 = {
    
    register: function()
    {
        return ['html'];

    },

    
    process: function(element, top)
    {
        // Find a head first.
        var children = element.childNodes;
        var head     = null;

        for (var i = 0; i < children.length; i++) {
            if (children[i].nodeName.toLowerCase() === 'head') {
                head = children[i];
                break;
            }
        }

        if (head === null) {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'There is no head section in which to place a descriptive title element.', 'H25.1.NoHeadEl');
        } else {
            var children = head.childNodes;
            var title    = null;

            for (var i = 0; i < children.length; i++) {
                if (children[i].nodeName.toLowerCase() === 'title') {
                    title = children[i];
                    break;
                }
            }

            if (title === null) {
                HTMLCS.addMessage(HTMLCS.ERROR, head, 'A title should be provided for the document, using a non-empty title element in the head section.', 'H25.1.NoTitleEl');
            } else {
                if (/^\s*$/.test(title.innerHTML) === true) {
                    HTMLCS.addMessage(HTMLCS.ERROR, title, 'The title element in the head section should be non-empty.', 'H25.1.EmptyTitle');
                } else {
                    HTMLCS.addMessage(HTMLCS.NOTICE, title, 'Check that the title element describes the document.', 'H25.2');
                }
            }//end if
        }//end if

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            var tabIndexExists = top.querySelector('*[tabindex]');

            if (tabIndexExists) {
                HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If tabindex is used, check that the tab order specified by the tabindex attributes follows relationships in the content.', 'H4.2');
            }
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_4 = {
    
    register: function()
    {
        return ['a'];

    },

    
    process: function(element, top)
    {
        if (element.hasAttribute('title') === true) {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that the link text combined with programmatically determined link context, or its title attribute, identifies the purpose of the link.', 'H77,H78,H79,H80,H81,H33');
        } else {
            HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that the link text combined with programmatically determined link context identifies the purpose of the link.', 'H77,H78,H79,H80,H81');
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_5 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this Web page is not part of a linear process, check that there is more than one way of locating this Web page within a set of Web pages.', 'G125,G64,G63,G161,G126,G185');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_6 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that headings and labels describe topic or purpose.', 'G130,G131');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_7 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // Fire this notice if there appears to be an input field or link on the page
        // (which will be just about anything). Links are important because they can
        // still be tabbed to.
        var inputField = top.querySelector('input, textarea, button, select, a');

        if (inputField !== null) {
            HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that there is at least one mode of operation where the keyboard focus indicator can be visually located on user interface controls.', 'G149,G165,G195,C15,SCR31');
        }

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_8 = {
    
    register: function()
    {
        return ['link'];

    },

    
    process: function(element, top)
    {
        var linkParentName = element.parentNode.nodeName.toLowerCase();

        // Check for the correct location. HTML4 states "it may only appear in the
        // HEAD element". HTML5 states it appears "wherever metadata content is
        // expected", which only includes the head element.
        if (linkParentName !== 'head') {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Link elements can only be located in the head section of the document.', 'H59.1');
        }

        // Check for mandatory elements.
        if ((element.hasAttribute('rel') === false) || (!element.getAttribute('rel')) || (/^\s*$/.test(element.getAttribute('rel')) === true)) {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Link element is missing a non-empty rel attribute identifying the link type.', 'H59.2a');
        }

        if ((element.hasAttribute('href') === false) || (!element.getAttribute('href')) || (/^\s*$/.test(element.getAttribute('href')) === true)) {
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Link element is missing a non-empty href attribute pointing to the resource being linked.', 'H59.2b');
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle2_Guideline2_4_2_4_9 = {
    
    register: function()
    {
        return ['a'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that text of the link describes the purpose of the link.', 'H30');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_1 = {
    
    register: function()
    {
        return ['html'];

    },

    
    process: function(element, top)
    {
        if ((element.hasAttribute('lang') === false) && (element.hasAttribute('xml:lang') === false)) {
            // TODO: if we can tell whether it's HTML or XHTML, we should split this
            // into two - one asking for "lang", the other for "xml:lang".
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'The html element should have a lang or xml:lang attribute which describes the language of the document.', 'H57.2');
        } else {
            if (element.hasAttribute('lang') === true) {
                var lang = element.getAttribute('lang');
                if (this.isValidLanguageTag(lang) === false) {
                    HTMLCS.addMessage(HTMLCS.ERROR, top, 'The language specified in the lang attribute of the document element does not appear to be well-formed.', 'H57.3.Lang');
                }
            }

            if (element.hasAttribute('xml:lang') === true) {
                var lang = element.getAttribute('xml:lang');
                if (this.isValidLanguageTag(lang) === false) {
                    HTMLCS.addMessage(HTMLCS.ERROR, top, 'The language specified in the xml:lang attribute of the document element does not appear to be well-formed.', 'H57.3.XmlLang');
                }
            }
        }

    },


    
    isValidLanguageTag: function(langTag)
    {
        // Allow irregular or private-use tags starting with 'i' or 'x'.
        // Values after it are 1-8 alphanumeric characters.
        var regexStr = '^([ix](-[a-z0-9]{1,8})+)$|';

        // Core language tags - 2 to 8 letters
        regexStr += '^[a-z]{2,8}';

        // Extlang subtags - three letters, repeated 0 to 3 times
        regexStr += '(-[a-z]{3}){0,3}';

        // Script subtag - four letters, optional.
        regexStr += '(-[a-z]{4})?';

        // Region subtag - two letters for a country or a three-digit region; optional.
        regexStr += '(-[a-z]{2}|-[0-9]{3})?';

        // Variant subtag - either digit + 3 alphanumeric, or
        // 5-8 alphanumeric where it doesn't start with a digit; optional
        // but repeatable.
        regexStr += '(-[0-9][a-z0-9]{3}|-[a-z0-9]{5,8})*';

        // Extension subtag - one single alphanumeric character (but not "x"),
        // followed by at least one value of 2-8 alphanumeric characters.
        // The whole thing is optional but repeatable (for different extensions).
        regexStr += '(-[a-wy-z0-9](-[a-z0-9]{2,8})+)*';

        // Private use subtag, starting with an "x" and containing at least one
        // value of 1-8 alphanumeric characters. It must come last.
        regexStr += '(-x(-[a-z0-9]{1,8})+)?$';

        // Make a regex out of it, and make it all case-insensitive.
        var regex = new RegExp(regexStr, 'i');

        // Throw the correct lang code depending on whether this is a document
        // element or not.
        var valid = true;
        if (regex.test(langTag) === false) {
            valid = false;
        }

        return valid;
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_2 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        // Generic message for changes in language.
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Ensure that any change in language is marked using the lang and/or xml:lang attribute on an element, as appropriate.', 'H58');

        // Alias the SC 3.1.1 object, which contains our "valid language tag" test.
        var sc3_1_1 = HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_1;

        // Note, going one element beyond the end, so we can test the top element
        // (which doesn't get picked up by the above query). Instead of going off the
        // cliff of the collection, the last loop (i === langEls.length) checks the
        // top element.
        var langEls = top.querySelectorAll('*[lang]');
        for (var i = 0; i <= langEls.length; i++) {
            if (i === langEls.length) {
                var langEl = top;
            } else {
                var langEl = langEls[i];
            }

            // Skip html nodes, they are covered by 3.1.1.
            // Also skip if the top element is the document element.
            if ((!langEl.documentElement) && (langEl.nodeName.toLowerCase() !== 'html')) {
                if (langEl.hasAttribute('lang') === true) {
                    var lang = langEl.getAttribute('lang');
                    if (sc3_1_1.isValidLanguageTag(lang) === false) {
                        HTMLCS.addMessage(HTMLCS.ERROR, langEl, 'The language specified in the lang attribute of this element does not appear to be well-formed.', 'H58.1.Lang');
                    }
                }

                if (langEl.hasAttribute('xml:lang') === true) {
                    var lang = langEl.getAttribute('xml:lang');
                    if (sc3_1_1.isValidLanguageTag(lang) === false) {
                        HTMLCS.addMessage(HTMLCS.ERROR, langEl, 'The language specified in the xml:lang attribute of this element does not appear to be well-formed.', 'H58.1.XmlLang');
                    }
                }
            }//end if
        }//end for
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that there is a mechanism available for identifying specific definitions of words or phrases used in an unusual or restricted way, including idioms and jargon.', 'H40,H54,H60,G62,G70');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_4 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that a mechanism for identifying the expanded form or meaning of abbreviations is available.', 'G102,G55,G62,H28,G97');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_5 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Where the content requires reading ability more advanced than the lower secondary education level, supplemental content or an alternative version should be provided.', 'G86,G103,G79,G153,G160');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_1_3_1_6 = {
    
    register: function()
    {
        return ['ruby'];

    },

    
    process: function(element, top)
    {
        var rb = element.querySelectorAll('rb');
        var rt = element.querySelectorAll('rt');
        if (rt.length === 0) {
            // Vary the message depending on whether an rb element exists. If it doesn't,
            // the presumption is that we are using HTML5 that uses the body of the ruby
            // element for the same purpose (otherwise, assume XHTML 1.1 with rb element).
            if (rb.length === 0) {
                HTMLCS.addMessage(HTMLCS.ERROR, element, 'Ruby element does not contain an rt element containing pronunciation information for its body text.', 'H62.1.HTML5');
            } else {
                HTMLCS.addMessage(HTMLCS.ERROR, element, 'Ruby element does not contain an rt element containing pronunciation information for the text inside the rb element.', 'H62.1.XHTML11');
            }
        }

        var rp = element.querySelectorAll('rp');
        if (rp.length === 0) {
            // No "ruby parentheses" tags for those user agents that don't support
            // ruby at all.
            HTMLCS.addMessage(HTMLCS.ERROR, element, 'Ruby element does not contain rp elements, which provide extra punctuation to browsers not supporting ruby text.', 'H62.2');
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_2_3_2_1 = {
    
    register: function()
    {
        return [
            'input',
            'textarea',
            'button',
            'select'
        ];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that a change of context does not occur when this input field receives focus.', 'G107');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_2_3_2_2 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();

        if (nodeName === 'form') {
            this.checkFormSubmitButton(element);
        }
    },

    
    checkFormSubmitButton: function(form)
    {
        var ok = false;

        // Test for INPUT-based submit buttons. The type must be specified, as
        // the default for INPUT is text.
        var inputButtons = form.querySelectorAll('input[type=submit], input[type=image]');
        if (inputButtons.length > 0) {
            ok = true;
        } else {
            // Check for BUTTONs that aren't reset buttons, or normal buttons.
            // If they're blank or invalid, they are submit buttons.
            var buttonButtons    = form.querySelectorAll('button');
            var nonSubmitButtons = form.querySelectorAll('button[type=reset], button[type=button]');
            if (buttonButtons.length > nonSubmitButtons.length) {
                ok = true;
            }
        }//end if

        if (ok === false) {
            HTMLCS.addMessage(
                HTMLCS.ERROR,
                form,
                'This form does not contain a submit button, which creates issues for those who cannot submit the form using the keyboard. Submit buttons are INPUT elements with type attribute "submit" or "image", or BUTTON elements with type "submit" or omitted/invalid.',
                'H32.2'
            );
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_2_3_2_3 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that navigational mechanisms that are repeated on multiple Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.', 'G61');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_2_3_2_4 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, top, 'Check that components that have the same functionality within this Web page are identified consistently in the set of Web pages to which it belongs.', 'G197');

    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_2_3_2_5 = {
    
    register: function()
    {
        return ['a'];

    },

    
    process: function(element, top)
    {
        var nodeName = element.nodeName.toLowerCase();

        if (nodeName === 'a') {
            this.checkNewWindowTarget(element);
        }
    },

    
    checkNewWindowTarget: function(link)
    {
        var hasTarget = link.hasAttribute('target');

        if (hasTarget === true) {
            var target = link.getAttribute('target') || '';
            if ((target === '_blank') && (/new window/i.test(link.innerHTML) === false)) {
                HTMLCS.addMessage(HTMLCS.WARNING, link, 'Check that this link\'s link text contains information indicating that the link will open in a new window.', 'H83.3');
            }
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_1 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If an input error is automatically detected in this form, check that the item(s) in error are identified and the error(s) are described to the user in text.', 'G83,G84,G85');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_2 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        // Only the generic message will be displayed here. If there were problems
        // with input boxes not having labels, it will be pulled up as errors in
        // other Success Criteria (eg. 1.3.1, 4.1.2).
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that descriptive labels or instructions (including for required fields) are provided for user input in this form.', 'G131,G89,G184,H90');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_3 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        // Only G177 (about providing suggestions) is flagged as a technique.
        // The techniques in 3.3.1 are also listed in this Success Criterion.
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that this form provides suggested corrections to errors in user input, unless it would jeopardize the security or purpose of the content.', 'G177');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_4 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'If this form would bind a user to a financial or legal commitment, modify/delete user-controllable data, or submit test responses, ensure that submissions are either reversible, checked for input errors, and/or confirmed by the user.', 'G98,G99,G155,G164,G168.LegalForms');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_5 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that context-sensitive help is available for this form, at a Web-page and/or control level.', 'G71,G184,G193');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle3_Guideline3_3_3_3_6 = {
    
    register: function()
    {
        return ['form'];

    },

    
    process: function(element, top)
    {
        HTMLCS.addMessage(HTMLCS.NOTICE, element, 'Check that submissions to this form are either reversible, checked for input errors, and/or confirmed by the user.', 'G98,G99,G155,G164,G168.AllForms');
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle4_Guideline4_1_4_1_1 = {
    
    register: function()
    {
        return [
            '_top'
        ];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            var elsWithIds = top.querySelectorAll('*[id]');
            var usedIds    = {};

            for (var i = 0; i < elsWithIds.length; i++) {
                var id = elsWithIds[i].getAttribute('id');
                if (usedIds[id] !== undefined) {
                    // F77 = "Failure of SC 4.1.1 due to duplicate values of type ID".
                    // Appropriate technique in HTML is H93.
                    HTMLCS.addMessage(HTMLCS.ERROR, elsWithIds[i], 'Duplicate id attribute value "' + id + '" found on the web page.', 'F77');
                } else {
                    usedIds[id] = true;
                }
            }
        }
    }
};



var HTMLCS_WCAG2AAA_Sniffs_Principle4_Guideline4_1_4_1_2 = {
    
    register: function()
    {
        return ['_top'];

    },

    
    process: function(element, top)
    {
        if (element === top) {
            var messages = this.processFormControls(top);
            for (var i = 0; i < messages.errors.length; i++) {
                HTMLCS.addMessage(HTMLCS.ERROR, messages.errors[i].element, messages.errors[i].msg, 'H91.' + messages.errors[i].subcode);
            }

            for (var i = 0; i < messages.warnings.length; i++) {
                HTMLCS.addMessage(HTMLCS.WARNING, messages.warnings[i].element, messages.warnings[i].msg, 'H91.' + messages.warnings[i].subcode);
            }

            this.addProcessLinksMessages(top);
        }//end if
    },

    addProcessLinksMessages: function(top)
    {
        var errors = this.processLinks(top);
        for (var i = 0; i < errors.empty.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.empty[i], 'Anchor element found with an ID but without a href or link text. Consider moving its ID to a parent or nearby element.', 'H91.A.Empty');
        }

        for (var i = 0; i < errors.emptyWithName.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.emptyWithName[i], 'Anchor element found with a name attribute but without a href or link text. Consider moving the name attribute to become an ID of a parent or nearby element.', 'H91.A.EmptyWithName');
        }

        for (var i = 0; i < errors.emptyNoId.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.emptyNoId[i], 'Anchor element found with no link content and no name and/or ID attribute.', 'H91.A.EmptyNoId');
        }

        for (var i = 0; i < errors.noHref.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.noHref[i], 'Anchor elements should not be used for defining in-page link targets. If not using the ID for other purposes (such as CSS or scripting), consider moving it to a parent element.', 'H91.A.NoHref');
        }

        for (var i = 0; i < errors.placeholder.length; i++) {
            HTMLCS.addMessage(HTMLCS.WARNING, errors.placeholder[i], 'Anchor element found with link content, but no href, ID or name attribute has been supplied.', 'H91.A.Placeholder');
        }

        for (var i = 0; i < errors.noContent.length; i++) {
            HTMLCS.addMessage(HTMLCS.ERROR, errors.noContent[i], 'Anchor element found with a valid href attribute, but no link content has been supplied.', 'H91.A.NoContent');
        }
    },

    processLinks: function(top)
    {
        var errors   = {
            empty: [],
            emptyWithName: [],
            emptyNoId: [],
            noHref: [],
            placeholder: [],
            noContent: []
        };

        var elements = top.querySelectorAll('a');

        for (var el = 0; el < elements.length; el++) {
            var element = elements[el];

            var nameFound = false;
            var hrefFound = false;
            var content   = HTMLCS.util.getElementTextContent(element);

            if ((element.hasAttribute('title') === true) && (/^\s*$/.test(element.getAttribute('title')) === false)) {
                nameFound = true;
            } else if (/^\s*$/.test(content) === false) {
                nameFound = true;
            }

            if ((element.hasAttribute('href') === true) && (/^\s*$/.test(element.getAttribute('href')) === false)) {
                hrefFound = true;
            }

            if (hrefFound === false) {
                // No href. We don't want these because, although they are commonly used
                // to create targets, they can be picked up by screen readers and
                // displayed to the user as empty links. A elements are defined by H91 as
                // having an (ARIA) role of "link", and using them as targets are
                // essentially misusing them. Place an ID on a parent element instead.
                if (/^\s*$/.test(content) === true) {
                    // Also no content. (eg. <a id=""></a> or <a name=""></a>)
                    if (element.hasAttribute('id') === true) {
                        errors.empty.push(element);
                    } else if (element.hasAttribute('name') === true) {
                        errors.emptyWithName.push(element);
                    } else {
                        errors.emptyNoId.push(element);
                    }
                } else {
                    // Giving a benefit of the doubt here - if a link has text and also
                    // an ID, but no href, it might be because it is being manipulated by
                    // a script.
                    if ((element.hasAttribute('id') === true) || (element.hasAttribute('name') === true)) {
                        errors.noHref.push(element);
                    } else {
                        // HTML5 allows A elements with text but no href, "for where a
                        // link might otherwise have been placed, if it had been relevant".
                        // Hence, thrown as a warning, not an error.
                        errors.placeholder.push(element);
                    }
                }//end if
            } else {
                if (nameFound === false) {
                    // Href provided, but no content or title.
                    // We only fire this message when there are no images in the content.
                    // A link around an image with no alt text is already covered in SC
                    // 1.1.1 (test H30).
                    if (element.querySelectorAll('img').length === 0) {
                        errors.noContent.push(element);
                    }
                }//end if
            }//end if
        }//end for

        return errors;
    },

    processFormControls: function(top)
    {
        var elements = top.querySelectorAll('button, fieldset, input, select, textarea');
        var errors   = [];
        var warnings = [];

        var requiredNames = {
            button: ['@title', '_content'],
            fieldset: ['legend'],
            input_button: ['@value'],
            input_text: ['label', '@title'],
            input_file: ['label', '@title'],
            input_password: ['label', '@title'],
            input_checkbox: ['label', '@title'],
            input_radio: ['label', '@title'],
            input_image: ['@alt', '@title'],
            select: ['label', '@title'],
            textarea: ['label', '@title']
        }

        var requiredValues = {
            select: 'option_selected'
        };

        for (var el = 0; el < elements.length; el++) {
            var element    = elements[el];
            var nodeName   = element.nodeName.toLowerCase();
            var msgSubCode = element.nodeName.substr(0, 1).toUpperCase() + element.nodeName.substr(1).toLowerCase();
            if (nodeName === 'input') {
                if (element.hasAttribute('type') === false) {
                    // If no type attribute, default to text.
                    nodeName += '_text';
                } else {
                    nodeName += '_' + element.getAttribute('type').toLowerCase();
                }

                // Treat all input buttons as the same
                if ((nodeName === 'input_submit') || (nodeName === 'input_reset')) {
                    nodeName = 'input_button';
                }

                // Get a format like "InputText".
                var msgSubCode = 'Input' + nodeName.substr(6, 1).toUpperCase() + nodeName.substr(7).toLowerCase();
            }//end if

            var requiredName  = requiredNames[nodeName];
            var requiredValue = requiredValues[nodeName];

            // Check all possible combinations of names to ensure that one exists.
            if (requiredName) {
                for (var i = 0; i < requiredNames[nodeName].length; i++) {
                    var requiredName = requiredNames[nodeName][i];
                    if (requiredName === '_content') {
                        // Work with content.
                        var content = HTMLCS.util.getElementTextContent(element);
                        if (/^\s*$/.test(content) === false) {
                            break;
                        }
                    } else if (requiredName === 'label') {
                        // Label element. Re-use the label associating
                        // functions in SC 1.3.1.
                        var hasLabel = HTMLCS_WCAG2AAA_Sniffs_Principle1_Guideline1_3_1_3_1.testLabelsOnInputs(element, top, true);
                        if (hasLabel !== false) {
                            found = true;
                            break;
                        }
                    } else if (requiredName.charAt(0) === '@') {
                        // Attribute.
                        requiredName = requiredName.substr(1, requiredName.length);
                        if ((element.hasAttribute(requiredName) === true) && (/^\s*$/.test(element.getAttribute(requiredName)) === false)) {
                            break;
                        }
                    } else {
                        // Sub-element contents.
                        var subEl = element.querySelector(requiredName);
                        if (subEl !== null) {
                            var content = HTMLCS.util.getElementTextContent(subEl);
                            if (/^\s*$/.test(content) === false) {
                                break;
                            }
                        }
                    }//end if
                }//end for

                if (i === requiredNames[nodeName].length) {
                    var msgNodeType = nodeName + ' element';
                    if (nodeName.substr(0, 6) === 'input_') {
                        msgNodeType = nodeName.substr(6) + ' input element';
                    }

                    var builtAttrs = requiredNames[nodeName].slice(0, requiredNames[nodeName].length);
                    for (var a = 0; a < builtAttrs.length; a++) {
                        if (builtAttrs[a] === '_content') {
                            builtAttrs[a] = 'element content';
                        } else if (builtAttrs[a].charAt(0) === '@') {
                            builtAttrs[a] = builtAttrs[a].substr(1) + ' attribute';
                        } else {
                            builtAttrs[a] = builtAttrs[a] + ' element';
                        }
                    }

                    var msg = 'This ' + msgNodeType + ' does not have a name available to an accessibility API. Valid names are: ' + builtAttrs.join(', ') + '.';
                    errors.push({
                        element: element,
                        msg: msg,
                        subcode: (msgSubCode + '.Name')
                    });
                }
            }//end if

            var requiredValue = requiredValues[nodeName];
            var valueFound    = false;

            if (requiredValue === undefined) {
                // Nothing required of us.
                valueFound = true;
            } else if (requiredValue === '_content') {
                // Work with content.
                var content = HTMLCS.util.getElementTextContent(element);
                if (/^\s*$/.test(content) === false) {
                    valueFound = true;
                }
            } else if (requiredValue === 'option_selected') {
                // Select lists are recommended to have a selected Option element.
                if (element.hasAttribute('multiple') === false) {
                    var selected = element.querySelector('option[selected]');
                    if (selected !== null) {
                        valueFound = true;
                    }
                } else {
                    // Allow zero element selection to be valid where the SELECT
                    // element has been declared as a multiple selection.
                    valueFound = true;
                }
            } else if (requiredValue.charAt(0) === '@') {
                // Attribute.
                requiredValue = requiredValue.substr(1, requiredValue.length);
                if ((element.hasAttribute(requiredValue) === true)) {
                    valueFound = true;
                }
            }//end if

            if (valueFound === false) {
                var msgNodeType = nodeName + ' element';
                if (nodeName.substr(0, 6) === 'input_') {
                    msgNodeType = nodeName.substr(6) + ' input element';
                }

                var msg = 'This ' + msgNodeType + ' does not have a value available to an accessibility API.';
                
                var builtAttr = '';
                var warning   = false;
                if (requiredValue === '_content') {
                    builtAttr = ' Add one by adding content to the element.';
                } else if (requiredValue === 'option_selected') {
                    // Change the message instead. The value is only undefined in HTML 4/XHTML 1;
                    // in HTML5 the first option in a single select dropdown is automatically selected.
                    // Because of this, it should also be sent out as a warning, not an error.
                    warning = true;
                    msg = 'This ' + msgNodeType + ' does not have an initially selected option.' + ' ' +
                        'Depending on your HTML version, the value exposed to an accessibility API may be undefined.';
                } else if (requiredValue.charAt(0) === '@') {
                    builtAttr = ' A value is exposed using the "' + requiredValue + '" attribute.';
                } else {
                    builtAttr = ' A value is exposed using the "' + requiredValue + '" element.';
                }

                msg += builtAttr;
                if (warning === false) {
                    errors.push({
                        element: element,
                        msg: msg,
                        subcode: (msgSubCode + '.Value')
                    });
                } else {
                    warnings.push({
                        element: element,
                        msg: msg,
                        subcode: (msgSubCode + '.Value')
                    });
                }
            }//end if
        }//end for

        return {
            errors: errors,
            warnings: warnings
        };
    }
};

ViperAccessibilityPlugin_WCAG2_Principle1_Guideline1_1 = {
    hasCss: false,
    id: 'ViperAccessibilityPlugin_WCAG2_Principle1_Guideline1_1',
    parent: null,

    res_1_1_1: function(contentElement, element, issue, code, viper)
    {
        var editPanel = null;
        var action    = null;
        var self      = this;
        var technique = code.techniques[0];

        switch (technique) {
            case 'H37':
            case 'H67.1':
            case 'H67.2':
                if (technique === 'H37') {
                    this._getImageResContent(contentElement, element, 'Enter a short text description of the image, or define the image as purely decorative.');
                } else {
                    this._getImageResContent(contentElement, element, 'Ensure this image is purely decorative. If not, enter appropriate alt and title text.');
                }

                editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var altid      = null;
                var titleid    = null;
                var checkboxid = null;
                checkboxid   = Viper.Util.getUniqueId();
                var checkbox = viper.Tools.createCheckbox(checkboxid, 'Image is decorative', (technique === 'H67.2'), function(checked) {
                    if (checked === true) {
                        viper.Tools.getItem(altid).disable();
                        viper.Tools.getItem(titleid).disable();
                    } else {
                        viper.Tools.getItem(altid).enable();
                        viper.Tools.getItem(titleid).enable();
                    }
                });
                editPanel.appendChild(checkbox);

                altid   = Viper.Util.getUniqueId();
                var alt = viper.Tools.createTextbox(altid, 'Alt', element.getAttribute('alt'));
                editPanel.appendChild(alt);

                titleid   = Viper.Util.getUniqueId();
                var title = viper.Tools.createTextbox(titleid, 'Title', element.getAttribute('title'));
                editPanel.appendChild(title);

                if (technique === 'H67.2') {
                    viper.Tools.getItem(altid).disable();
                    viper.Tools.getItem(titleid).disable();
                }

                action = function() {
                    if (viper.Tools.getItem(checkboxid).getValue() !== true) {
                        element.setAttribute('alt', viper.Tools.getItem(altid).getValue());
                        element.setAttribute('title', viper.Tools.getItem(titleid).getValue());
                    } else {
                        element.setAttribute('alt', '');
                        element.removeAttribute('title');
                    }
                };

                this.parent.addActionButton(action, contentElement, [checkboxid, titleid, altid], null, null, function() {
                    if (viper.Tools.getItem(checkboxid).getValue() !== true
                        && viper.Tools.getItem(altid).getValue() === ''
                    ) {
                        return false;
                    }
                });
            break;

            case 'H2.EG3':
            case 'H2.EG5':
            case 'H30.2':
            case 'G94.Image':
                var msg = '';
                if (technique === 'H2.EG3') {
                    msg = 'Update the image\'s alt text to something other than the nearby link "' + element.getAttribute('alt') + '".';
                } else if (technique === 'H30.2') {
                    msg = 'Make sure the image\'s alt text describes the purpose of the link it\'s being used for.';
                } else if (technique === 'G94') {
                    msg = 'Ensure the image\'s alt text describes the purpose or content of the image.';
                }

                if (Viper.Util.isTag(element, 'a') === true) {
                    element = Viper.Util.getTag('img', element)[0];
                }

                this._getImageResContent(contentElement, element, msg);

                editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var altid = Viper.Util.getUniqueId();
                var alt   = viper.Tools.createTextbox(altid, 'Alt', element.getAttribute('alt'));
                editPanel.appendChild(alt);
                action = function() {
                    element.setAttribute('alt', viper.Tools.getItem(altid).getValue());
                };

                this.parent.addActionButton(action, contentElement, [altid]);
            break;

            default:
                // No interface.
            break;
        }//end switch

    },

    _getImageResContent: function(contentElement, element, msg)
    {
        this.parent.setResolutionInstruction(contentElement, '<div class="Viper-imagePreview "><img class="Viper-thumb" src="' + element.getAttribute('src') + '"></div><p>' + msg + '</p>');

    }

};

ViperAccessibilityPlugin_WCAG2_Principle1_Guideline1_3 = {
    hasCss: false,
    id: 'ViperAccessibilityPlugin_WCAG2_Principle1_Guideline1_3',
    parent: null,

    res_1_3_1: function(contentElement, element, issue, code, viper, issueid)
    {
        var editPanel = null;
        var action    = null;
        var self      = this;
        var technique = code.techniques[0];

        switch(technique) {
            case 'H48.1':
            case 'H48.2':
                var content  = '';
                var btnTitle = '';
                if (technique === 'H48.1') {
                    content  = '<p>This section of content resembles a content list. If this is intentional, it should be converted to the proper list format.</p>';
                    btnTitle = 'Convert to Unordered List';
                } else {
                    content  = '<p>This section of content resembles a numbered list. If this is intentional it should be converted to the proper list format.</p>';
                    btnTitle = 'Convert to Ordered List';
                }

                this.parent.setResolutionInstruction(contentElement, content);

                var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                action = function() {
                    if (technique === 'H48.1') {
                        self._convertToUnorderedList(element);
                    } else {
                        self._convertToOrderedList(element);
                    }
                };

                this.parent.addActionButton(action, contentElement, null, btnTitle, true);
            break;

            case 'H39':
                if (code.techniques[1] === 'H73.4') {
                    this.parent.setResolutionInstruction(contentElement, '<p>Update either the table\'s caption or summary so they are not identical.</p>');

                    var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                    var captionid = Viper.Util.getUniqueId();
                    var caption   = viper.Tools.createTextarea(captionid, 'Caption', this._getTableCaption(element));
                    editPanel.appendChild(caption);

                    var summaryid = Viper.Util.getUniqueId();
                    var summary   = viper.Tools.createTextarea(summaryid, 'Summary', this._getTableSummary(element));
                    editPanel.appendChild(summary);

                    action = function() {
                        var captionVal = viper.Tools.getItem(captionid).getValue();
                        var summaryVal = viper.Tools.getItem(summaryid).getValue();

                        self._setTableCaption(element, captionVal);
                        self._setTableSummary(element, summaryVal);
                    };

                    this.parent.addActionButton(action, contentElement, [captionid, summaryid], null, null, function() {
                        var captionVal = viper.Tools.getItem(captionid).getValue();
                        var summaryVal = viper.Tools.getItem(summaryid).getValue();
                        if (Viper.Util.trim(captionVal) === Viper.Util.trim(summaryVal)) {
                            return false;
                        }
                    });
                }
            break;

            case 'H39.3.NoCaption':
            case 'H39.3.Check':
                this.parent.setResolutionInstruction(contentElement, '<p>Enter a caption for the table.</p>');

                var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var captionid  =  null;
                var checkboxid = Viper.Util.getUniqueId();
                var useCaption = false;

                if (technique === 'H39.3.Check') {
                    useCaption = true;
                }

                var checkbox   = viper.Tools.createCheckbox(checkboxid, 'Use caption', useCaption, function(checked) {
                    if (checked === true) {
                        viper.Tools.getItem(captionid).enable();
                    } else {
                        viper.Tools.getItem(captionid).disable();
                    }
                });
                editPanel.appendChild(checkbox);

                captionid = Viper.Util.getUniqueId();
                var tableCaption = this._getTableCaption(element);

                var caption = viper.Tools.createTextarea(captionid, 'Caption', tableCaption);

                if (!tableCaption && useCaption === false) {
                    viper.Tools.getItem(captionid).disable();
                }

                editPanel.appendChild(caption);

                action = function() {
                    var captionVal = '';
                    if (viper.Tools.getItem(checkboxid).getValue() === true) {
                        captionVal = viper.Tools.getItem(captionid).getValue();
                    }

                    self._setTableCaption(element, captionVal);
                };

                this.parent.addActionButton(action, contentElement, [captionid, checkboxid], null, null, function() {
                    var captionVal = viper.Tools.getItem(captionid).getValue();
                    if (!captionVal && viper.Tools.getItem(checkboxid).getValue() !== false) {
                        return false;
                    }
                });
            break;

            case 'H73.3.NoSummary':
            case 'H73.3.Check':
                this.parent.setResolutionInstruction(contentElement, '<p>Enter a summary for the table.</p>');

                var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var summaryid  =  null;
                var checkboxid = Viper.Util.getUniqueId();
                var useSummary = false;

                if (technique === 'H73.3.Check') {
                    useSummary = true;
                }

                var checkbox   = viper.Tools.createCheckbox(checkboxid, 'Use summary', useSummary, function(checked) {
                    if (checked === true) {
                        viper.Tools.getItem(summaryid).enable();
                    } else {
                        viper.Tools.getItem(summaryid).disable();
                    }
                });
                editPanel.appendChild(checkbox);

                summaryid   = Viper.Util.getUniqueId();
                var tableSummary = this._getTableSummary(element);
                var summary = viper.Tools.createTextarea(summaryid, 'Summary', tableSummary);

                if (!tableSummary && useSummary === false) {
                    viper.Tools.getItem(summaryid).disable();
                }

                editPanel.appendChild(summary);

                action = function() {
                    var summaryVal = '';
                    if (viper.Tools.getItem(checkboxid).getValue() === true) {
                        summaryVal = viper.Tools.getItem(summaryid).getValue();
                    }

                    self._setTableSummary(element, summaryVal);
                };

                this.parent.addActionButton(action, contentElement, [summaryid, checkboxid], null, null, function() {
                    var summaryVal = Viper.Util.trim(viper.Tools.getItem(summaryid).getValue());
                    if (!summaryVal && viper.Tools.getItem(checkboxid).getValue() !== false) {
                        return false;
                    }
                });
            break;

            case 'H43.IncorrectAttr':
                this.parent.setResolutionInstruction(contentElement, '<p>Fix the header attribute of this cell.</p>');
                var action = function() {
                    var newAttribute = issue.msg.match(/Expected "([^"]+)"/i)[1];
                    element.setAttribute('headers', newAttribute);
                };
                this.parent.addActionButton(action, contentElement, null, 'Fix headers attribute', true);
            break;

            case 'H49.B':
                this.parent.setResolutionInstruction(contentElement, '<p>Convert the B tag to the more appropriate STRONG tag.</p>');
                var action = function() {
                    var newTag = document.createElement('strong');
                    element.parentNode.replaceChild(newTag, element);
                    while (element.firstChild) {
                        newTag.appendChild(element.firstChild);
                    }
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to STRONG tag', true);
            break;

            case 'H49.I':
                this.parent.setResolutionInstruction(contentElement, '<p>Convert the I tag to the more appropriate EM tag.</p>');
                var action = function() {
                    var newTag = document.createElement('em');
                    element.parentNode.replaceChild(newTag, element);
                    while (element.firstChild) {
                        newTag.appendChild(element.firstChild);
                    }
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to EM tag', true);
            break;

            case 'H49.U':
                this.parent.setResolutionInstruction(contentElement, '<p>The U tag should be removed to reduce confusion with links.</p>');
                var action = function() {
                    while (element.firstChild) {
                        Viper.Util.insertBefore(element, element.firstChild);
                    }

                    Viper.Util.remove(element);
                };
                this.parent.addActionButton(action, contentElement, null, 'Remove U tag', true);
            break;

            case 'H49.S':
                this.parent.setResolutionInstruction(contentElement, '<p>The S tag needs to be replaced with a DEL tag.</p>');
                var action = function() {
                    var newTag = document.createElement('del');
                    element.parentNode.replaceChild(newTag, element);
                    while (element.firstChild) {
                        newTag.appendChild(element.firstChild);
                    }
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to DEL tag', true);
            break;

            case 'H49.Strike':
                this.parent.setResolutionInstruction(contentElement, '<p>The Strike tag needs to be replaced with a DEL tag.</p>');
                var action = function() {
                    var newTag = document.createElement('del');
                    element.parentNode.replaceChild(newTag, element);
                    while (element.firstChild) {
                        newTag.appendChild(element.firstChild);
                    }
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to DEL tag', true);
            break;

            case 'H49.Tt':
                this.parent.setResolutionInstruction(contentElement, '<p>The TT tag needs to be replaced with a CODE tag.</p>');
                var action = function() {
                    var newTag = document.createElement('code');
                    element.parentNode.replaceChild(newTag, element);
                    while (element.firstChild) {
                        newTag.appendChild(element.firstChild);
                    }
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to CODE tag', true);
            break;

            case 'H49.Big':
                this.parent.setResolutionInstruction(contentElement, '<p>The BIG tag needs to be removed.</p>');
                var action = function() {
                    while (element.firstChild) {
                        Viper.Util.insertBefore(element, element.firstChild);
                    }

                    Viper.Util.remove(element);
                };
                this.parent.addActionButton(action, contentElement, null, 'Remove BIG tag', true);
            break;

            case 'H49.Small':
                this.parent.setResolutionInstruction(contentElement, '<p>The SMALL tag needs to be removed.</p>');
                var action = function() {
                    while (element.firstChild) {
                        Viper.Util.insertBefore(element, element.firstChild);
                    }

                    Viper.Util.remove(element);
                };
                this.parent.addActionButton(action, contentElement, null, 'Remove SMALL tag', true);
            break;

            case 'H49.Center':
                this.parent.setResolutionInstruction(contentElement, '<p>The CENTER tag needs to be converted to a CSS based alignment method.</p>');
                var action = function() {
                    var parent = null;
                    while (element.firstChild) {
                        if (Viper.Util.isBlockElement(element.firstChild) === true) {
                            parent = element.firstChild;
                            Viper.Util.insertBefore(element, parent);
                            Viper.Util.setStyle(parent, 'text-align', 'center');
                        } else if (!parent) {
                            parent = document.createElement('p');
                            Viper.Util.insertBefore(element, parent);
                            Viper.Util.setStyle(parent, 'text-align', 'center');
                            parent.appendChild(element.firstChild);
                        } else {
                            parent.appendChild(element.firstChild);
                        }
                    }

                    Viper.Util.remove(element);
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to CSS alignment', true);
            break;

            case 'H49.Font':
                this.parent.setResolutionInstruction(contentElement, '<p>The FONT tag needs to be removed. Consider using a CSS class on the containing element to achieve variations in fonts/colours/sizes etc.</p>');
                var action = function() {
                    while (element.firstChild) {
                        Viper.Util.insertBefore(element, element.firstChild);
                    }

                    Viper.Util.remove(element);
                };
                this.parent.addActionButton(action, contentElement, null, 'Remove FONT tag', true);
            break;

            case 'H49.AlignAttr':
                this.parent.setResolutionInstruction(contentElement, '<p>The ALIGN attribute needs to be converted to a CSS based alignment method.</p>');
                var action = function() {
                    var align = element.getAttribute('align');

                    if (Viper.Util.isTag(align, 'img') === true) {
                        switch (align) {
                            case 'left':
                                Viper.Util.setStyle(element, 'float', 'left');
                                Viper.Util.setStyle(element, 'margin', '1em 1em 1em 0');
                                Viper.Util.setStyle(element, 'display', '');
                            break;

                            case 'right':
                                Viper.Util.setStyle(element, 'float', 'right');
                                Viper.Util.setStyle(element, 'margin', '1em 0 1em 1em');
                                Viper.Util.setStyle(element, 'display', '');
                            break;

                            case 'middle':
                                Viper.Util.setStyle(element, 'margin', '1em auto');
                                Viper.Util.setStyle(element, 'float', '');
                                Viper.Util.setStyle(element, 'display', 'block');
                            break;

                            default:
                                Viper.Util.setStyle(element, 'margin', '');
                                Viper.Util.setStyle(element, 'float', '');
                                Viper.Util.setStyle(element, 'display', '');
                            break;
                        }//end switch
                    } else {
                        Viper.Util.setStyle(element, 'text-align', align);
                    }

                    element.removeAttribute('align');
                };
                this.parent.addActionButton(action, contentElement, null, 'Convert to CSS alignment', true);
            break;

            case 'H42':
                this.parent.setResolutionInstruction(contentElement, '<p>If a paragraph\'s content consists solely of bold or italic text to simulate a heading it should be converted to the appropriate heading level.</p>');
                var updateResolution = function() {
                    // Insert a specific text before the element so that we can find
                    // it in HTML string.
                    var textNode = document.createTextNode('__VAP_ELEM_POS__');
                    Viper.Util.insertBefore(element, textNode);

                    // Get Viper's current content from start to the __VAP_ELEM_POS__.
                    var viperElemContent = viper.getHtml();
                    viperElemContent = viperElemContent.substring(0, viperElemContent.indexOf('__VAP_ELEM_POS__'));

                    // Remove the text node we just created.
                    Viper.Util.remove(textNode);

                    // Find the last heading level.
                    var headings = viperElemContent.match(/.*<h(\d)/i);
                    if (headings) {
                        var lastHeading = parseInt(headings[1]);

                        self.parent.removeActionButtons(contentElement);
                        var actionButtonids = [];

                        for (var i = lastHeading; i <= (lastHeading + 1); i++) {
                            (function(headingLevel) {
                                var action = function() {
                                    for (var j = 0; j < actionButtonids.length; j++) {
                                        viper.Tools.disableButton(actionButtonids[j]);
                                    }

                                    var newTag = document.createElement('h' + headingLevel);
                                    element.parentNode.replaceChild(newTag, element);
                                    while (element.firstChild) {
                                        newTag.appendChild(element.firstChild);
                                    }

                                    var tags = Viper.Util.getTag('strong,em', newTag);
                                    for (var j = 0; j < tags.length; j++) {
                                        while (tags[j].firstChild) {
                                            Viper.Util.insertBefore(tags[j], tags[j].firstChild);
                                        }

                                        Viper.Util.remove(tags[j]);
                                    }
                                };

                                actionButtonids.push(self.parent.addActionButton(action, contentElement, null, 'Convert to H' + headingLevel, true));
                            }) (i);
                        }
                    }
                };

                viper.registerCallback('ViperAccessibilityPlugin:showResolution:' + issueid, 'ViperAccessibilityPlugin:resolution', function() {
                    updateResolution();
                });

            break;

            default:
                // No interface.
            break;

        }//end switch

    },

    _convertToOrderedList: function(element)
    {
        var list = document.createElement('ol');

        var li = document.createElement('li');
        while (element.firstChild) {
            var child = element.firstChild;
            if (child.nodeType === Viper.Util.ELEMENT_NODE && Viper.Util.isTag(child, 'br') === true) {
                list.appendChild(li);
                li = document.createElement('li');
                Viper.Util.remove(child);
            } else {
                if (!li.firstChild) {
                    // First child of this list item, remove any numbers at the start
                    // of the its content.
                    child.data = Viper.Util.ltrim(child.data).replace(/^(\d+)[ .\/\-\:]+/, '');
                }

                li.appendChild(child);
            }
        }

        if (li.firstChild) {
            list.appendChild(li);
        }

        Viper.Util.insertBefore(element, list);
        Viper.Util.remove(element);

    },

    _convertToUnorderedList: function(element)
    {
        var list = document.createElement('ul');

        var li = document.createElement('li');
        while (element.firstChild) {
            var child = element.firstChild;
            if (child.nodeType === Viper.Util.ELEMENT_NODE && Viper.Util.isTag(child, 'br') === true) {
                list.appendChild(li);
                li = document.createElement('li');
                Viper.Util.remove(child);
            } else {
                if (!li.firstChild) {
                    // First child of this list item, remove any numbers at the start
                    // of the its content.
                    child.data = Viper.Util.ltrim(child.data).replace(/^([\*\-+\#~>]+)/, '');
                }

                li.appendChild(child);
            }
        }

        if (li.firstChild) {
            list.appendChild(li);
        }

        Viper.Util.insertBefore(element, list);
        Viper.Util.remove(element);

    },

    _getTableCaption: function(table)
    {
        var caption  = '';
        var captions = Viper.Util.getTag('caption', table);
        if (captions.length > 0) {
            caption = Viper.Util.getNodeTextContent(captions[0]);
        }

        return caption;

    },

    _setTableCaption: function(table, caption)
    {
        if (!caption) {
            var captionTags = Viper.Util.getTag('caption', table);
            if (captionTags.length > 0) {
                Viper.Util.remove(captionTags);
            }
        } else {
            var captionTags = Viper.Util.getTag('caption', table);
            if (captionTags.length > 0) {
                Viper.Util.remove(captionTags);
            }

            var captionTag = document.createElement('caption');
            Viper.Util.setHtml(captionTag, caption);
            Viper.Util.insertBefore(table.firstChild, captionTag);
        }

    },

    _getTableSummary: function(table)
    {
        return Viper.Util.trim(table.getAttribute('summary') || '');

    },

    _setTableSummary: function(table, summary)
    {
        if (!summary) {
            table.removeAttribute('summary');
        } else {
            table.setAttribute('summary', Viper.Util.trim(summary));
        }

    }

};

ViperAccessibilityPlugin_WCAG2_Principle2_Guideline2_4 = {
    hasCss: false,
    id: 'ViperAccessibilityPlugin_WCAG2_Principle2_Guideline2_4',
    parent: null,

    res_2_4_1: function(contentElement, element, issue, code, viper, issueid)
    {
        var editPanel = null;
        var action    = null;
        var self      = this;
        var technique = code.techniques[0];

        switch(technique) {
            case 'H64.1':
            case 'H64.2':
                this.parent.setResolutionInstruction(contentElement, '<p>Enter an appropriate title for the iframe to describe it\'s purpose.</p>');

                var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var titleid =  null;
                titleid     = Viper.Util.getUniqueId();
                var title   = viper.Tools.createTextbox(titleid, 'Title', element.getAttribute('title') || '');
                editPanel.appendChild(title);

                action = function() {
                    var titleVal = viper.Tools.getItem(titleid).getValue();
                    element.setAttribute('title', titleVal);
                };

                this.parent.addActionButton(action, contentElement, [titleid], null, null, function() {
                    var titleVal = Viper.Util.trim(viper.Tools.getItem(titleid).getValue());
                    if (!titleVal) {
                        return false;
                    }
                });
            break;

            default:
                // No interface.
            break;

        }//end switch

    }

};

ViperAccessibilityPlugin_WCAG2_Principle4_Guideline4_1 = {
    hasCss: false,
    id: 'ViperAccessibilityPlugin_WCAG2_Principle4_Guideline4_1',
    parent: null,

    res_4_1_1: function(contentElement, element, issue, code, viper, issueid)
    {
        var editPanel = null;
        var action    = null;
        var self      = this;
        var technique = code.techniques[0];

        switch(technique) {
            case 'F77':
                this.parent.setResolutionInstruction(contentElement, '<p>Update the ID to be unique.</p>');

                var editPanel = this.parent.getResolutionActionsContainer(contentElement);

                var idAttrid =  null;
                idAttrid     = Viper.Util.getUniqueId();
                var idAttr   = viper.Tools.createTextbox(idAttrid, 'ID', element.getAttribute('id') || '');
                editPanel.appendChild(idAttr);

                action = function() {
                    var idAttrVal = viper.Tools.getItem(idAttrid).getValue();
                    element.setAttribute('id', idAttrVal);
                };

                this.parent.addActionButton(action, contentElement, [idAttrid], null, null, function() {
                    var idAttrVal = Viper.Util.trim(viper.Tools.getItem(idAttrid).getValue());
                    if (!idAttrVal) {
                        return false;
                    } else {
                        var elem = Viper.Util.getid(idAttrVal);
                        if (Viper.Util.inArray(viper.getViperElement(), Viper.Util.getParents(elem)) === true) {
                            return false;
                        }
                    }
                });
            break;

            default:
                // No interface.
            break;

        }//end switch

    }

};

ViperAccessibilityPlugin_WCAG2 = {
    viper: null,
    vap: null,
    _contentElement: null,

    getReferenceContent: function(issue, callback, vap)
    {
        this.vap   = vap;
        this.viper = vap.viper;

        var code = this._parseCode(issue.code);

        var content = '<strong>' + code.standard + ' References</strong><br>';
        content    += '<em>Principle: </em> <a target="_blank" href="http://www.w3.org/TR/WCAG20/#' + code.principleName + '">' + Viper.Util.ucFirst(code.principleName) + '</a><br>';
        content    += '<em>Techniques: </em> ';

        var techStrs = [];
        for (var i = 0; i < code.techniques.length; i++) {
            techStrs.push('<a target="_blank" href="http://www.w3.org/TR/WCAG20-TECHS/' + code.techniques[i] + '">' + code.techniques[i] + '</a>');
        }

        content += techStrs.join(', ');

        var element = document.createElement('div');
        Viper.Util.setHtml(element, content);
        Viper.Util.addClass(element, 'Viper-issueWcag');

        callback.call(this, element);

    },

    getResolutionContent: function(issue, contentElement, vap, issueid)
    {
        this.vap   = vap;
        this.viper = vap.viper;

        var code    = this._parseCode(issue.code);
        var objName = 'ViperAccessibilityPlugin_WCAG2_Principle' + code.principle + '_Guideline' + code.guideline.replace('.', '_');
        var obj     = window[objName];
        if (obj) {
            var fn = obj['res_' + code.section.replace('.', '_')];
            if (Viper.Util.isFn(fn) === true) {
                obj.parent = this;
                fn.call(obj, contentElement, issue.element, issue, code, vap.viper, issueid);
            }

            return;
        } else if (Viper.build === true) {
            // If Viper build is being used then do not include any resolution files.
            return;
        }

        var url  = vap.viper.getViperPath();
        url     += '/Plugins/ViperAccessibilityPlugin/Resolutions/WCAG2/';
        url     += 'Principle' + code.principle + '/Guideline' + code.guideline.replace('.', '_');

        var scriptUrl = url + '/resolutions.js';
        var cssUrl    = url + '/resolutions.css';

        var self = this;
        vap.loadObject(scriptUrl, objName, function(obj) {
            if (!obj) {
                return;
            }

            if (obj.hasCss === true) {
                vap.includeCss(cssUrl);
            }

            obj.parent = self;

            var fn = obj['res_' + code.section.replace('.', '_')];
            if (Viper.Util.isFn(fn) === true) {
                fn.call(obj, contentElement, issue.element, issue, code, vap.viper, issueid);
            }
        });

    },

    addActionButton: function(action, resolutionContainer, widgetids, title, enabled, updateCallback)
    {
        title   = title || 'Apply Changes';

        var disabled = !enabled;
        var tools    = this.viper.Tools;
        var self     = this;
        var buttonid = Viper.Util.getUniqueId();
        var button   = tools.createButton(buttonid, title, title, 'Viper-VAP-actionBtn', function() {
            tools.disableButton(buttonid);

            var dismissBtn = Viper.Util.getClass('Viper-VAP-dismissBtn', resolutionContainer);
            if (dismissBtn.length === 1) {
                tools.disableButton(dismissBtn[0].id.replace(self.viper.getId() + '-', ''));
            }

            self.vap.fixIssue();
            self.viper.fireNodesChanged();
            return action.call(this);
        }, disabled);

        if (widgetids) {
            for (var i = 0; i < widgetids.length; i++) {
                if (!widgetids[i]) {
                    continue;
                }

                (function(widgetid) {
                    self.viper.registerCallback('ViperTools:changed:' + widgetid, 'ViperAccessibilityPlugin:wcag2', function() {
                        if (updateCallback && updateCallback.call(this, widgetid) === false) {
                            // Disable button.
                            tools.disableButton(buttonid);
                            return;
                        }

                        tools.enableButton(buttonid);
                    });
                }) (widgetids[i]);
            }
        }

        var actionButtons = Viper.Util.getClass('Viper-actionButtons', resolutionContainer)[0];
        if (actionButtons.firstChild) {
            var otherActionButtons = Viper.Util.getClass('Viper-VAP-actionBtn', actionButtons);
            if (otherActionButtons && otherActionButtons.length > 0) {
                Viper.Util.insertAfter(otherActionButtons[otherActionButtons.length - 1], button);
            } else {
                Viper.Util.insertBefore(actionButtons.firstChild, button);
            }
        } else {
            actionButtons.appendChild(button);
        }

        return buttonid;

    },

    removeActionButtons: function(resolutionContainer)
    {
        var actionButtons = Viper.Util.getClass('Viper-VAP-actionBtn', resolutionContainer);
        Viper.Util.remove(actionButtons);

    },

    getDefaultContent: function(issueid, issue, objName, vap)
    {
        this.vap   = vap;
        this.viper = vap.viper;

        if (!objName) {
            var code = this._parseCode(issue.code);
            objName  = 'ViperAccessibilityPlugin_WCAG2_Principle' + code.principle + '_Guideline' + code.guideline.replace('.', '_');
        }

        var div = document.createElement('div');
        Viper.Util.addClass(div, objName);

        var content = '<div class="Viper-resolutionInstructions">';

        switch (issue.type) {
            case HTMLCS.ERROR:
                content += '<p>Please resolve this issue manually and then click the refresh button to confirm that the issue is resolved.</p>';
            break;

            case HTMLCS.WARNING:
            case HTMLCS.NOTICE:
                content += '<p>Either fix this issue manually and then click the refresh button to confirm that the issue is resolved or, if no changes are required, click the "Dismiss" button.</p>';
            break;
        }

        content += '</div>';
        content += '<div class="Viper-resolutionActions"><div class="Viper-editing"></div><div class="Viper-actionButtons"></div></div>';
        Viper.Util.setHtml(div, content);

        if (issue.type !== HTMLCS.ERROR) {
            var actionButtons = Viper.Util.getClass('Viper-actionButtons', div)[0];

            var self = this;
            var buttonid = Viper.Util.getUniqueId();
            var dismissButton = this.viper.Tools.createButton(buttonid, 'Dismiss', 'Dismiss Issue', 'Viper-VAP-dismissBtn', function() {
                self.viper.Tools.disableButton(buttonid);
                self.vap.dismissIssue(issueid);
            });

            actionButtons.appendChild(dismissButton);
        }

        return div;

    },

    setResolutionInstruction: function(resolutionContainer, content)
    {
        var instructionCont = Viper.Util.getClass('Viper-resolutionInstructions', resolutionContainer)[0];

        if (typeof content === 'string') {
            Viper.Util.setHtml(instructionCont, content);
        } else {
            Viper.Util.empty(instructionCont);
            instructionCont.appendChild(content);
        }

    },

    getResolutionActionsContainer: function(resolutionContainer)
    {
        var instructionCont = Viper.Util.getClass('Viper-editing', resolutionContainer)[0];
        Viper.Util.empty(instructionCont);
        return instructionCont;

    },

    _parseCode: function(code)
    {
        var sections = code.split('.');
        var parsed   = {};
        parsed.standard = sections[0];

        if (sections[1].indexOf('Principle') === 0) {
            var principle = sections[1].replace('Principle', '');
            var principleName = '';
            switch (principle) {
                case '1':
                    principleName = 'perceivable';
                break;

                case '2':
                    principleName = 'operable';
                break;

                case '3':
                    principleName = 'understandable';
                break;

                case '4':
                    principleName = 'robust';
                break;
            }

            parsed.principle     = principle;
            parsed.principleName = principleName;
        }

        if (sections[2].indexOf('Guideline') === 0) {
            parsed.guideline = sections[2].replace('Guideline', '').replace('_', '.');
        }

        parsed.section = sections[3].replace('_', '.');

        parsed.techniques = [];

        var techniques = sections.splice(4, (sections.length - 1)).join('.');
        var techniques = techniques.split(',');
        for (var i = 0; i < techniques.length; i++) {
            parsed.techniques.push(techniques[i]);
        }

        return parsed;

    }

};


 (function(ViperUtil, ViperSelection, _) {
     function ViperAccessibilityPlugin(viper)
     {
         this.viper            = viper;
         this._toolbar         = null;
         this._loadedScripts   = [];
         this._loadCallbacks   = {};
         this._includedCSS     = [];
         this._standard        = 'WCAG2AAA';
         this._dismissedIssues = {};
         this._htmlcsWrapper   = document.createElement('div');

         var url = this.viper.getViperPath();
         url    += '/Plugins/ViperAccessibilityPlugin/HTML_CodeSniffer/';
         this._htmlCSsrc = url;

     }

     Viper.PluginManager.addPlugin('ViperAccessibilityPlugin', ViperAccessibilityPlugin);

     ViperAccessibilityPlugin.prototype = {
         init: function()
         {
             var self = this;
             this._createToolbarItems();

             this.viper.registerCallback('Viper:clickedOutside', 'ViperAccessibilityPlugin', function() {
                 ViperUtil.remove(ViperUtil.getClass('HTMLCS-pointer'));
             });

             this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperAccessibilityPlugin', function(data) {
                 self.viper.Tools.enableButton('accessibility');
             });

         },

         setSettings: function(settings)
         {
             if (!settings) {
                 return;
             }

             if (settings.standard) {
                 this._standard = settings.standard;
             }

         },

         getIssues: function()
         {
             var self = this;
             if (!window.HTMLCSAuditor) {
                 this.includeScript(this._htmlCSsrc + '/HTMLCS.js', function() {
                     self.includeScript(self._htmlCSsrc + 'Auditor/HTMLCSAuditor.js', function() {
                         var link   = document.createElement('link');
                         link.rel   = 'stylesheet';
                         link.media = 'screen';
                         link.href  = self._htmlCSsrc + 'Auditor/HTMLCSAuditor.css';
                         document.getElementsByTagName('head')[0].appendChild(link);

                         self.getIssues();
                     });
                 });

                 return;
             }//end if

             ViperUtil.setHtml(this._htmlcsWrapper, '');
             HTMLCSAuditor.pointerContainer = this._toolbar.getBubble('VAP:bubble').element;
             HTMLCSAuditor.run(this._standard, this.viper.getViperElement(), {
                 noHeader: true,
                 includeCss: false,
                 parentElement: self._htmlcsWrapper,
                 customIssueSource: function(id, issue, standard, resolutionElem, detailsElem) {
                     self._createIssueDetail(id, issue, resolutionElem, detailsElem);
                 },
                 listUpdateCallback: function(issues) {
                     // Re mark the issues that were dismissed as done.
                     self._remarkDismissedIssues(issues);
                 },
                 runCallback: function(issues) {
                     self.viper.removeCallback(null, 'ViperAccessibilityPlugin:resolution');
                     self._updateStandard();
                     return self._moveDismissedIssuesToEnd(issues);
                 },
                 showIssueCallback: function(issueid) {
                     self.viper.fireCallbacks('ViperAccessibilityPlugin:showResolution:' + issueid);
                 },
                 ignoreMsgCodes: [
                     /Guideline1_4\.1_4_3/,
                     /Guideline1_4\.1_4_6/
                 ]
             });

         },

         loadHTMLCS: function(callback)
         {
             if (window.HTMLCS) {
                 callback.call(this);
             } else {
                 this.includeScript(this._htmlCSsrc + '/HTMLCS.js', callback);
             }

         },

         _createIssueDetail: function(id, issue, resolutionElem, detailsElem)
         {
             var issueDoneElem = document.createElement('div');
             ViperUtil.addClass(issueDoneElem, 'Viper-issueDoneCont');
             detailsElem.appendChild(issueDoneElem);

             var main = resolutionElem;
             ViperUtil.addClass(main, 'ViperAP-issuePane');

             var issueType = this._getIssueType(issue);

             var self = this;
             this._loadStandard(issue.code, function(standardObj) {
                 var resolutionCont = document.createElement('div');
                 ViperUtil.addClass(resolutionCont, 'ViperAP-issueResolution');

                 var resHtml = '<div class="Viper-resolutionHeader"><strong>Resolution</strong></div>';

                 ViperUtil.setHtml(resolutionCont, resHtml);
                 main.appendChild(resolutionCont);

                 var resolutionHeader = ViperUtil.getClass('Viper-resolutionHeader', resolutionCont)[0];

                 // Create resolution tools.
                 var tools = self.viper.Tools;
                 var locateBtn     = tools.createButton('VAP:locateElem', '', _('Locate Element'), 'Viper-locate', function() {
                     HTMLCSAuditor.pointToElement(issue.element);
                 });
                 resolutionHeader.appendChild(locateBtn);
                 var sourceViewBtn = tools.createButton('VAP:showInSource', '', _('Show in Source View'), 'Viper-sourceView', function() {
                     var tmpText = document.createTextNode('__STH__');
                     ViperUtil.insertAfter(issue.element, tmpText);
                     var sourceViewPlugin = self.viper.getPluginManager().getPlugin('ViperSourceViewPlugin');
                     var contents = sourceViewPlugin.getContents();
                     ViperUtil.remove(tmpText);
                     sourceViewPlugin.showSourceView(contents, function() {
                         if (ViperUtil.isBrowser('msie') === true) {
                             sourceViewPlugin.scrollToText('__STH__');
                             sourceViewPlugin.replaceSelection('');
                             sourceViewPlugin.updateOriginalSourceValue();
                         } else {
                             sourceViewPlugin.scrollToText('__STH__');
                             setTimeout(function() {
                                 sourceViewPlugin.replaceSelection('');
                                 sourceViewPlugin.updateOriginalSourceValue();
                             }, 500);
                         }
                     });
                 });
                 resolutionHeader.appendChild(sourceViewBtn);

                 var refreshIssueBtn = tools.createButton('VAP:toggleIssueDone', '', _('Refresh Issue'), 'Viper-accessRerun', function() {
                     self.refreshIssue(id, issue, detailsElem, detailsElem);
                 });
                 resolutionHeader.appendChild(refreshIssueBtn);

                 var defaultContent = standardObj.getDefaultContent(id, issue, null, self);
                 resolutionCont.appendChild(defaultContent);
                 standardObj.getResolutionContent(issue, defaultContent, self, id);
             });

         },

         runChecks: function(callback)
         {
             var self       = this;
             var _runChecks = function() {
                 HTMLCS.process(self._standard, self.viper.getViperElement(), callback);
             };

             if (!window.HTMLCS) {
                 var script    = document.createElement('script');
                 script.onload = function() {
                     _runChecks();
                 };

                 script.src = this._htmlCSsrc;

                 if (document.head) {
                     document.head.appendChild(script);
                 } else {
                     document.getElementsByTagName('head')[0].appendChild(script);
                 }

                 return;
             }

             _runChecks();

         },

         _createToolbarItems: function()
         {
             var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
             if (!toolbar) {
                 return;
             }

             this._toolbar = toolbar;
             var self      = this;
             var tools     = this.viper.Tools;

             this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperAccessibilityPlugin', function(data) {
                 self.viper.Tools.enableButton('accessibility');
             });

             // Create the Toolbar Bubble for the plugin interface. The bubble's main content
             // is the tools section.
             var aaTools = toolbar.createBubble('VAP:bubble', _('Accessibility Auditor') + ' - ' + this._standard, null, null, function() {
                 self.getIssues();
             }, function() {
             }, 'ViperAccessibilityPlugin');
             aaTools.id = this.viper.getId() + '-VAP';

             // Create the sub section.
             var bubble       = toolbar.getBubble('VAP:bubble');
             var subSection   = bubble.addSubSection('VAP:subSection', this._htmlcsWrapper);
             bubble.setSetting('keepOpen', true);
             toolbar.getBubble('VAP:bubble').showSubSection('VAP:subSection');

             // The main toolbar button to toggle the toolbar bubble on and off.
             var vapButton = tools.createButton('accessibility', '', _('Accessibility Auditor'), 'Viper-accessAudit', null, true);
             toolbar.setBubbleButton('VAP:bubble', 'accessibility');
             toolbar.addButton(vapButton);

         },

         refreshIssue: function(issueNum, issue, issueElem, issueDetails)
         {
             ViperUtil.addClass(issueElem, 'Viper-rechecking');

             // Add the re-checking issue overlay.
             var issueRecheck = document.createElement('div');
             ViperUtil.addClass(issueRecheck, 'ViperAP-issueRecheck');
             issueDetails.appendChild(issueRecheck);

             ViperUtil.setHtml(issueRecheck, '<div class="Viper-issueChecking">' + _('Re-checking issue') + ' …</div>');

             var self     = this;
             this.runChecks(function() {
                 var msgs  = HTMLCS.getMessages();
                 var found = false;
                 for (var i in msgs) {
                     if (msgs[i].code === issue.code && msgs[i].element === issue.element) {
                         found = true;
                         break;
                     }
                 }

                 if (found === false) {
                     ViperUtil.setHtml(issueRecheck, '');
                     ViperUtil.removeClass(issueElem, 'Viper-rechecking');

                     // Mark issue as done.
                     self.fixIssue(issueNum, true);
                 } else {
                     ViperUtil.empty(issueRecheck);
                     var issueRemains = document.createElement('div');
                     ViperUtil.addClass(issueRemains, 'Viper-issueRemains');
                     ViperUtil.setHtml(issueRemains, '<span class="Viper-recheckMessage">' + _('This issue has not been resolved') + '</span>');
                     issueRemains.appendChild(self.viper.Tools.createButton('VAP-issues:notResolvedBtn', _('OK'), '', '', function() {
                         ViperUtil.setHtml(issueRecheck, '');
                         ViperUtil.removeClass(issueElem, 'Viper-rechecking');
                     }));
                     issueRecheck.appendChild(issueRemains);
                 }
             });

         },

         dismissIssue: function(issueid)
         {
             this._markAsDone(issueid);

             var issue = HTMLCSAuditor.getIssue(issueid);
             if (!this._dismissedIssues[issue.code]) {
                 this._dismissedIssues[issue.code] = [];
             }

             this._dismissedIssues[issue.code].push(issue.element);

             var self = this;
             setTimeout(function() {
                 self.nextIssue();
             }, 800);

         },

         fixIssue: function(issueNum, goNext)
         {
             if (!issueNum && issueNum !== 00) {
                 issueNum = this.getCurrentIssueNumber();
             }

             this._markAsDone(issueNum);

             if (goNext === true) {
                 var self = this;
                 setTimeout(function() {
                     self.nextIssue();
                 }, 800);
             }

         },

         _updateStandard: function()
         {
             // Updates the standard info from HTMLCSAuditor.
             this._standard = HTMLCSAuditor.getCurrentStandard();

             this.viper.Tools.getItem('VAP:bubble').setTitle(_('Accessibility Auditor') + ' - ' + this._standard);
         },

         _markAsDone: function(issueNum)
         {
             var issueElement = this.getIssueElement(issueNum, 'details');
             ViperUtil.addClass(issueElement, 'Viper-issueDone');

             var listItem = this.getIssueElement(issueNum, 'listItem');
             ViperUtil.addClass(listItem, 'Viper-issueDone');

         },

         _moveDismissedIssuesToEnd: function(issues)
         {
             if (ViperUtil.isEmpty(this._dismissedIssues) === true) {
                 return issues;
             }

             // Copy issues..
             var toMoveIndexes = [];
             var toMoveElements = []
             var c = issues.length;
             for (var i = 0; i < c; i++) {
                 var issue = issues[i];
                 if (!this._dismissedIssues[issue.code]) {
                     continue;
                 }

                 if (ViperUtil.inArray(issue.element, this._dismissedIssues[issue.code]) === true) {
                     toMoveIndexes.push(i);
                     toMoveElements.push(issue);
                 }
             }

             toMoveIndexes  = toMoveIndexes.reverse();
             toMoveElements = toMoveElements.reverse();

             for (var i = 0; i < toMoveIndexes.length; i++) {
                 issues.splice(toMoveIndexes[i], 1);
                 issues.push(toMoveElements[i]);
             }

             return issues;

         },

         _remarkDismissedIssues: function(issues)
         {
             if (ViperUtil.isEmpty(this._dismissedIssues) === true) {
                 return;
             }

             var c = issues.length;
             for (var i = 0; i < c; i++) {
                 var issue = issues[i];
                 if (!this._dismissedIssues[issue.code]) {
                     continue;
                 }

                 if (ViperUtil.inArray(issue.element, this._dismissedIssues[issue.code]) === true) {
                     this._markAsDone(i);
                 }
             }

         },

         nextIssue: function()
         {
             ViperUtil.trigger(ViperUtil.getid('HTMLCS-button-next-issue'), 'click');

         },

         getIssueElement: function(issueNum, section)
         {
             if (section === 'listItem') {
                 return ViperUtil.getid('HTMLCS-msg-' + issueNum);
             }

             var issueElement = ViperUtil.getid('HTMLCS-msg-detail-' + issueNum);
             if (section === 'details') {
                 issueElement = ViperUtil.getClass('HTMLCS-issue-details', issueElement)[0];
             }

             return issueElement;

         },

         getCurrentIssueNumber: function()
         {
             var currentIssueElem = ViperUtil.getClass('HTMLCS-current', this._htmlcsWrapper)[0];
             var id = Number(currentIssueElem.id.split('-').pop());
             return id;

         },

         _loadStandard: function(issueCode, callback)
         {
             // Load the standard's file.
             var url = this.viper.getViperPath();
             url    += '/Plugins/ViperAccessibilityPlugin/Resolutions/';

             // First part of the issueCode must the standard name.
             var parts    = issueCode.split('.');
             var standard = parts[0];
             if (standard.indexOf('WCAG2') === 0) {
                 standard = 'WCAG2';
             }

             var standardScriptUrl = url + standard + '/' + standard + '.js';

             this.loadObject(standardScriptUrl, 'ViperAccessibilityPlugin_' + standard, callback);

         },

         _getIssueType: function(issue)
         {
             var issueType = '';
             switch (issue.type) {
                 case HTMLCS.ERROR:
                     issueType = 'error';
                 break;

                 case HTMLCS.WARNING:
                     issueType = 'warning';
                 break;

                 case HTMLCS.NOTICE:
                     issueType = 'manual';
                 break;

                 default:
                     issueType = '';
                 break;
             }

             return issueType;

         },

         loadObject: function(src, objName, callback)
         {
             if (window[objName] || ViperUtil.inArray(src, this._loadedScripts) === true) {
                 callback.call(this, window[objName]);
                 return;
             }

             // Load the script file only once. Any multiple requests to load the same
             // script file will be added to the loadCallbacks, once the file is available
             // all the callbacks will be executed.
             if (!this._loadCallbacks[src]) {
                 this._loadCallbacks[src] = [callback];

                 var self = this;
                 this.includeScript(src, function() {
                     for (var i = 0; i < self._loadCallbacks[src].length; i++) {
                         self._loadCallbacks[src][i].call(self, window[objName]);
                     }

                     delete self._loadCallbacks[src];
                 });

             } else {
                 this._loadCallbacks[src].push(callback);
             }//end if

         },

         
         includeScript: function(src, callback) {
             var script    = document.createElement('script');
             script.onload = function() {
                 script.onload = null;
                 script.onreadystatechange = null;
                 callback.call(this);
             };

             if (navigator.appName == 'Microsoft Internet Explorer') {
                 var rv = -1;
                 var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                 if (re.exec(navigator.userAgent) != null) {
                     rv = parseFloat(RegExp.$1);
                 }

                 if (rv <= 8.0) {
                     script.onreadystatechange = function() {
                         if (/^(complete|loaded)$/.test(this.readyState) === true) {
                             script.onreadystatechange = null;
                             script.onload();
                         }
                     }
                 }
             }//end if

             script.src = src;

             if (document.head) {
                 document.head.appendChild(script);
             } else {
                 document.getElementsByTagName('head')[0].appendChild(script);
             }
         },

         
         includeCss: function(href) {
             if (ViperUtil.inArray(href, this._includedCSS) === true) {
                 return;
             }

             this._includedCSS.push(href);

             var link    = document.createElement('link');
             link.rel    = 'stylesheet';
             link.media  = 'screen';
             link.onload = function() {
                 link.onload = null;
                 link.onreadystatechange = null;
             };

             link.onreadystatechange = function() {
                 if (/^(complete|loaded)$/.test(this.readyState) === true) {
                     link.onreadystatechange = null;
                     link.onload();
                 }
             }

             link.href = href;

             if (document.head) {
                 document.head.appendChild(link);
             } else {
                 document.getElementsByTagName('head')[0].appendChild(link);
             }
         },

         remove: function()
         {
             // Remove plugin buttons.
             this.viper.Tools.removeItem('accessibility');

         }

     };

 })(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {

    function ViperCharMapPlugin(viper)
    {
        this.viper = viper;

    }

    Viper.PluginManager.addPlugin('ViperCharMapPlugin', ViperCharMapPlugin);

    ViperCharMapPlugin.prototype = {

        init: function()
        {
            this._initToolbar();

        },

        _initToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperCharMapPlugin', function(data) {
                if (data.range) {
                    var nodeSelection = data.range.getNodeSelection();
                    if (nodeSelection && ViperUtil.isStubElement(nodeSelection) === true) {
                        self.viper.Tools.disableButton('insertCharacter');
                        return;
                    }
                }

                self.viper.Tools.enableButton('insertCharacter');
            });

            this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperCharMapPlugin', function(data) {
                self.viper.Tools.enableButton('insertCharacter');
            });

            var self = this;

            var subContent = document.createElement('div');

            var categories = this.getCharacters('currency');
            var count      = categories.length;

            var catTable = '';
            var list     = '<ul class="VCMP-list">';

            for (var i = 0; i < count; i++) {
                var category = categories[i];

                list += '<li>' + category.name + '</li>';

                var tableClass = 'VCMP-table';
                if (i === 0) {
                    tableClass += ' Viper-visible';
                }

                catTable     += '<table class="' + tableClass + '" border="0" cellspacing="0" cellpadding="0"><tbody>';
                var charCount = category.chars.length;
                for (var j = 0; j < charCount; j++) {
                    if ((j % 7) === 0) {
                        if (j !== 0) {
                            catTable += '</tr>';
                        }

                        catTable += '<tr>';
                    }

                    catTable += '<td data_viper_char="' + category.chars[j].replace('&', '') + '">' + category.chars[j] + '</td>';
                }

                catTable += '</tbody></table>';
            }//end for

            list += '</ul>';

            var wrapper = '<div class="VCMP-wrapper">' + list + '<div class="VCMP-tablesWrapper">' + catTable + '</div></div>';

            ViperUtil.setHtml(subContent, wrapper);

            var tools = this.viper.Tools;

            var map = toolbar.createBubble('ViperCMP:bubble', _('Insert Character'), subContent, null, null, null, 'VCMP-main');

            var toggle = tools.createButton('insertCharacter', '', _('Insert Character'), 'Viper-charMap', null, true);
            toolbar.setBubbleButton('ViperCMP:bubble', 'insertCharacter');
            toolbar.addButton(toggle);

            // Table cell click event.
            var listItems = ViperUtil.getTag('li', subContent);
            var tables    = ViperUtil.getTag('table', subContent);

            // Select the initial item.
            ViperUtil.addClass(listItems[0], 'Viper-selected');

            ViperUtil.addEvent(listItems, 'click', function(e) {
                var target = ViperUtil.getMouseEventTarget(e);
                if (ViperUtil.isTag(target, 'li') === false) {
                    target = target.parentNode;
                }

                ViperUtil.removeClass(listItems, 'Viper-selected');
                ViperUtil.addClass(target, 'Viper-selected');

                var index = 0;
                while (target.previousSibling) {
                    if (ViperUtil.isTag(target.previousSibling, 'li') === true) {
                        index++;
                    }

                    target = target.previousSibling;
                }

                // Show the table at this index.
                ViperUtil.removeClass(tables, 'Viper-visible');
                ViperUtil.addClass(tables[index], 'Viper-visible');
            });

            var btn = document.createElement('div');
            ViperUtil.addClass(btn, 'VCMP-hoverBtn Viper-button');
            subContent.appendChild(btn);

            ViperUtil.addEvent(btn, 'click', function() {
                 var charCode = btn.firstChild.data.charCodeAt(0);
                 self.insertCharacter(charCode);
            });

            ViperUtil.hover(ViperUtil.getTag('td', subContent), function(e) {
                ViperUtil.setHtml(btn, ViperUtil.getHtml(e.target));
                var mapCoords    = ViperUtil.getElementCoords(map);
                var coords       = ViperUtil.getElementCoords(e.target);

                ViperUtil.setStyle(btn, 'left', (coords.x - mapCoords.x) + 'px');
                ViperUtil.setStyle(btn, 'top', (coords.y - mapCoords.y) + 'px');
                ViperUtil.setStyle(btn, 'display', 'block');
            }, function(e) {});

            ViperUtil.hover(btn, function() {}, function() {
                ViperUtil.setStyle(btn, 'display', 'none');
            });

        },

        insertCharacter: function(charCode)
        {
            var range = this.viper.getViperRange();
            if (range.collapsed !== true) {
                range = this.viper.deleteRangeContent();
            }

            var newNode = document.createTextNode(String.fromCharCode(charCode));

            range.insertNode(newNode);
            range.setStart(newNode, 1);

            if (ViperUtil.isBrowser('msie', '<11') === true) {
                range.moveStart('character', 1);
            }

            range.collapse(true);
            ViperSelection.addRange(range);

            this.viper.contentChanged();

        },

        getCharacters: function()
        {
            var categories = [];

            var _getRange = function(start, stop) {
                var str = '';
                for (var i = start; i <= stop; i++) {
                    str += '|' + i;
                }

                return str;
            };

            var chars    = '$|&cent;|&pound;|&curren;|&yen';
            var htmlEnt  = '|1547|2546|2547|2801|3065|3647|6107';
            htmlEnt     += _getRange(8352, 8375);
            htmlEnt     += '|65020|65129|65284|65504|65505|65509|65510';
            chars       += htmlEnt.replace(/\|/g, ';|&#') + ';';
            chars        = chars.split('|');
            var currency = chars;

            chars     = '&Agrave;|&agrave;|&Aacute;|&aacute;|&Acirc;|&acirc;|&Atilde;|&atilde;|&Auml;|&auml;|&Aring;|&aring;|&#256;|&#257;|&AElig;|&aelig;|&Ccedil;|&ccedil;|&ETH;|&eth;|&Egrave;|&egrave;|&Eacute;|&eacute;|&Ecirc;|&ecirc;|&Euml;|&euml;|&#274;|&#275;|&Igrave;|&igrave;|&Iacute;|&iacute;';
            chars    += '|&Icirc;|&icirc;|&Iuml;|&iuml;|&#298;|&#299;|&micro;|&Ntilde;|&ntilde;|&Ograve;|&ograve;|&Oacute;|&oacute;|&Ocirc;|&ocirc;|&Otilde;|&otilde;|&Ouml;|&ouml;|&#332;|&#333;|&Oslash;|&oslash;|&OElig;|&oelig;|&Scaron;|&scaron;|&szlig;|&THORN;|&thorn;|&Ugrave;|&ugrave;|&Uacute;|&uacute;|&Ucirc;|&ucirc;|&Uuml;|&uuml;|&#362;|&#363;|&Yacute;|&yacute;|&yuml;|&Yuml;';
            chars     = chars.split('|');
            var latin = chars;

            chars     = '&sup1;|&sup2;|&sup3;|&times;|&divide;|&frac14;|&frac12;|&frac34;|&ordf;|&ordm;|&not;|&deg;|&plusmn;|&Delta;|&fnof;|&Omega;|&circ;|&tilde;|&ndash;|&mdash;|&dagger;|&Dagger;|&bull;|&hellip;|&radic;|&infin;|&int;|&part;|&ne;|&le;|&ge;|&sum;|&permil;|&prod;|&pi;|&loz;';
            chars     = chars.split('|');
            var maths = chars;

            chars       = '&uml;|&macr;|&acute;|&cedil;|&iexcl;|&iquest;|&middot;|&brvbar;|&laquo;|&raquo;|&para;|&sect;|&copy;|&reg;|&trade;';
            chars       = chars.split('|');
            var symbols = chars;

            categories.push({
                name: _('Symbols'),
                chars: symbols
            });

            categories.push({
                name: _('Latin'),
                chars: latin
            });

            categories.push({
                name: _('Mathematics'),
                chars: maths
            });

            categories.push({
                name: _('Currency'),
                chars: currency
            });

            return categories;

        }

    };

})(Viper.Util, Viper.Selection, Viper._);



(function(ViperUtil, ViperSelection, _) {
    function ViperCopyPastePlugin(viper)
    {
        this.viper = viper;

        this.pasteElement    = null;
        this.pasteValue      = null;
        this.rangeObj        = null;
        this.pasteType       = 'formatted';
        this.cutType         = 'formatted';
        this.allowedTags     = 'table|tr|td|th|ul|li|ol|br|p|a|img|form|input|select|option';
        this.convertTags     = null;
        this._tmpNode        = null;
        this._tmpNodeOffset  = 0;
        this._iframe         = null;
        this._isMSIE         = ViperUtil.isBrowser('msie') || ViperUtil.isBrowser('edge');
        this._toolbarElement = null;
        this._selectedRows   = null;
        this._pasteProcess   = 0;
        this._isRightClick   = false;
        this._aggressiveMode = true;

    }

    Viper.PluginManager.addPlugin('ViperCopyPastePlugin', ViperCopyPastePlugin);

    ViperCopyPastePlugin.prototype = {
        init: function()
        {
            var self = this;
            this.viper.registerCallback('Viper:editableElementChanged', 'ViperCopyPastePlugin', function() {
                self._init();
            });

            this.viper.registerCallback(['Viper:dropped:text/html', 'Viper:dropped:Text'], 'ViperCopyPastePlugin', function(data) {
                if (!data.data) {
                    return;
                }

                // Bookmark the current selection so that it can be deleted.
                var bookmark = null;
                if (data.origRange.collapsed === false) {
                    bookmark = self.viper.createBookmark(data.origRange);
                }

                ViperSelection.addRange(data.range);
                var div = document.createElement('div');
                ViperUtil.setHtml(div, data.data);

                if (bookmark) {
                    self.viper.removeBookmark(bookmark);
                }

                self._beforePaste(data.range);

                if (self._bookmark) {
                    self._insertTmpNodeBeforeBookmark(self._bookmark);
                }

                self._handleFormattedPasteValue(false, div);

                return false;
            });

            this.viper.registerCallback(['Viper:rightMouseDown', 'Viper:mouseDown'], 'ViperCopyPastePlugin', function(data) {
                if (data.which === 3) {
                    self._isRightClick = true;
                } else {
                    self._isRightClick = false;
                }

                self._pasteProcess = 0;
            });

        },

        setSettings: function(settings)
        {
            if (ViperUtil.isset(settings.pasteType) === true) {
                this.pasteType = settings.pasteType;
            }

            if (ViperUtil.isset(settings.cutType) === true) {
                this.cutType = settings.cutType;
            }

            if (ViperUtil.isset(settings.allowedTags) === true) {
                this.allowedTags = settings.allowedTags;
            }

            if (ViperUtil.isset(settings.convertTags) === true) {
                this.convertTags = settings.convertTags;
            }

            if (ViperUtil.isset(settings.aggressiveMode) === true) {
                this._aggressiveMode = settings.aggressiveMode;
            }

        },

        _init: function()
        {
            var elem = this.viper.getViperElement();

            if (!elem) {
                return;
            }

            var self = this;
            if (this._isMSIE !== true) {
                elem.onpaste = function(e) {
                    if (!e.clipboardData) {
                        return;
                    }

                    var dataType = null;
                    if (e.clipboardData.types) {
                        if (ViperUtil.inArray('text/html', e.clipboardData.types) === true
                            && e.clipboardData.getData('text/html').length !== 0
                        ) {
                            dataType = 'text/html';
                        } else if (ViperUtil.inArray('text/plain', e.clipboardData.types) === true
                            && e.clipboardData.getData('text/plain').length !== 0
                        ) {
                            dataType = 'text/plain';
                        }
                    }

                    self._beforePaste();
                    if (self.pasteType === 'formatted' || self.pasteType === 'formattedClean') {
                        if (dataType === null) {
                            dataType = 'text/html';
                        }

                        var files = ViperUtil.arraySearch('Files', e.clipboardData.types);

                        self.pasteElement = self._createPasteDiv();
                        var pasteContent  = e.clipboardData.getData(dataType);
                        if (dataType === 'text/plain') {
                            pasteContent = pasteContent.replace(/\r\n/g, '<br />');
                            pasteContent = pasteContent.replace(/\n/g, '<br />');
                        } else if (files === 0) {
                            var file = e.clipboardData.items[files];
                            var blob  = file.getAsFile();
                            self.readPastedImage(blob, function() {
                                var base64   = event.target.result;
                                pasteContent = '<img src="' + base64 + '"/>';
                                ViperUtil.setHtml(self.pasteElement, pasteContent);
                                self._handleFormattedPasteValue((self.pasteType === 'formattedClean'));
                            });

                            ViperUtil.preventDefault(e);
                            return false;
                        }

                        ViperUtil.setHtml(self.pasteElement, pasteContent);
                        self._handleFormattedPasteValue((self.pasteType === 'formattedClean'));
                    } else {
                        if (dataType === null) {
                            dataType = 'text';
                        } else {
                            dataType = 'text/plain';
                        }

                        self._handleRawPasteValue(e.clipboardData.getData(dataType));
                    }

                    ViperUtil.preventDefault(e);
                    return false;
                };

            } else {
                self._pasteProcess = 0;

                if (ViperUtil.isBrowser('msie', '<11') === true) {
                    var cutPasteDiv    = null;
                    elem.onbeforepaste = function() {
                        if (self._pasteProcess === 0) {
                            // This is the 2nd time the onbeforepaste is called when the right click menu is opened.
                            // Get the contents of the current selection and add Viper element so that it can be cleaned up in paste.
                            var range           = self.viper.getCurrentRange();
                            var selectedContent = '';
                            if (range.collapsed !== true) {
                                var selectedNode    = range.getNodeSelection();
                                var viperElem       = self.viper.getViperElement();
                                if (selectedNode && selectedNode !== viperElem) {
                                    var surroundingParents = ViperUtil.getSurroundingParents(selectedNode, null, false, viperElem);
                                    if (surroundingParents.length > 0) {
                                        selectedNode = surroundingParents.pop();
                                    }

                                    var tmp = document.createElement('div');
                                    tmp.appendChild(selectedNode.cloneNode(true));
                                    selectedContent = ViperUtil.getHtml(tmp);
                                } else {
                                    selectedContent = range.getHTMLContents()
                                }

                                selectedContent = self._fixPartialSelection(selectedContent, range);
                            }

                            // Save the position where the paste needs to happen.
                            self._beforePaste();

                            // Remove the existing paste div.
                            cutPasteDiv = ViperUtil.getid('ViperPasteDivNew');
                            ViperUtil.remove(cutPasteDiv);

                            // Create the new tmp div with the currently selected content.  This content is used by cut and
                            // copy operations.
                            cutPasteDiv = document.createElement('div');
                            cutPasteDiv.innerHTML = selectedContent;
                            cutPasteDiv.id = 'ViperPasteDivNew';
                            elem.appendChild(cutPasteDiv);

                            if (selectedContent !== '') {
                                // Select all the contents of the temp element.
                                var firstChild = range._getFirstSelectableChild(cutPasteDiv);
                                var lastChild = range._getLastSelectableChild(cutPasteDiv);
                                if (cutPasteDiv.lastChild.nodeType === ViperUtil.ELEMENT_NODE) {
                                    // Last child could be an image etc.
                                    cutPasteDiv.appendChild(document.createTextNode(''));
                                    range.setEnd(cutPasteDiv.lastChild, 0);
                                } else if (ViperUtil.isBrowser('msie', '<11') === true) {
                                    range.setEnd(lastChild, lastChild.data.length);
                                } else {
                                    range.setEnd(lastChild, lastChild.data.length);
                                }

                                if (!firstChild && cutPasteDiv.firstChild.nodeType === ViperUtil.ELEMENT_NODE) {
                                    // Last child could be an image etc.
                                    ViperUtil.insertBefore(cutPasteDiv.firstChild, document.createTextNode(''));
                                    firstChild = cutPasteDiv.firstChild;
                                    range.setStart(firstChild, 0);
                                }

                                range.setStart(firstChild, 0);
                                ViperSelection.addRange(range);
                            }

                            // Give the focus to cut/paste temp div so that its contents are properly selected. When the user
                            // clicks the cut/copy/paste action in the right click menu, browser will use the cutPasteDiv
                            // as the source element.
                            cutPasteDiv.focus();

                            cutPasteDiv.onpaste = function() {
                                // Insert the tmpNode where the content is inserted before the bookmark that was created.
                                var bookmark = self._bookmark;
                                if (!bookmark.start.previousSibling) {
                                    if (bookmark.start.parentNode !== self.viper.getViperElement()) {
                                        ViperUtil.insertBefore(bookmark.start.parentNode, self._tmpNode);
                                    } else {
                                        ViperUtil.insertBefore(bookmark.start, self._tmpNode);
                                    }
                                } else {
                                    ViperUtil.insertBefore(bookmark.start, self._tmpNode);
                                }

                                // Since this is a paste remove the selected contents.
                                self.viper.removeBookmark(bookmark, true);

                                setTimeout(function() {
                                    // Remove the temp div.
                                    ViperUtil.remove(cutPasteDiv);

                                    range.setStart(self._tmpNode, 0);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);

                                    // Use the cutPasteDiv to get the pasted content and inserted where the tmpNode is located.
                                    self._handleFormattedPasteValue(null, cutPasteDiv);
                                }, 100);
                            };

                            if (selectedContent !== '') {
                                // Only add oncut and onpaste if there is something selected, if range is collapsed then
                                // there is no point of adding these events.
                                cutPasteDiv.oncut = function(e) {
                                    var bookmark = self._bookmark;
                                    if (!bookmark.start.previousSibling) {
                                        if (bookmark.start.parentNode !== self.viper.getViperElement()) {
                                            ViperUtil.insertBefore(bookmark.start.parentNode, self._tmpNode);
                                        } else {
                                            ViperUtil.insertBefore(bookmark.start, self._tmpNode);
                                        }
                                    } else {
                                        ViperUtil.insertBefore(bookmark.start, self._tmpNode);
                                    }

                                    self.viper.removeBookmark(self._bookmark);

                                    setTimeout(function() {
                                        ViperUtil.remove(cutPasteDiv);

                                        range.setStart(self._tmpNode, 0);
                                        range.collapse(true);
                                        ViperSelection.addRange(range);

                                        self.viper.fireCallbacks('Viper:cut');
                                        self.viper.contentChanged(false, range);
                                    }, 5);
                                }

                                cutPasteDiv.oncopy = function(e) {
                                    ViperUtil.remove(cutPasteDiv);
                                    self.viper.selectBookmark(self._bookmark);

                                    self.viper.fireCallbacks('Viper:copy');
                                    self.viper.contentChanged();
                                }
                            }//end if
                        }//end if

                        self._pasteProcess++;
                    }//end if
                } else {
                    var pasteDiv       = null;
                    elem.onbeforepaste = function (e) {
                        var range = self.viper.getViperRange();
                        var isImg = ViperUtil.isTag(range.getNodeSelection(), 'img');
                        if (self._pasteProcess === 0) {
                            // Initial call to onbeforepaste, happens when right click menu opens.
                            // Create the paste div.
                            pasteDiv = self._createPasteDiv(true);
                        } else if (self._pasteProcess === 2
                            || (self._pasteProcess === 1 && isImg === false && (self._isRightClick === false || ViperUtil.isBrowser('edge') === true))
                        ) {
                            // Third call to onbeforepaste, happens when paste option is clicked.
                            self._beforePaste();

                            // Give paste div the focus.
                            pasteDiv.focus();
                            var max = 0;
                            var t   = setInterval(function () {
                                if (pasteDiv.innerHTML !== '') {
                                    pasteDiv.onpaste();
                                    self._pasteProcess = 0;
                                    clearInterval(t);
                                } else if (max > 10) {
                                    self._pasteProcess = 0;
                                    clearInterval(t);
                                }

                                max++;
                            }, 20);
                        }

                        self._pasteProcess++;
                    };
                }//end if

            }//end if

            var onCopy = function(e) {
                var yCoord = null;
                if (ViperUtil.isBrowser('msie', '<11') === true) {
                    yCoord = self.viper.getCaretCoords().y;
                }

                var range  = self.viper.getViperRange();

                // Create a clone of the current range as we are going to modify it.
                var rangeClone = range.cloneRange();

                // Get the contents of the current selection and add Viper element so that it can be cleaned up in paste.
                var selectedContent = '';
                var selectedNode    = range.getNodeSelection();
                var viperElem       = self.viper.getViperElement();
                if (selectedNode && selectedNode !== viperElem) {
                    var surroundingParents = ViperUtil.getSurroundingParents(selectedNode, null, false, viperElem);
                    if (surroundingParents.length > 0) {
                        selectedNode = surroundingParents.pop();
                    }

                    var tmp = document.createElement('div');
                    tmp.appendChild(selectedNode.cloneNode(true));
                    selectedContent = ViperUtil.getHtml(tmp);
                } else {
                    selectedContent = range.getHTMLContents()
                }

                selectedContent = self._fixPartialSelection(selectedContent, range);
                selectedContent = '<div class="__viper_copy">' + selectedContent + '</div>';

                // IE needs space before B tag otherwise it gets stripped out..
                if (ViperUtil.isBrowser('msie', '<9') === true) {
                    selectedContent = '&nbsp;' + selectedContent + '&nbsp;';
                } else if (ViperUtil.isBrowser('msie', '>=9') === true || ViperUtil.isBrowser('edge') === true) {
                    selectedContent = '&nbsp;' + selectedContent;
                }

                // Chrome adds style information for the copied selection -.- To prevent this, use clipboardData.setData
                // method to set the modified content and prevent the default copy action.
                if (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true) {
                    e.clipboardData.setData('text', range.rangeObj.toString());
                    e.clipboardData.setData('text/html', selectedContent);
                    ViperUtil.preventDefault(e);
                    return false;
                }

                // Create a temp element and set the content as the selection content.
                var tmp = document.createElement('div');
                tmp.setAttribute('contenteditable', 'true');
                ViperUtil.addClass(tmp, 'Viper-copyDiv');
                document.body.appendChild(tmp);
                ViperUtil.setHtml(tmp, selectedContent);

                // Set the coords of the tmp element to be same as the current window scroll position so that when we move
                // the focus to the tmp element the page does not 'jump'.
                if (yCoord !== null) {
                    ViperUtil.setStyle(tmp, 'top', yCoord + 'px');
                }

                if (ViperUtil.isBrowser('msie', '8') === true) {
                    tmp.focus();
                }

                // Select the contents of the temp element.
                var firstChild = range._getFirstSelectableChild(tmp);
                var lastChild = range._getLastSelectableChild(tmp);
                if (tmp.lastChild.nodeType === ViperUtil.ELEMENT_NODE) {
                    // Last child could be an image etc.
                    tmp.appendChild(document.createTextNode(''));
                    range.setEnd(tmp.lastChild, 0);
                } else if (ViperUtil.isBrowser('msie', '<9') === true) {
                    range.setEnd(lastChild, lastChild.data.length - 1);
                } else {
                    range.setEnd(lastChild, lastChild.data.length);
                }

                // WORKING ON IE8
                if (ViperUtil.isBrowser('msie', '<11') === true) {
                    range.setStart(firstChild, 1);
                } else if (firstChild === null) {
                    range.setStart(tmp.firstChild, 0);
                } else if (tmp.firstChild.nodeType === ViperUtil.ELEMENT_NODE) {
                    ViperUtil.insertBefore(firstChild, document.createTextNode(''));
                    range.setStart(tmp.firstChild, 0);
                } else {
                    range.setStart(firstChild, 0);
                }

                ViperSelection.addRange(range);

                // Browser's copy action will kick in and copy the selected contents in temp element.
                // After a time out remove the temp element and put the range back to original selection.
                setTimeout(function() {
                    ViperUtil.remove(tmp);
                    ViperSelection.addRange(rangeClone);
                }, 0);
            };

            elem.oncopy = onCopy;

            // Handle cut event for Chrome/FF/Safari.
            if (ViperUtil.isBrowser('msie', '<9') !== true) {
                elem.oncut = function(e) {
                    onCopy(e);

                    setTimeout(function() {
                        var fakeEvent = self._getFakeKeyboardEvent();

                        if (self.viper.getKeyboardHandler().handleDelete(fakeEvent) !== false || fakeEvent.prevent !== true) {
                            // Update the range object as it might have changed by handleDelete().
                            range = self.viper.getCurrentRange();
                            range.deleteContents(self.viper.getViperElement(), self.viper.getDefaultBlockTag());
                            ViperSelection.addRange(range);
                        }

                        self.viper.fireCallbacks('Viper:cut');

                        self.viper.contentChanged();
                    }, 5);
                }
           } else {
               
           }//end if

            // Handle drag/drop text in Webkit to prevent extra 'span' tags.
            if (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true) {
                ViperUtil.addEvent(elem, 'drop.' + self.viper.getEventNamespace(), function(e) {
                    // Determine the selected content.
                    var selectedContent = '';
                    var rangeClone      = self.viper.getCurrentRange().cloneRange();
                    var selectedNode    = rangeClone.getNodeSelection();
                    if (selectedNode && selectedNode !== elem) {
                        var surroundingParents = ViperUtil.getSurroundingParents(selectedNode, null, false, elem);
                        if (surroundingParents.length > 0) {
                            selectedNode = surroundingParents.pop();
                        }

                        var tmp = document.createElement('div');
                        tmp.appendChild(selectedNode.cloneNode(true));
                        selectedContent = ViperUtil.getHtml(tmp);
                    } else {
                        selectedContent = rangeClone.getHTMLContents()
                    }

                    if (!selectedContent) {
                        return;
                    }

                    // Make sure partially selected lists, tables etc dont have broken HTML.
                    selectedContent = self._fixPartialSelection(selectedContent, rangeClone);

                    // Create a bookmark if a node was not selected so that we can remove it later on.
                    var bookmark = null;
                    if (!selectedNode) {
                        bookmark = self.viper.createBookmark(rangeClone);
                    }

                    // Get the range from the mouse pointer (drop location).
                    var rangeObj  = document.caretRangeFromPoint(e.originalEvent.clientX, e.originalEvent.clientY);
                    var range     = new Viper.MozRange(rangeObj);

                    // Create the tmpNode that is used for pasting content.
                    self._tmpNode = document.createTextNode(' ');
                    range.insertNode(self._tmpNode);
                    range.setStart(self._tmpNode, 0);
                    range.collapse(true);
                    ViperSelection.addRange(range);

                    // Use the pasteContent method to simulate pasting.
                    self._pasteContent(selectedContent, false, true);

                    // Remove the original selected content. Note that we must use bookmark instead of range as the content
                    // gets updated by pasteContent method. Also this content deletion cannot be done before inserting it to
                    // new location as it moves the content and changes the drop location.
                    if (selectedNode && selectedNode !== self.viper.getViperElement()) {
                        ViperUtil.remove(selectedNode);
                    } else if (bookmark) {
                        self.viper.removeBookmark(bookmark);
                    }

                    ViperUtil.preventDefault(e);
                });
            }

        },

        readPastedImage: function(file, callback)
        {
            var reader = new FileReader();
            reader.onload = function (event) {
                var image = new Image();
                image.src = event.target.result;
                callback.call(this, image, file);
            };

            reader.readAsDataURL(file);

        },

        _getFakeKeyboardEvent: function()
        {
            var fakeEvent = {
                prevent: false,
                keyCode: 8,
                which: 8,
                preventDefault: function() {this.prevent = true;},
                stopPropagation: function() {}
            };

            return fakeEvent;
        },

        _beforeCut: function(e, rightClickCut)
        {
            // Get the coordinates of the caret. The temp div needs to be placed at same Y coords as the caret so that
            // when the focus is moved to this element there is no 'screen jump'.
            var yCoord = null;
            if (ViperUtil.isBrowser('msie', '<11') === true) {
                yCoord = this.viper.getCaretCoords().y;
            }

            var self       = this;
            var range      = self.viper.getViperRange();
            var rangeClone = range.cloneRange();

            if (ViperUtil.isBrowser('msie', '>=11') === true || ViperUtil.isBrowser('edge') === true) {
                yCoord = window.pageYOffset;
            }

            // Get the contents of the current selection and add Viper element so that it can be cleaned up in paste.
            var selectedContent = '';
            var selectedNode    = range.getNodeSelection();
            var viperElem       = self.viper.getViperElement();
            if (selectedNode && selectedNode !== viperElem) {
                var surroundingParents = ViperUtil.getSurroundingParents(selectedNode, null, false, viperElem);
                if (surroundingParents.length > 0) {
                    selectedNode = surroundingParents.pop();
                }

                var tmp = document.createElement('div');
                tmp.appendChild(selectedNode.cloneNode(true));
                selectedContent = ViperUtil.getHtml(tmp);
            } else {
                selectedContent = range.getHTMLContents()
            }

            // Need to make the temp element content editable so that cut event works.
            var tmp = document.createElement('div');
            tmp.setAttribute('contenteditable', 'true');
            ViperUtil.addClass(tmp, 'Viper-copyDiv');

            if (yCoord !== null) {
                ViperUtil.setStyle(tmp, 'top', yCoord + 'px');
            }

            tmp.oncut = function(e) {
                setTimeout(function() {
                    // Remove the temp element.
                    ViperUtil.remove(tmp);

                    // Move the range back to original selection.
                    ViperSelection.addRange(rangeClone);

                    // Use the InputHandler to remove the selected contents, if it did not prevent default
                    // use browsers deleteContents() method.
                    if (self.viper.getKeyboardHandler().handleDelete({keyCode: 8, which: 8}) !== false) {
                        rangeClone = self.viper.getViperRange();
                        rangeClone.deleteContents(self.viper.getViperElement(), self.viper.getDefaultBlockTag());
                        ViperSelection.addRange(rangeClone);
                        self.viper.contentChanged();
                    } else {
                        ViperSelection.addRange(rangeClone);
                        self.viper.contentChanged();
                    }
                }, 0);
            }

            // Add the temp element to Viper element so that we do not need to change focus.
            this.viper.element.appendChild(tmp);

            if (ViperUtil.isBrowser('msie', '8') === true) {
                tmp.focus();
            }

            ViperUtil.setHtml(tmp, selectedContent);

            // Select the contents of the temp element.
            var firstChild = range._getFirstSelectableChild(tmp);
            var lastChild = range._getLastSelectableChild(tmp);
            if (!firstChild) {
                firstChild = document.createTextNode('');
                if (tmp.firstChild.childNodes.length > 0) {
                    ViperUtil.insertBefore(tmp.firstChild.firstChild, firstChild);
                } else {
                    ViperUtil.insertBefore(tmp.firstChild);
                }
            }

            if (!lastChild) {
                lastChild = document.createTextNode('');
                if (tmp.lastChild.childNodes.length > 0) {
                    tmp.lastChild.appendChild(lastChild);
                } else {
                    tmp.appendChild(lastChild);
                }
            }

            range.setEnd(lastChild, lastChild.data.length);
            range.setStart(firstChild, 0);
            ViperSelection.addRange(range);

            // When right click menu cut is used oncut event is not fired.
            if (rightClickCut === true) {
                tmp.oncut();
            }

        },

        _fixPartialSelection: function(selectedContent, range)
        {
            if (selectedContent.toLowerCase().indexOf('<li>') === 0) {
                // Selection is inside a list.
                // Get list type from selection.
                var parents = ViperUtil.getParents(range.startContainer, 'ul,ol');
                if (parents.length > 0) {
                    var listType = ViperUtil.getTagName(parents[0]);
                    selectedContent = '<' + listType + '>' + selectedContent + '</' + listType + '>';
                }
            } else {
                // Check for partial table selection.
                var tableMatch = selectedContent.match(/^<(caption|tr|td|tbody|th|tfoot|thead)/i);
                if (tableMatch) {
                    // Add required wrapping table tags for the selected section.
                    switch (tableMatch[1]) {
                        case 'td':
                            var re      = new RegExp(/<\/?(\w+)((\s+\w+(\s*=\s*(?:".*?"|'.*?'|[^'">\s]+))?)+\s*|\s*)\/?>/gim);
                            var resCont = selectedContent;
                            var count   = 0;
                            while ((match = re.exec(selectedContent)) != null) {
                                var rep = false;
                                if (match[0].indexOf('<td') === 0) {
                                    count++;
                                    rep = true;
                                } else if (match[0].indexOf('</td>') === 0) {
                                    rep = true;
                                }

                                if (rep === true) {
                                    resCont = resCont.replace(match[0], '');
                                }
                            }

                            if (count === 1) {
                                selectedContent = resCont;
                                break;
                            }


                            selectedContent = '<tr>' + selectedContent + '</tr>';

                        default:
                            selectedContent = '<table border="1" style="width: 100%;">' + selectedContent + '</table>';
                        break;
                    }
                }
            }

            return selectedContent;

        },

        _beforePaste: function(range)
        {
            range         = range || this.viper.getCurrentRange();
            this.rangeObj = range.cloneRange();

            if (this._isTableSelection(range) === true) {
                return;
            }

            this._tmpNode = document.createTextNode('');
            this._tmpNodeOffset = 0;

            if (this._isMSIE === true) {
                this.rangeObj  = null;
                if (range.collapsed === true) {
                    this._bookmark = this.viper.createBookmark();
                    ViperUtil.insertBefore(this._bookmark.start, this._tmpNode);
                } else {
                    this.viper.highlightSelection();
                    this._bookmark = this.viper.createBookmarkFromHighlight(true);
                    ViperUtil.insertBefore(this._bookmark.start, this._tmpNode);
                }
            } else {
                try {
                    this.viper.insertNodeAtCaret(this._tmpNode, range);
                } catch (e) {
                    this.viper.initEditableElement();
                    this.viper.insertNodeAtCaret(this._tmpNode);
                }
            }

        },

        _isTableSelection: function(range)
        {
            this._selectedRows = null;
            var rows = [];
            if (ViperUtil.isBrowser('firefox') === true) {
                // Firefox has multiple range objects for each selected table cell.
                var ffRange = null;
                var i       = 0;
                while (ffRange = ViperSelection.getRangeAt(i)) {
                    i++;
                    var elem = ffRange.getStartNode();
                    if (ViperUtil.isTag(elem, 'td') === false) {
                        // Not a table selection using Firefox range object. Try the generic way.
                        rows = [];
                        continue;
                    }

                    if (ViperUtil.inArray(elem.parentNode, rows) === false) {
                        rows.push(elem.parentNode);
                    }
                }

                if (rows.length > 0) {
                    this._selectedRows = rows;
                    return true;
                }
            }

            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();
            var elements  = ViperUtil.getElementsBetween(startNode, endNode);
            for (var i = 0; i < elements.length; i++) {
                var row = null;
                if (elements[i].nodeType === ViperUtil.TEXT_NODE) {
                    continue;
                } else if (ViperUtil.isTag(elements[i], 'td') === false) {
                    if (ViperUtil.isTag(elements[i], 'tr') === false) {
                        return false;
                    } else {
                        row = elements[i];
                    }
                } else {
                    row = elements[i].parentNode;
                }

                if (ViperUtil.inArray(row, rows) === false) {
                    rows.push(row);
                }
            }

            if (rows.length > 0) {
                this._selectedRows = rows;
                return true;
            }

            return false;
        },

        _handleRawPasteValue: function(content)
        {
            if (!content) {
                content = '';
            }

            this._tmpNode.data = content;
            var range = this.viper.getCurrentRange();
            range.setStart(this._tmpNode, this._tmpNode.data.length);
            range.collapse(true);
            ViperSelection.addRange(range);

            if (this.pasteElement) {
                ViperUtil.remove(this.pasteElement);
                this.pasteElement = null;
            }

        },

        _createPasteDiv: function(noIframe)
        {
            // If the old exists then get rid of it as a bit of an IE8 hack to address
            // pasting positioning problems as well as range non object issues.
            var oldEl = ViperUtil.getid('ViperPasteDiv');
            if (oldEl) {
                ViperUtil.remove(oldEl);
            }

            if (noIframe !== true) {
                var iframe   = this._createPasteIframe();
                iframe.id    = 'ViperPasteDivIframe';
                var frameDoc = ViperUtil.getIFrameDocument(iframe);
                this._iframe = iframe;
                return frameDoc.getElementById('ViperPasteIframeDiv');
            } else {
                var div = document.createElement('div');
                div.setAttribute('id', 'ViperPasteDiv');
                div.setAttribute('contentEditable', true);
                this.viper.addElement(div);

                var self = this;
                div.onpaste = function(e) {
                    var bookmark = self._bookmark;
                    self._insertTmpNodeBeforeBookmark(bookmark);

                    self.viper.removeBookmark(bookmark, true);
                    setTimeout(function() {
                        self._handleFormattedPasteValue(null, div);
                        self.viper.focus();
                    }, 100);
                };

                return div;
            }

        },

        _insertTmpNodeBeforeBookmark: function (bookmark) {
            ViperUtil.insertBefore(bookmark.start, this._tmpNode);

        },

        _createPasteIframe: function(parent)
        {
            var iframe = document.createElement('iframe');
            iframe.src = 'about:blank';
            ViperUtil.addClass(iframe, 'ViperCopyPastePlugin-iframe');

            if (parent) {
                parent.appendChild(iframe);
            } else {
                this.viper.addElement(iframe);
            }

            var content = '<!DOCTYPE html><head>';
            content    += '</head><body style="overflow:hidden;margin:0;"><div id="ViperPasteIframeDiv" contentEditable="true" ';
            content    += 'style="-moz-box-sizing: border-box; box-sizing: border-box; width: 100%; height: 2.1em;outline:none;';
            content    += 'background: none repeat scroll 0 0 #2B2B2B;border-bottom: 1px solid #777777;border-radius: 0.4em 0.4em 0.4em 0.4em;'
            content    += 'border-top: 1px solid #000000;box-shadow: 0 0 3px #000000 inset;color: #999;';
            content    += 'display: block;padding: 4px 0.5em;position: relative;text-align: center;font-style:italic;font-family:arial;font-size:0.9em;';
            content    += 'overflow:hidden;';
            content    += '"></div></body></html>';

            var doc = ViperUtil.getIFrameDocument(iframe);
            doc.open();
            doc.write(content);
            doc.close();

            return iframe;

        },

        _handleFormattedPasteValue: function(stripTags, origPasteElement)
        {
            this._pasteProcess = 0;

            origPasteElement = origPasteElement || this.pasteElement;
            var pasteElement = origPasteElement.cloneNode(true);

            // Check if the content was copied from Viper element.
            var isViperContent = false;
            var viperCopyElems = ViperUtil.getClass('__viper_copy', pasteElement);

            if (viperCopyElems.length === 1) {
                isViperContent = true;
                ViperUtil.setHtml(pasteElement, ViperUtil.getHtml(viperCopyElems[0]));
            }

            this.viper.removeNotAllowedAttributes(pasteElement);

            var html = ViperUtil.getHtml(pasteElement);
            if (isViperContent === true) {
                html = html.replace(/&nbsp;$/, '');
            }

            // Generic cleanup.
            html        = this._cleanPaste(html);
            var preHtml = html;

            if (isViperContent === true) {
                // Content copied from Viper.
                html = this._cleanViperPaste(html);
            } else if (this._isGoogleDocs(pasteElement) === true) {
                // Google Docs.
                html = this._cleanGoogleDocsPaste(html);
            } else {
                // Word etc..
                html    = this._cleanWordPaste(html);
                html    = this._removeAttributes(html);
                preHtml = html;
                html    = this._updateElements(html);
            }

            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, html);
            this.viper.cleanDOM(tmp);
            html = ViperUtil.getHtml(tmp);

            var self = this;
            this.viper.fireCallbacks('ViperCopyPastePlugin:cleanPaste', {html: html, stripTags: stripTags}, function(obj, newHTML) {
                if (newHTML) {
                    html = newHTML;
                }

                self._pasteContent(html, stripTags, isViperContent, preHtml);
            });

        },

        _pasteContent: function(html, stripTags, isViperContent, preHtml)
        {
            if (this._iframe) {
                ViperUtil.remove(this._iframe);
                this._iframe = null;
            }

            if (stripTags === true) {
                html = ViperUtil.stripTags(html, this.allowedTags.split('|'));
            }

            if (html) {
                html = ViperUtil.trim(html);

                if (isViperContent !== true) {
                    html = this.viper.cleanHTML(html, ['dir', 'class', 'lang', 'align']);
                }
            }

            if (!html) {
                this._updateSelection();
                return;
            }

            var fragment = null;
            var range    = this.rangeObj || this.viper.getCurrentRange();
            if (ViperUtil.isBrowser('chrome') === true
                && range.startContainer === range.endContainer
                && ViperUtil.isTag(range.startContainer, 'br') === true
            ) {
                // Workaround for Chrome not being able to create fragment "in br".
                var tmpTextNode = document.createTextNode('');
                var rangeClone  = range.cloneRange();
                rangeClone.setStart(tmpTextNode);
                rangeClone.collapse(true);
                fragment = rangeClone.createDocumentFragment(html);
            } else {
                fragment = range.createDocumentFragment(html);
            }

            var convertTags = this.convertTags;
            if (stripTags === true && this.convertTags !== null) {
                ViperUtil.foreach(convertTags, function(tag) {
                    var elems = ViperUtil.getTag(tag, fragment.firstChild);
                    var ln    = elems.length;
                    for (var i = 0; i < ln; i++) {
                        var cElem = document.createElement(convertTags[tag]);
                        while (elems[i].firstChild) {
                            cElem.appendChild(elems[i].firstChild);
                        }

                        ViperUtil.insertBefore(elems[i], cElem);
                        ViperUtil.remove(elems[i]);
                    }
                });
            }

            if (this._selectedRows !== null) {
                // Table selection paste..
                var pastedRows = [];
                if (fragment.firstChild && ViperUtil.isTag(fragment.firstChild, 'table') === true
                    && fragment.firstChild === fragment.lastChild
                ) {
                    // Chrome.
                    pastedRows = ViperUtil.getTag('tr', fragment.firstChild);
                } else if (fragment.firstElementChild && ViperUtil.isTag(fragment.firstElementChild, 'td') === true) {
                    // Firefox only has the TD elements need to split them in to rows.
                    var cellCount = ViperUtil.getTag('td', this._selectedRows[0]).length;
                    var tr = null;
                    var i  = 0;
                    var node = null;
                    while (node = fragment.firstElementChild) {
                        if (i % cellCount === 0) {
                            tr = document.createElement('tr');
                            pastedRows.push(tr);
                        }
                        tr.appendChild(node);
                        i++;
                    }
                }

                if (pastedRows.length > 0) {
                    // Replace selected rows with pasted rows.
                    for (var i = 0; i < pastedRows.length; i++) {
                        ViperUtil.insertBefore(this._selectedRows[0], pastedRows[i]);
                    }

                    ViperUtil.remove(this._selectedRows);
                    this._updateSelection();
                    this.viper.cleanDOM();

                    this.viper.contentChanged();
                    this.viper.fireCallbacks('ViperCopyPastePlugin:paste');
                    return;
                } else {
                    var td = ViperUtil.getTag('td', this._selectedRows[0])[0];
                    ViperUtil.setHtml(td, ' ');
                    this._tmpNode = td.firstChild;
                }

            }

            // If fragment contains block level elements most likely we will need to
            // do some spliting so we do not have P tags in P tags etc.. Split the
            // container from current selection and then insert paste contents after it.
            if (ViperUtil.hasBlockChildren(fragment) === true) {
                // TODO: We should move handleEnter function to somewhere else and make it
                // a little bit more generic.
                var keyboardEditor = this.viper.getKeyboardHandler()
                var viperElem      = this.viper.getViperElement();
                var prevBlock      = null;
                var range          = this.viper.getViperRange();

                if (ViperUtil.isPartOfDOM(this._tmpNode, viperElem) === false) {
                    // The tmp node is missing from DOM, add it back in.
                    var bookmark = this.viper.createBookmark();
                    this._insertTmpNodeBeforeBookmark(bookmark);
                }

                range.setEnd(this._tmpNode, 0);
                range.collapse(false);

                if (ViperUtil.getHtml(viperElem) !== '') {
                    if (viperElem.firstChild === viperElem.lastChild
                        && (viperElem.firstChild === null || ViperUtil.isTag(viperElem.firstChild, 'br') === true)
                    ) {
                        if (viperElem.firstChild === null) {
                            viperElem.appendChild(this._tmpNode);
                        } else {
                            ViperUtil.insertBefore(this._tmpNode, viperElem.firstChild);
                        }
                    } else if (ViperUtil.trim(ViperUtil.getHtml(this._tmpNode.parentNode)) === '&nbsp;'
                        && ViperUtil.isBlockElement(this._tmpNode.parentNode)
                    ) {
                        ViperUtil.insertBefore(this._tmpNode.parentNode, this._tmpNode);
                        ViperUtil.remove(this._tmpNode.nextSibling);
                    } else {
                        prevBlock = keyboardEditor.splitAtRange(true, range);
                    }
                } else {
                    // Viper Element is empty make sure tmpNode is added to DOM.
                    viperElem.appendChild(this._tmpNode);
                }

                if (!prevBlock) {
                    prevBlock = this._tmpNode;
                } else {
                    try {
                        if (!this._tmpNode.parentNode) {
                            if (prevBlock.lastChild) {
                                this._tmpNode = prevBlock.lastChild;
                            } else {
                                this._tmpNode = prevBlock;
                            }
                        }
                    } catch (e) {
                        // Guess which browser this try/catch block is for....
                        this._tmpNode = document.createTextNode('');
                        if (prevBlock.lastChild) {
                            ViperUtil.insertAfter(prevBlock.lastChild, this._tmpNode);
                        } else {
                            prevBlock.appendChild(this._tmpNode);
                        }
                    }
                }

                var prevCheckCont = ViperUtil.trim(ViperUtil.getNodeTextContent(prevBlock));
                if (prevCheckCont !== '') {
                    // Lets do another check for IE..
                    if (prevCheckCont.length === 1 && prevCheckCont.charCodeAt(0) !== 160) {
                        prevBlock = prevBlock.nextSibling;
                    }
                }

                if (prevBlock.nextSibling) {
                    prevCheckCont = ViperUtil.trim(ViperUtil.getNodeTextContent(prevBlock.nextSibling));
                    if (prevCheckCont === '' || (prevCheckCont.length === 1 && prevCheckCont.charCodeAt(0) === 160)) {
                        ViperUtil.remove(prevBlock.nextSibling);

                        if (prevBlock.lastChild) {
                            // Also remove the last child of prevBlock if its empty. This is to prevent things like:
                            // <blockquote><p>text</p><p>*</p></blockquote> where * is the paste location.
                            prevCheckCont = ViperUtil.trim(ViperUtil.getNodeTextContent(prevBlock.lastChild));
                            if (prevCheckCont === '' || (prevCheckCont.length === 1 && prevCheckCont.charCodeAt(0) === 160)) {
                                ViperUtil.remove(prevBlock.lastChild);
                            }
                        }
                    }
                }

                if (ViperUtil.getParents(prevBlock, 'pre', this.viper.getViperElement()).length > 0) {
                    var textNode = document.createTextNode(preHtml);
                    ViperUtil.insertBefore(this._tmpNode, textNode);
                } else {
                    var prevChild   = null;
                    var lastChild   = null;
                    var prevWrapper = null;
                    while (fragment.lastChild) {
                        if (prevChild === fragment.lastChild) {
                            break;
                        }

                        if (ViperUtil.isTag(fragment.lastChild, 'img') === true) {
                            if (fragment.lastChild.src.match('%7E') !== null) {
                                fragment.lastChild.src = fragment.lastChild.src.replace('%7E', '~');
                            }
                        }

                        // Check child elements.
                        var images = ViperUtil.getTag('img', fragment.lastChild);
                        for (var i = 0; i < images.length; i++) {
                            if (images[i].src.match('%7E') !== null) {
                                images[i].src = images[i].src.replace('%7E', '~');
                            }
                        }

                        prevChild = fragment.lastChild;
                        var ctNode = null;
                        if (ViperUtil.isBlockElement(fragment.lastChild) === true && ViperUtil.isStubElement(fragment.lastChild) === false) {
                            prevWrapper = null;
                            ctNode = fragment.lastChild;

                            if (ViperUtil.isTag(ctNode, ['ul', 'ol']) === true
                                && ViperUtil.isTag(prevBlock, ['li', 'ul', 'ol']) === true
                            ) {
                                // If this list is being pasted inside another list use its items instead.
                                var insAfter = prevBlock;
                                if (ViperUtil.isTag(insAfter, 'li') === false) {
                                    insAfter = this._tmpNode.nextSibling;
                                }

                                while (ctNode.firstChild) {
                                    var firstChild = ctNode.firstChild;
                                    ViperUtil.insertAfter(insAfter, firstChild);
                                    insAfter = firstChild;
                                }

                                // Remove other list.
                                ViperUtil.remove(ctNode);
                            } else if (ViperUtil.isTag(ctNode, 'table') === true
                                && ViperUtil.getParents(prevBlock, 'table', this.viper.getViperElement()).length > 0
                            ) {
                                // Pasting table inside a table is not allowed. Just paste the tables content.
                                var tableContentTags = 'td,th,caption';
                                var contentNodes = ViperUtil.getTag(tableContentTags, ctNode);
                                while (contentNodes.length > 0) {
                                    var contentNode = contentNodes.pop();
                                    while (contentNode.childNodes.length > 0) {
                                        ViperUtil.insertAfter(prevBlock, contentNode.lastChild);
                                    }
                                }
                            } else {
                                ViperUtil.insertAfter(prevBlock, ctNode);
                            }
                        } else {
                            // Text or stub element. If defaultTag is set then add wrap this node with the default tag.
                            var defaultTag = this.viper.getDefaultBlockTag();
                            ctNode         = fragment.lastChild;
                            if (defaultTag && prevWrapper === null) {
                                // No default tag was created before this so create a new one now.
                                ctNode = document.createElement(defaultTag);
                                ctNode.appendChild(fragment.lastChild);
                                prevWrapper = ctNode;
                            } else if (prevWrapper !== null) {
                                // Use the previous sibling default tag which was created by above code.
                                ViperUtil.insertBefore(prevWrapper.firstChild, fragment.lastChild);
                                continue;
                            }

                            ViperUtil.insertAfter(prevBlock, ctNode);
                        }

                        if (lastChild === null) {
                            lastChild = ctNode;
                        }
                    }

                    // Check that previous container is not empty.
                    if (prevBlock && ViperUtil.isTag(prevBlock, 'table') === false) {
                        prevCheckCont = ViperUtil.trim(ViperUtil.getNodeTextContent(prevBlock));
                        if (prevCheckCont === '' || (prevCheckCont.length === 1 && prevCheckCont.charCodeAt(0) === 160)) {
                            if (ViperUtil.isChildOf(this._tmpNode, prevBlock) === true) {
                                // Tmp node could be the child of this element (when paste is made in a new P tag for exammple).
                                this._tmpNode = range._getLastSelectableChild(prevBlock.nextSibling);
                                if (this._tmpNode) {
                                    this._tmpNodeOffset = this._tmpNode.data.length;
                                } else {
                                    this._tmpNodeOffset = 0;
                                }
                            }

                            ViperUtil.remove(prevBlock);
                        }
                    }
                }//end if

                if (lastChild) {
                    // Move the caret to the end of the last pasted content.
                    var lastSelectable = range._getLastSelectableChild(lastChild);
                    if (lastSelectable) {
                        this._tmpNode = lastSelectable;
                        this._tmpNodeOffset = this._tmpNode.data.length;
                    }
                }
            } else {
                if (ViperUtil.getParents(this._tmpNode, 'pre', this.viper.getViperElement()).length > 0) {
                    var textNode = document.createTextNode(preHtml);
                    ViperUtil.insertBefore(this._tmpNode, textNode);
                } else {
                    if (this._tmpNode.parentNode === this.viper.getViperElement()
                        && ViperUtil.isBlockElement(fragment.firstChild) === false
                    ) {
                        var defaultTag = this.viper.getDefaultBlockTag();
                        if (defaultTag) {
                            defaultTag = document.createElement(defaultTag);
                            ViperUtil.insertBefore(this._tmpNode, defaultTag);
                            defaultTag.appendChild(this._tmpNode);
                        }
                    }

                    while (fragment.firstChild) {
                        ViperUtil.insertBefore(this._tmpNode, fragment.firstChild);
                    }
                }
            }//end if

            this._updateSelection();

            this.viper.contentChanged();
            this.viper.fireCallbacks('ViperCopyPastePlugin:paste');

        },

        _cleanWordPaste: function(content)
        {
            if (!content) {
                return content;
            }

            // Convert span.Apple-converted-space to normal space (Chrome only).
            if (ViperUtil.isBrowser('chrome') === true) {
                content = content.replace(/<span class="Apple-converted-space">&nbsp;<\/span>/g, ' ');
            }

            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);
            this._convertSpansToStyleTags(tmp);

            // Clean Word track changes comments.
            var msocomanchor = ViperUtil.find(tmp, 'a[class="msocomanchor"]');
            ViperUtil.remove(msocomanchor);

            // Remove everything after this element.
            var msocomoff = ViperUtil.find(tmp, 'hr[class="msocomoff"]');
            if (msocomoff.length > 0) {
                msocomoff = msocomoff[0];
                while (msocomoff.nextSibling) {
                    ViperUtil.remove(msocomoff.nextSibling);
                }

                ViperUtil.remove(msocomoff);
            }

            content = ViperUtil.getHtml(tmp);

            // Remove span and o:p etc. tags.
            content = content.replace(/<\/?span[^>]*>/gi, "");
            content = content.replace(/<\/?\w+:[^>]*>/gi, '' );

            // Remove XML tags.
            content = content.replace(/<\\?\?xml[^>]*>/gi, '');

            if (this._isMSIE === true) {
                // Remove the font tags here before putting the contents in to a
                // DOM object. In IE8 font tags are not in correct DOM strucutre,
                // there are cases similar to this: <font><p>invalid dom</font></p>.
                // This causes problems with spacing, and when the content is set as
                // the html attribute of DOM elements IE tries to fix it by creating
                // more paragraphs...
                content = content.replace(/<\/?font[^>]*>/gi, "");
            }

            // Convert Words orsm "lists"..
            content = this._convertWordPasteList(content);

            content = this._cleanStyleAttributes(content);

            // Page breaks?
            content = content.replace('<br clear="all">', '');
            content = this._removeWordTags(content);
            content = this._convertTags(content);

            return content;

        },

        _cleanViperPaste: function(content)
        {
            content = content.replace(/<(font)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>\s*/ig, '');
            content = content.replace(/\s*<\/(font)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>/ig, '');

            if (ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true) {
                var tmp = document.createElement('div');
                ViperUtil.setHtml(tmp, content);

                // Remove all child tags inside links.
                var aTags = ViperUtil.find(tmp, 'a');
                for (var i = 0; i < aTags.length; i++) {
                    var surrChildren = ViperUtil.getSurroundedChildren(aTags[i]);
                    for (var j = 0; j < surrChildren.length; j++) {
                        if (ViperUtil.isTag(surrChildren[j], ['strong', 'em']) === true) {
                            // Wrap the A tag with this tag.
                            var newElem = document.createElement(ViperUtil.getTagName(surrChildren[j]));
                            ViperUtil.insertBefore(aTags[i], newElem);
                            newElem.appendChild(aTags[i]);
                        } else if (this.viper.isSpecialElement(surrChildren[j]) === true) {
                            // Keyword.
                            surrChildren[j] = null;
                        }
                    }

                    for (var j = (surrChildren.length - 1); j >= 0; j--) {
                        if (surrChildren[j] === null) {
                            ViperUtil.removeArrayIndex(surrChildren, j);
                        }
                    }

                    if (surrChildren.length > 0) {
                        this._moveChildren(surrChildren[surrChildren.length - 1], surrChildren[0]);
                        ViperUtil.remove(surrChildren);
                    }
                }

                content = ViperUtil.getHtml(tmp);
            }

            return content;

        },

        _cleanGoogleDocsPaste: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            var docParent = null;
            if (ViperUtil.isBlockElement(tmp.firstChild) === true) {
                docParent = tmp;
            } else {
                docParent = tmp.firstChild;
            }

            tmp = docParent;

            // Remove Google Doc id.
            var docIdElem = ViperUtil.find(tmp, '[id^="docs-internal-guid-"]');
            if (docIdElem.length > 0) {
                ViperUtil.removeAttr(docIdElem, 'id');
            }

            // Remove the wrapping b tag.
            var bTag = ViperUtil.getTag('b', tmp);
            if (bTag.length > 0) {
                ViperUtil.setHtml(tmp, ViperUtil.getHtml(bTag[0]));
            }

            content = ViperUtil.getHtml(tmp);
            content = this._cleanStyleAttributes(content, 'google_docs');

            // Convert span tags with styles to the proper tags.
            ViperUtil.setHtml(tmp, content);
            this._convertSpansToStyleTags(tmp);

            // Remove all p tags inside LI elements.
            var pInLI = ViperUtil.find(tmp, 'li > p');
            for (var i = 0; i < pInLI.length; i++) {
                while (pInLI[i].firstChild) {
                    ViperUtil.insertBefore(pInLI[i], pInLI[i].firstChild);
                }

                ViperUtil.remove(pInLI[i]);
            }

            // Find all ol/ul tags inside other ol/ul tags.
            var nestedLists = ViperUtil.find(tmp, 'ol > ol,ol > ul, ul > ul, ul > ol');
            for (var i = 0; i < nestedLists.length; i++) {
                var list = nestedLists[i];
                // Get the previous list item.
                for (var prevSib = list.previousSibling; prevSib; prevSib = prevSib.previousSibling) {
                    if (ViperUtil.isTag(prevSib, 'li') === false) {
                        continue;
                    }

                    // Found the previous list item, append this list to this list item.
                    prevSib.appendChild(list);
                    break;
                }
            }

            this._joinSplitLists(tmp);

            // Remove BR tags from main element.
            var brTags = ViperUtil.find(tmp, ' > br');
            if (brTags.length > 0) {
                ViperUtil.remove(brTags);
            }

            // Remove strong/em tags from H1..H6 elements.
            var strongAndEmTags = ViperUtil.find(tmp, 'h1 > strong,h2 > strong,h3 > strong,h4 > strong,h5 > strong,h6 > strong,h1 > em,h2 > em,h3 > em,h4 > em,h5 > em,h6 > em');
            for (var i = 0; i < strongAndEmTags.length; i++) {
                while (strongAndEmTags[i].firstChild) {
                    ViperUtil.insertBefore(strongAndEmTags[i], strongAndEmTags[i].firstChild);
                }

                ViperUtil.remove(strongAndEmTags[i]);
            }

            content = ViperUtil.getHtml(tmp);

            // Remove all remaining span tags.
            content = content.replace(/<\/?span[^>]*>/gi, "");

            // Clean all font-weight etc.
            content = this._cleanStyleAttributes(content);

            return content;
        },

        _isGoogleDocs: function(elem)
        {
            if (elem.firstChild) {
                if (ViperUtil.isTag(elem.firstChild, 'b') === true
                    || ViperUtil.isTag(elem.firstChild.nextSibling, 'b') === true
                    || (elem.firstChild.id && elem.firstChild.id.indexOf('docs-internal-guid-') === 0)
                ) {
                    // Firefox, IE.
                    return true;
                } else if (ViperUtil.isTag(elem.firstChild, 'meta') === true
                    && ViperUtil.isTag(elem.lastChild, 'b') === true
                    || (elem.lastChild.id && elem.lastChild.id.indexOf('docs-internal-guid-') === 0)
                ) {
                    // Chrome.
                    return true;
                } else if (ViperUtil.find(elem, '[id^="docs-internal-guid-"]').length === 1) {
                    // IE8.
                    return true;
                }
            }

            return false;

        },

        _joinSplitLists: function(parentElement)
        {
            // If there are lists like <ol></ol><ol start="2"></ol><ol start="3"></ol> convert it to a single list.
            var lists = ViperUtil.find(parentElement, 'ol');
            for (var i = lists.length - 1; i >= 0; i--) {
                var list  = lists[i];
                var start = parseInt(ViperUtil.attr(list, 'start')) || 1;
                if (start > 1 && i > 0) {
                    // The start attribute is set. Check if the list before this has (start - 1).
                    var prevList  = lists[(i - 1)];
                    var prevStart = parseInt(ViperUtil.attr(prevList, 'start')) || 1;
                    if (prevStart === (start - 1)) {
                        var elemsBetween = ViperUtil.getElementsBetween(prevList, list);

                        // Move elements in between to the prevList last child.
                        var lastLi = ViperUtil.find(prevList, ' > li')[0];
                        for (var j = 0; j < elemsBetween.length; j++) {
                            lastLi.appendChild(elemsBetween[j]);
                        }

                        // Move the child list items of the current list to previous list.
                        while (list.firstChild) {
                            prevList.appendChild(list.firstChild)
                        }

                        ViperUtil.remove(list);
                    }
                }
            }

        },

        _convertSpansToStyleTags: function(elem)
        {
            var validStyles = {
                'font-weight:\\s*bold': 'strong',
                'font-weight:\\s*(\\d+)': 'strong',
                'font-style:\\s*italic': 'em',
                'text-decoration:\\s*line-through': 'del',
                'vertical-align:\\s*sub': 'sub',
                'vertical-align:\\s*super': 'sup'
            };

            var spanTags = ViperUtil.getTag('span', elem);
            var regexs   = {};
            for (var i = 0; i < spanTags.length; i++) {
                var span     = spanTags[i];
                var newTag   = null;
                var outerTag = null;
                if (ViperUtil.hasAttribute(span, 'style') === true) {
                    for (var style in validStyles) {
                        if (!regexs[style]) {
                            regexs[style] = new RegExp(style);
                        }

                        var match = ViperUtil.attr(span, 'style').match(regexs[style]);
                        if (match !== null) {
                            if (validStyles[style] === 'strong') {
                                // Incase the font-weight is a numeric value check if its 400+.
                                if (style === 'font-weight:\\s*(\\d+)' && match[1] <= 400) {
                                    continue;
                                }
                            }

                            // Create a new tag for this style.
                            var t = document.createElement(validStyles[style]);

                            if (newTag) {
                                newTag.appendChild(t);
                            } else {
                                outerTag = t;
                            }

                            newTag = t;
                        }
                    }
                }//end if

                if (newTag) {
                    // A new tag was created insert the contents of the span to this new tag.
                    while (span.firstChild) {
                        newTag.appendChild(span.firstChild);
                    }

                    ViperUtil.insertBefore(span, outerTag);
                } else {
                    while (span.firstChild) {
                        ViperUtil.insertBefore(span, span.firstChild);
                    }

                }

                // Remove this span tag.
                ViperUtil.remove(span);
            }//end for

        },

        _removeSpansWithNoAttributes: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            var spans = ViperUtil.getTag('span', tmp);
            for (var i = 0; i < spans.length; i++) {
                if (ViperUtil.hasAttribute(spans[i], 'lang') === false
                    && ViperUtil.hasAttribute(spans[i], 'dir') === false
                    && ViperUtil.hasAttribute(spans[i], 'style') === false
                ) {
                    this._moveChildren(spans[i]);
                    ViperUtil.remove(spans[i]);
                }
            }

            content = ViperUtil.getHtml(tmp);
            return content;

        },

        _cleanStyleAttributes: function(content, contentType)
        {
            var self  = this;
            var quote = '"';
            var replaceCallback = function() {
                var styles      = arguments[2];
                var stylesList  = styles.split(';');
                var validStyles = [];
                var replacement = '';
                for (var i = 0; i < stylesList.length; i++) {
                    var style = ViperUtil.trim(stylesList[i].replace("\n", ''));
                    if (self.isAllowedStyle(style, contentType) === true) {
                        validStyles.push(style);
                    }
                }

                if (validStyles.length > 0) {
                    styles    = validStyles.join(';');
                    replacement = '<' + arguments[1] + ' style=' + quote + styles + quote + arguments[3];
                } else {
                    replacement = '<' + arguments[1] + arguments[3];
                }

                return replacement;
            };

            content = content.replace(new RegExp('<(\\w[^>]*) style="([^"]*)"([^>]*)', 'gi'), replaceCallback);

            quote   = "'";
            content = content.replace(new RegExp('<(\\w[^>]*) style=\'([^\']*)\'([^>]*)', 'gi'), replaceCallback);

            return content;

        },

        isAllowedStyle: function(style, contentType)
        {
            if (style.indexOf('mso-') === 0) {
                return false;
            }

            var styleName     = style.split(':');
            var allowedStyles = ['height', 'width', 'list-style-type'];

            if (this._aggressiveMode === false) {
                // Aggressive mode is turned off, allow these styles.
                allowedStyles = allowedStyles.concat(['padding', 'text-align', 'text-indent', 'border-collapse', 'border', 'border-top', 'border-bottom', 'border-right', 'border-left']);
            }

            if (contentType === 'google_docs') {
                allowedStyles = allowedStyles.concat(['font-weight', 'font-style', 'vertical-align', 'text-decoration']);
            }

            if (ViperUtil.inArray(styleName[0], allowedStyles) === true) {
                // Style is allowed but its value might not be.
                var invalidStyleValues = {
                    'text-indent': ['0px'],
                    'text-align': ['start', 'left', 'initial'],
                    'padding': ['0px'],
                    'text-indent': ['0px']
                };

                if (!invalidStyleValues[styleName[0]]
                    || ViperUtil.inArray(ViperUtil.trim(styleName[1]), invalidStyleValues[styleName[0]]) === false
                ) {
                    return true;
                }
            }

            return false;

        },

        _convertTags: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            // Remove the INS tags.
            var insTags = ViperUtil.getTag('ins', tmp);
            var ins     = null;
            while (ins = insTags.shift()) {
                while (ins.firstChild) {
                    ViperUtil.insertBefore(ins, ins.firstChild);
                }

                ViperUtil.remove(ins);
            }

            // Remove the CENTER tags.
            var centerTags = ViperUtil.getTag('center', tmp);
            var center     = null;
            while (center = centerTags.shift()) {
                var parent    = null;
                var childTags = ViperUtil.getTag('*', center);
                if (childTags.length === 0) {
                    parent = document.createElement('p');
                }

                while (center.firstChild) {
                    if (parent) {
                        parent.appendChild(center.firstChild);
                    } else {
                        ViperUtil.insertBefore(center, center.firstChild);
                    }
                }

                if (parent) {
                    ViperUtil.insertBefore(center, parent);
                }

                ViperUtil.remove(center);
            }

            content = ViperUtil.getHtml(tmp);

            return content;

        },

        _removeAttributes: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            ViperUtil.$(tmp).find('[class]').removeAttr('class');
            ViperUtil.$(tmp).find('br[clear]').removeAttr('clear');

            // Remove all attributes from table related elements.
            var tableElements = ViperUtil.$(tmp).find('td,tr,table,tbody,tfoot,thead');
            var c = tableElements.length;
            for (var i = 0; i < c; i++) {
                var attributes = tableElements[i].attributes;

                if (ViperUtil.isTag(tableElements[i], 'td') === true
                    || ViperUtil.isTag(tableElements[i], 'th') === true
                ) {
                    if (!ViperUtil.trim(ViperUtil.getHtml(tableElements[i]))) {
                        if (this._isMSIE === true) {
                            ViperUtil.setHtml(tableElements[i], '&nbsp;');
                        } else {
                            ViperUtil.setHtml(tableElements[i], '<br />');
                        }
                    }
                }

                for (var j = (attributes.length - 1); j >= 0; j--) {
                    var attrName = attributes[j].name.toLowerCase();
                    if (attrName === 'colspan' || attrName === 'rowspan') {
                        continue;
                    }

                    tableElements[i].removeAttribute(attrName);
                }
            }

            // Remove colgroup from tables.
            ViperUtil.remove(ViperUtil.$(tmp).find('colgroup'));

            content = ViperUtil.getHtml(tmp);
            return content;

        },

        _updateElements: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            // Set all table elements to have width=100%.
            var tables = ViperUtil.getTag('table', tmp);
            var c      = tables.length;

            for (var i = 0; i < c; i++) {
                var table = tables[i];

                ViperUtil.setStyle(tmp, 'display', 'none');
                this.viper.getViperElement().appendChild(tmp);

                ViperUtil.setStyle(table, 'width', '100%');

                // Determine if we need to add borders.
                var col         = ViperUtil.getTag('td,th', table)[0];
                var rightWidth  = parseInt(ViperUtil.getComputedStyle(col, 'border-right-width'));
                var bottomWidth = parseInt(ViperUtil.getComputedStyle(col, 'border-bottom-width'));
                if (bottomWidth === 0
                    || rightWidth === 0
                    || isNaN(bottomWidth) === true
                    || isNaN(rightWidth) === true
                ) {
                    ViperUtil.attr(table, 'border', 1);
                }

                // Convert TDs that are inside thead elements to THs.
                var thead = ViperUtil.getTag('thead', table);
                for (var j = 0; j < thead.length; j++) {
                    var tds = ViperUtil.getTag('td', thead);
                    for (var k = 0; k < tds.length; k++) {
                        var td = tds[k];
                        var th = document.createElement('th');
                        while (td.firstChild) {
                            th.appendChild(td.firstChild);
                        }

                        var colspan = ViperUtil.attr(td, 'colspan');
                        if (colspan) {
                            th.setAttribute('colspan', colspan);
                        }

                        var rowspan = ViperUtil.attr(td, 'rowspan');
                        if (rowspan) {
                            th.setAttribute('rowspan', rowspan);
                        }

                        ViperUtil.insertBefore(td, th);
                        ViperUtil.remove(td);
                    }
                }

                ViperUtil.remove(tmp);
                ViperUtil.setStyle(tmp, 'display', 'auto');
            }//end for

            var defaultTag = this.viper.getDefaultBlockTag();
            if (defaultTag !== '') {
                var brs = ViperUtil.getTag('br', tmp);
                if (brs.length !== 0) {
                    var br    = null;
                    var first = true;
                    while (br = brs.shift()) {
                        if (br.parentNode
                            && br.parentNode.firstChild === br
                            && ViperUtil.isBlockElement(br.parentNode) === true
                        ) {
                            ViperUtil.remove(br);
                            continue;
                        }

                        // Find the next double BR tag and replace them with a new
                        // block element (p, div, etc.).
                        if (ViperUtil.isTag(br.nextSibling, 'br') === true) {
                            while (ViperUtil.isTag(br.nextSibling, 'br') === true) {
                                // Remove the next BR.
                                ViperUtil.remove(brs.shift());
                            }

                            // Create the new wrapper element and insert it after the
                            // BR tag.
                            var wrapper = document.createElement(defaultTag);
                            ViperUtil.insertAfter(br, wrapper);

                            // We no longer need this BR.
                            ViperUtil.remove(br);

                            // If this is the first double BR found then move any
                            // content before them until a block tag is found or
                            // to the beginning of content in to a new block element.
                            var node = null;
                            if (first === true) {
                                first = false;
                                var preWrapper = document.createElement(defaultTag);
                                while (node = wrapper.previousSibling) {
                                    if (ViperUtil.isBlockElement(node) === true) {
                                        break;
                                    }

                                    if (preWrapper.firstChild) {
                                        ViperUtil.insertBefore(preWrapper.firstChild, node);
                                    } else {
                                        preWrapper.appendChild(node);
                                    }
                                }

                                if (preWrapper.childNodes.length !== 0) {
                                    ViperUtil.insertBefore(wrapper, preWrapper);
                                }
                            }

                            // Move all content after the new wrapper tag till next
                            // block element or double BR.
                            node = null;
                            while (node = wrapper.nextSibling) {
                                if (ViperUtil.isBlockElement(node) === true
                                    || (ViperUtil.isTag(node, 'br') === true && ViperUtil.isTag(node.nextSibling, 'br') === true)
                                ) {
                                    break;
                                } else if (node.nodeType !== ViperUtil.TEXT_NODE || node.data.length !== 0) {
                                    wrapper.appendChild(node);
                                }
                            }

                            if (wrapper.childNodes.length === 0) {
                                ViperUtil.remove(wrapper);
                            }
                        }//end if
                    }//end while
                }//end if
            }//end if

            content = ViperUtil.getHtml(tmp);
            return content;

        },

        _removeWordTags: function(content)
        {
            var tmp = document.createElement('div');
            ViperUtil.setHtml(tmp, content);

            // Remove all tags with language=JavaScript. These are tags used by MS track changes.
            var tags = ViperUtil.find(tmp, '[language="JavaScript"]');
            for (var i = 0; i < tags.length; i++) {
                // Could be a comment.
                if (tags[i].id
                    && tags[i].id.indexOf('_com_') === 0
                    && tags[i].parentNode
                    && ViperUtil.isTag(tags[i].parentNode, 'div') === true
                ) {
                    // Check if parent has an hr sibling.
                    if (ViperUtil.isTag(tags[i].parentNode.previousElementSibling, 'hr') === true) {
                        // Remove the parent of this tag. Actual structure is:
                        // <div><hr/><div><div id="_com_1">...</div></div></div>.
                        ViperUtil.remove(tags[i].parentNode.parentNode);
                    } else {
                        ViperUtil.remove(tags[i].parentNode);
                    }
                } else {
                    ViperUtil.remove(tags[i]);
                }
            }

            // Remove the link tags with no href attributes. Usualy for the footnotes.
            var aTags = ViperUtil.getTag('a', tmp);
            var c     = aTags.length;
            for (var i = 0; i < c; i++) {
                var aTag = aTags[i];
                if (!aTag.getAttribute('href')) {
                    if (ViperUtil.isBlank(ViperUtil.getHtml(aTag)) === false) {
                        while (aTag.firstChild) {
                            ViperUtil.insertBefore(aTag, aTag.firstChild);
                        }
                    }

                    var parent = aTag.parentNode;
                    ViperUtil.remove(aTag);
                    if (ViperUtil.isBlank(ViperUtil.getHtml(parent)) === true) {
                        ViperUtil.remove(parent);
                    }
                } else {
                    // Chrome adds slash at the end of the urls, trim them..
                    aTag.setAttribute('href', aTag.getAttribute('href').replace(/\/$/, ''));

                    // Outlook adds blocked:: prefix to hrefs. Remove it.
                    aTag.setAttribute('href', aTag.getAttribute('href').replace(/^blocked::/i, ''));
                }
            }

            // Remove divs with ids starting with ftn (Footnotes).
            var tags = ViperUtil.getTag('div', tmp);
            var c    = tags.length;
            for (var i = 0; i < c; i++) {
                var id = tags[i].getAttribute('id');
                if (id && id.indexOf('ftn') === 0) {
                    var parent = tags[i].parentNode;
                    ViperUtil.remove(tags[i]);
                    if (ViperUtil.isBlank(ViperUtil.getHtml(parent)) === true) {
                        ViperUtil.remove(parent);
                    }
                }
            }

            // Remove retarded P tags in between list elements...
            var lists = ViperUtil.getTag('ol,ul', tmp);
            for (var i = 0; i < lists.length; i++) {
                var node = lists[i].firstChild;
                while (node) {
                    if (ViperUtil.isTag(node, 'li') === false) {
                        while (node.firstChild) {
                            ViperUtil.insertBefore(node, node.firstChild);
                        }
                        ViperUtil.remove(node);
                        node = lists[i].firstChild;
                    } else {
                        node = node.nextSibling;
                    }
                }
            }

            // Remove the src attribute of images pointing to local path.
            var tags = ViperUtil.find(tmp, 'img');
            for (var i = 0; i < tags.length; i++) {
                var img = tags[i];
                if (img.getAttribute('src').indexOf('file://') === 0) {
                    img.setAttribute('src', '');
                }
            }

            // Remove any font tag with multiple children.
            var tags = ViperUtil.find(tmp, 'font');
            for (var i = 0; i < tags.length; i++) {
                if (ViperUtil.getTag('*', tags[i]).length > 1) {
                    while (tags[i].firstChild) {
                        ViperUtil.insertBefore(tags[i], tags[i].firstChild);
                    }

                    ViperUtil.remove(tags[i]);
                }
            }

            // If the first element is a P tag and the next element is an empty font tag
            // then it must be a heading element.
            if (tmp.firstChild && ViperUtil.isTag(tmp.firstChild, 'p') === true) {
                var firstChild = tmp.firstChild;
                var nextSibling = firstChild.nextSibling;
                while (nextSibling) {
                    if (nextSibling.nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(nextSibling.data)) === true) {
                        nextSibling = nextSibling.nextSibling;
                    } else if (nextSibling && ViperUtil.isTag(nextSibling, 'font') === true) {
                        if (ViperUtil.getNodeTextContent(nextSibling) === '') {
                            // Conver this P tag to a H1 tag.
                            var newElement = document.createElement('h1');
                            while (firstChild.firstChild) {
                                newElement.appendChild(firstChild.firstChild);
                            }

                            ViperUtil.insertBefore(firstChild, newElement);
                            ViperUtil.remove(firstChild);
                        }

                        break;
                    } else {
                        break;
                    }
                }
            }//end if

            // Convert [strong + em ] + font + p tags to heading tags.
            var tags = ViperUtil.find(tmp, 'font > p');
            var c    = tags.length;
            for (var i = 0; i < c; i++) {
                var parent      = tags[i].parentNode;
                var fontCount   = 0;
                var strongCount = 0;
                var emCount     = 0;
                var headingType = 0;
                var fontSize    = 0;
                var lastParent  = null;
                while (parent) {
                    var tagName = ViperUtil.getTagName(parent);
                    if (tagName === 'font') {
                        lastParent = parent;
                        fontCount++;
                        if (parent.getAttribute('size')) {
                            fontSize = parseInt(parent.getAttribute('size'));
                        }
                    } else if (tagName === 'em') {
                        lastParent = parent;
                        emCount++;
                    } else if (tagName === 'strong') {
                        lastParent = parent;
                        strongCount++;
                        break;
                    } else {
                        break;
                    }

                    if (!parent.parentNode) {
                        break;
                    }

                    parent = parent.parentNode;
                }

                if (strongCount >= 1) {
                    if (fontCount >= 3 && fontSize >= 5) {
                        // H1.
                        headingType = 1;
                    } else if (fontCount >= 3 && fontSize >= 4) {
                        headingType = 2;
                    } else if (fontCount === 2 && emCount === 0) {
                        headingType = 3;
                    } else if (fontCount === 2 && emCount >= 1) {
                        headingType = 4;
                    }
                } else if (emCount === 0 && fontCount === 2) {
                    headingType = 5;
                } else if (emCount === 1 && fontCount === 2) {
                    headingType = 6;
                }

                if (headingType > 0) {
                    var heading = document.createElement('h' + headingType);
                    while (tags[i].firstChild) {
                        heading.appendChild(tags[i].firstChild);
                    }

                    ViperUtil.insertBefore(lastParent, heading);
                    ViperUtil.remove(tags[i]);
                }
            }//end for

            if (ViperUtil.isBrowser('msie') === true) {
                var tags = ViperUtil.find(tmp, 'strong > font > p');
                var c    = tags.length;
                for (var i = 0; i < c; i++) {
                    var heading = document.createElement('h1');
                    while (tags[i].firstChild) {
                        heading.appendChild(tags[i].firstChild);
                    }

                    ViperUtil.insertBefore(tags[i].parentNode.parentNode, heading);
                    ViperUtil.remove(tags[i].parentNode.parentNode);
                }

                tags = ViperUtil.find(tmp, 'strong > p');
                c    = tags.length;
                for (var i = 0; i < c; i++) {
                    var heading = document.createElement('h1');
                    while (tags[i].firstChild) {
                        heading.appendChild(tags[i].firstChild);
                    }

                    ViperUtil.insertBefore(tags[i].parentNode, heading);
                    ViperUtil.remove(tags[i].parentNode);
                }

                tags = ViperUtil.find(tmp, 'strong > em > p');
                c    = tags.length;
                for (var i = 0; i < c; i++) {
                    var heading = document.createElement('h1');
                    while (tags[i].firstChild) {
                        heading.appendChild(tags[i].firstChild);
                    }

                    ViperUtil.insertBefore(tags[i].parentNode.parentNode, heading);
                    ViperUtil.remove(tags[i].parentNode.parentNode);
                }
            }

            // Remove font tags.
            // Must use regex here as IE8 has a bug with empty nodes and multiple parents
            // for DOM elemnts it seems like font tag is a major issue:
            // https://roadmap.squiz.net/viper/2288.
            content = ViperUtil.getHtml(tmp);
            content = content.replace(/<(font)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>\s*/ig, '');
            content = content.replace(/\s*<\/(font)((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+)?\s*>/ig, '');
            ViperUtil.setHtml(tmp, content);

            // Remove empty tags.
            var tags = ViperUtil.getTag('*', tmp);
            var c    = tags.length;
            for (var i = 0; i < c; i++) {
                this.removeEmptyNodes(tags[i]);
            }

            // Remove empty P tags.
            tags = ViperUtil.getTag('p', tmp);
            var c    = tags.length;
            for (var i = 0; i < c; i++) {
                var tagContent = ViperUtil.getHtml(tags[i]);
                if (tagContent === '&nbsp;' || ViperUtil.isBlank(tagContent) === true || ViperUtil.trim(tagContent).replace(/[\r\n]/, '') === "<br><br>") {
                    // Before removing this empty P tag check previous and next siblings for lists,
                    // empty P tag might have split a single list in to two.
                    if (tags[i].previousSibling && tags[i].nextSibling) {
                        var prevTagName = ViperUtil.getTagName(tags[i].previousElementSibling);
                        var nextTagName = ViperUtil.getTagName(tags[i].nextElementSibling);
                        if (prevTagName === nextTagName && ViperUtil.isTag(tags[i].previousElementSibling, ['ul', 'ol'])) {
                            // Move child elements of the next sibling in to the prev list.
                            ViperUtil.moveChildrenToElement(tags[i].nextElementSibling, tags[i].previousElementSibling);
                            ViperUtil.remove(tags[i].nextElementSibling);
                        }
                    }

                    ViperUtil.remove(tags[i]);
                }
            }

            if (ViperUtil.isBrowser('msie') === true && ViperUtil.getTag('p', tmp).length > 0) {
                // Move any content that is not inside a paragraph in to a previous paragraph..
                var steps = 2;
                for (var i = 0; i < steps; i++) {
                    // Do this twice to make sure IE8 has the correct DOM structure in the
                    // second loop..
                    var node      = tmp.firstChild;
                    var prevBlock = null;

                    while (node) {
                        if (ViperUtil.isBlockElement(node) !== true) {
                            if (node.nodeType === ViperUtil.TEXT_NODE) {
                                if (ViperUtil.isBlank(ViperUtil.trim(node.data)) === true) {
                                    var currentNode = node;
                                    node = node.nextSibling;
                                    ViperUtil.remove(currentNode);
                                    continue;
                                }
                            }

                            if (!prevBlock) {
                                prevBlock = document.createElement('p');
                            }

                            if (node.nodeType !== ViperUtil.TEXT_NODE && ViperUtil.isStubElement(node) === false) {
                                prevBlock.appendChild(document.createTextNode(' '));
                            }

                            var currentNode = node;
                            node = node.nextSibling;
                            prevBlock.appendChild(currentNode);
                        } else {
                            if (ViperUtil.trim(ViperUtil.getHtml(node)).match(/^[^\w:-_…]$/)) {
                                // Only a single non-word character in this paragraph, move it
                                // to the previous one in the next loop.
                                var currentNode = node;
                                node = currentNode.firstChild;
                                ViperUtil.insertBefore(currentNode, node);
                                ViperUtil.remove(currentNode);
                            } else {
                                prevBlock = node;
                                node      = node.nextSibling;
                            }
                        }
                    }

                    content = ViperUtil.getHtml(tmp);
                    ViperUtil.setHtml(tmp, content);
                }//end for
            }

            // Convert MsoQuote to blockquote.
            var prevBlockquote = null;
            var quotes         = ViperUtil.find(tmp, '[class="MsoQuote"]');
            for (var i = 0; i < quotes.length; i++) {
                var quote = quotes[i];
                if (prevBlockquote === null || quote.previousElementSibling !== prevBlockquote) {
                    prevBlockquote = document.createElement('blockquote');
                    ViperUtil.insertBefore(quote, prevBlockquote);
                }

                prevBlockquote.appendChild(quote);

            }

            content = ViperUtil.getHtml(tmp);
            ViperUtil.setHtml(tmp, content);

            return content;

        },

        _getListType: function(elem, listTypes)
        {
            var style     = elem.getAttribute('style');
            var className = elem.getAttribute('class') || '';
            if (!style || (style.indexOf('mso-list') === -1 && className.indexOf('MsoList') === -1)) {
                return null;
            }

            var tmp   = document.createElement('div');
            var range = this.viper.getViperRange();

            var elContent = ViperUtil.getNodeTextContent(elem);
            elContent     = elContent.replace(/\n/, '');
            elContent     = elContent.replace(/^(&nbsp;)+/m, '');
            elContent     = ViperUtil.trim(elContent);
            var info      = null;
            ViperUtil.foreach(listTypes, function(k) {
                ViperUtil.foreach(listTypes[k], function(j) {
                    ViperUtil.foreach(listTypes[k][j], function(m) {
                        var r = new RegExp(listTypes[k][j][m]);
                        if (r.test(elContent) === true) {
                            var origHtml = ViperUtil.getHtml(elem);
                            var html = origHtml.replace(/\n/mg, ' ');
                            html     = ViperUtil.trim(html);
                            html     = html.replace(/^(&nbsp;)+/m, '');
                            html     = html.replace(/(&nbsp;)+$/m, '');
                            html     = ViperUtil.trim(html);

                            var start = 1;
                            if (k === 'ol') {
                                var match = elContent.match(r);
                                if (match && match.length === 2) {
                                    match = match[1].match(/\d+/);
                                    if (match && parseInt(match[0])) {
                                        start = parseInt(match[0]);
                                    }
                                }
                            }

                            var replacedHTML = html.replace(r, '');
                            if (replacedHTML === html) {
                                // The content must be in an inline tag. E.g. <strong>1.   </strong>.
                                ViperUtil.setHtml(tmp, html);
                                var firstChild  = range._getFirstSelectableChild(tmp);
                                firstChild.data = firstChild.data.replace(r, '');
                                replacedHTML    = ViperUtil.getHtml(tmp);
                            }

                            info = {
                                html: replacedHTML,
                                listType: k,
                                listStyle: j,
                                listStart: start,
                                origHtml: origHtml
                            };

                            // Break from loop.
                            return false;
                        }
                    });

                    if (info !== null) {
                        // Break from loop.
                        return false;
                    }
                });

                if (info !== null) {
                    // Break from loop.
                    return false;
                }
            });

            return info;

        },

        _convertWordPasteList: function(content)
        {
            var div        = document.createElement('div');
            var ul         = null;
            var prevLevel  = null;
            var indentLvl  = {};
            var li         = null;
            var newList    = true;
            var prevType   = null;
            var styleToLvl = {};
            var prevCssStyle = null;

            var circleCharsArray = [111, 118, 167, 183, 216, 222, 223, 252, 8721, 8226];
            var circleChars      = [];
            for (var i = 0; i < circleCharsArray.length; i++) {
                circleChars.push(String.fromCharCode(circleCharsArray[i]));
            }

            circleChars = circleChars.join('|');

            var listTypes = {
                ul: {
                    circle: ['^(?:' + circleChars + ')(?:\\s|&nbsp;)+']
                },
                ol: {
                    'i': ['^[ivxlcdm]+[\\.\\)](\\s|&nbsp;)+'],
                    'I': ['^[IVXLCDM]+[\\.\\)](\\s|&nbsp;)+'],
                    'a': ['^[a-z]+[\\.\\)](\\s|&nbsp;)+'],
                    'A': ['^[A-Z]+[\\.\\)](\\s|&nbsp;)+'],
                    decimal: ['^((?:\\d+|[a-z][^a-z])[\\.\\)]?)+(?:\\s|&nbsp;)+']
                }
            };

            ViperUtil.setHtml(div, content);

            var pElems = ViperUtil.getTag('p', div);
            var pln    = pElems.length;
            for (var i = 0; i < pln; i++) {
                var pEl          = pElems[i];
                var listTypeInfo = this._getListType(pEl, listTypes);
                if (listTypeInfo === null) {
                    // Next list item will be the start of a new list.
                    newList = true;
                    styleToLvl = {};
                    prevLevel = null;
                    continue;
                }

                var listType  = listTypeInfo.listType;
                var listStyle = listTypeInfo.listStyle;
                var level     = (pEl.getAttribute('style') || '').match(/level([\d])+/mi);
                var cssStyle  = pEl.getAttribute('style');
                ViperUtil.setHtml(pEl, listTypeInfo.html);

                if (listType === 'ol' && listTypeInfo.origHtml.indexOf('v') === 0) {
                    // Change the list type to ul.
                    // TODO: Might have to check font-family here incase this is part of a OL list a -> z.
                    listType = 'ul';
                }

                if (ViperUtil.isTag(pEl.parentNode, 'li') === true) {
                    listType = ViperUtil.getTagName(pEl.parentNode.parentNode);
                }

                if (!level) {
                    level = prevLevel || 1;
                } else {
                    level = level[1];
                }

                if (prevType !== listType && level === prevLevel) {
                    newList = true;
                }

                prevType = listType;

                if (!listType) {
                    listType = 'ol';
                }

                if (newList === true) {
                    // Start a new list.
                    ul        = document.createElement(listType);
                    indentLvl = {};

                    if (listTypeInfo.listStart > 1) {
                        ViperUtil.attr(ul, 'start', listTypeInfo.listStart);
                    }

                    if (listStyle !== 'decimal' && listStyle !== 'circle') {
                        ul.setAttribute('type', listStyle);
                    }

                    indentLvl[level] = ul;
                    if (ViperUtil.isTag(pEl.parentNode, 'li') === true) {
                        // IE somtimes have this strucuture: <ul><li><p>..</p><p>..</p>..</li></ul>.
                        // Move the P before the list element.
                        ViperUtil.insertBefore(pEl.parentNode.parentNode, ul);
                        ViperUtil.remove(pEl.parentNode.parentNode);
                    } else {
                        ViperUtil.insertBefore(pEl, ul);
                    }
                } else {
                    if (level !== prevLevel) {
                        if (ViperUtil.isset(indentLvl[level]) === true) {
                            // Going back up.
                            ul = indentLvl[level];
                            for (var lv in indentLvl) {
                                if (lv > level) {
                                    delete indentLvl[lv];
                                }
                            }
                        } else if (level > prevLevel) {
                            // Sub list, create a new list.
                            ul = document.createElement(listType);

                            if (listStyle !== 'decimal' && listStyle !== 'circle') {
                                ul.setAttribute('type', listStyle);
                            }

                            li.appendChild(ul);

                            indentLvl[level] = ul;
                        }
                    }
                }

                // Create a new list item.
                li = this._createListItemFromElement(pEl);
                ul.appendChild(li);

                prevLevel = level;
                ViperUtil.remove(pEl);
                newList = false;
            }//end for

            // Find all ol/ul tags inside other ol/ul tags.
            var nestedLists = ViperUtil.find(div, 'ol > ol,ol > ul, ul > ul, ul > ol');
            for (var i = 0; i < nestedLists.length; i++) {
                var list = nestedLists[i];
                if (!list.previousElementSibling && !list.nextElementSibling) {
                    // Nested list for no reason.. Take it out of its parent and remove the old parent.
                    ViperUtil.insertBefore(list.parentNode, list);
                    ViperUtil.remove(list.nextElementSibling);
                }
            }

            // Make sure the sub lists are inside list items.
            var lists = ViperUtil.getTag('ul,ol', div);
            var lc    = lists.length;
            for (var i = 0; i < lc; i++) {
                var list = lists[i];
                var styleToType = {
                    'lower-alpha': 'a',
                    'lower-roman': 'i',
                    'upper-alpha': 'A',
                    'upper-roman': 'I'
                };

                // Convert list style to type.
                var listStyle = ViperUtil.getStyle(list, 'list-style-type');
                if (listStyle) {
                    var type = styleToType[listStyle];
                    if (type) {
                        list.setAttribute('type', type);
                    }
                }

                ViperUtil.removeAttr(list, 'style');

                if (ViperUtil.isTag(list.parentNode, 'ul') === true
                    || ViperUtil.isTag(list.parentNode, 'ol') === true
                ) {
                    // This sub list is sitting outside of an LI tag.
                    // Find the previous list item and add this list to that item.
                    var prevSibling = list.previousSibling;
                    while (prevSibling) {
                        if (ViperUtil.isTag(prevSibling, 'li') === true) {
                            prevSibling.appendChild(list);
                            break;
                        }

                        prevSibling = prevSibling.previousSibling;
                    }
                }
            }

            // Make sure each list item is inside a list element.
            var listItems = ViperUtil.getTag('li', div);
            var c         = listItems.length;
            for (var i = 0; i < c; i++) {
                var li = listItems[i];
                ViperUtil.removeAttr(li, 'style');
                if (!li.parentNode || (ViperUtil.isTag(li.parentNode, 'ul') !== true  && ViperUtil.isTag(li.parentNode, 'ol') !== true)) {
                    // This list item is not inside a list element.
                    // If there is a list before this item join to it, if not create a
                    // new list.

                    var list = null;
                    var sibling = li.previousSibling;
                    while (sibling) {
                        if (sibling.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(sibling.data) !== '') {
                            break;
                        } else if (ViperUtil.isTag(sibling, 'ol') === true || ViperUtil.isTag(sibling, 'ul') === true) {
                            list = sibling;
                            break;
                        } else if (sibling.nodeType === ViperUtil.ELEMENT_NODE) {
                            break;
                        }

                        sibling = sibling.previousSibling;

                    }

                    if (list) {
                        list.appendChild(li);
                    } else {
                        list = document.createElement('ul');
                        ViperUtil.insertBefore(li, list);
                        list.appendChild(li);
                    }
                }
            }

            // Remove all p tags inside LI elements.
            var pInLI = ViperUtil.find(div, 'li > p');
            for (var i = 0; i < pInLI.length; i++) {
                while (pInLI[i].firstChild) {
                    ViperUtil.insertBefore(pInLI[i], pInLI[i].firstChild);
                }

                ViperUtil.remove(pInLI[i]);
            }

            this._joinSplitLists(div);

            content = ViperUtil.getHtml(div);

            return content;

        },

        removeEmptyNodes: function(node)
        {
            if (node && node.nodeType === ViperUtil.ELEMENT_NODE) {
                if ((!node.firstChild || ViperUtil.isBlank(ViperUtil.getHtml(node)) === true) && ViperUtil.isStubElement(node) === false) {
                    if (ViperUtil.isTag(node, 'td') !== true && ViperUtil.isTag(node, 'th') !== true) {
                        var parent = node.parentNode;
                        parent.removeChild(node);
                        this.removeEmptyNodes(parent);
                    }
                }
            }

        },

        _createListItemFromElement: function(elem)
        {
            var li = document.createElement('li');
            while (elem.firstChild) {
                li.appendChild(elem.firstChild);
            }

            return li;

        },

        _cleanPaste: function(content)
        {
            content = ViperUtil.trim(content);

            // Clean head tags.
            content = content.replace(/<(meta|link|base)[^>]+>/gi, "");
            content = content.replace(/<title[\s\S]*?<\/title>/gi, '');
            content = content.replace(/<style[\s\S]*?<\/style>/gi, '');

            // Remove everything after <!--EndFragment--> on Chrome.
            var pos = content.indexOf('<!--EndFragment-->');
            if (pos > 0) {
                content = content.substr(0, pos);
            }

            // Comments.
            content = content.replace(/<!--(.|\s)*?-->/gi, '');

            // Some generic content cleanup. Change all b/i tags to strong/em.
            content = content.replace(/<b(\s+|>)/gi, "<strong$1");
            content = content.replace(/<\/b(\s+|>)/gi, "</strong$1");
            content = content.replace(/<i(\s+|>)/gi, "<em$1");
            content = content.replace(/<\/i(\s+|>)/gi, "</em$1");
            content = content.replace(/<s(\s+|>)/gi, "<del$1");
            content = content.replace(/<\/s(\s+|>)/gi, "</del$1");
            content = content.replace(/<strike(\s+|>)/gi, "<del$1");
            content = content.replace(/<\/strike(\s+|>)/gi, "</del$1");
            return content;

        },

        _moveChildren: function(cont, beforeElem)
        {
            beforeElem = beforeElem || cont;

            // Moves the child nodes of cont before the cont.
            while (ViperUtil.isset(cont.firstChild) === true) {
                ViperUtil.insertBefore(beforeElem, cont.firstChild);
            }

        },

        _updateSelection: function()
        {
            try {
                if (this._tmpNode !== null && ViperUtil.isPartOfDOM(this._tmpNode) === true) {
                    var range = this.viper.getCurrentRange();
                    range.setEnd(this._tmpNode, this._tmpNodeOffset);
                    range.setStart(this._tmpNode, this._tmpNodeOffset);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }

                if (this._bookmark) {
                    this.viper.removeBookmarks(null, true);
                }

                // Remove tmp nodes.
                ViperUtil.remove(this.pasteElement);
                this._tmpNode     = null;
                this.pasteElement = null;
            } catch (e) {
            }

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperCoreStylesPlugin(viper)
    {
        this.viper = viper;

        this.styleTags         = ['strong', 'em', 'sub', 'sup', 'del'];
        this.toolbarPlugin     = null;
        this._onChangeAddStyle = [];

        this._buttons = {
            strong: 'bold',
            em: 'italic',
            sub: 'subscript',
            sup: 'superscript',
            del: 'strikethrough',
            removeFormat: 'removeFormat',
            hr: 'hr'
        };

    }

    Viper.PluginManager.addPlugin('ViperCoreStylesPlugin', ViperCoreStylesPlugin);

    ViperCoreStylesPlugin.prototype = {

        handleKeyPress: function(e, type)
        {
            if (type) {
                return this.handleStyle(type);
            }

        },

        init: function()
        {
            var self = this;

            var ctrlName = 'CTRL';
            if (navigator.platform.toLowerCase().indexOf('mac') >= 0) {
                ctrlName = 'CMD';
            }

            var tools = this.viper.Tools;
            var toolbarPlugin  = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            this.toolbarPlugin = toolbarPlugin;

            var toolbarButtons = {};
            var btnGroup = tools.createButtonGroup('ViperCoreStylesPlugin:vtp:stylesBtns');

            // Main styles and remove format button groups.
            toolbarButtons.styles   = ['strong', 'em', 'sub', 'sup', 'del'];
            toolbarButtons.removeFormat = ['removeFormat'];
            toolbarButtons.justify = ['left', 'center', 'right', 'block'];
            toolbarButtons.other = ['hr'];

            tools.createButton('bold', '', _('Bold'), 'Viper-bold', function() {
                return self.handleStyle('strong');
            }, true);
            tools.createButton('italic', '', _('Italic'), 'Viper-italic', function() {
                return self.handleStyle('em');
            }, true);
            tools.createButton('removeFormat', '', _('Remove Format'), 'Viper-removeFormat', function() {
                self.removeFormat();
            }, true);

            tools.addButtonToGroup('bold', 'ViperCoreStylesPlugin:vtp:stylesBtns');
            tools.addButtonToGroup('italic', 'ViperCoreStylesPlugin:vtp:stylesBtns');
            tools.addButtonToGroup('removeFormat', 'ViperCoreStylesPlugin:vtp:stylesBtns');

            // Extra style buttons, sub, sup and strike.
            var btnGroup2 = tools.createButtonGroup('ViperCoreStylesPlugin:vtp:btnGroup2');
            tools.createButton('subscript', '', _('Subscript'), 'Viper-subscript', function() {
                self.handleStyle('sub');
            }, true);
            tools.createButton('superscript', '', _('Superscript'), 'Viper-superscript', function() {
                self.handleStyle('sup');
            }, true);
            tools.createButton('strikethrough', '', _('Strikethrough'), 'Viper-strikethrough', function() {
                self.handleStyle('del');
            }, true);

            tools.addButtonToGroup('subscript', 'ViperCoreStylesPlugin:vtp:btnGroup2');
            tools.addButtonToGroup('superscript', 'ViperCoreStylesPlugin:vtp:btnGroup2');
            tools.addButtonToGroup('strikethrough', 'ViperCoreStylesPlugin:vtp:btnGroup2');

            // Justify buttons bubble.
            var justifyBubbleContent = document.createElement('div');
            var btnGroup3 = tools.createButtonGroup('ViperCoreStylesPlugin:vtp:btnGroup3');
            tools.createButton('ViperCoreStylesPlugin:vtp:left', '', _('Left Justify'), 'Viper-justifyLeft', function() {
                self.handleJustify('left');
            });
            tools.createButton('ViperCoreStylesPlugin:vtp:center', '', _('Center Justify'), 'Viper-justifyCenter', function() {
                self.handleJustify('center');
            });
            tools.createButton('ViperCoreStylesPlugin:vtp:right', '', _('Right Justify'), 'Viper-justifyRight', function() {
                self.handleJustify('right');
            });
            tools.createButton('ViperCoreStylesPlugin:vtp:block', '', _('Block Justify'), 'Viper-justifyBlock', function() {
                self.handleJustify('justify');
            });

            tools.addButtonToGroup('ViperCoreStylesPlugin:vtp:left', 'ViperCoreStylesPlugin:vtp:btnGroup3');
            tools.addButtonToGroup('ViperCoreStylesPlugin:vtp:center', 'ViperCoreStylesPlugin:vtp:btnGroup3');
            tools.addButtonToGroup('ViperCoreStylesPlugin:vtp:right', 'ViperCoreStylesPlugin:vtp:btnGroup3');
            tools.addButtonToGroup('ViperCoreStylesPlugin:vtp:block', 'ViperCoreStylesPlugin:vtp:btnGroup3');
            justifyBubbleContent.appendChild(btnGroup3);

            var hr = tools.createButton('hr', '', _('Horizontal Rule'), 'Viper-insertHr', function() {
                self.handleHR();
            }, true);

            tools.getItem('bold').setButtonShortcut('CTRL+B');
            tools.getItem('italic').setButtonShortcut('CTRL+I');

            if (toolbarPlugin) {
                toolbarPlugin.addButton(btnGroup);
                toolbarPlugin.addButton(btnGroup2);

                toolbarPlugin.createBubble('ViperCoreStylesPlugin:justifyBubble', _('Justification'), null, justifyBubbleContent);
                var justifyBubbleToggle = tools.createButton('justify', '', _('Toggle Justification'), 'Viper-justifyLeft', null, true);
                toolbarPlugin.addButton(justifyBubbleToggle);
                toolbarPlugin.setBubbleButton('ViperCoreStylesPlugin:justifyBubble', 'justify');

                toolbarPlugin.addButton(hr);

                this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperCoreStylesPlugin', function(data) {
                    var range = data;
                    if (data.range) {
                        range = data.range;
                    }

                    setTimeout(
                        function() {
                            self._updateToolbarButtonStates(toolbarButtons, range);
                        },
                        10
                    )

                    if (self._onChangeAddStyle.length > 0) {
                        var style = null;
                        while (style = self._onChangeAddStyle.shift()) {
                            self.viper.Tools.setButtonInactive(self._buttons[style]);
                        }
                    }
                });
            }//end if

            this.viper.registerCallback('Viper:keyDown', 'ViperCoreStylesPlugin', function(e) {
                if (e.which === 85 && (e.ctrlKey === true || e.metaKey === true)) {
                    // Disable ctrl/cmd + u.
                    return false;
                }
            });

            this.viper.registerCallback('Viper:keyPress', 'ViperCoreStylesPlugin', function(e) {
                if (self._onChangeAddStyle.length > 0 && ViperUtil.isInputKey(e) === true) {
                    var character = String.fromCharCode(e.which);
                    return self.viper.insertTextAtCaret(character);
                }
            });

            this.viper.registerCallback('Viper:nodesInserted', 'ViperCoreStylesPlugin', function(data) {
                return self._wrapNodeWithActiveStyle(data.node, data.range);
            });

            this.viper.registerCallback('Viper:charInsert', 'ViperCoreStylesPlugin', function(data) {
                self._onChangeAddStyle = [];
            });

            // Inline toolbar.
            var inlineToolbar = this.viper.PluginManager.getPlugin('ViperInlineToolbarPlugin');
            if (inlineToolbar) {
                if (inlineToolbar.isInitialised() === true) {
                    self._createInlineToolbarContent(inlineToolbar.getToolbar());
                } else {
                    this.viper.registerCallback('ViperInlineToolbarPlugin:initToolbar', 'ViperCoreStylesPlugin', function(toolbar) {
                        self._createInlineToolbarContent(toolbar);
                    });
                }

                this.viper.registerCallback('ViperInlineToolbarPlugin:updateToolbar', 'ViperCoreStylesPlugin', function(data) {
                    self._updateInlineToolbar(data);
                });
            }

            var tagNames = {
                em: _('Italic'),
                strong: _('Bold'),
                sub: _('Subscript'),
                sup: _('Superscript'),
                del: _('Strikethrough')
            };

            this.viper.registerCallback('Viper:mouseDown', 'ViperCoreStylesPlugin', function(e) {
                self._selectedImage = null;
                var target = ViperUtil.getMouseEventTarget(e);
                if (target && ViperUtil.isTag(target, 'hr') !== true) {
                    if (ViperUtil.isTag(target, 'img') === true) {
                        self.viper.Tools.disableButton('ViperCoreStylesPlugin:vtp:block');
                        self._selectedImage = target;
                        self._updateToolbarButtonStates();
                    }

                    return;
                }

                if (ViperUtil.isBrowser('msie') === true) {
                    // This block of code prevents IE moving user selection to the.
                    // button element when clicked. When the button element is removed
                    // and added back to DOM selection is not moved. Seriously, IE?
                    if (target.previousSibling) {
                        var sibling = target.previousSibling;
                        target.parentNode.removeChild(target);
                        ViperUtil.insertAfter(sibling, target);
                    } else if (target.nextSibling) {
                        var sibling = target.nextSibling;
                        target.parentNode.removeChild(target);
                        ViperUtil.insertBefore(sibling, target);
                    } else {
                        var parent = target.parentNode;
                        target.parentNode.removeChild(target);
                        parent.appendChild(target);
                    }
                }//end if

                // Set the range after the HR element, if there is no element after
                // HR create a new P tag.
                var blockSibling = target.nextSibling;
                while (blockSibling) {
                    if (ViperUtil.isBlockElement(blockSibling) === true) {
                        break;
                    } else if (blockSibling.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(blockSibling.data) !== '') {
                        blockSibling = null;
                        break;
                    }

                    blockSibling = blockSibling.nextSibling;
                }

                if (!blockSibling) {
                    blockSibling = document.createElement('p');
                    ViperUtil.setHtml(blockSibling, '&nbsp;');
                    ViperUtil.insertAfter(target, blockSibling);
                } else if (ViperUtil.getHtml(blockSibling) === '') {
                    ViperUtil.setHtml(blockSibling, '&nbsp;');
                }

                var range      = self.viper.getViperRange();
                var selectable = range._getFirstSelectableChild(blockSibling);
                if (!selectable) {
                    selectable = document.createTextNode(' ');
                    if (blockSibling.firstChild) {
                        ViperUtil.insertBefore(blockSibling.firstChild, selectable);
                    } else {
                        blockSibling.appendChild(selectable);
                    }
                }

                range.setStart(selectable, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
                return false;
            });

        },

        handleJustify: function(type)
        {
            if (this._selectedImage) {
                this._handleImageJustify(this._selectedImage, type);
                return;
            }

            var range = this.viper.getViperRange();

            var start = range.startContainer;
            var end   = range.endContainer;
            var node  = start;
            var next  = null;

            var common = this.viper.getNodeSelection();
            if (!common) {
                common = range.getCommonElement();
                common = this.getFirstBlockParent(common);
            }

            if (ViperUtil.isBlockElement(common) === true
                && ViperUtil.inArray(ViperUtil.getTagName(common), ['tr', 'table']) === false
                && ViperUtil.isChildOf(common, this.viper.element) === true
            ) {
                this.toggleJustify(common, type);
            } else {
                var parent       = null;
                var bookmark     = null;
                var elemsBetween = [];

                if (range.collapsed !== true || ViperUtil.isStubElement(start) === false) {
                    bookmark     = this.viper.createBookmark();
                    elemsBetween = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
                } else {
                    elemsBetween = ViperUtil.getElementsBetween(start, end);
                    elemsBetween.unshift(start);
                    elemsBetween.push(end);
                }

                var toggleAlignment = true;
                var parentElements  = [];
                while (node = elemsBetween.shift()) {
                    if (ViperUtil.isBlockElement(node) === true) {
                        if (ViperUtil.getStyle(node, 'text-align') !== type) {
                            toggleAlignment = false;
                        }

                        if (ViperUtil.inArray(node, parentElements) === false) {
                            parentElements.push(node);
                        }

                        parent = null;
                    } else if (parent === null && (parent = this.getFirstBlockParent(node))) {
                        // If we havent found a good parent and the node's parent is a block
                        // element then set the style of that parent.
                        if (ViperUtil.getStyle(parent, 'text-align') !== type) {
                            toggleAlignment = false;
                        }

                        if (ViperUtil.inArray(parent, parentElements) === false) {
                            parentElements.push(parent);
                        }

                        parent = null;
                    } else if (node.nodeType == ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(node.data)) === true) {
                        continue;
                    } else {
                        // This is not a block element so we need to insert
                        // this element and all of its non-block siblings to a
                        // new P element.
                        if (parent === null) {
                            parent = Viper.document.createElement('p');

                            // Insert the new P tag before this node.
                            ViperUtil.insertBefore(node, parent);
                        }

                        if (ViperUtil.getStyle(parent, 'text-align') !== type) {
                            toggleAlignment = false;
                        }

                        // Add the node to the new P elem.
                        parent.appendChild(node);

                        if (ViperUtil.inArray(parent, parentElements) === false) {
                            parentElements.push(parent);
                        }
                    }//end if

                    if (node === end) {
                        break;
                    }
                }//end while

                for (var i = 0; i < parentElements.length; i++) {
                    this.toggleJustify(parentElements[i], type, !toggleAlignment);
                }

                if (bookmark !== null) {
                    this.viper.selectBookmark(bookmark);
                }
            }//end if

            this.viper.focus();
            this.viper.contentChanged();

        },

        toggleJustify: function(node, type, force)
        {
            var current = node.style.textAlign;
            if (force !== true && current === type) {
                ViperUtil.setStyle(node, 'text-align', '');

                if (ViperUtil.hasAttribute(node, 'style') === true
                    && node.getAttribute('style') === ''
                ) {
                    node.removeAttribute('style');
                }
            } else {
                ViperUtil.setStyle(node, 'text-align', type);
            }

        },

        _handleImageJustify: function(image, type)
        {
            if (!image || type === 'block') {
                return;
            }

            var currentType = this._getImageJustify(image);
            if (currentType === type) {
                type = null;
            }

            this.viper.fireCallbacks('ViperCoreStylesPlugin:beforeImageUpdate', image);

            switch (type) {
                case 'left':
                    ViperUtil.setStyle(image, 'float', 'left');
                    ViperUtil.setStyle(image, 'margin', '1em 1em 1em 0px');
                    ViperUtil.setStyle(image, 'display', '');
                break;

                case 'right':
                    ViperUtil.setStyle(image, 'float', 'right');
                    ViperUtil.setStyle(image, 'margin', '1em 0px 1em 1em');
                    ViperUtil.setStyle(image, 'display', '');
                break;

                case 'center':
                    ViperUtil.setStyle(image, 'margin', '1em auto');
                    ViperUtil.setStyle(image, 'float', '');
                    ViperUtil.setStyle(image, 'display', 'block');
                break;

                default:
                    ViperUtil.setStyle(image, 'margin', '');
                    ViperUtil.setStyle(image, 'float', '');
                    ViperUtil.setStyle(image, 'display', '');
                break;
            }//end switch

            if (image.getAttribute('style') === '') {
                image.removeAttribute('style');
            }

            // Reset button status.
            var types = ['left', 'center', 'right', 'block'];
            var c     = types.length;
            this.viper.Tools.getItem('justify').setIconClass('Viper-justifyLeft');
            this.viper.Tools.setButtonInactive('justify');
            for (var i = 0; i < c; i++) {
                this.viper.Tools.setButtonInactive('ViperCoreStylesPlugin:vtp:' + types[i]);
            }

            this.viper.Tools.disableButton('ViperCoreStylesPlugin:vtp:block');

            if (type !== null) {
                this.viper.Tools.setButtonActive('ViperCoreStylesPlugin:vtp:' + type);
                this.viper.Tools.getItem('justify').setIconClass('Viper-justify' + ViperUtil.ucFirst(type));
            } else {
                this.viper.Tools.getItem('justify').setIconClass('Viper-justifyLeft');
            }

            this.viper.Tools.setButtonActive('justify');

            this.viper.contentChanged();

            this.viper.fireCallbacks('ViperCoreStylesPlugin:afterImageUpdate', image);

        },

        _getImageJustify: function(image)
        {
            if (!image) {
                return null;
            }

            var type  = '';
            var imgFloat = ViperUtil.getStyle(image, 'float');
            if (imgFloat === 'left') {
                type = 'left';
            } else if (imgFloat === 'right') {
                type = 'right';
            } else if (ViperUtil.getStyle(image, 'display') === 'block') {
                type = 'center';
            }

            return type;

        },

        handleHR: function()
        {
            var hr = document.createElement('hr');
            this.viper.HistoryManager.begin();

            var range = this.viper.getViperRange();
            if (range.collapsed !== true) {
                range.deleteContents();
                range = this.viper.getViperRange();
            }

            if (ViperUtil.isBrowser('msie') === true
                && range.startContainer
                && range.collapsed === true
                && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && (ViperUtil.getHtml(range.startContainer.parentNode) === ''
                    || ViperUtil.getHtml(range.startContainer.parentNode) === '&nbsp;')
            ) {
                var prev = range.startContainer.parentNode;
            } else {
                if (!range.startContainer.previousSibling
                    && range.collapsed === true
                    && range.startOffset === 0
                    && ViperUtil.isBlockElement(range.startContainer.parentNode) === true
                ) {
                    // At the start of a block element. Insert the HR before the block parent.
                    ViperUtil.insertBefore(range.startContainer.parentNode, hr);
                    this.viper.HistoryManager.end();
                    this.viper.fireSelectionChanged(range, true);
                    return;
                } else {
                    var prev = this.viper.getKeyboardHandler().splitAtRange(true, null);
                    if (ViperUtil.isTag(prev, 'br') === true && prev.nextSibling === null && prev.previousSibling === null) {
                        prev = prev.parentNode;
                        var prevElemSib = prev.previousElementSibling;
                        if (ViperUtil.isTag(prevElemSib, ['ul', 'ol', 'table']) === true) {
                            // Remove the blank paragraph if its after these tags.
                            ViperUtil.remove(prev);
                            prev = prevElemSib;
                        }
                    }
                }
            }

            var nextSibling = prev.nextSibling;
            var blockTag    = this.viper.getDefaultBlockTag();

            ViperUtil.insertAfter(prev, hr);

            if (ViperUtil.isTag(nextSibling, 'br') === true) {
                ViperUtil.remove(nextSibling);
                nextSibling = prev.nextSibling.nextSibling;
            } else if (!nextSibling || (ViperUtil.isBlockElement(nextSibling) === false && blockTag !== '')) {
                var p = document.createElement(blockTag);
                ViperUtil.setHtml(p, '&nbsp;');
                ViperUtil.insertAfter(hr, p);
                nextSibling = p;
            } else {
                if (ViperUtil.trim(ViperUtil.getNodeTextContent(nextSibling)) === '' && ViperUtil.elementIsEmpty(nextSibling) === true) {
                    if (!nextSibling.nextElementSibling || ViperUtil.isBlockElement(nextSibling.nextElementSibling) === false) {
                        if (ViperUtil.isStubElement(nextSibling) !== true) {
                            ViperUtil.setHtml(nextSibling, '&nbsp;');
                        }

                        var nextEmptyElem = nextSibling.nextSibling;
                        while (nextEmptyElem) {
                            if (ViperUtil.isBlockElement(nextEmptyElem) === true) {
                                var html = ViperUtil.getHtml(nextEmptyElem);
                                if (html === '' || html === '<br>' || html === '&nbsp;') {
                                    // This is an empty block element that is after the next sibling.. remove it..
                                    nextEmptyElem.parentNode.removeChild(nextEmptyElem);
                                }

                                break;
                            } else if (nextEmptyElem.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(nextEmptyElem.data) !== '') {
                                break;
                            }

                            nextEmptyElem = nextEmptyElem.nextSibling;
                        }
                    } else if (nextSibling.nextElementSibling) {
                        var delNode = nextSibling;
                        nextSibling = nextSibling.nextElementSibling;
                        ViperUtil.remove(delNode);
                    }
                } else if (range.startOffset === 0
                    && (ViperUtil.trim(ViperUtil.getNodeTextContent(prev)) === ''
                    ||  ViperUtil.getHtml(prev) === '&nbsp;')
                ) {
                    ViperUtil.remove(prev);
                }
            }//end if

            var range = this.viper.getViperRange();
            var selectable = range._getFirstSelectableChild(nextSibling);
            if (!selectable) {
                selectable = document.createTextNode('');
                if (nextSibling.firstChild) {
                    ViperUtil.insertBefore(nextSibling.firstChild, selectable);
                } else {
                    nextSibling.appendChild(selectable)
                }
            }

            range.setStart(selectable, 0);
            range.collapse(true);
            ViperSelection.addRange(range);

            if (nextSibling.previousSibling
                && nextSibling.previousSibling.nodeType === ViperUtil.TEXT_NODE
                && ViperUtil.trim(nextSibling.previousSibling.data) === ''
            ) {
                ViperUtil.remove(nextSibling.previousSibling);
            }

            this.viper.HistoryManager.end();
            this.viper.fireSelectionChanged(range, true);

        },

        getFirstBlockParent: function(elem)
        {
            if (ViperUtil.isBlockElement(elem) === true) {
                return elem;
            }

            // Get the parents of the start node.
            var parents = ViperUtil.getParents(elem);

            var parent = null;
            var pln    = parents.length;
            for (var i = 0; i < pln; i++) {
                parent = parents[i];
                if (parent === this.viper.element) {
                    return null;
                }

                if (ViperUtil.isBlockElement(parent) === true) {
                    return parent;
                }
            }

        },


        getAlignment: function(element)
        {
            var parent = this.getFirstBlockParent(element);
            if (parent !== null) {
                return ViperUtil.getStyle(parent, 'text-align');
            }

        },

        setAlignment: function(element, type)
        {
            ViperUtil.setStyle(element, 'text-align', type);

        },

        removeFormat: function()
        {
            var range = this.viper.getViperRange().cloneRange();
            range     = this.viper.adjustRange(range);

            var nodeSelection = range.getNodeSelection();
            var startNode     = null;
            var endNode       = null;
            var bookmark      = null;

            if (nodeSelection) {
                var sParents  = ViperUtil.getSurroundingParents(nodeSelection);
                if (sParents.length > 0 && sParents[(sParents.length - 1)] !== this.viper.getViperElement()) {
                    nodeSelection = sParents[(sParents.length - 1)];
                }
            }

            if (nodeSelection && nodeSelection === this.viper.getViperElement()) {
                nodeSelection = null;
            }

            if (!nodeSelection) {
                var startNode = range.getStartNode();
                if (ViperUtil.isChildOf(startNode, this.viper.element) === false) {
                    range.setStart(this.viper.element, 0);
                }

                var endNode = range.getEndNode();
                if (ViperUtil.isChildOf(endNode, this.viper.element) === false) {
                    range.setEnd(this.viper.element, this.viper.element.childNodes.length);
                }

                ViperSelection.addRange(range);
                bookmark = this.viper.createBookmark();

                // Get the parent block element of the bookmark so its styles are removed as well.
                startNode = ViperUtil.getFirstBlockParent(bookmark.start);
                if (ViperUtil.isChildOf(startNode, this.viper.element) === false) {
                    startNode = bookmark.start;
                }
            } else {
                bookmark  = this.viper.createBookmark();
                startNode = nodeSelection;
            }

            var stopElem = null
            if (nodeSelection) {
                stopElem = range._getLastSelectableChild(nodeSelection);
            }

            ViperUtil.walk(startNode, function(elem) {
                if (bookmark && elem === bookmark.end) {
                    return false;
                }

                var continueElement = null;
                if (!bookmark || elem !== bookmark.start) {
                    if (elem.nodeType === ViperUtil.ELEMENT_NODE) {
                        ViperUtil.removeAttr(elem, 'style');
                        ViperUtil.removeAttr(elem, 'class');

                        if (elem.attributes.length === 0 && ViperUtil.isTag(elem, 'span') === true) {
                            // Set the continueElement to be the first child of this element as it will be removed and
                            // we want to continue walking DOM from the first child element.
                            continueElement = elem.firstChild;
                            while (elem.firstChild) {
                                ViperUtil.insertBefore(elem, elem.firstChild);
                            }

                            ViperUtil.remove(elem);
                            if (nodeSelection === elem) {
                                return false;
                            }
                        }
                    }
                }

                if (nodeSelection && elem === stopElem) {
                    return false;
                }

                return continueElement;
            });

            if (bookmark) {
                this.viper.selectBookmark(bookmark);
            }

            var tags = this.styleTags.concat(['font', 'u', 'strike']);

            // Remove all formating tags.
            var tmpSpan = null;
            if (nodeSelection) {
                var tagName = ViperUtil.getTagName(nodeSelection);
                if (ViperUtil.inArray(tagName, tags) === true) {
                    // Bookmark the selection and wrap the node in to a tmp span incase the node it self gets removed.
                    bookmark = this.viper.createBookmark();
                    tmpSpan = document.createElement('span');
                    ViperUtil.insertBefore(nodeSelection, tmpSpan);
                    tmpSpan.appendChild(nodeSelection);
                }
            }

            var tln = tags.length;
            for (var i = 0; i < tln; i++) {
                this.viper.removeStyle(tags[i], tmpSpan);
            }

            if (tmpSpan) {
                while (tmpSpan.firstChild) {
                    ViperUtil.insertBefore(tmpSpan, tmpSpan.firstChild);
                }

                ViperUtil.remove(tmpSpan);
                this.viper.selectBookmark(bookmark);
            }

            if (ViperUtil.isBrowser('msie', '<11') === true && nodeSelection && !bookmark) {
                var self = this;
                setTimeout(function() {
                    ViperSelection.addRange(range);
                    self.viper.contentChanged();
                }, 10);
            } else {
                if (nodeSelection && this.viper.isOutOfBounds(nodeSelection) === false) {
                    range.selectNode(nodeSelection);
                    ViperSelection.addRange(range);
                }

                this.viper.contentChanged();

                if (nodeSelection
                    && ViperUtil.isTag(nodeSelection, 'table') === true
                    && (ViperUtil.isBrowser('chrome') === true || ViperUtil.isBrowser('safari') === true)
                ) {
                    // Webkit seems to fail to return the correct position for table
                    // range. Update position for specific table element and not range.
                    var inlineToolbar = this.viper.PluginManager.getPlugin('ViperInlineToolbarPlugin');
                    inlineToolbar.getToolbar().updatePosition(null, nodeSelection);
                }
            }

        },

        _wrapNodeWithActiveStyle: function(node, range)
        {
            if (!node || !this._onChangeAddStyle.length || !range) {
                return;
            }

            var origData = node.data;
            var style    = null;
            while (style = this._onChangeAddStyle.shift()) {
                var nodes = this.viper.splitNodeAtRange(style, range, true);

                if (ViperUtil.isTag(nodes.prevNode, style) === true || ViperUtil.isTag(nodes.nextNode, style) === true) {
                    if (this._onChangeAddStyle.length > 0) {
                        node.data = '';
                    } else {
                        node.data = origData;
                    }

                    // Removing styles..
                    if (nodes.midNode === null) {
                        // Create an empty text node in between two new nodes.
                        ViperUtil.insertAfter(nodes.prevNode, node);
                    } else if (nodes.midNode.nodeType === ViperUtil.TEXT_NODE) {
                        nodes.midNode.data = node.data + nodes.midNode.data;
                        node = nodes.midNode;
                    } else {
                        // Find the last node and insert the text node there..
                        var tmpnode = nodes.midNode;
                        while (tmpnode.firstChild) {
                            tmpnode = tmpnode.firstChild;
                        }

                        tmpnode.appendChild(node);
                    }

                    // Make sure nextNode is not empty.
                    if (ViperUtil.getNodeTextContent(nodes.nextNode).length === 0) {
                        ViperUtil.remove(nodes.nextNode);
                    }

                    if ((!nodes.midNode
                        || !nodes.midNode.parentNode)
                        && (nodes.prevNode
                        && nodes.prevNode.parentNode)
                    ) {
                        ViperUtil.insertAfter(nodes.prevNode, node);
                    }

                    var emptyTextNode = null;
                    while (emptyTextNode = node.nextSibling) {
                        if (emptyTextNode.nodeType === ViperUtil.TEXT_NODE
                            && emptyTextNode.data.length === 0
                        ) {
                            ViperUtil.remove(emptyTextNode);
                        } else {
                            break;
                        }
                    }

                    if (!node.nextSibling && node.nodeType === ViperUtil.TEXT_NODE) {
                        ViperUtil.insertAfter(node, document.createElement('br'));
                    }

                    if (node.data.length > 0) {
                        range.setEnd(node, 1);
                    } else {
                        range.setEnd(node, 0);
                    }

                    range.collapse(false);
                    ViperSelection.addRange(range);
                } else {
                    // Start a new style tag.
                    var styleTag = Viper.document.createElement(style);

                    if (nodes.prevNode) {
                        this.viper.insertAfter(nodes.prevNode, styleTag);
                    } else if (nodes.nextNode) {
                        this.viper.insertBefore(nodes.nextNode, styleTag);
                    }

                    var offset = 1;
                    if (this._onChangeAddStyle.length > 0) {
                        node.data = '';
                        offset = 0;
                    } else {
                        node.data = origData;
                    }

                    styleTag.appendChild(node);

                    range.setStart(node, offset);
                    range.collapse(true);
                    ViperSelection.addRange(range);
                }//end if
            }

            return false;

        },

        handleStyle: function(style)
        {
            // Determine if we need to apply or remove the styles.
            var range = this.viper.getViperRange();

            if (range.collapsed === true) {
                // Range is collapsed. We need to listen for next insertion.
                var index = ViperUtil.arraySearch(style, this._onChangeAddStyle);
                if (index >= 0) {
                    ViperUtil.removeArrayIndex(this._onChangeAddStyle, index);
                    this.viper.Tools.setButtonInactive(this._buttons[style]);
                } else {
                    this._onChangeAddStyle.push(style);

                    var button = this.viper.Tools.getItem(this._buttons[style]);
                    if (button) {
                        if (button.isActive() === true) {
                            this.viper.Tools.setButtonInactive(this._buttons[style]);
                        } else {
                            this.viper.Tools.setButtonActive(this._buttons[style]);
                        }
                    }

                    // Do not allow sub & sup to be applied at the same time.
                    if (style === 'sup') {
                        this.viper.Tools.disableButton(this._buttons['sub']);
                    } else if (style === 'sub') {
                        this.viper.Tools.disableButton(this._buttons['sup']);
                    }
                }
                return false;
            }

            var selectedNode = range.getNodeSelection(null, true);
            var startNode    = null;
            var endNode      = null;
            var viperElement = this.viper.getViperElement();

            if (!selectedNode) {
                startNode = range.getStartNode();
                endNode   = range.getEndNode();
            } else {
                startNode = selectedNode;
            }

            if (!endNode) {
                endNode = startNode;
            } else if (endNode.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isBrowser('msie') === true) {
                endNode = range._getLastSelectableChild(endNode);
                range.setEnd(endNode, endNode.data.length);
                ViperSelection.addRange(range);
            }

            var commonParent = range.getCommonElement();

            if (startNode === endNode
                && ((startNode === viperElement)
                || (startNode.nodeType === ViperUtil.TEXT_NODE
                && ViperUtil.trim(startNode.data) === ''
                && startNode === viperElement.firstChild))
            ) {
                // Whole content is selected.
                startNode = range._getFirstSelectableChild(viperElement);
                endNode   = range._getLastSelectableChild(viperElement);

                if (ViperUtil.getParents(startNode, style, viperElement).length > 0
                    && ViperUtil.getParents(endNode, style, viperElement).length > 0
                ) {
                    // Selection is inside the style tags. Remove styles.
                    this.viper.removeStyle(style);
                    this.viper.contentChanged(false, this.viper.adjustRange());
                    return;
                }
            }

            if (ViperUtil.isTag(commonParent, style) === true
                || ViperUtil.isTag(startNode, style) === true
                || (ViperUtil.getParents(startNode, style).length > 0
                && ViperUtil.getParents(endNode, style).length > 0)
                || (selectedNode && this._getWholeStyleSelections(selectedNode, [style], []).length > 0)
            ) {
                // This selection is already styles, remove it.
                this.viper.removeStyle(style);
                this.viper.contentChanged();
                return false;
            }

            this.viper.HistoryManager.begin();

            // Apply the new tag.
            this.applyTag(style);

            this.viper.contentChanged();
            this.viper.HistoryManager.end();

            // Prevent event bubbling etc.
            return false;

        },

        getStyleTags: function()
        {
            var range = this.viper.getViperRange();
            var tags  = ViperUtil.getParents(range.startContainer, this.styleTags.join(','));
            return tags;

        },

        applyTag: function(tag)
        {
            this.viper.HistoryManager.begin();
            this.viper.surroundContents(tag);
            this.viper.HistoryManager.end();

        },

        _canStyleNode: function(node, topBar)
        {
            if (topBar === true) {
                if (this._selectedImage || ViperUtil.isTag(node, 'img') === true) {
                    return false;
                }

                return true;
            }

            var tagName = ViperUtil.getTagName(node);
            if (ViperUtil.isBlockElement(node) === true) {
                if (ViperUtil.isTag(node, 'li') !== true
                    && ViperUtil.isTag(node, 'td') !== true
                    && ViperUtil.isTag(node, 'th') !== true
                    && ViperUtil.isTag(node, 'img') !== true
                ) {
                    return false;
                }
            } else {
                var tagNames = ['thead', 'tfoot'];
                if (ViperUtil.inArray(tagName, tagNames) === true) {
                    return false;
                }
            }

            return true;

        },

        _createInlineToolbarContent: function(toolbar)
        {
            var self        = this;
            var tools       = this.viper.Tools;
            var buttonGroup = tools.createButtonGroup('ViperCoreStylesPlugin:vitp:btnGroup');

            tools.createButton('vitpBold', '', _('Bold'), 'Viper-bold', function() {
                return self.handleStyle('strong');
            });
            tools.createButton('vitpItalic', '', _('Italic'), 'Viper-italic', function() {
                return self.handleStyle('em');
            });

            tools.addButtonToGroup('vitpBold', 'ViperCoreStylesPlugin:vitp:btnGroup');
            tools.addButtonToGroup('vitpItalic', 'ViperCoreStylesPlugin:vitp:btnGroup');

            toolbar.addButton(buttonGroup);

        },

        _updateInlineToolbar: function(data)
        {
            if (data.range.collapsed === true) {
                return;
            }

            if (this._canStyleNode(data.lineage[data.current]) !== true) {
                this._selectedImage = null;
                return;
            } else if (ViperUtil.isTag(data.lineage[data.current], 'img') === true) {
                this.viper.Tools.disableButton('ViperCoreStylesPlugin:vtp:block');
                this._selectedImage = data.lineage[data.current];
                return;
            }

            this.viper.Tools.setButtonInactive('vitpBold');
            this.viper.Tools.setButtonInactive('vitpItalic');

            var selectedNode = data.range.getNodeSelection();

            // List of tags where the bold and italic icons will not be shown if they are part or inside of the selection.
            var ignoredTags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
            if (!selectedNode) {
                ignoredTags.push('a');
            } else {
                switch (ViperUtil.getTagName(selectedNode)) {
                    case 'a':
                    case 'strong':
                    case 'em':
                        // For these cases do not add the A tag.
                    break;

                    default:
                        ignoredTags.push('a');
                    break;
                }
            }

            var activeStates = {};
            for (var i = 0; i < data.lineage.length; i++) {
                var tagName = ViperUtil.getTagName(data.lineage[i]);
                if (ViperUtil.inArray(tagName, ignoredTags) === true) {
                    // Dont want to show style buttons for these tags.
                    return;
                } else if (tagName === 'strong') {
                    this.viper.Tools.setButtonActive('vitpBold');
                } else if (tagName === 'em') {
                    this.viper.Tools.setButtonActive('vitpItalic');
                }
            }

            // If the selection is between multiple elements then find out if the range
            // start and end are in same style tags.
            var tagNames  = ['strong', 'em'];
            var states    = this._getActiveStates(data.range, tagNames);
            for (var i = 0; i < states.length; i++) {
                var tagName = states[i];
                if (tagName === 'strong') {
                    this.viper.Tools.setButtonActive('vitpBold');
                } else if (tagName === 'em') {
                    this.viper.Tools.setButtonActive('vitpItalic');
                }
            }

            data.toolbar.showButton('vitpBold');
            data.toolbar.showButton('vitpItalic');

        },

        _updateToolbarButtonStates: function(buttons, range)
        {
            range = range || this.viper.getViperRange();

            var startNode = this.viper.getNodeSelection();
            if (!startNode) {
                startNode = range.getStartNode();
            }

            if (!startNode) {
                startNode = range.startContainer;
            }

            var endNode = range.getEndNode()
            if (!endNode) {
                endNode = range.endContainer;
            }

            var tools = this.viper.Tools;
            if (this._canStyleNode(startNode, true) !== true) {
                for (var btn in buttons) {
                    if (btn === 'justify' || btn === 'removeFormat') {
                        continue;
                    }

                    var c = buttons[btn].length;
                    for (var i = 0; i < c; i++) {
                        var buttonName = this._buttons[buttons[btn][i]] || 'ViperCoreStylesPlugin:vtp:' + buttons[btn][i];
                        tools.disableButton(buttonName);
                    }
                }

                if (this._selectedImage) {
                    // Enable justify icon for selected image.
                    var type = this._getImageJustify(this._selectedImage);
                    tools.enableButton('justify');

                    var types = ['left', 'center', 'right', 'block'];
                    var c     = types.length;
                    tools.getItem('justify').setIconClass('Viper-justifyLeft');
                    tools.setButtonInactive('justify');
                    for (var i = 0; i < c; i++) {
                        tools.setButtonInactive('ViperCoreStylesPlugin:vtp:' + types[i]);
                    }

                    if (type) {
                        tools.setButtonActive('ViperCoreStylesPlugin:vtp:' + type);
                        tools.getItem('justify').setIconClass('Viper-justify' + ViperUtil.ucFirst(type));
                        tools.setButtonActive('justify');
                    }
                }

                return;
            }

            var tagNames = [];
            var c        = buttons.styles.length;
            for (var i = 0; i < c; i++) {
                tools.enableButton(this._buttons[buttons.styles[i]]);
                tools.setButtonInactive(this._buttons[buttons.styles[i]]);
                tagNames.push(buttons.styles[i]);
            }

            // Do not allow sub & sup to be applied at the same time.
            if (ViperUtil.isTag(range.startContainer, 'sub') === true || ViperUtil.isTag(range.endContainer, 'sub') === true) {
                tools.disableButton(this._buttons['sup']);
            } else if (ViperUtil.isTag(range.startContainer, 'sup') === true || ViperUtil.isTag(range.endContainer, 'sup') === true) {
                tools.disableButton(this._buttons['sub']);
            } else {
                // Check parents.
                var elems = [range.startContainer, range.endContainer];
                while (elems.length > 0) {
                    var elem        = elems.shift();
                    var subParents  = ViperUtil.getParents(elem, null, this.viper.getViperElement());
                    for (var i = 0; i < subParents.length; i++) {
                        var tagName = ViperUtil.getTagName(subParents[i]);
                        if (tagName === 'sub') {
                            tools.disableButton(this._buttons['sup']);
                            break;
                        } else if (tagName === 'sup') {
                            tools.disableButton(this._buttons['sub']);
                            break;
                        }
                    }
                }
            }

            // Active states.
            var states = this._getActiveStates(range, tagNames);
            for (var i = 0; i < states.length; i++) {
                tools.setButtonActive(this._buttons[states[i]]);
            }

            if (range.collapsed === false) {
                tools.enableButton('removeFormat');
            } else {
                tools.disableButton('removeFormat');
            }

            var hasParent = true;
            if (!ViperUtil.getFirstBlockParent(startNode, null, true)
                || !ViperUtil.getFirstBlockParent(endNode, null, true)
            ) {
                hasParent = false;
            }

            if (hasParent) {
                tools.enableButton('justify');

                if (!states.alignment) {
                    states.alignment = 'start';
                }

                if (states.alignment) {
                    var justify       = states.alignment;
                    var c             = buttons.justify.length;
                    var toolbarButton = tools.getItem('justify');
                    toolbarButton.setIconClass('Viper-justifyLeft');

                    if (justify === 'justify') {
                        justify = 'block';
                    }

                    var setToggleInactive = true;
                    for (var i = 0; i < c; i++) {
                        tools.enableButton('ViperCoreStylesPlugin:vtp:' + buttons.justify[i]);

                        if (buttons.justify[i] === justify) {
                            tools.setButtonActive('ViperCoreStylesPlugin:vtp:' + buttons.justify[i]);
                            toolbarButton.setIconClass('Viper-justify' + ViperUtil.ucFirst(justify));
                            tools.setButtonActive('justify');
                            setToggleInactive = false;
                        } else {
                            tools.setButtonInactive('ViperCoreStylesPlugin:vtp:' + buttons.justify[i]);
                        }
                    }

                    if (setToggleInactive === true) {
                        tools.setButtonInactive('justify');
                    }
                }//end if
            } else {
                tools.disableButton('justify');
            }

            var enableHr     = true;
            var hrIgnoreTags = 'tr,td,th,li,caption,img,ul,ol,table';
            if (ViperUtil.inArray(ViperUtil.getTagName(startNode), hrIgnoreTags.split(',')) === true) {
                enableHr = false;
            }

            if (enableHr === true) {
                var parents = ViperUtil.getParents(startNode, hrIgnoreTags, this.viper.getViperElement());
                if (parents.length > 0) {
                    enableHr = false;
                }
            }

            if (enableHr === true) {
                tools.enableButton('hr');
            } else {
                tools.disableButton('hr');
            }

        },

        _getActiveStates: function(range, tagNames)
        {
            var activeStates = [];
            var selectedNode = range.getNodeSelection(null, true);
            var startNode    = null;
            var endNode      = null;

            if (!selectedNode) {
                startNode = range.getStartNode();
                endNode   = range.getEndNode();
            } else if (selectedNode === this.viper.getViperElement()) {
                startNode = range._getFirstSelectableChild(selectedNode);
                endNode   = range._getLastSelectableChild(selectedNode);
            } else {
                startNode = selectedNode;
            }

            if (!endNode) {
                endNode = startNode;
            }

            if (startNode && endNode) {
                var viperElement = this.viper.getViperElement();

                if (startNode === endNode && startNode === viperElement) {
                    startNode = range._getFirstSelectableChild(viperElement);
                    endNode   = range._getLastSelectableChild(viperElement);
                    if (!startNode) {
                        return activeStates;
                    }
                }

                // Justify state.
                activeStates.alignment = null;

                var startParent = null;
                if (!selectedNode || selectedNode === viperElement || ViperUtil.isBlockElement(selectedNode) === false) {
                    startParent = ViperUtil.getFirstBlockParent(startNode, null, true);
                } else {
                    startParent = selectedNode;
                }

                if (startNode !== endNode) {
                    var endParent = endNode;
                    if (endNode !== viperElement) {
                        endParent = ViperUtil.getFirstBlockParent(endNode, null, true);
                    }

                    if (startParent && endParent) {
                        var elems     = ViperUtil.getElementsBetween(startParent, endParent);
                        elems.unshift(startParent);
                        elems.push(endParent);
                        var c         = elems.length;
                        for (var i = 0; i < c; i++) {
                            if (elems[i].nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isBlockElement(elems[i]) === true) {
                                var alignment = elems[i].style.textAlign;
                                if (activeStates.alignment !== null && alignment !== activeStates.alignment) {
                                    activeStates.alignment = null;
                                    break;
                                } else {
                                    activeStates.alignment = alignment;
                                }
                            }
                        }
                    }
                } else if (startParent && startParent.style) {
                    activeStates.alignment = startParent.style.textAlign;
                }//end if

                if (startNode === endNode
                    || (selectedNode && selectedNode !== viperElement)
                ) {
                    while (startNode
                        && ViperUtil.isBlockElement(startNode) !== true
                        && startNode !== this.viper.getViperElement()
                    ) {
                        var pos = ViperUtil.arraySearch(ViperUtil.getTagName(startNode), tagNames);
                        if (pos >= 0) {
                            activeStates.push(tagNames[pos]);
                        }

                        startNode = startNode.parentNode;
                    }

                    // Also check first and last selectable child of endNode (nodeSelection).
                    activeStates.concat(this._getWholeStyleSelections(endNode, tagNames, activeStates));
                } else {
                    var foundTags = [];
                    while (startNode
                        && ViperUtil.isBlockElement(startNode) !== true
                        && startNode !== this.viper.getViperElement()
                    ) {
                        var pos = ViperUtil.arraySearch(ViperUtil.getTagName(startNode), tagNames);
                        if (pos >= 0) {
                            foundTags.push(tagNames[pos]);
                        }

                        startNode = startNode.parentNode;
                    }

                    while (endNode
                        && ViperUtil.isBlockElement(endNode) !== true
                        && endNode !== this.viper.getViperElement()
                    ) {
                        var tagName = ViperUtil.getTagName(endNode);
                        var pos = ViperUtil.arraySearch(tagName, foundTags);
                        if (pos >= 0) {
                            activeStates.push(tagName);
                        }

                        endNode = endNode.parentNode;
                    }
                }//end if
            }//end if

            return activeStates;

        },

        _getWholeStyleSelections: function(parentNode, tagNames, parentStyles)
        {
            var range           = this.viper.getCurrentRange();
            var firstSelectable = range._getFirstSelectableChild(parentNode);
            var lastSelectable  = range._getLastSelectableChild(parentNode);
            var firstSelectableParents = [];
            var styles = parentStyles;
            if (firstSelectable && lastSelectable) {
                while (firstSelectable && firstSelectable.parentNode !== parentNode) {
                    var pos = ViperUtil.arraySearch(ViperUtil.getTagName(firstSelectable.parentNode), tagNames);
                    if (pos >= 0) {
                        firstSelectableParents.push(tagNames[pos]);
                    }

                    firstSelectable = firstSelectable.parentNode;
                }

                if (firstSelectableParents.length > 0) {
                    while (lastSelectable && lastSelectable.parentNode !== parentNode) {
                        var pos = ViperUtil.arraySearch(ViperUtil.getTagName(lastSelectable.parentNode), tagNames);
                        if (pos >= 0
                            && ViperUtil.inArray(tagNames[pos], firstSelectableParents) === true
                            && ViperUtil.inArray(tagNames[pos], styles) === false
                        ) {
                            styles.push(tagNames[pos]);
                        }

                        lastSelectable = lastSelectable.parentNode;
                    }
                }
            }

            return styles;

        },

        remove: function()
        {
            // Remove plugin buttons.
            this.viper.Tools.removeItem('ViperCoreStylesPlugin:vtp:stylesBtns');
            this.viper.Tools.removeItem('bold');
            this.viper.Tools.removeItem('italic');
            this.viper.Tools.removeItem('subscript');
            this.viper.Tools.removeItem('superscript');
            this.viper.Tools.removeItem('strikethrough');
            this.viper.Tools.removeItem('vitpBold');
            this.viper.Tools.removeItem('vitpItalic');
            this.viper.removeCallback(null, 'ViperCoreStylesPlugin');

        }


    };
})(Viper.Util, Viper.Selection, Viper._);



(function(ViperUtil, ViperSelection, _) {
    function ViperCursorAssistPlugin(viper)
    {
        this.viper = viper;
        this._dist = 30;

    }

    Viper.PluginManager.addPlugin('ViperCursorAssistPlugin', ViperCursorAssistPlugin);

    ViperCursorAssistPlugin.prototype = {

        init: function()
        {
            var self = this;
            var t    = null;
            var validElems      = 'table,hr,img,object,ul,ol,iframe,canvas,audio,embed,figure,pre,blockquote';
            var validElemsArray = validElems.split(',');
            var prevElement = null;
            var prevPos     = null;
            var hover       = false;

            var _removeLine = function(line, clearPrev) {
                if (line) {
                    ViperUtil.remove(line);
                }

                hover = false;
                if (clearPrev !== false) {
                    prevElement = null;
                    prevPos     = null;
                }
            };

            this.viper.registerCallback('Viper:editableElementChanged', 'ViperCursorAssistPlugin', function() {
                ViperUtil.addEvent(ViperUtil.getDocuments(), 'mousemove', function(e) {
                    clearTimeout(t);
                    t = setTimeout(function() {
                        var line = ViperUtil.getid(self.viper.getId() + '-cursorAssist');

                        if (self.viper.isEnabled() === false) {
                            if (line) {
                                _removeLine(line);
                            }

                            return;
                        }

                        var hoverElem = self.viper.getElementAtCoords(e.clientX, e.clientY);
                        if (hoverElem && (hover === true || hoverElem === line || (hoverElem.parentNode && hoverElem.parentNode.parentNode === line))) {
                            return;
                        }

                        if (!hoverElem || self.viper.isOutOfBounds(hoverElem) === true) {
                            _removeLine(line);
                            return;
                        }

                        if (ViperUtil.inArray(ViperUtil.getTagName(hoverElem), validElemsArray) !== true) {
                            var elems = ViperUtil.getParents(hoverElem, validElems, self.viper.getViperElement());
                            if (elems.length === 0) {
                                _removeLine(line);
                                return;
                            } else {
                                hoverElem = elems.shift();

                                if (elems.length > 0
                                    && (ViperUtil.isTag(hoverElem, 'ul') === true || ViperUtil.isTag(hoverElem, 'ol') === true)
                                ) {
                                    // Do not show the line if this is a nested list.
                                    if (ViperUtil.getParents(hoverElem, 'ul,ol', self.viper.getViperElement()).length > 0) {
                                        _removeLine(line);
                                        return;
                                    }
                                }
                            }
                        }

                        var sibling  = '';
                        var scroll   = ViperUtil.getScrollCoords();
                        var mousePos = (e.clientY + scroll.y);
                        var elemRect = ViperUtil.getBoundingRectangle(hoverElem);
                        var dist     = self._dist;
                        var childScrollCoords = {x:0, y:0};

                        if (self.viper.isEditableInIframe() === true) {
                            childScrollCoords = ViperUtil.getScrollCoords(hoverElem.ownerDocument.defaultView);
                            mousePos += childScrollCoords.y;
                        }

                        if (ViperUtil.isTag(hoverElem, 'table') === true
                            && ViperUtil.isBrowser('firefox') === true
                        ) {
                            // Firefox does not include the caption element's height as part of the table.
                            // Need to add it here.
                            var caption = ViperUtil.getTag('caption', hoverElem);
                            if (caption) {
                                elemRect.y2 += ViperUtil.$(caption[0]).outerHeight(true);
                            }
                        }

                        var height = (elemRect.y2 - elemRect.y1);

                        if (height < 40) {
                            dist = (height / 2);
                        }

                        var relYPoint = null;
                        if (elemRect.y1 + dist > mousePos) {
                            sibling = 'previousSibling';
                            relYPoint = elemRect.y1;
                        } else if (elemRect.y2 - dist < mousePos) {
                            sibling = 'nextSibling';
                            relYPoint = elemRect.y2;
                        } else {
                            _removeLine(line);
                            return;
                        }

                        if (prevElement === hoverElem && prevPos === sibling) {
                            return;
                        }

                        if (self.isInToolbarBounds(relYPoint) === true) {
                            return;
                        }

                        prevElement = hoverElem;
                        prevPos = sibling;
                        var inBetween = false;

                        var canShowLine = function(siblingType) {
                            // Check if the element after hoverElem is one of the valid elements or no next sibling.
                            var siblingElem = hoverElem[siblingType];
                            while (siblingElem) {
                                if (siblingElem.nodeType !== ViperUtil.TEXT_NODE) {
                                    if (ViperUtil.inArray(ViperUtil.getTagName(siblingElem), validElemsArray) !== true) {
                                        if (line) {
                                            _removeLine(line, false);
                                        }

                                        return false;
                                    } else {
                                        inBetween = true;
                                        return true;
                                    }
                                }

                                siblingElem = siblingElem[siblingType];
                            }

                            // No sibling found
                            return true;
                        }

                        if (canShowLine(sibling) !== true) {
                            return;
                        }

                        if (line) {
                            _removeLine(line, false);
                        }

                        line    = document.createElement('div');
                        line.id = self.viper.getId() + '-cursorAssist';
                        ViperUtil.addClass(line, 'ViperCursorAssistPlugin');
                        ViperUtil.setHtml(line, '<span class="ViperCursorAssistPlugin-cursorText">Insert</span><span class="ViperCursorAssistPlugin-cursorLine"></span>');
                        hover = false;

                        ViperUtil.hover(line, function() {
                            hover = true;
                        }, function() {
                            hover = false;
                        });

                        ViperUtil.addEvent(line, 'mousedown', function() {
                            _removeLine(line, false);

                            var p = document.createElement('p');

                            if (ViperUtil.isBrowser('msie', '<11') === true) {
                                ViperUtil.setHtml(p, '&nbsp;');
                            } else {
                                ViperUtil.setHtml(p, '<br/>');
                            }

                            // Use the block parent element of img, object etc.
                            if (ViperUtil.isBlockElement(hoverElem) === false || ViperUtil.isStubElement(hoverElem) === true) {
                                var blockParent = ViperUtil.getFirstBlockParent(hoverElem, self.viper.getViperElement());
                                if (blockParent) {
                                    hoverElem = blockParent;
                                }
                            }

                            if (sibling === 'previousSibling') {
                                ViperUtil.insertBefore(hoverElem, p);
                            } else {
                                ViperUtil.insertAfter(hoverElem, p);
                            }

                            setTimeout(function() {
                                if (ViperUtil.isBrowser('msie') === false) {
                                    self.viper.focus();
                                }

                                var range = self.viper.getCurrentRange();
                                var offset = 0;
                                if (ViperUtil.isBrowser('msie', '<11') === true) {
                                    offset = 1;
                                }

                                range.setEnd(p.firstChild, offset);
                                range.setStart(p.firstChild, offset);
                                range.collapse(false);
                                ViperSelection.addRange(range);

                                self.viper.contentChanged();
                            }, 10);
                        });

                        if (self.viper.isEditableInIframe() === true) {
                            childScrollCoords = ViperUtil.getScrollCoords(hoverElem.ownerDocument.defaultView);
                            elemRect.y1 -= childScrollCoords.y;
                            elemRect.y2 -= childScrollCoords.y;

                            var frameOffset = ViperUtil.getDocumentOffset(hoverElem.ownerDocument);
                            elemRect.y1 += frameOffset.y;
                            elemRect.y2 += frameOffset.y;
                            elemRect.x1 += frameOffset.x;
                            elemRect.x2 += frameOffset.x;

                        }

                        ViperUtil.removeClass(line, 'insertBetween');
                        if (sibling === 'previousSibling') {
                            ViperUtil.setStyle(line, 'top', elemRect.y1 + 'px');
                            ViperUtil.removeClass(line, 'insertAfter');

                            if (inBetween === true) {
                                ViperUtil.addClass(line, 'insertBetween');
                            } else {
                                ViperUtil.addClass(line, 'insertBefore');
                            }
                        } else {
                            ViperUtil.setStyle(line, 'top', elemRect.y2 + 'px');
                            ViperUtil.removeClass(line, 'insertBefore');

                            if (inBetween === true) {
                                ViperUtil.addClass(line, 'insertBetween');
                            } else {
                                ViperUtil.addClass(line, 'insertAfter');
                            }
                        }//end if

                        ViperUtil.setStyle(line, 'left', elemRect.x1 + 'px');
                        ViperUtil.setStyle(line, 'width', (elemRect.x2 - elemRect.x1) + 'px');
                        self.viper.addElement(line);

                        setTimeout(function() {
                            if (self.isInToolbarBounds(relYPoint) === true) {
                                _removeLine(line);
                                return;
                            }
                        }, 100)
                    }, 200);
                });
            });

            this.viper.registerCallback(['Viper:mouseDown', 'Viper:mouseUp'], 'ViperCursorAssistPlugin', function() {
                setTimeout(
                    function() {
                        var line = ViperUtil.getid(self.viper.getId() + '-cursorAssist');
                        if (line) {
                            _removeLine(line, false);
                        }
                    },
                    50
                );
            });

        },

        isInToolbarBounds: function(yPoint)
        {
            var gap             = 30;
            var visibleToolbars = this.viper.Tools.getVisibleToolbarRectangles();
            for (var i = 0; i < visibleToolbars.length; i++) {
                if (yPoint >= (visibleToolbars[i].y1 - gap) && yPoint <= (visibleToolbars[i].y2 + gap)) {
                    return true;
                }
            }

            return false;

        },

        isPluginElement: function(elem)
        {
            var viperid = this.viper.getId();
            if (elem.id === viperid + '-cursorAssist'
                || (elem.parentNode && elem.parentNode.id === viperid + '-cursorAssist')
            ) {
                return true;
            }

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperFormatPlugin(viper)
    {
        this.viper = viper;

        this.styleTags = {
            h1: _('Heading 1'),
            h2: _('Heading 2'),
            h3: _('Heading 3'),
            h4: _('Heading 4'),
            h5: _('Heading 5'),
            h6: _('Heading 6'),
            p: _('Paragraph'),
            pre: _('Preformatted'),
            address: _('Address'),
            blockquote: _('Quote')
        };

        this.toolbarPlugin   = null;
        this.activeStyles    = [];
        this._range          = null;
        this._inlineToolbar  = null;
        this._custStyles     = null;
        this._custStyleNames = null;
        this._popoutid       = null;
        this._styleListid    = 'ViperFormatPlugin-classList';
        this._stylePickerRow = [];
        this._stylesListElement = [];
        this._selectedNode = null;

        this._inlineToolbarActiveSubSection = null;

        this.initInlineToolbar();

    }

    Viper.PluginManager.addPlugin('ViperFormatPlugin', ViperFormatPlugin);

    ViperFormatPlugin.prototype = {

        init: function()
        {
            var self = this;

            // Main toolbar.
            this.toolbarPlugin = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (this.toolbarPlugin) {
                this._createToolbarContent();
            }

            this.viper.registerCallback('ViperTableEditorPlugin:initToolbar', 'ViperFormatPlugin', function(data) {
                self._createTableEditorContent(data.toolbar, data.type);
            });

            this.viper.registerCallback('ViperTableEditorPlugin:updateToolbar', 'ViperFormatPlugin', function(data) {
                self._updateTableEditorContent(data);
            });

        },

        setSettings: function (settings) {
            

            if (settings.styles && ViperUtil.isEmpty(settings.styles) === false) {
                this._custStyles = settings.styles;

                var items    = {};
                var expanded = {};
                for (var name in this._custStyles) {
                    var classNames = '';
                    var showFor    = '';
                    var hideFor    = '';
                    if (typeof this._custStyles[name] === 'string') {
                        classNames = this._custStyles[name].split(' ');
                    } else if (typeof this._custStyles[name] === 'object' && this._custStyles[name].classNames) {
                        // Extra settings provided for this style.
                        classNames = this._custStyles[name].classNames.split(' ');

                        // If the showFor settings is not a * (show for everything) then get the list of tags to show for.
                        // Note that showFor overrides the hideFor setting.
                        if (this._custStyles[name].showFor) {
                            if (this._custStyles[name].showFor === '*') {
                                showFor = '*';
                            } else {
                                showFor = this._custStyles[name].showFor.split(',');
                            }
                        }

                        // Hide for setting.
                        if (this._custStyles[name].hideFor) {
                            if (this._custStyles[name].hideFor === '*') {
                                hideFor = '*';
                            } else {
                                hideFor = this._custStyles[name].hideFor.split(',');
                            }
                        }
                    } else {
                        continue;
                    }

                    items[classNames.join(' ')] = name;

                    expanded[classNames.join(' ')] = {
                        classNames: classNames,
                        showFor: showFor,
                        hideFor: hideFor
                    }
                }

                this._custStyleNames = items;
                this._custStyles     = expanded;

                var self  = this;
                var tools = this.viper.Tools;

                // If there is a list already remove it.
                var listElement = tools.getItem(this._styleListid);
                if (listElement) {
                    ViperUtil.remove(listElement.element);
                }

                var listElement = tools.createSelectionList(
                    this._styleListid,
                    items,
                    function () {
                        // When the item is clicked update the main styles list.
                        self._updateDefinedStylesList();
                    }
                );

                var panel = this.viper.Tools.getItem(this._popoutid);
                if (!panel) {
                    return;
                }

                panel.element.appendChild(listElement);
            }//end if

        },

        _getHeadingsSection: function(prefix)
        {
            var self   = this;
            var tools  = this.viper.Tools;

            // Headings format section.
            var headingsSubSection = document.createElement('div');

            var headingBtnGroup = tools.createButtonGroup(prefix + 'headingFormats');
            headingsSubSection.appendChild(headingBtnGroup);

            for (var i = 1; i <= 6; i++) {
                (function(headingCount) {
                    tools.createButton(prefix + 'heading:h' + headingCount, 'H' + headingCount, ViperUtil.sprintf(_('Convert to Heading %s'), headingCount), null, function() {
                        self.handleFormat('h' + headingCount);
                    });
                    tools.addButtonToGroup(prefix + 'heading:h' + headingCount, prefix + 'headingFormats');
                }) (i);
            }//end for

            return headingsSubSection;

        },

        _getFormatsSection: function(prefix)
        {
            var self   = this;
            var tools  = this.viper.Tools;

            var formatsSubSection = document.createElement('div');
            var formatButtons = {
                p: 'P',
                div: 'DIV',
                blockquote: 'Quote',
                pre: 'PRE'
            };

            for (var tag in formatButtons) {
                (function(tagName) {
                    var button = tools.createButton(prefix + 'formats:' + formatButtons[tagName], formatButtons[tagName], ViperUtil.sprintf(_('Convert to %s'), formatButtons[tagName]), null, function() {
                        self.handleFormat(tagName);
                    });
                    formatsSubSection.appendChild(button);
                })
                (tag);
            }

            return formatsSubSection;

        },

        _getAnchorSection: function(prefix)
        {
            var self  = this;
            var tools = this.viper.Tools;

            var anchorSubContent = document.createElement('div');
            var idTextbox = tools.createTextbox(prefix + 'anchor:input', _('ID'), '');
            anchorSubContent.appendChild(idTextbox);

            return anchorSubContent;

        },

        _getClassSection: function(prefix, element)
        {
            var self  = this;
            var tools = this.viper.Tools;

            var classSubContent = document.createElement('div');

            this._createDefinedStylesBlock(classSubContent, prefix);

            var classTextbox = tools.createTextbox(prefix + 'class:input', _('Class'), '');
            classSubContent.appendChild(classTextbox);

            return classSubContent;

        },

        
        _createDefinedStylesBlock: function(classSubContentElement, prefix) {
            var tools          = this.viper.Tools;
            var stylePicker    = document.createElement('div');
            var stylePickerRow = tools.createRow(prefix + 'customStyles', 'ViperUtil-hidden');

            // Create a row that will be shown when there are defined styles.
            // Note that multiple of these elements will be created due to multiple toolbars.
            stylePickerRow.appendChild(stylePicker);
            ViperUtil.addClass(stylePicker, 'ViperFormatPlugin-stylePickerButton');
            ViperUtil.setHtml(stylePicker, _('Choose Styles'));
            classSubContentElement.appendChild(stylePickerRow);
            this._stylePickerRow.push(stylePickerRow);

            var stylesListElement = document.createElement('div');
            ViperUtil.addClass(stylesListElement, 'ViperFormatPlugin-stylesList');
            stylePickerRow.appendChild(stylesListElement);
            this._stylesListElement.push(stylesListElement);

            ViperUtil.addEvent(
                stylesListElement,
                'click',
                function(e) {
                    if (ViperUtil.hasClass(e.target, 'ViperFormatPlugin-styleListItem-remove') === true) {
                        // Remove defined style.
                        tools.getItem(self._styleListid).removeFromSelection(ViperUtil.attr(e.target, 'data-id'));
                        self._updateDefinedStylesList();
                    }
                }
            );

            var title = document.createElement('div');
            ViperUtil.addClass(title, 'ViperFormatPlugin-stylePicker-title');
            ViperUtil.setHtml(title, _('Custom Class'));
            stylePickerRow.appendChild(title);

            if (!this._popoutid) {
                var classList = document.createElement('div');
                ViperUtil.addClass(classList, 'ViperFormatPlugin-classList');

                this._popoutid = this.viper.getId() + '-ViperFormatPlugin-classPopout';
                tools.createPopoutPanel(this._popoutid, classList);

                this.viper.registerCallback(
                    ['ViperToolbar:subsectionClosed', 'ViperToolbarPlugin:bubbleClosed'],
                    'ViperFormatPlugin',
                    function(sectionid) {
                        if (sectionid.indexOf('ViperFormatPlugin:') === 0
                           || sectionid.indexOf('ViperTableEditor-Format-') === 0
                        ) {
                            tools.getItem(self._popoutid).hide();
                        }
                    }
                );
            }

            var self = this;
            var popout = tools.getItem(self._popoutid);
            ViperUtil.addEvent(
                stylePicker,
                'click',
                function() {
                    if (popout.isOpen() !== true) {
                        popout.show(stylePicker);
                    } else {
                        popout.hide();
                    }
                }
            );

            this.viper.registerCallback(
                'Viper:editableElementChanged',
                'ViperFormatPlugin-stylePicker',
                function() {
                    var elemDoc = self.viper.getViperElementDocument();
                    if (elemDoc !== document) {
                        ViperUtil.removeEvent(elemDoc.defaultView, 'scroll.ViperFormatPlugin-stylePicker');
                        ViperUtil.addEvent(
                            elemDoc.defaultView,
                            'scroll.ViperFormatPlugin-stylePicker',
                            function(e) {
                                if (popout.isOpen() === true) {
                                    popout.hide();
                                }
                            }
                        );
                    }//end if
                }
            );

        },

        _getToolbarContents: function(toolbarType)
        {
            var prefix = 'ViperFormatPlugin:' + toolbarType + ':';

            return {
                headings: this._getHeadingsSection(prefix),
                formats: this._getFormatsSection(prefix),
                anchor: this._getAnchorSection(prefix),
                cssClass: this._getClassSection(prefix)
            }

        },

        getNodeWithAttributeFromRange: function(attributeName, node)
        {
            if (!attributeName) {
                return null;
            }

            var range        = this.viper.getViperRange();
            var selectedNode = node || range.getNodeSelection();
            if (selectedNode
                && selectedNode.nodeType === ViperUtil.ELEMENT_NODE
                && selectedNode !== this.viper.getViperElement()
                && ViperUtil.hasAttribute(selectedNode, attributeName) === true
            ) {
                return selectedNode;
            }

            return null;

        },

        _getAttributeValue: function(attribute, node)
        {
            if (!node) {
                return '';
            }

            node = this.getNodeWithAttributeFromRange(attribute, node);
            if (node) {
                var value = this.viper.getAttribute(node, attribute);
                if (attribute === 'class') {
                    value = this._removeViperHighlightClass(value);
                }

                return value;
            }

            return '';

        },

        getTagFromRange: function(range, tagNames)
        {
            var c = tagNames.length;

            var selectedNode = range.getNodeSelection();
            if (selectedNode && selectedNode.nodeType === ViperUtil.ELEMENT_NODE) {
                if (selectedNode === this.viper.getViperElement()) {
                    return null;
                }

                for (var i = 0; i < c; i++) {
                    if (ViperUtil.isTag(selectedNode, tagNames[i]) === true) {
                        return selectedNode;
                    }
                }
            }

            var viperElem = this.viper.getViperElement();
            var common    = range.getCommonElement();
            while (common) {
                if (common === viperElem) {
                    return null;
                }

                for (var i = 0; i < c; i++) {
                    if (ViperUtil.isTag(common, tagNames[i]) === true) {
                        return common;
                    }
                }

                if (ViperUtil.isBlockElement(common) === true) {
                    break;
                }

                common = common.parentNode;
            }

            return null;

        },

        _removeViperHighlightClass: function(className)
        {
            return className.replace(/\s*(__viper_selHighlight|__viper_cleanOnly)/gi, '');

        },

        getCommonFormatElement: function(range)
        {
            range = range || this.viper.getViperRange();

            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();
            var common    = range.getCommonElement();

            if (!endNode) {
                endNode = startNode;
            }

            if (ViperUtil.isChildOf(common, this.viper.getViperElement()) === false) {
                return null;
            }

            var startParents = ViperUtil.getParents(startNode, null, common, true);
            var endParents   = ViperUtil.getParents(endNode, null, common, true);

            var startTopParent = common;
            var endTopParent   = common;
            if (startParents.length > 0) {
                startTopParent = startParents[startParents.length - 1];
            }

            if (endParents.length > 0) {
                endTopParent = endParents[endParents.length - 1];
            }

            if (startTopParent === endTopParent) {
                return common;
            }

            var first = false;
            var last  = null;
            for (var node = common.firstChild; node; node = node.nextSibling) {
                if (node.nodeType === ViperUtil.TEXT_NODE) {
                    continue;
                } else if (node === startTopParent) {
                    first = true;
                } else if (first !== true) {
                    return null;
                }

                last = node;
            }

            if (last !== endTopParent) {
                return null;
            }

            return common;

        },

        initInlineToolbar: function()
        {
            var self = this;
            this.viper.registerCallback('ViperInlineToolbarPlugin:initToolbar', 'ViperFormatPlugin', function(toolbar) {
                self.createInlineToolbar(toolbar);
            });
            this.viper.registerCallback('ViperInlineToolbarPlugin:updateToolbar', 'ViperFormatPlugin', function(data) {
                self.updateInlineToolbar(data);
            });

        },

        createInlineToolbar: function(toolbar)
        {
            var tools  = this.viper.Tools;
            var prefix = 'ViperFormatPlugin:vitp:';
            var self   = this;

            this._inlineToolbar = this.viper.getPluginManager().getPlugin('ViperInlineToolbarPlugin');

            // Headings format section.
            var headingsSubSection = toolbar.makeSubSection(prefix + 'heading:subSection', this._getHeadingsSection(prefix));

            // Formats section.
            var formatsSubSection = toolbar.makeSubSection(prefix + 'formats:subSection', this._getFormatsSection(prefix));

            var buttonGroup = tools.createButtonGroup(prefix + 'formatsAndHeading:buttons');
            toolbar.addButton(buttonGroup);

            tools.createButton('vitpFormats', '', _('Toggle Formats'), 'Viper-formats');
            tools.addButtonToGroup('vitpFormats', prefix + 'formatsAndHeading:buttons');
            toolbar.setSubSectionButton('vitpFormats', prefix + 'formats:subSection');

            tools.createButton('vitpHeadings', '', _('Toggle Headings'), 'Viper-headings');
            tools.addButtonToGroup('vitpHeadings', prefix + 'formatsAndHeading:buttons');
            toolbar.setSubSectionButton('vitpHeadings', prefix + 'heading:subSection');

            var buttonGroup = tools.createButtonGroup(prefix + 'anchorAndClassButtons');
            toolbar.addButton(buttonGroup);

            // Anchor.
            tools.createButton('vitpAnchor', '', _('Anchor name (ID)'), 'Viper-anchorID');
            tools.addButtonToGroup('vitpAnchor', prefix + 'anchorAndClassButtons');

            toolbar.makeSubSection(prefix + 'anchor:subSection', this._getAnchorSection(prefix));
            toolbar.setSubSectionButton('vitpAnchor', prefix + 'anchor:subSection');
            toolbar.setSubSectionAction(prefix + 'anchor:subSection', function() {
                var value = tools.getItem(prefix + 'anchor:input').getValue();
                self._setAttributeForSelection('id', value);
            }, [prefix + 'anchor:input']);

            // Class.
            tools.createButton('vitpClass', '', _('Class name'), 'Viper-cssClass');
            tools.addButtonToGroup('vitpClass', prefix + 'anchorAndClassButtons');

            toolbar.makeSubSection(prefix + 'class:subSection', this._getClassSection(prefix));
            toolbar.setSubSectionButton('vitpClass', prefix + 'class:subSection');
            toolbar.setSubSectionAction(prefix + 'class:subSection', function() {
                var value = tools.getItem(prefix + 'class:input').getValue();
                self._updateClassAttribute(value);
            }, [prefix + 'class:input', self._styleListid]);

        },

        _updateClassAttribute: function(value, element) {
            if (this._custStyles) {
                // Check if any of the custom styles is selected.
                var tools          = this.viper.Tools;
                var selectedStyles = tools.getItem(this._styleListid).getSelectedItems();
                if (selectedStyles.length > 0) {
                    value  = this._removeDefinedStylesFromClass(value, selectedStyles);
                    value += ' ' + selectedStyles.join(' ');
                }
            }

            if (element) {
                this._setAttributeForElement(element, 'class', value);
            } else {
                this._setAttributeForSelection('class', value);
            }

        },

        _getClassInitialValue: function(attrClass, node) {
            var selectedItems = [];
            if (this._custStyles && attrClass) {
                // There are custom styles check if the selection matches any of those.
                var classNames = attrClass.split(' ');
                var listItems  = [];
                for (var custStyle in this._custStyles) {
                    var intersect = ViperUtil.arrayIntersect(this._custStyles[custStyle].classNames, classNames);
                    if (intersect.length === this._custStyles[custStyle].classNames.length) {
                        selectedItems.push(custStyle);

                        // Remove these defined classes from the attrClass so it does not appear in the input.
                        attrClass = this._removeDefinedStylesFromClass(attrClass, this._custStyles[custStyle].classNames);
                    }
                }

                // Filter the selected classes array by most specific classes.
                for (var i = (selectedItems.length - 1); i >= 0 ; i--) {
                    var isSubset = false;
                    for (var j = 0; j < selectedItems.length; j++) {
                        if (i === j) {
                            continue;
                        }

                        var intersect = ViperUtil.arrayIntersect(
                            this._custStyles[selectedItems[j]].classNames,
                            this._custStyles[selectedItems[i]].classNames
                        );

                        // Class names in j contains all the class names in i. Remove i from the list.
                        if (intersect.length === this._custStyles[selectedItems[i]].classNames.length) {
                            isSubset = true;
                            break;
                        }
                    }

                    if (isSubset === true) {
                        ViperUtil.removeArrayIndex(selectedItems, i);
                    }
                }
            }

            if (this._custStyles) {
                var nodeTagName = ViperUtil.getTagName(node) || 'text-selection';
                var list        = this.viper.Tools.getItem(this._styleListid);
                var itemShown   = false;

                // Filter the list of classes that should be shown depending on the showFor, and hideFor settings.
                for (var classNames in this._custStyles) {
                    var hideFor = this._custStyles[classNames].hideFor;
                    var showFor = this._custStyles[classNames].showFor;

                    if ((hideFor
                        && (hideFor === '*'
                        || ViperUtil.inArray(nodeTagName, hideFor) === true))
                        && (!showFor
                        || ViperUtil.inArray(nodeTagName, showFor) === false)
                    ) {
                        list.hideItem(classNames);
                    } else if (!showFor || showFor === '*' || ViperUtil.inArray(nodeTagName, showFor) === true) {
                        list.showItem(classNames);
                        itemShown = true;
                    } else {
                        list.hideItem(classNames);
                    }
                }

                if (itemShown === true) {
                    ViperUtil.removeClass(this._stylePickerRow, 'ViperUtil-hidden');
                } else {
                    ViperUtil.addClass(this._stylePickerRow, 'ViperUtil-hidden');
                }

                list.setSelectedItems(selectedItems, true);
                this._updateDefinedStylesList();
            }

            attrClass = ViperUtil.trim(attrClass);
            return attrClass;

        },

        _removeDefinedStylesFromClass: function(attrClass, definedStyles) {
            var re    = new RegExp('(\\s|^)' + definedStyles.join('|') + '(\\s|$)' ,'g');
            attrClass = attrClass.replace(re, '').replace(/\s{2,}/gi, ' ');
            return attrClass;

        },

        updateInlineToolbar: function(data, removeLinkOnly)
        {
            if (!data.lineage || data.range.collapsed === true) {
                return;
            }

            var tools           = this.viper.Tools;
            var prefix          = 'ViperFormatPlugin:vitp:';
            var selectedNode    = data.lineage[data.current];

            // Heading section.
            if (this._canShowHeadingOptions(selectedNode) === true) {
                data.toolbar.showButton('vitpHeadings');

                for (var i = 1; i <= 6; i++) {
                    var tagName = 'h' + i;
                    for (var j = 0; j < data.lineage.length; j++) {
                        if (ViperUtil.isTag(data.lineage[j], tagName) === true) {
                            tools.setButtonActive(prefix + 'heading:h' + i);
                            tools.setButtonActive('vitpHeadings');
                        } else {
                            tools.setButtonInactive(prefix + 'heading:h' + i);
                        }
                    }
                }
            } else {
                tools.setButtonInactive('vitpHeadings');
                for (var i = 1; i <= 6; i++) {
                    tools.setButtonInactive(prefix + 'heading:h' + i);
                }
            }//end if

            // Formats section.
            var formatButtons = {
                p: 'P',
                div: 'DIV',
                blockquote: 'Quote',
                pre: 'PRE'
            };

            var ignoredTags = ['caption', 'li', 'ul', 'ol', 'img', 'table', 'tr', 'tbody', 'tfoot', 'thead'];

            var formatButtonStatuses = null;
            var currentElement       = data.lineage[data.current];

            if (ViperUtil.isBlockElement(currentElement) === true && ViperUtil.inArray(ViperUtil.getTagName(currentElement), ignoredTags) === false) {
                if (currentElement.nodeType === ViperUtil.TEXT_NODE && data.lineage.length === 1) {
                    formatButtonStatuses = this.getFormatButtonStatuses();
                } else {
                    formatButtonStatuses = this.getFormatButtonStatuses(data.lineage[data.current]);
                }

                var enableFormatsButton  = formatButtonStatuses._none;
                for (var button in formatButtonStatuses) {
                    if (button === '_none' || button === '_canChange') {
                        continue;
                    }

                    if (formatButtonStatuses[button] === true) {
                        enableFormatsButton = true;
                        tools.enableButton(prefix + 'formats:' + formatButtons[button]);
                        tools.setButtonInactive(prefix + 'formats:' + formatButtons[button]);
                    } else {
                        tools.setButtonInactive(prefix + 'formats:' + formatButtons[button]);
                        tools.disableButton(prefix + 'formats:' + formatButtons[button]);
                    }
                }

                tools.getItem('vitpFormats').setIconClass('Viper-formats');
                if (enableFormatsButton === true) {
                    tools.enableButton('vitpFormats');

                    if (currentElement.nodeType === ViperUtil.TEXT_NODE && data.lineage.length > 1) {
                        currentElement = data.lineage[(data.current - 1)];
                    } else if (ViperUtil.isBlockElement(currentElement) === true) {
                        data.toolbar.showButton('vitpFormats');
                    }

                    var isBlockQuote = false;
                    if (ViperUtil.isTag(currentElement, 'p') === true
                        && ViperUtil.isTag(currentElement.parentNode, 'blockquote') === true
                    ) {
                        isBlockQuote = true;
                    }

                    for (var tag in formatButtons) {
                        if (ViperUtil.isTag(currentElement, tag) === true) {
                            if (formatButtonStatuses[tag] === true) {
                                tools.enableButton(prefix + 'formats:' + formatButtons[tag]);

                                if (isBlockQuote !== true) {
                                    tools.setButtonActive(prefix + 'formats:' + formatButtons[tag]);
                                }
                            }

                            tools.setButtonActive('vitpFormats');
                            if (isBlockQuote === true) {
                                tools.setButtonActive(prefix + 'formats:' + formatButtons['blockquote']);
                                tools.getItem('vitpFormats').setIconClass('Viper-formats-blockquote');
                            } else {
                                tools.setButtonActive(prefix + 'formats:' + formatButtons[tag]);
                                tools.getItem('vitpFormats').setIconClass('Viper-formats-' + tag);
                            }
                        }
                    }
                } else {
                    tools.disableButton('vitpFormats');
                }
            } else if ((!currentElement || currentElement.nodeType === ViperUtil.TEXT_NODE || (ViperUtil.isBlockElement(currentElement) === true && ViperUtil.inArray(ViperUtil.getTagName(currentElement), ignoredTags) === false)) && this.isWholeBlockSelection(data.range)) {
                var pOnly = this._selectionHasPTagsOnly(data.range);

                for (var tag in formatButtons) {
                    tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                    if (tag === 'div' || (pOnly === true && tag === 'blockquote')) {
                        tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                    } else {
                        tools.disableButton(prefix + 'formats:' + formatButtons[tag]);
                    }
                }

                tools.getItem('vitpFormats').setIconClass('Viper-formats');
                tools.enableButton('vitpFormats');
                data.toolbar.showButton('vitpFormats');
            } else {
                tools.disableButton('vitpFormats');
            }

            buttonsToEnable = [];
            var startNode   = data.range.getStartNode();
            var endNode     = data.range.getEndNode();
            if (!endNode) {
                endNode = startNode;
            }

            this._selectedNode = selectedNode;

            // Anchor and Class.
            if (selectedNode
                && (selectedNode.nodeType === ViperUtil.ELEMENT_NODE
                || ViperUtil.getFirstBlockParent(startNode) === ViperUtil.getFirstBlockParent(endNode))
            ) {
                var attrId = this._getAttributeValue('id', selectedNode);
                if (attrId) {
                    tools.setButtonActive('vitpAnchor');
                }

                var attrClass = this._getAttributeValue('class', selectedNode);
                if (attrClass) {
                    tools.setButtonActive('vitpClass');
                }

                attrClass = this._getClassInitialValue(attrClass, selectedNode);

                tools.getItem(prefix + 'anchor:input').setValue(attrId);
                tools.getItem(prefix + 'class:input').setValue(attrClass);

                data.toolbar.showButton('vitpAnchor');
                data.toolbar.showButton('vitpClass');
            }//end if

        },

        _createToolbarContent: function()
        {
            var self    = this;
            var tools   = this.viper.Tools;
            var toolbar = this.toolbarPlugin;
            var prefix  = 'ViperFormatPlugin:vtp:';

            var content = this._getToolbarContents('vtp');

            // Toolbar buttons.
            var buttonGroup = tools.createButtonGroup(prefix + 'formatAndHeadingButtons');
            tools.createButton('formats', '', _('Formats'), 'Viper-formats', null, true);
            tools.createButton('headings', '', _('Headings'), 'Viper-headings', null, true);
            tools.addButtonToGroup('formats', prefix + 'formatAndHeadingButtons');
            tools.addButtonToGroup('headings', prefix + 'formatAndHeadingButtons');
            toolbar.addButton(buttonGroup);

            var buttonGroup = tools.createButtonGroup(prefix + 'anchorAndClassButtons');
            tools.createButton('anchor', '', _('Anchor ID'), 'Viper-anchorID', null, true);
            tools.createButton('class', '', _('Class'), 'Viper-cssClass', null, true);
            tools.addButtonToGroup('anchor', prefix + 'anchorAndClassButtons');
            tools.addButtonToGroup('class', prefix + 'anchorAndClassButtons');
            toolbar.addButton(buttonGroup);

            // Create the bubbles.
            toolbar.createBubble(prefix + 'formatsBubble', _('Formats'), null, content.formats);
            toolbar.setBubbleButton(prefix + 'formatsBubble', 'formats');

            toolbar.createBubble(prefix + 'headingsBubble', _('Headings'), null, content.headings);
            toolbar.setBubbleButton(prefix + 'headingsBubble', 'headings');

            toolbar.createBubble(prefix + 'anchorBubble', _('Anchor ID'), content.anchor);
            toolbar.setBubbleButton(prefix + 'anchorBubble', 'anchor');
            tools.getItem(prefix + 'anchorBubble').setSubSectionAction(prefix + 'anchorBubbleSubSection', function() {
                var value = tools.getItem(prefix + 'anchor:input').getValue();
                self._setAttributeForSelection('id', value);
            }, [prefix + 'anchor:input']);

            toolbar.createBubble(prefix + 'classBubble', _('Class'), content.cssClass);
            toolbar.setBubbleButton(prefix + 'classBubble', 'class');
            tools.getItem(prefix + 'classBubble').setSubSectionAction(prefix + 'classBubbleSubSection', function() {
                var value = tools.getItem(prefix + 'class:input').getValue();
                self._updateClassAttribute(value);
            }, [prefix + 'class:input', self._styleListid]);

            var headingTags   = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
            var formatButtons = {
                p: 'P',
                div: 'DIV',
                blockquote: 'Quote',
                pre: 'PRE'
            };

            var ignoredTags = ('tr|table|tbody|thead|tfoot|caption|ul|ol|li|img').split('|');

            // Listen for the main toolbar update and update the statuses of the buttons.
            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperFormatPlugin', function(data) {
                // Need to have a time out here so that the inline toolbar has time to update it self as we use its lineage
                // to determine button statuses.
                setTimeout(function() {
                    updateToolbar();
                }, 10);
            });

            var updateToolbar = function() {
                var range = self.viper.getViperRange();

                // Make sure passed in range is still valud.
                try {
                    if (range) {
                        if (range.startContainer) {
                            range.startContainer.parentNode;
                        }

                        if (range.endContainer) {
                            range.endContainer.parentNode;
                        }
                    }
                } catch(e) {
                }

                var nodeSelection = range.getNodeSelection(null, true);
                var startNode = range.getStartNode();
                var endNode   = range.getEndNode();

                if (!endNode) {
                    endNode = startNode;
                }

                if (!endNode) {
                    return;
                }

                if ((!nodeSelection || nodeSelection.nodeType !== ViperUtil.ELEMENT_NODE || nodeSelection === self.viper.getViperElement())
                    && (range.collapsed === true || ViperUtil.getFirstBlockParent(startNode) !== ViperUtil.getFirstBlockParent(endNode))
                    || (startNode === endNode && ViperUtil.isTag(startNode, 'br') === true && range.collapsed === true)
                    || (ViperUtil.isBrowser('msie', '8') === true && range.collapsed === true && nodeSelection && ViperUtil.getHtml(nodeSelection) === '' && ViperUtil.isStubElement(nodeSelection) === false)
                ) {
                    tools.disableButton('anchor');
                    tools.disableButton('class');
                    tools.setButtonInactive('anchor');
                    tools.setButtonInactive('class');
                } else if (nodeSelection && nodeSelection === self.viper.getViperElement()) {
                    tools.disableButton('anchor');
                    tools.disableButton('class');
                    tools.setButtonInactive('anchor');
                    tools.setButtonInactive('class');
                } else if (nodeSelection
                    && range.collapsed === true
                    && nodeSelection.nodeType === ViperUtil.ELEMENT_NODE
                ) {
                    tools.disableButton('anchor');
                    tools.disableButton('class');
                    tools.setButtonInactive('anchor');
                    tools.setButtonInactive('class');
                } else {
                    tools.enableButton('anchor');
                    tools.enableButton('class');
                }

                if (!startNode
                    && !endNode
                    && range.startContainer === range.endContainer
                ) {
                    startNode = range.startContainer;
                }

                var viperElement    = self.viper.getViperElement();
                var lineage         = [];
                var currentLinIndex = 0;

                if (self._inlineToolbar) {
                    lineage         = self._inlineToolbar.getLineage();
                    currentLinIndex = self._inlineToolbar.getCurrentLineageIndex(true);
                }

                var formatElement   = lineage[currentLinIndex];

                if (!nodeSelection || lineage[(lineage.length - 1)] !== nodeSelection) {
                    // If the last item of the lineage is currently selected then use nodeSelection else use the
                    // currently selected lineage item.
                    if (formatElement && formatElement.nodeType !== ViperUtil.TEXT_NODE) {
                        nodeSelection = formatElement;
                    }
                }

                // Format button.
                if (formatElement && nodeSelection && formatElement !== nodeSelection) {
                    nodeSelection = formatElement;
                }

                if (nodeSelection
                    || (range.collapsed === false
                    || (ViperUtil.isTag(startNode, 'br') === false
                    && (startNode.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(startNode.data) === '') === false))
                ) {
                    if (nodeSelection && nodeSelection === self.viper.getViperElement()) {
                        tools.disableButton('anchor');
                        tools.disableButton('class');
                        tools.setButtonInactive('anchor');
                        tools.setButtonInactive('class');
                    } else if (nodeSelection && range.collapsed !== true) {
                        tools.enableButton('anchor');
                        tools.enableButton('class');

                        // Anchor.
                        var attrId = self._getAttributeValue('id', nodeSelection);
                        tools.getItem(prefix + 'anchor:input').setValue(attrId);
                        if (attrId) {
                            tools.setButtonActive('anchor');
                        } else {
                            tools.setButtonInactive('anchor');
                        }

                        // Class.
                        var originalAttrClass = self._getAttributeValue('class', nodeSelection);
                        attrClass = self._getClassInitialValue(originalAttrClass, nodeSelection);
                        tools.getItem(prefix + 'class:input').setValue(attrClass);
                        if (originalAttrClass) {
                            tools.setButtonActive('class');
                        } else {
                            tools.setButtonInactive('class');
                        }
                    } else {
                        tools.getItem(prefix + 'class:input').setValue('');
                        tools.getItem(prefix + 'anchor:input').setValue('');
                        tools.setButtonInactive('anchor');
                        tools.setButtonInactive('class');
                    }
                }//end if

                // Format and Heading.
                tools.disableButton('headings');
                tools.disableButton('formats');
                tools.setButtonInactive('headings');
                tools.setButtonInactive('formats');

                // Heading button.
                // Heading button will only be enabled if its a whole node selection or
                // no selection and not in a blockquote with multiple paragraphs.
                if (nodeSelection) {
                    if (ViperUtil.isBlockElement(nodeSelection) === false) {
                        var surroundParent = ViperUtil.getSurroundingParents(nodeSelection, null, 'block', self.viper.getViperElement());
                        if (surroundParent.length > 0) {
                            nodeSelection = surroundParent.shift();
                        }
                    }

                    if (nodeSelection.nodeType === ViperUtil.TEXT_NODE) {
                        if (range.collapsed === true) {
                            // Disable the heading tag if the selection is in a blockquote
                            // with multiple paragraph tags.
                            var blockquote = ViperUtil.getParents(nodeSelection, 'blockquote', self.viper.getViperElement());
                            if (blockquote.length === 0 || ViperUtil.getTag('p', blockquote[0]).length <= 1) {
                                tools.enableButton('headings');
                            }
                        }
                    } else if ((ViperUtil.isTag(nodeSelection, 'blockquote') !== true
                        || ViperUtil.getTag('p', nodeSelection).length <= 1)
                        && ((ViperUtil.isTag(nodeSelection, 'p') !== true)
                        || ViperUtil.isTag(nodeSelection.parentNode, 'blockquote') === false)
                    ) {
                        if (ViperUtil.isBlockElement(nodeSelection) === true && ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), ignoredTags) === false) {
                            // Check if this node contains any block elements, if it does
                            // then headings cannnot be applied.
                            var blockChildren = ViperUtil.getBlockChildren(nodeSelection);
                            if (blockChildren.length <= 1) {
                                tools.enableButton('headings');
                            }
                        }
                    }
                } else if (range.collapsed === true && formatElement) {
                    var firstBlock = ViperUtil.getFirstBlockParent(formatElement);
                    if (ViperUtil.inArray(ViperUtil.getTagName(firstBlock), ignoredTags) === false) {
                        var isBlockQuote = false;
                        if (ViperUtil.isTag(firstBlock, 'p') === true && ViperUtil.isTag(firstBlock.parentNode, 'blockquote') === true) {
                            firstBlock = firstBlock.parentNode;
                            isBlockQuote = true;
                        } else if (ViperUtil.isTag(firstBlock, 'blockquote') === true) {
                            isBlockQuote = true;
                        }

                        if (firstBlock && (isBlockQuote === false || ViperUtil.getTag('p', firstBlock).length === 1)) {
                            tools.enableButton('headings');
                        }
                    }
                }

                for (var i = 0; i < headingTags.length; i++) {
                    tools.setButtonInactive(prefix + 'heading:' + headingTags[i]);
                }

                var headingElement = self.getTagFromRange(range, headingTags);
                if (headingElement) {
                    var tagName = ViperUtil.getTagName(headingElement);
                    tools.setButtonActive('headings');
                    tools.setButtonActive(prefix + 'heading:' + tagName);
                }

                // Returns the most relevant parent.
                var getValidParent = function(node) {
                    var parent = ViperUtil.getFirstBlockParent(node);
                    if (parent && ViperUtil.isTag(parent, 'p') === true && ViperUtil.isTag(parent.parentNode, 'blockquote') === true) {
                        parent = parent.parentNode;
                    } else if (parent === self.viper.getViperElement()) {
                        // Ignore the Viper element.
                        parent = null;
                    }

                    return parent;
                };

                if (self._canEnableFormatButtons(startNode, nodeSelection, range) === true) {
                    // Reset icon of the main toolbar button.
                    tools.getItem('formats').setIconClass('Viper-formats');
                    if (range.collapsed === true) {
                        // If the range is collapsed then we need to get the most relevant
                        // parent. Which is the first block parent unless its a P tag
                        // inside a blockquote. Then it becomes the blockquote.
                        var parent = getValidParent(startNode);

                        if (parent !== null) {
                            // Enable the main toolbar button.
                            tools.enableButton('formats');

                            // Set the main toolbar button icon.
                            var parentTagName = ViperUtil.getTagName(parent, range);
                            if (formatButtons[parentTagName]) {
                                tools.getItem('formats').setIconClass('Viper-formats-' + parentTagName);
                            }

                            var formatButtonStatuses = self.getFormatButtonStatuses(parent);
                            for (var tag in formatButtons) {
                                if (formatButtonStatuses[tag] === true) {
                                    tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                } else {
                                    tools.disableButton(prefix + 'formats:' + formatButtons[tag]);
                                }

                                if (tag === parentTagName) {
                                    tools.setButtonActive(prefix + 'formats:' + formatButtons[tag]);
                                    tools.setButtonActive('formats');
                                } else {
                                    tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                }
                            }
                        } else {
                            tools.disableButton('formats');
                        }
                    } else if (nodeSelection && nodeSelection.nodeType === ViperUtil.ELEMENT_NODE) {
                        // This is an element selection.
                        // First set the correct icon for the main toolbar button.
                        var parentTagName = ViperUtil.getTagName(nodeSelection);
                        var parent        = nodeSelection;
                        if (ViperUtil.isBlockElement(nodeSelection) === false) {
                            parent        = getValidParent(startNode);
                            parentTagName = ViperUtil.getTagName(parent);
                        } else if (parentTagName === 'p' && ViperUtil.isTag(parent.parentNode, 'blockquote') === true) {
                            parent        = parent.parentNode;
                            parentTagName = 'blockquote';
                        }

                        if (formatButtons[parentTagName] && nodeSelection !== viperElement) {
                            tools.getItem('formats').setIconClass('Viper-formats-' + parentTagName);
                        }

                        var isBlockElement  = ViperUtil.isBlockElement(nodeSelection);
                        if (isBlockElement === true) {
                            // If this is a P tag selection and P tag belongs to a
                            // blockquote and blockquote has more than one P tag then
                            // do not allow this P tag to be converted to anything else.
                            if (ViperUtil.isTag(nodeSelection, 'p') === true
                                && ViperUtil.isTag(nodeSelection.parentNode, 'blockquote') === true
                                && ViperUtil.getTag('p', nodeSelection.parentNode).length > 1
                            ) {
                                tools.disableButton('formats');
                            } else {
                                tools.enableButton('formats');
                                var formatButtonStatuses = self.getFormatButtonStatuses(parent);
                                for (var tag in formatButtons) {
                                    if (formatButtonStatuses[tag] === true) {
                                        tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                    } else {
                                        tools.disableButton(prefix + 'formats:' + formatButtons[tag]);
                                    }

                                    if (tag === parentTagName) {
                                        if (nodeSelection !== viperElement) {
                                            tools.setButtonActive(prefix + 'formats:' + formatButtons[tag]);
                                            tools.setButtonActive('formats');
                                        } else {
                                            tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                        }
                                    } else {
                                        tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                    }
                                }
                            }
                        } else if (parentTagName === 'div') {
                            // Its a stub or an inline element and parent is DIV. Enable all buttons.
                            tools.enableButton('formats');
                            for (var tag in formatButtons) {
                                tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                            }
                        }

                        // Get surrounding parents.
                        var surroundingParents = ViperUtil.getSurroundingParents(nodeSelection, null, 'block', self.viper.getViperElement());
                        if (surroundingParents.length > 0) {
                            var surroundingParent = surroundingParents[0];
                            var surTagName        = ViperUtil.getTagName(surroundingParent)
                            if (surroundingParents.length > 1
                                && surTagName === 'p'
                                && ViperUtil.getTagName(surroundingParents[1]) === 'blockquote'
                            ) {
                                surTagName = 'blockquote';
                            }

                            tools.setButtonActive(prefix + 'formats:' + formatButtons[surTagName]);
                        }
                    } else {
                        // Its a text selection.
                        var startBlock    = ViperUtil.getFirstBlockParent(startNode);
                        var commonParent  = self.getCommonFormatElement(range);

                        if (commonParent && ViperUtil.isBlockElement(commonParent) === false) {
                            commonParent  = ViperUtil.getFirstBlockParent(commonParent);
                        }

                        var commonTagName = ViperUtil.getTagName(commonParent);

                        if (commonParent && formatButtons[commonTagName]) {
                            if (commonTagName === 'p' && ViperUtil.isTag(commonParent.parentNode, 'blockquote') === true) {
                                tools.getItem('formats').setIconClass('Viper-formats-blockquote');
                            } else {
                                tools.getItem('formats').setIconClass('Viper-formats-' + commonTagName);

                                if (commonTagName === 'div') {
                                    // Div tags allow nested tags anywhere in their
                                    // content. So enable the top toolbar button.
                                    tools.enableButton('formats');
                                }
                            }

                            if (commonParent && startBlock !== commonParent) {
                                // Text inside multiple block elements is selected.
                                tools.enableButton('formats');

                                var formatButtonStatuses = self.getFormatButtonStatuses(commonParent);
                                for (var tag in formatButtons) {
                                    if (formatButtonStatuses[tag] === true) {
                                        tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                    } else {
                                        tools.disableButton(prefix + 'formats:' + formatButtons[tag]);
                                    }

                                    if (tag === commonTagName) {
                                        if (commonParent !== viperElement) {
                                            if (tag !== 'div') {
                                                tools.setButtonActive(prefix + 'formats:' + formatButtons[tag]);
                                            } else {
                                                tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                            }
                                        }

                                        tools.enableButton('formats');
                                        tools.setButtonActive('formats');
                                    } else {
                                        tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                    }
                                }
                            } else {
                                // Text inside a single block element is selected.
                                if (commonTagName === 'div') {
                                    // Div tag allows nested tags inside it. Set all
                                    // buttons to inactive and enable them.
                                    for (var tag in formatButtons) {
                                        tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                        tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                                    }
                                }
                            }
                        } else if (startBlock === self.viper.getViperElement()
                            && self.viper.getViperElement() === ViperUtil.getFirstBlockParent(endNode)
                        ) {
                            // Top level text selection. Allow all formats.
                            tools.enableButton('formats');

                            for (var tag in formatButtons) {
                                tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);
                            }
                        } else {
                            // Text accross multiple block elements is selected.
                            // Only Div is allowed unless selection consists of only P tags
                            // then Blockquote is also allowed.
                            tools.enableButton('formats');

                            var pOnly = self._selectionHasPTagsOnly(range);
                            for (var tag in formatButtons) {
                                tools.setButtonInactive(prefix + 'formats:' + formatButtons[tag]);

                                if (tag === 'div' || (pOnly === true && tag === 'blockquote')) {
                                    tools.enableButton(prefix + 'formats:' + formatButtons[tag]);
                                } else {
                                    tools.disableButton(prefix + 'formats:' + formatButtons[tag]);
                                }
                            }
                        }//end if//end if
                    }//end if
                } else {
                    tools.getItem('formats').setIconClass('Viper-formats');

                    // Pick the right button icon for disabled state as nothing can be
                    // changed.
                    if (range.collapsed === true) {
                        var parent = getValidParent(startNode);

                        var parentTagName = ViperUtil.getTagName(parent);
                        if (formatButtons[parentTagName]) {
                            tools.getItem('formats').setIconClass('Viper-formats-' + parentTagName);
                        }
                    }
                }//end if
            };

        },

        _updateTableEditorContent: function(data)
        {
            if (data.type === 'cell'
                || data.type === 'row'
                || data.type === 'table'
            ) {
                var prefix  = 'ViperTableEditor-Format-'+ data.type + ':';
                var element = data.cell;

                switch (data.type) {
                    case 'row':
                        element = element.parentNode;
                    break;

                    case 'table':
                        element = ViperUtil.getParents(element, 'table')[0];
                    break;

                    default:
                        // Nothing.
                    break;
                }

                // Add class button.
                var classBtnActive = false;
                var classAttribute = '';

                if (ViperUtil.hasAttribute(element, 'class') === true) {
                    classAttribute = element.getAttribute('class');
                    this.viper.Tools.setButtonActive(prefix + 'classBtn-' + data.type);
                } else {
                    this.viper.Tools.setButtonInactive(prefix + 'classBtn-' + data.type);
                }

                classAttribute = this._getClassInitialValue(classAttribute, element);
                this.viper.Tools.getItem(prefix + 'class:input').setValue(classAttribute);

                data.toolbar.showButton(prefix + 'classBtn-' + data.type);
            }

        },

        _createTableEditorContent: function(toolbar, type)
        {
            if (type === 'cell'
                || type === 'row'
                || type === 'table'
            ) {
                var prefix      = 'ViperTableEditor-Format-' + type + ':';
                var element     = null;
                var buttonIndex = null;

                switch (type) {
                    case 'row':
                        buttonIndex = -1;
                    break;

                    case 'table':
                        buttonIndex = -1;
                    break;

                    default:
                        buttonIndex = null;
                    break;
                }

                // Add class button.
                var tools = this.viper.Tools;

                var button = tools.createButton(prefix + 'classBtn-' + type, '', _('Class name'), 'Viper-cssClass', null, false, false);
                toolbar.addButton(button, buttonIndex);

                var self = this;
                var tableEditorPlugin = this.viper.PluginManager.getPlugin('ViperTableEditorPlugin');
                var classSection      = this._getClassSection(prefix);
                toolbar.makeSubSection(prefix + 'class:subSection-' + type, classSection);
                toolbar.setSubSectionAction(prefix + 'class:subSection-' + type, function() {
                    var element  = tableEditorPlugin.getActiveCell();
                    switch (type) {
                        case 'row':
                            element = element.parentNode;
                        break;

                        case 'table':
                            element = ViperUtil.getParents(element, 'table')[0];
                        break;

                        default:
                            // Nothing.
                        break;
                    }

                    var value = tools.getItem(prefix + 'class:input').getValue();
                    self._updateClassAttribute(value, element);

                    // Set the current value as the initial value.
                    tools.getItem(prefix + 'class:input').setValue(value, true);

                    if (value) {
                        tools.setButtonActive(prefix + 'classBtn-' + type);
                    } else {
                        tools.setButtonInactive(prefix + 'classBtn-' + type);
                    }

                    self.viper.contentChanged(true);
                }, [prefix + 'class:input']);

                tools.viper.registerCallback(
                    'ViperTools:changed:' + this._styleListid,
                    'ViperFormatPlugin-toolbar',
                    function() {
                         tools.enableButton(toolbar.getActiveSection() + '-applyButton');
                    }
                );

                toolbar.setSubSectionButton(prefix + 'classBtn-' + type, prefix + 'class:subSection-' + type);
            }//end if

        },

        _updateDefinedStylesList: function()
        {
            // Add the list item to the main class panel.
            var tools         = this.viper.Tools;
            var list          = tools.getItem(this._styleListid);
            var selectedItems = list.getSelectedItems();
            var listItems     = [];

            for (var i = 0; i < selectedItems.length; i++) {
                var styleListItem = document.createElement('div');
                ViperUtil.addClass(styleListItem, 'ViperFormatPlugin-styleListItem');
                var content = '<div class="ViperFormatPlugin-styleListItem-name">' + this._custStyleNames[selectedItems[i]] + '</div>';
                content    += '<div class="ViperFormatPlugin-styleListItem-classes">.' + this._custStyles[selectedItems[i]].classNames.join(' .') + '</div>';
                content    += '<span class="ViperFormatPlugin-styleListItem-remove Viper-textbox-action" data-id="' + selectedItems[i] + '"></span>';
                ViperUtil.setHtml(styleListItem, content);
                listItems.push(styleListItem);
            }

            for (var i = 0; i < this._stylesListElement.length; i++) {
                ViperUtil.empty(this._stylesListElement[i]);
                if (listItems.length > 0) {
                    for (var j = 0; j < listItems.length; j++) {
                        this._stylesListElement[i].appendChild(listItems[j].cloneNode(true));
                    }
                }
            }

        },

        _setAttributeForElement: function(element, attr, value)
        {
            if (element.nodeType === ViperUtil.ELEMENT_NODE) {
                // Set the attribute of this element.
                this.viper.setAttribute(element, attr, value);
                return element;
            }

            return null;

        },

        _setAttributeForSelection: function(attr, value)
        {
            var range        = this.viper.getViperRange();
            var selectedNode = this.viper.getNodeSelection();

            if (selectedNode) {
                var oldVal = '';
                if (selectedNode.nodeType === ViperUtil.TEXT_NODE) {
                    var span = document.createElement('span');
                    ViperUtil.insertBefore(selectedNode, span);
                    span.appendChild(selectedNode);
                    selectedNode = span;
                    range.selectNode(span);
                    ViperSelection.addRange(range);
                } else {
                    oldVal = selectedNode.getAttribute(attr) || '';
                }

                this.viper.setAttribute(selectedNode, attr, value);
                this.viper.contentChanged();

                this.viper.fireCallbacks('ViperFormatPlugin:elementAttributeSet', {element: selectedNode, oldValue: oldVal, newValue:value});
                return;
            } else if (ViperUtil.trim(value) === '') {
                return;
            }

            // Wrap the selection with span tag.
            var bookmark = this.viper.createBookmark();

            // Move the elements between start and end of bookmark to the new
            // span tag. Then select the new span tag and update selection.
            var span = null;
            if (bookmark.start && bookmark.end) {
                if (bookmark.start.nextSibling
                    && bookmark.start.nextSibling.nodeType === ViperUtil.ELEMENT_NODE
                    && bookmark.start.nextSibling === bookmark.end.previousSibling
                ) {
                    span = bookmark.start.nextSibling;
                    this.viper.removeBookmarks();
                    this._setAttributeForElement(span, attr, value);
                    range.selectNode(span);
                } else {
                    var attributes = {attributes: {}};
                    attributes.attributes[attr] = value;
                    range = this.viper.selectBookmark(bookmark);
                    this.viper.surroundContents('span', attributes, range);
                    range = this.viper.getViperRange();

                    this.viper.removeBookmarks();
                }//end if

                ViperSelection.addRange(range);

                this.viper.adjustRange();

                this.viper.contentChanged();

                this.viper.fireCallbacks('ViperFormatPlugin:elementAttributeSet', {element: span, oldValue: '', newValue:value});

                return span;
            }

            return null;

        },

        _canShowHeadingOptions: function(node)
        {
            if (!node) {
                return false;
            }

            if (node.nodeType === ViperUtil.TEXT_NODE) {
                // If this is a text selection then dont show the tools.
                return false;
            } else if (ViperUtil.isBlockElement(node) === false) {
                return false;
            } else {
                switch (node.tagName.toLowerCase()) {
                    case 'li':
                    case 'ul':
                    case 'ol':
                    case 'img':
                    case 'th':
                    case 'tr':
                    case 'td':
                    case 'table':
                    case 'caption':
                        return false;
                    break;

                    case 'blockquote':
                        if (ViperUtil.getTag('p', node).length > 1) {
                            return false;
                        } else {
                            var textContent = ViperUtil.getNodeTextContent(node);
                            if (textContent && textContent.length > 80) {
                                return false;
                            }
                        }
                    break;

                    default:
                        if (ViperUtil.isTag(node, 'p') === true
                            && ViperUtil.isTag(node.parentNode, 'blockquote') === true
                        ) {
                            return false;
                        }

                        // Check the selection length if the length is too long then
                        // dont show the tools.
                        var textContent = ViperUtil.getNodeTextContent(node);
                        if (textContent && textContent.length > 80) {
                            return false;
                        }

                        return true;
                    break;
                }
            }

            return true;

        },

        _canEnableFormatButtons: function(startNode, nodeSelection, range)
        {
            // Direct parent ignore list.
            var ignoredTagsStr = 'tr|table|tbody|thead|tfoot|caption|ul|ol|li|img';
            var ignoredTags    = ignoredTagsStr.split('|');
            var viperElement   = this.viper.getViperElement();

            // If any of the parents of the element is one of these tags then ignore it.
            var parents = ViperUtil.getParents(startNode, 'caption,ul,ol,li,img', viperElement);
            if (parents.length > 0 || (ViperUtil.isStubElement(startNode) === true && ViperUtil.isTag(startNode, 'br') === false)) {
                return false;
            } else if (range.collapsed === true && startNode.nodeType === ViperUtil.TEXT_NODE) {
                var blockquotes = ViperUtil.getParents(startNode, 'blockquote', viperElement);
                if (blockquotes.length === 1 && ViperUtil.getTag('p', blockquotes[0]).length > 1) {
                    return false;
                }
            }

            if (nodeSelection) {
                if (ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), ignoredTags) === true) {
                    return false;
                } else if (ViperUtil.isBlockElement(nodeSelection) === false
                    && ViperUtil.inArray(ViperUtil.getTagName(ViperUtil.getFirstBlockParent(nodeSelection)), ignoredTags) === true
                ) {
                    return false;
                }
            } else if (startNode) {
                if (ViperUtil.inArray(ViperUtil.getTagName(ViperUtil.getFirstBlockParent(startNode)), ignoredTags) === true) {
                    return false;
                }
            }

            return true;

        },

        isWholeBlockSelection: function(range)
        {
            range = range || this.viper.getViperRange();

            var nodeSelection = range.getNodeSelection();
            if (nodeSelection && ViperUtil.isBlockElement(nodeSelection) === true) {
                return nodeSelection;
            }

            if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                && range.startOffset === 0
                && range.endOffset === range.endContainer.data.length
            ) {
                // Now startContainer must be the first selectable child in its block
                // element. And endContainer must be the last selectable child in its
                // block element.
                var startBlock = ViperUtil.getFirstBlockParent(range.startContainer);
                var endBlock   = ViperUtil.getFirstBlockParent(range.endContainer);
                if (range._getFirstSelectableChild(startBlock) === range.startContainer
                    && range._getLastSelectableChild(endBlock) === range.endContainer
                ) {
                    return true;
                }
            }

            return false;


        },

        _selectionHasPTagsOnly: function(range)
        {
            var startBlock = ViperUtil.getFirstBlockParent(range.startContainer);
            var endBlock   = ViperUtil.getFirstBlockParent(range.endContainer);
            var common     = range.getCommonElement();
            var elements   = ViperUtil.getElementsBetween(startBlock, endBlock);

            if (startBlock) {
                elements.push(startBlock);
            }

            if (endBlock) {
                elements.push(endBlock);
            }

            for (var i = 0; i < elements.length; i++) {
                if (elements[i].nodeType === ViperUtil.TEXT_NODE
                    && ViperUtil.trim(elements[i].data) === ''
                ) {
                    continue;
                } else if (ViperUtil.isBlockElement(elements[i]) === true
                    && ViperUtil.isTag(elements[i], 'p') === false
                ) {
                    return false;
                } else {
                    var blockParents = ViperUtil.getParents(elements[i], null, common, true);
                    for (var j = 0; j < blockParents.length; j++) {
                        if (ViperUtil.isTag(blockParents[j], 'p') === false) {
                            return false;
                        }
                    }
                }
            }

            return true;

        },

        
        getFormatButtonStatuses: function(element)
        {
            var statuses = {
                p: false,
                pre: false,
                div: false,
                blockquote: false,
                _none: false,
                _canChange: false
            };

            var range        = this.viper.getViperRange();
            var selectedNode = element || range.getNodeSelection();
            var viperElement = this.viper.getViperElement();
            var defaultTag   = this.viper.getDefaultBlockTag();

            if (!selectedNode && range.startContainer === range.endContainer && range.collapsed === true) {
                selectedNode = ViperUtil.getFirstBlockParent(range.startContainer);
            }

            if (selectedNode === viperElement) {
                statuses = {
                    p: true,
                    pre: true,
                    div: true,
                    blockquote: true,
                    _none: false,
                    _canChange: true
                };

                var parasOnly        = true;
                var hasBlockChildren = false;
                for (var node = selectedNode.firstChild; node; node = node.nextSibling) {
                    if (ViperUtil.isBlockElement(node) === true) {
                        hasBlockChildren = true;
                        if (ViperUtil.isTag(node, 'p') !== true) {
                            parasOnly = false;
                            break;
                        }
                    }
                }

                if (parasOnly === false) {
                    statuses.p = false;
                    statuses.pre = false;
                    statuses.blockquote = false;
                } else if (hasBlockChildren === true) {
                    statuses.p = false;
                    statuses.pre = false;
                }

                return statuses;
            }

            if (selectedNode && ViperUtil.isBlockElement(selectedNode) === true) {
                var isBlockquote = false;
                var singlePTag   = true;
                if (ViperUtil.isTag(selectedNode, 'p') === true && ViperUtil.isTag(selectedNode.parentNode, 'blockquote') === true) {
                    selectedNode = selectedNode.parentNode;
                    isBlockquote = true;
                    if (ViperUtil.getTag('p', selectedNode).length > 1) {
                        singlePTag = false;
                    }
                }

                for (var tagName in statuses) {
                    if (isBlockquote === true) {
                        statuses[tagName] = singlePTag;
                        continue;
                    }

                    var canConvert = this.canConvert(selectedNode, tagName);
                    statuses[tagName] = canConvert;
                    if (canConvert === true) {
                        statuses._canChange = false;
                    }
                }

                statuses._none = singlePTag;
            } else if (selectedNode && selectedNode.nodeType === ViperUtil.TEXT_NODE) {
                var parent = ViperUtil.getFirstBlockParent(selectedNode);
                if (ViperUtil.isTag(parent, 'div') === true) {
                    statuses = {
                        p: true,
                        pre: true,
                        div: true,
                        blockquote: true
                    };
                }
            } else {
                var start      = range.getStartNode();
                if (!start) {
                    return statuses;
                }

                var end        = range.getEndNode();
                var elements   = ViperUtil.getElementsBetween(start, end);
                var commonElem = range.getCommonElement();

                elements.unshift(start);

                if (start !== end && end) {
                    elements.push(end);
                }

                var parents = [];
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    if (elem.nodeType === ViperUtil.TEXT_NODE && ViperUtil.trim(elem.data) === '') {
                        continue;
                    }

                    if (ViperUtil.isBlockElement(elem) === true) {
                        parents.push(elem);
                    }

                    var elemParents = ViperUtil.getParents(elem, null, commonElem);
                    for (var j = 0; j < elemParents.length; j++) {
                        if (ViperUtil.isBlockElement(elemParents[j]) === true) {
                            parents.push(elemParents[j]);
                        }
                    }
                }

                if (parents.length === 0) {
                    // A text node is selected inside the same block parent.
                    var parent = ViperUtil.getFirstBlockParent(start);
                    if (ViperUtil.isTag(parent, 'div') === true) {
                        statuses = {
                            p: true,
                            pre: true,
                            div: true,
                            blockquote: true,
                            _canChange: true
                        };
                    }
                } else {
                    statuses.div = true;
                    statuses._canChange = true;

                    if (parents.length > 0) {
                        statuses.blockquote = true;
                    }
                }
            }//end if

            return statuses;

        },

        canConvert: function(element, toTagName)
        {
            var tagName = ViperUtil.getTagName(element);
            if (tagName === 'p') {
                // If the original tag is a P tag and its parent is a blockquote then
                // it cannot be converted or removed.
                if (ViperUtil.isTag(element.parentNode, 'blockquote') === true) {
                    return false;
                }
            }

            if (toTagName === '_none') {
                if (this.viper.getDefaultBlockTag() === '') {
                    // Tag can be removed.
                    return true;
                }

                return false;
            } else if (tagName === toTagName && this.viper.getDefaultBlockTag() !== '') {
                return false;
            }

            switch (toTagName) {
                case 'p':
                    // Any element can be converted to a P unless there are child block
                    // elements.
                    if (this.hasBlockChildren(element) === true) {
                        return false;
                    }

                    // Or its in a PRE tag.
                    var preTags = ViperUtil.getParents(element, 'pre', this.viper.getViperElement());
                    if (preTags.length > 0) {
                        return false;
                    }
                break;

                case 'pre':
                    if (this.hasBlockChildren(element) === true) {
                        return false;
                    }
                break;

                case 'blockquote':
                    var tags = ViperUtil.getTag('*', element);
                    for (var i = 0; i < tags.length; i++) {
                        if (ViperUtil.isBlockElement(tags[i]) === true && ViperUtil.isTag(tags[i], 'p') === false && ViperUtil.isStubElement(tags[i]) === false) {
                            return false;
                        }
                    }
                break;
            }

            return true;

        },

        hasBlockChildren: function(element)
        {
            var isBlockQuote = ViperUtil.isTag(element, 'blockquote');
            var hasBlock     = false;

            var tags = ViperUtil.getTag('*', element);
            for (var i = 0; i < tags.length; i++) {
                if (ViperUtil.isBlockElement(tags[i]) === true && ViperUtil.isStubElement(tags[i]) === false) {
                    if (isBlockQuote === true && hasBlock === false && ViperUtil.isTag(tags[i], 'p') === true) {
                        // In blockquote element only return true if there is more than
                        // one block element.
                        hasBlock = true;
                        continue;
                    }

                    return true;
                }
            }

            return false;

        },

        
        handleFormat: function(type)
        {
            var lineage         = [];
            var currentLinIndex = 0;
            if (this._inlineToolbar) {
                lineage         = this._inlineToolbar.getLineage();
                currentLinIndex = this._inlineToolbar.getCurrentLineageIndex();
            }

            var range          = this.viper.getViperRange();
            var selectedNode   = selectedNode || range.getNodeSelection();
            var nodeSelection  = selectedNode;
            var viperElement   = this.viper.getViperElement();
            var formatElement  = null;

            if (range.collapsed !== true) {
                formatElement = lineage[currentLinIndex];
                if (formatElement && formatElement.nodeType !== ViperUtil.TEXT_NODE) {
                    selectedNode = formatElement;
                }
            }

            if (selectedNode === viperElement) {
                selectedNode = null;
            } else if (selectedNode && ViperUtil.isBlockElement(selectedNode) === false) {
                // Not a block element selection, check if its being wrapped with
                // block elements e.g. <p><strong>text</strong></p>.
                var surroundingBlockElems = ViperUtil.getSurroundingParents(selectedNode, null, true);
                if (surroundingBlockElems.length > 0) {
                    selectedNode = surroundingBlockElems[0];
                }
            }

            if (selectedNode
                && (selectedNode.nodeType !== ViperUtil.ELEMENT_NODE || ViperUtil.isStubElement(selectedNode) === true)
            ) {
                // Text node, get the first block parent.
                selectedNode = ViperUtil.getFirstBlockParent(selectedNode);
            } else if (!selectedNode && (range.collapsed === true || type.match(/^h\d$/))) {
                var startNode = range.getStartNode();
                if (ViperUtil.isBlockElement(startNode) === true) {
                    selectedNode = startNode;
                } else {
                    selectedNode = ViperUtil.getFirstBlockParent(range.startContainer, null, true);
                }
            } else if (selectedNode && ViperUtil.isBlockElement(selectedNode) === false) {
                // Get surrounding parent.
                var surroundParent = ViperUtil.getSurroundingParents(selectedNode, null, 'block', this.viper.getViperElement());
                if (surroundParent.length > 0) {
                    selectedNode = surroundParent.shift();
                }
            }

            if (selectedNode) {
                var ignoreTags = ['li'];
                if (ViperUtil.inArray(ViperUtil.getTagName(selectedNode), ignoreTags) === true) {
                    return false;
                }

                if (selectedNode !== viperElement) {
                    var bookmark = this.viper.createBookmark();

                    if (ViperUtil.isTag(selectedNode, 'td') === true
                        || ViperUtil.isTag(selectedNode, 'th') === true
                        || ViperUtil.isTag(selectedNode, 'caption') === true
                    ) {
                        // Do not convert the TD tag.
                        var newElem = document.createElement(type);
                        if (type === 'blockquote' && ViperUtil.getTag(selectedNode, 'p').length === 0) {
                            newElem.appendChild(document.createElement('p'));
                            while (selectedNode.firstChild) {
                                newElem.firstChild.appendChild(selectedNode.firstChild);
                            }
                        } else if (type.match(/^h\d$/)) {
                            while (selectedNode.firstChild) {
                                if (ViperUtil.isBlockElement(selectedNode.firstChild) === true) {
                                    while (selectedNode.firstChild.firstChild) {
                                        newElem.appendChild(selectedNode.firstChild.firstChild);
                                    }

                                    ViperUtil.remove(selectedNode.firstChild);
                                } else {
                                    newElem.appendChild(selectedNode.firstChild);
                                }
                            }
                        } else {
                            while (selectedNode.firstChild) {
                                newElem.appendChild(selectedNode.firstChild);
                            }
                        }

                        selectedNode.appendChild(newElem);
                        this.viper.selectBookmark(bookmark);
                    } else if (ViperUtil.isBlockElement(selectedNode) === false) {
                        // Wrap element.
                        var newElem = document.createElement(type);
                        ViperUtil.insertBefore(selectedNode, newElem);

                        if (type === 'blockquote') {
                            var p = document.createElement('p');
                            newElem.appendChild(p);
                            newElem = p;
                        }

                        newElem.appendChild(selectedNode);
                        range = this.viper.selectBookmark(bookmark);
                        ViperSelection.addRange(range);
                    } else {
                        var newElem = this._convertSingleElement(selectedNode, type);
                        if (nodeSelection && newElem) {
                            this.viper.removeBookmarks();

                            // If the element is empty then collapse range.
                            if (ViperUtil.hasContent(newElem) === false) {
                                if (type === 'blockquote') {
                                    ViperUtil.setHtml(newElem, '<p><br/></p>');
                                    range.setStart(newElem.firstElementChild.firstElementChild, 0);
                                } else if (type === 'pre') {
                                    ViperUtil.setHtml(newElem, ' ');
                                    range.setStart(newElem.firstChild, 0);
                                } else {
                                    ViperUtil.setHtml(newElem, '<br/>');
                                    range.setStart(newElem.firstElementChild, 0);
                                }

                                range.collapse(true);
                            } else {
                                range.selectNode(newElem);
                            }

                            ViperSelection.addRange(range);
                        } else {
                            this.viper.selectBookmark(bookmark);
                        }
                    }

                    this.viper.contentChanged();
                } else {
                    // We cannot convert the Viper element so we need to create a new
                    // element from the textnodes that are around the current range.
                    this._handleTopLevelFormat(type, range);
                }
            } else {
                var start    = range.getStartNode();
                var end      = range.getEndNode();
                var elements = ViperUtil.getElementsBetween(start, end);
                elements.unshift(start);

                if (start !== end && end) {
                    if (end.nodeType === ViperUtil.TEXT_NODE && range.endOffset > 0) {
                        elements.push(end);
                    } else {
                        var elem = range.getPreviousContainer(end, null, true);
                        range.setEnd(elem, elem.data.length);
                        ViperSelection.addRange(range);
                    }
                }

                var parents = [];
                var c       = elements.length;
                for (var i = 0; i < c; i++) {
                    if (elements[i].nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(elements[i].data)) === true) {
                        continue;
                    } else if (ViperUtil.isBlockElement(elements[i]) === true) {
                        if (ViperUtil.inArray(elements[i], parents) === false) {
                            parents.push(elements[i]);
                        }
                    } else {
                        var parent    = ViperUtil.getFirstBlockParent(elements[i]);
                        if (parent && ViperUtil.inArray(parent, parents) === false) {
                            parents.push(parent);
                        }
                    }
                }

                if (parents.length === 1 && range.collapsed === false) {
                    // Convert only the selection to specified element.
                    // This will create the new element inside the parent element.
                    var parent     = parents[0];
                    var newElement = document.createElement(type);
                    var contents   = range.getHTMLContents();

                    if (type === 'blockquote') {
                        contents = '<p>' + contents + '</p>';
                    }

                    ViperUtil.setHtml(newElement, contents);

                    var bookmark = this.viper.createBookmark();
                    ViperUtil.remove(ViperUtil.getElementsBetween(bookmark.start, bookmark.end));
                    ViperUtil.insertAfter(bookmark.start, newElement);
                    this.viper.selectBookmark(bookmark);

                    this.viper.contentChanged();
                    this.viper.fireCallbacks('ViperFormatPlugin:formatChanged', type);

                    return;
                }

                // Check if all the parents are siblings. If there is a parent element
                // that is not a sibling see if its the only child of its parent and if
                // that is a sibling.
                var prevParent = null;
                var siblings   = true;
                var commonElem = range.getCommonElement();
                var newParents = [];

                for (var i = 0; i < parents.length; i++) {
                    var parent = parents[i];
                    if (parent !== commonElem && parent.parentNode !== commonElem) {
                        var parentParents = ViperUtil.getParents(parent, null, commonElem);

                        // Check if any of these parents are already in newParents array.
                        var skip = false;
                        if (newParents.length !== 0) {
                            for (var j = 0; j < parentParents.length; j++) {
                                if (ViperUtil.inArray(parentParents[j], newParents) === true) {
                                    skip = true;
                                    break;
                                }
                            }
                        }

                        if (skip === true) {
                            continue;
                        }

                        // Check if its the first child of its parent.
                        for (var j = 0; j < parentParents.length; j++) {
                            var parentParent = parentParents[j];
                            for (var node = parent.previousSibling; node; node = node.previousSibling) {
                                if (node && node.nodeType === ViperUtil.ELEMENT_NODE || ViperUtil.trim(node.data) !== '') {
                                    return false;
                                }
                            }

                            parent = parentParent;
                        }

                        newParents.push(parent);
                    } else {
                        newParents.push(parent);
                    }//end if
                }//end for

                if (newParents.length > 0) {
                    var removeType = false;

                    if (ViperUtil.isTag(commonElem, type) === true && commonElem !== viperElement) {
                        // Check if we are removing the type. If first parent and last parent are the whole selection
                        // then remove the common type.
                        var firstSelectableParent = ViperUtil.getFirstBlockParent(range._getFirstSelectableChild(commonElem));
                        var lastSelectableParent  = ViperUtil.getFirstBlockParent(range._getLastSelectableChild(commonElem));
                        var lastParent = newParents[(newParents.length - 1)];
                        if (firstSelectableParent === newParents[0]) {
                            while (lastSelectableParent !== commonElem) {
                                if (lastSelectableParent === lastParent) {
                                    removeType = true;
                                    break;
                                }

                                lastSelectableParent = lastSelectableParent.parentNode;
                            }
                        }
                    }

                    var bookmark = this.viper.createBookmark();

                    if (removeType === true) {
                        for (var i = 0; i < newParents.length; i++) {
                            ViperUtil.insertBefore(commonElem, newParents[i]);
                        }

                        ViperUtil.remove(commonElem);
                    } else {
                        var newElem = document.createElement(type);
                        ViperUtil.insertBefore(newParents[0], newElem);
                        for (var i = 0; i < newParents.length; i++) {
                            if (type === 'blockquote' && ViperUtil.isTag(newParents[i], 'p') === false) {
                                // Replace any block elements with P tags.
                                var pTag = document.createElement('p');
                                while (newParents[i].firstChild) {
                                    pTag.appendChild(newParents[i].firstChild);
                                }
                                newElem.appendChild(pTag);
                                ViperUtil.remove(newParents[i]);
                            } else {
                                newElem.appendChild(newParents[i]);
                            }
                        }

                    }

                    this.viper.selectBookmark(bookmark);
                    this.viper.contentChanged();
                }
            }//end if

            this.viper.fireCallbacks('ViperFormatPlugin:formatChanged', type);

        },

        _convertSingleElement: function(element, type)
        {
            var isBlockQuote = false;
            if (ViperUtil.isTag(element, 'p') === true && ViperUtil.isTag(element.parentNode, 'blockquote') === true) {
                element      = element.parentNode;
                isBlockQuote = true;
            } else if (ViperUtil.isTag(element, 'blockquote') === true) {
                isBlockQuote = true;
            }

            if (ViperUtil.isTag(element, type) === true) {
                if (element.parentNode === this.viper.getViperElement()) {
                    if (this.viper.getDefaultBlockTag() !== '') {
                        if (type === this.viper.getDefaultBlockTag()) {
                            return null;
                        } else if (ViperUtil.hasBlockChildren(element) === false) {
                            return this._convertSingleElement(element, this.viper.getDefaultBlockTag());
                        } else {
                            var parentElem = null;
                            while (element.firstChild) {
                                if (ViperUtil.isBlockElement(element.firstChild) === false) {
                                    if (element.firstChild.nodeType === ViperUtil.TEXT_NODE
                                        && ViperUtil.isBlank(ViperUtil.trim(element.firstChild.data)) === true
                                    ) {
                                        ViperUtil.remove(element.firstChild);
                                        continue;
                                    } else if (!parentElem) {
                                        parentElem = document.createElement(this.viper.getDefaultBlockTag());
                                        ViperUtil.insertBefore(element, parentElem);
                                    }

                                    parentElem.appendChild(element.firstChild);
                                } else {
                                    parentElem = null;
                                    ViperUtil.insertBefore(element, element.firstChild);
                                }
                            }

                            ViperUtil.remove(element);
                            return;
                        }
                    }
                }

                if (type.indexOf('h') === 0) {
                    // Heading to P tag.
                    var p = document.createElement('p');
                    while (element.firstChild) {
                        p.appendChild(element.firstChild);
                    }

                    ViperUtil.insertBefore(element, p);
                } else {
                    // This is element is already the specified type remove the element.
                    while (element.firstChild) {
                        if (isBlockQuote === true && ViperUtil.isTag(element.firstChild, 'p') === true) {
                            // Also remove the P tags.
                            while (element.firstChild.firstChild) {
                                ViperUtil.insertBefore(element, element.firstChild.firstChild);
                            }

                            ViperUtil.remove(element.firstChild);
                        } else {
                            ViperUtil.insertBefore(element, element.firstChild);
                        }
                    }
                }

                if (type === 'pre') {
                    this._convertNewLineToBr(element);
                }

                ViperUtil.remove(element);
            } else if (type === 'blockquote') {
                var newElem = document.createElement(type);
                ViperUtil.insertBefore(element, newElem);

                if (ViperUtil.isTag(element, 'p') === true) {
                    newElem.appendChild(element);
                } else if (ViperUtil.getTag('p', element).length > 0) {
                    while (element.firstChild) {
                        newElem.appendChild(element.firstChild);
                    }

                    ViperUtil.remove(element);
                } else {
                    var p = document.createElement('p');
                    newElem.appendChild(p);
                    while (element.firstChild) {
                        p.appendChild(element.firstChild);
                    }

                    ViperUtil.remove(element);
                }

                ViperUtil.copyAttributes(element, newElem);

                return newElem;
            } else {
                var newElem = document.createElement(type);

                if (isBlockQuote === true && (type === 'p' || type === 'pre')) {
                    for (var childPTag = element.firstChild; childPTag; childPTag = childPTag.nextSibling) {
                        while (childPTag.firstChild) {
                            newElem.appendChild(childPTag.firstChild);
                        }
                    }
                } else if (isBlockQuote === true && type.match(/^h\d$/)) {
                    while (element.firstChild) {
                        newElem.appendChild(element.firstChild);
                    }

                    var pTag = ViperUtil.getTag('p', newElem)[0];
                    while (pTag.firstChild) {
                        newElem.appendChild(pTag.firstChild);
                    }

                    ViperUtil.remove(pTag);
                } else if (isBlockQuote === true && type === 'div') {
                    var childPTags = ViperUtil.getTag('p', element);
                    for (var i = 0; i < childPTags.length; i++) {
                        var childPTag = childPTags[i];

                        var div = document.createElement('div');
                        ViperUtil.copyAttributes(element, div);
                        ViperUtil.insertBefore(element, div);
                        while (childPTag.firstChild) {
                            div.appendChild(childPTag.firstChild);
                        }
                    }

                    newElem = null;
                } else if (type.match(/^h\d$/)) {
                    while (element.firstChild) {
                        if (ViperUtil.isBlockElement(element.firstChild) === true) {
                            var firstChild = element.firstChild;
                            if (ViperUtil.isTag(firstChild, 'blockquote') === true) {
                                firstChild = firstChild.firstChild;
                            }

                            while (firstChild.firstChild) {
                                newElem.appendChild(firstChild.firstChild);
                            }

                            ViperUtil.remove(element.firstChild);
                        } else {
                            newElem.appendChild(element.firstChild);
                        }
                    }
                } else {
                    while (element.firstChild) {
                        newElem.appendChild(element.firstChild);
                    }
                }

                if (newElem) {
                    if (type === 'pre') {
                        this._convertBrToNewLine(newElem);
                    } else if (ViperUtil.isTag(element, 'pre') === true) {
                        this._convertNewLineToBr(newElem);
                    }

                    ViperUtil.insertBefore(element, newElem);

                    ViperUtil.copyAttributes(element, newElem);
                }

                ViperUtil.remove(element);

                return newElem;
            }

            return null;

        },

        _convertBrToNewLine: function(element)
        {
            var brTags = ViperUtil.getTag('br', element);
            for (var i = 0; i < brTags.length; i++) {
                var node = document.createTextNode("\n");
                ViperUtil.insertBefore(brTags[i], node);
                ViperUtil.remove(brTags[i]);
            }

        },

        _convertNewLineToBr: function(element)
        {
            if (element.nodeType === ViperUtil.TEXT_NODE) {
                var nlIndex = -1;

                do {
                    nlIndex = element.data.lastIndexOf("\n");
                    if (nlIndex >= 0) {
                        var newNode = element.splitText(nlIndex);
                        var br      = document.createElement('br');
                        ViperUtil.insertBefore(newNode, br);

                        if (newNode.data.length === 1) {
                            ViperUtil.remove(newNode);
                        } else {
                            newNode.data = newNode.data.substring(1, newNode.data.length);
                        }
                    }
                } while (nlIndex >= 0);
            } else {
                var textNodes = ViperUtil.getTextNodes(element);
                var c         = textNodes.length;
                for (var i = 0; i < c; i++) {
                    var textNode = textNodes[i];
                    this._convertNewLineToBr(textNode);
                }
            }

        },

        _handleTopLevelFormat: function(type, range)
        {
            var bookmark = this.viper.createBookmark();

            // Find the block parent before and after the bookmarks.
            var elements = [];

            // Elements before..
            var node     = bookmark.start;
            while (node && ViperUtil.isBlockElement(node) === false) {
                elements.unshift(node);
                node = node.previousSibling;
            }

            var insideSelection = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
            var count = insideSelection.length;
            for (var i = 0; i < count; i++) {
                if (ViperUtil.isBlockElement(insideSelection[i]) === true && ViperUtil.isStubElement(insideSelection[i]) === false) {
                    var group = [];
                    for (var j = 0; j < insideSelection[i].childNodes.length; j++) {
                        group.push(insideSelection[i].childNodes[j]);
                    }
                    elements.push(group);
                } else {
                    elements.push(insideSelection[i]);
                }
            }

            // Elements after..
            node = bookmark.end;
            while (node && ViperUtil.isBlockElement(node) === false) {
                elements.push(node);
                node = node.nextSibling;
            }

            if (elements.length === 0) {
                return;
            }

            var newBlock    = document.createElement(type);
            var prevBlock   = newBlock;
            ViperUtil.insertBefore(elements[0], newBlock);

            var c = elements.length;
            for (var i = 0; i < c; i++) {
                if (elements[i] instanceof Array) {
                    newBlock = document.createElement(type);
                    for (var j = 0; j < elements[i].length; j++) {
                        newBlock.appendChild(elements[i][j]);
                    }

                    ViperUtil.insertAfter(prevBlock, newBlock);
                    prevBlock = newBlock;
                    newBlock = null;
                } else {
                    if (!newBlock) {
                        newBlock = document.createElement(type);
                        ViperUtil.insertAfter(prevBlock, newBlock);
                        prevBlock = newBlock;
                    }

                    newBlock.appendChild(elements[i]);
                }
            }

            this.viper.selectBookmark(bookmark);
            this.viper.contentChanged();

        },

        _getFormat: function(startNode)
        {
            while (startNode.parentNode) {
                if (startNode === document) {
                    return null;
                }

                if (startNode.tagName) {
                    var tagName = startNode.tagName.toLowerCase();
                    if (this.styleTags[tagName]) {
                        return tagName;
                    }
                }

                startNode = startNode.parentNode;
            }

            return null;

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperHistoryPlugin(viper)
    {
        var self           = this;
        var _toolbarPlugin = null;

        this.init = function()
        {
            var toolbarPlugin = viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (toolbarPlugin) {
                _toolbarPlugin = toolbarPlugin;
                var tools = viper.Tools;

                var toolbarButtons = {
                    undo: 'undo',
                    redo: 'redo'
                };

                var btnGroup = tools.createButtonGroup('ViperHistoryPlugin:buttons');
                tools.createButton('undo', '', _('Undo'), 'Viper-historyUndo', function() {
                    return self.handleUndo();
                });
                tools.createButton('redo', '', _('Redo'), 'Viper-historyRedo', function() {
                    return self.handleRedo();
                });
                tools.addButtonToGroup('undo', 'ViperHistoryPlugin:buttons');
                tools.addButtonToGroup('redo', 'ViperHistoryPlugin:buttons');
                toolbarPlugin.addButton(btnGroup);

                tools.getItem('undo').setButtonShortcut('CTRL+Z');
                tools.getItem('redo').setButtonShortcut('CTRL+SHIFT+Z');

                viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperHistoryPlugin', function(data) {
                    _updateToolbarButtonStates(toolbarButtons);
                });

                _updateToolbarButtonStates(toolbarButtons);

                viper.registerCallback(['ViperHistoryManager:add', 'ViperHistoryManager:undo', 'ViperHistoryManager:redo', 'ViperHistoryManager:clear'], 'ViperHistoryPlugin', function(e) {
                    _updateToolbarButtonStates(toolbarButtons);
                });
            }

        };

        this.handleUndo = function()
        {
            viper.HistoryManager.undo();

            return false;

        };

        this.handleRedo = function()
        {
            viper.HistoryManager.redo();

            return false;

        };

        var _updateToolbarButtonStates = function(toolbarButtons)
        {
            if (!_toolbarPlugin) {
                return;
            }

            var tools = viper.Tools;
            if (viper.HistoryManager.getUndoCount() > 1) {
                tools.enableButton(toolbarButtons.undo);
            } else {
                tools.disableButton(toolbarButtons.undo);
            }

            if (viper.HistoryManager.getRedoCount() > 0) {
                tools.enableButton(toolbarButtons.redo);
            } else {
                tools.disableButton(toolbarButtons.redo);
            }

        }

    };

    Viper.PluginManager.addPlugin('ViperHistoryPlugin', ViperHistoryPlugin);
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperImagePlugin(viper)
    {
        this.viper = viper;

        this._previewBox    = null;
        this._resizeImage   = null;
        this._ieImageResize = null;
        this._resizeHandles = null;
        this._inlineToolbar = null;
        this._moveImage     = null;

        this._initInlineToolbar();

    }

    Viper.PluginManager.addPlugin('ViperImagePlugin', ViperImagePlugin);

    ViperImagePlugin.prototype = {

        init: function()
        {
            this.initTopToolbar();

            var self = this;
            this.viper.registerCallback('Viper:mouseDown', 'ViperImagePlugin', function(e) {
                var target = ViperUtil.getMouseEventTarget(e);
                self._ieImageResize = null;

                if (ViperUtil.isTag(target, 'img') === true) {
                    ViperUtil.preventDefault(e);
                    self.hideImageResizeHandles();
                    self.showImageResizeHandles(target);
                    self._cancelMove();
                    self._updateToolbars(target);

                    var range = self.viper.getViperRange();
                    range.selectNode(target);
                    ViperSelection.addRange(range);
                    if (ViperUtil.isBrowser('msie') === true) {
                        self.viper.fireSelectionChanged(range, true);
                    }

                    if (ViperUtil.isBrowser('msie', '<9') === true && ViperUtil.isTag(target, 'img') === true) {
                        self._ieImageResize = target;
                        self.viper.registerCallback('Viper:mouseUp', 'ViperImagePlugin:ie', function(e) {
                           var range = self.viper.getCurrentRange();
                           if (!target.nextSibling || target.nextSibling.nodeType !== ViperUtil.TEXT_NODE) {
                               var textNode = document.createTextNode('');
                               ViperUtil.insertAfter(target, textNode);
                           }

                           if (!target.previousSibling || target.previousSibling.nodeType !== ViperUtil.TEXT_NODE) {
                               var textNode = document.createTextNode('');
                               ViperUtil.insertBefore(target, textNode);
                           }

                           range.setStart(target.previousSibling, target.previousSibling.data.length);
                           range.setEnd(target.nextSibling, 0);
                           ViperSelection.addRange(range);

                           ViperUtil.preventDefault(e);
                           self.viper.removeCallback('Viper:mouseUp', 'ViperImagePlugin:ie');
                           return false;
                        });
                    }

                    // Enable toolbar if its not already due to event cancelation.
                    var toolbar = self.viper.PluginManager.getPlugin('ViperToolbarPlugin');
                    if (toolbar && toolbar.isDisabled() === true) {
                        toolbar.enable();
                    }

                    return false;
                } else {
                    self._updateToolbars();
                    return self.hideImageResizeHandles();
                }
            });

            this.viper.registerCallback(['Viper:keyDown', 'Viper:beforeDelete'], 'ViperImagePlugin', function(e) {
                if (self._resizeImage
                    && ViperUtil.isInputKey(e)
                    && e.which !== 20
                    && e.which !== 16
                    && e.which !== 9
                ) {
                    self.hideImageResizeHandles();
                }

                if (e.which === 8 || e.which === 46) {
                    var range = self.viper.getViperRange();
                    if (range.getHTMLContentsObj().childNodes.length > 1) {
                        // Other content is also selected.
                        return;
                    }

                    if (self._resizeImage) {
                        if (self.removeImage(self._resizeImage) === true) {
                            self._updateToolbars();
                            self._inlineToolbar.hide();
                            return false;
                        }
                    }

                    if (self._ieImageResize) {
                        ViperUtil.remove(self._ieImageResize);
                        self._ieImageResize = null;
                        self.viper.contentChanged(true);
                        return false;
                    } else {
                        var range        = self.viper.getViperRange();
                        var selectedNode = range.getNodeSelection();
                        if (selectedNode) {
                            if (self.removeImage(selectedNode) === true) {
                                self._updateToolbars();
                                return false;
                            }
                        }
                    }
                }
            });

            this.viper.registerCallback('Viper:getHtml', 'ViperImagePlugin', function(data) {
                var tags = ViperUtil.getClass('ui-resizable', data.element);
                for (var i = 0; i < tags.length; i++) {
                    var parent = tags[i].parentNode;
                    ViperUtil.removeClass(tags[i], 'ui-resizable');
                    ViperUtil.insertBefore(parent, tags[i]);
                    self.hideImageResizeHandles();
                    ViperUtil.remove(parent);

                    // Remove empty style and class attributes.
                    if (!tags[i].getAttribute('style')) {
                        tags[i].removeAttribute('style');
                    }

                    if (!tags[i].getAttribute('class')) {
                        tags[i].removeAttribute('class');
                    }
                }
            });

            this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperImagePlugin', function(data) {
                self.viper.Tools.enableButton('image');
            });

            this.viper.registerCallback('ViperCoreStylesPlugin:afterImageUpdate', 'ViperImagePlugin', function(image) {
                self.showImageResizeHandles(image);
            });

            this.viper.registerCallback(
                ['ViperHistoryManager:beforeUndo', 'Viper:clickedOutside', 'ViperTools:popup:open', 'ViperCoreStylesPlugin:beforeImageUpdate', 'Viper:cut', 'Viper:disabled'],
                'ViperImagePlugin',
                function() {
                    self.hideImageResizeHandles();
                }
            );

            this.viper.registerCallback('Viper:dropped', 'ViperImagePlugin', function(data) {
                if (!data.dataTransfer.files) {
                    return;
                }

                var range    = data.range;
                if (data.e.target && ViperUtil.isTag(data.e.target, 'img') === true) {
                    // Image dropped on top of another image. Replace.
                    range.selectNode(data.e.target);
                }

                var bookmark = self.viper.createBookmark(range, null, 'imageDrop');

                // TODO: For some reason dropping image between two elements sometimes causes bookmark elements to move
                // to the end of the Viper element. Adding this tmp element before it and then re adding the bookmark
                // back to its position seems to resolve this issue.
                var _tmpElem = document.createElement('span');
                ViperUtil.insertBefore(bookmark.start, _tmpElem);

                for (var i = 0; i < data.dataTransfer.files.length; i++) {
                    self.readDroppedImage(data.dataTransfer.files[i], function(image, file) {
                        ViperUtil.insertBefore(_tmpElem, bookmark.start);
                        ViperUtil.insertBefore(_tmpElem, bookmark.end);
                        self.insertDroppedImage(image, range, file);
                        noImage = false;
                    });
                }

                if (data.dataTransfer.files.length > 0) {
                    return false;
                }
            });

            this.viper.registerCallback(
                'Viper:editableElementChanged',
                'ViperImagePlugin',
                function() {
                    var elemDoc = self.viper.getViperElementDocument();
                    if (elemDoc !== document) {
                        ViperUtil.removeEvent(elemDoc.defaultView, 'scroll.ViperImagePlugin');
                        ViperUtil.addEvent(
                            elemDoc.defaultView,
                            'scroll.ViperImagePlugin',
                            function(e) {
                                if (self._resizeImage) {
                                    self.showImageResizeHandles(self._resizeImage);
                                }
                            }
                        );
                    }//end if
                }
            );

        },

        readDroppedImage: function(file, callback)
        {
            var self   = this;
            var reader = new FileReader();
            reader.onload = function (event) {
                var image = new Image();
                image.src = event.target.result;
                callback.call(self, image, file);
            };

            reader.readAsDataURL(file);

        },

        insertDroppedImage: function(image, range, fileInfo)
        {
            fileInfo    = fileInfo || {};
            range       = range || this.viper.getViperRange();
            image.alt   = fileInfo.name || '';

            this._rangeToImage(range, image);

        },

        moveImage: function(image, range)
        {
            if (!range || !image) {
                return;
            }

            return this._rangeToImage(range, image, null, null, null, true);
        },

        rangeToImage: function(range, url, alt, title)
        {
            if (!range || !url) {
                return;
            }

            return this._rangeToImage(range, null, url, alt, title);

        },

        _rangeToImage: function(range, img, url, alt, title, isMoveAction)
        {
            this._resizeImage = null;

            range = range || this.viper.getViperRange();
            var selectedNode = range.getNodeSelection();

            if (ViperUtil.isBlockElement(selectedNode) === true) {
                ViperUtil.setHtml(selectedNode, '&nbsp');
                range.setStart(selectedNode.firstChild, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
            }

            if (this.viper.rangeInViperBounds(range) === false) {
                range = this.viper.getViperRange();
            }

            var bookmark = this.viper.getBookmarkById('imageDrop') || this.viper.createBookmark(range);

            var elems = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
            for (var i = 0; i < elems.length; i++) {
                ViperUtil.remove(elems[i]);
            }

            var newImage = false;
            if (!img) {
                newImage = true;
                img = document.createElement('img');

                this.viper.setAttribute(img, 'src', url);

                if (alt !== null) {
                    this.viper.setAttribute(img, 'alt', alt, true);
                }

                if (title !== null && ViperUtil.trim(title).length !== 0) {
                    this.viper.setAttribute(img, 'title', title);
                }
            }

            if (isMoveAction === true) {
                // Image is being moved, make sure its surrounding parents also move with it.
                var surroundingParents = ViperUtil.getSurroundingParents(img, null, null, this.viper.getViperElement());
                if (surroundingParents.length > 0) {
                    var parent = null
                    while (parent = surroundingParents.pop()) {
                        if (ViperUtil.isBlockElement(parent) === false) {
                            ViperUtil.insertBefore(bookmark.start, parent);
                            break;
                        }
                    }

                    if (!parent) {
                        if (bookmark.start.parentNode === img) {
                            this.viper.removeBookmark(bookmark, true);
                            this._cancelMove();
                            return;
                        } else {
                            ViperUtil.insertBefore(bookmark.start, img);
                        }
                    }
                } else if (bookmark.start.parentNode === img) {
                    this.viper.removeBookmark(bookmark, true);
                    this._cancelMove();
                    return;
                } else {
                    ViperUtil.insertBefore(bookmark.start, img);
                }
            } else {
                ViperUtil.insertBefore(bookmark.start, img);
            }

            this.viper.removeBookmark(bookmark);

            ViperSelection.removeAllRanges();

            if (ViperUtil.isBrowser('msie', '>=11') === true) {
                var selectable = img.nextSibling;
                if (!img.nextSibling) {
                    selectable = document.createTextNode(' ');
                    ViperUtil.insertAfter(img, selectable);
                } else if (img.nextSibling.nodeType !== ViperUtil.TEXT_NODE) {
                    selectable = range.getFirstSelectableChild(img.nextSibling);
                    if (selectable) {
                        selectable = document.createTextNode(' ');
                        ViperUtil.insertAfter(img, selectable);
                    }
                }

                range.setStart(selectable, 1);
                range.collapse(true);
                ViperSelection.addRange(range);
            } else if (newImage === true && ViperUtil.isBrowser('msie', '<11') === true) {
                ViperUtil.removeAttr(img, 'width');
                ViperUtil.removeAttr(img, 'height');
            }

            this.viper.contentChanged();

            return img;

        },

        removeImage: function(image)
        {
            if (image && ViperUtil.isTag(image, 'img') === true) {
                this.hideImageResizeHandles();

                // If there are text nodes around then move the range to one of them,
                // else create a new text node and move the range to it.
                var node  = null;
                var start = 0;
                if (image.nextSibling && image.nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                    node = image.nextSibling;
                } else if (image.previousSibling && image.previousSibling.nodeType === ViperUtil.TEXT_NODE) {
                    node  = image.previousSibling;
                    start = node.data.length;
                } else if (image.parentNode && ViperUtil.isTag(image.parentNode, 'a') === true) {
                    if (image.parentNode.nextSibling && image.parentNode.nextSibling.nodeType === ViperUtil.TEXT_NODE) {
                        node = image.parentNode.nextSibling;
                    } else if (image.parentNode.previousSibling && image.parentNode.previousSibling.nodeType === ViperUtil.TEXT_NODE) {
                        node = image.parentNode.previousSibling;
                        start = image.parentNode.previousSibling.data.length;
                    } else {
                        node = document.createTextNode(' ');
                        ViperUtil.insertAfter(image.parentNode, node);
                    }

                    ViperUtil.remove(image.parentNode);
                } else {
                    node = document.createTextNode(' ');
                    ViperUtil.insertAfter(image, node);
                }

                image.parentNode.removeChild(image);

                var range = this.viper.getViperRange();
                range.setStart(node, start);
                range.collapse(true);
                ViperSelection.addRange(range);

                this.viper.contentChanged();

                return true;
            }

            return false;
        },

        setImageAlt: function(image, alt, keepEmptyAttribute)
        {
            if (!image) {
                return;
            }

            this.viper.setAttribute(image, 'alt', alt, keepEmptyAttribute);

        },

        setImageURL: function(image, url)
        {
            if (!image) {
                return;
            }

            this.viper.setAttribute(image, 'src', url);

        },

        setImageTitle: function(image, title)
        {
            if (!image) {
                return;
            } else if (title === null) {
                image.removeAttribute('title');
            } else {
                this.viper.setAttribute(image, 'title', title);
            }

        },

        initTopToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            // Preview box to display image info and preview.
            var previewBox = document.createElement('div');
            ViperUtil.addClass(previewBox, 'ViperITP-msgBox ViperImagePlugin-previewPanel');
            ViperUtil.setHtml(previewBox, 'Loading preview');
            ViperUtil.setStyle(previewBox, 'display', 'none');
            this._previewBox = previewBox;

            var self       = this;
            var tools      = this.viper.Tools;
            var subContent = this._getToolbarContents('ViperImagePlugin');

            var imgTools = toolbar.createBubble('ViperImagePlugin:bubble', _('Insert Image'), subContent);
            tools.getItem('ViperImagePlugin:bubble').setSubSectionAction('ViperImagePlugin:bubbleSubSection', function() {
                self._setImageAttributes('ViperImagePlugin');
            }, ['ViperImagePlugin:urlInput', 'ViperImagePlugin:altInput', 'ViperImagePlugin:titleInput', 'ViperImagePlugin:isDecorative']);

            // Add the preview panel to the popup contents.
            subContent.appendChild(previewBox);

            var toggleImagePlugin = tools.createButton('image', '', _('Toggle Image Options'), 'Viper-image', null, true);
            toolbar.addButton(toggleImagePlugin);
            toolbar.setBubbleButton('ViperImagePlugin:bubble', 'image');
        },

        _getToolbarContents: function(prefix)
        {
            var self  = this;
            var tools = this.viper.Tools;

            // Create Image button and popup.
            var createImageSubContent = document.createElement('div');

            // URL text box.
            var urlTextbox = null;
            var url = tools.createTextbox(prefix + ':urlInput', _('URL'), '', null, true);
            createImageSubContent.appendChild(url);
            urlTextbox = (ViperUtil.getTag('input', createImageSubContent)[0]);

            // Test URL.
            var inputTimeout = null;
            this.viper.registerCallback('ViperTools:changed:' + prefix + ':urlInput', 'ViperImagePlugin', function() {
                clearTimeout(inputTimeout);

                var url = ViperUtil.trim(tools.getItem('ViperImagePlugin:urlInput').getValue());
                if (!url) {
                     ViperUtil.setStyle(self._previewBox, 'display', 'none');
                     tools.setFieldErrors(prefix + ':urlInput', []);
                } else {
                    if (url === '- Dropped Image -') {
                        url = self._base64ImgSRC;
                    }

                    // After a time period update the image preview.
                    inputTimeout = setTimeout(function() {
                        self._lastPreviewURL = null;
                        self.updateImagePreview(url);
                    }, 1000);
                }
            });

            // Decorative checkbox.
            var decorative = tools.createCheckbox(prefix + ':isDecorative', _('Image is decorative'), false, function(presVal) {
                if (presVal === true) {
                    tools.getItem(prefix + ':altInput').disable();
                    tools.getItem(prefix + ':titleInput').disable();
                    tools.getItem(prefix + ':altInput').setRequired(false);
                } else {
                    tools.getItem(prefix + ':altInput').setRequired(true);
                    tools.getItem(prefix + ':altInput').enable();
                    tools.getItem(prefix + ':titleInput').enable();
                }
            });
            createImageSubContent.appendChild(decorative);

            // Alt text box.
            var alt = tools.createTextbox(prefix + ':altInput', _('Alt'), '', null, true);
            createImageSubContent.appendChild(alt);

            // Title text box.
            var title = tools.createTextbox(prefix + ':titleInput', _('Title'));
            createImageSubContent.appendChild(title);

            return createImageSubContent;

        },

        _setImageAttributes: function(prefix)
        {
            var tools = this.viper.Tools;
            var url   = tools.getItem(prefix + ':urlInput').getValue();
            var alt   = tools.getItem(prefix + ':altInput').getValue();
            var title = tools.getItem(prefix + ':titleInput').getValue();
            var pres  = tools.getItem(prefix + ':isDecorative').getValue();

            if (url === '- Dropped Image -') {
                url = this._base64ImgSRC;
            }

            if (pres === true) {
                title = null;
                alt   = '';
            } else if (title === '') {
                title = null;
            }

            var image = this._resizeImage;
            if (ViperUtil.isBrowser('msie', '<9') === true) {
                image = this._ieImageResize;
            }

            if (!image || ViperUtil.isTag(image, 'img') === false) {
                image = this.rangeToImage(this.viper.getViperRange(), this.getImageUrl(url), alt, title);
            } else {
                this.setImageURL(image, this.getImageUrl(url));
                this.setImageAlt(image, alt, pres);
                this.setImageTitle(image, title);
                this.viper.contentChanged(true);
            }

            this._updateToolbars(image);

            var self = this;
            var imageLoaded = function() {
                // Image is loaded update the handles.
                self.showImageResizeHandles(image);
                self.viper.fireSelectionChanged(null, true);
            };

            image.onload  = imageLoaded;
            image.onerror = imageLoaded;

        },

        _updateToolbars: function(image)
        {
            this._updateToolbar(image, 'ViperImagePlugin');
            this._updateToolbar(image, 'vitpImagePlugin');

        },

        _updateToolbar: function(image, toolbarPrefix)
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            var tools = this.viper.Tools;

            if (image && ViperUtil.isTag(image, 'img') === true) {
                tools.setButtonActive('image');

                var src = this.viper.getAttribute(image, 'src');
                this.setUrlFieldValue(src);
                tools.getItem(toolbarPrefix + ':altInput').setValue(this.viper.getAttribute(image, 'alt') || '');
                tools.getItem(toolbarPrefix + ':titleInput').setValue(this.viper.getAttribute(image, 'title') || '');

                if (!image.getAttribute('alt')) {
                    tools.getItem(toolbarPrefix + ':isDecorative').setValue(true);
                } else {
                    tools.getItem(toolbarPrefix + ':isDecorative').setValue(false);
                }

                // Update preview pane.
                this.updateImagePreview(src);
            } else {
                tools.enableButton('image');
                tools.setButtonInactive('image');

                tools.getItem(toolbarPrefix + ':isDecorative').setValue(false);
                tools.getItem(toolbarPrefix + ':urlInput').setValue('');
                tools.getItem(toolbarPrefix + ':altInput').setValue('');
                tools.getItem(toolbarPrefix + ':titleInput').setValue('');
                tools.setFieldErrors(toolbarPrefix + ':urlInput', []);

                // Update preview pane.
                this._lastPreviewURL = null;
                ViperUtil.empty(this._previewBox);
                ViperUtil.setStyle(this._previewBox, 'display', 'none');
            }//end if

        },


        _initInlineToolbar: function()
        {
            var self = this;
            this.viper.registerCallback('ViperInlineToolbarPlugin:initToolbar', 'ViperImagePlugin', function(toolbar) {
                self.createInlineToolbar(toolbar);
            });

            this.viper.registerCallback('ViperInlineToolbarPlugin:updateToolbar', 'ViperImagePlugin', function(data) {
                self._updateInlineToolbar(data);
            });

        },

        createInlineToolbar: function(toolbar)
        {
            var self       = this;
            var tools      = this.viper.Tools;
            var moveButton = null;
            var image      = null;
            var idPrefix   = 'vitpImagePlugin';

            this._inlineToolbar = toolbar;

            // Create a tooltip that will be shown when the image move icon is clicked.
            tools.createToolTip('ViperImageToolbar-tooltip', _('The selected image will be moved to the next location you click. To cancel, press the move icon again, or ESC'), 'mouse');

            // Image Details.
            var subContent = this._getToolbarContents(idPrefix);
            toolbar.makeSubSection(idPrefix + '-infoSubsection', subContent);
            var imageButton = tools.createButton('vitpImage', '', _('Toggle Image Options'), 'Viper-image', null);
            toolbar.setSubSectionButton('vitpImage', idPrefix + '-infoSubsection');
            toolbar.setSubSectionAction(idPrefix + '-infoSubsection', function() {
                self._setImageAttributes(idPrefix);
            }, [idPrefix + ':urlInput', idPrefix + ':altInput', idPrefix + ':titleInput', idPrefix + ':isDecorative']);

            // Image Move.
            moveButton  = tools.createButton('vitpImageMove', '', _('Move Image'), 'Viper-move', function() {
                self._moveImage = self._resizeImage;

                if (ViperUtil.hasClass(moveButton, 'Viper-selected') === true) {
                    self._cancelMove();
                    return;
                }

                ViperUtil.addClass(moveButton, 'Viper-selected');

                // Show the tooltip under the mouse pointer.
                tools.getItem('ViperImageToolbar-tooltip').show();

                // When mouse is clicked in content move the image to that selection range.
                self.viper.registerCallback('Viper:mouseUp', 'ViperImagePlugin:move', function(e) {
                    var imageElement = self._moveImage;
                    self._cancelMove();

                    var clickTarget = ViperUtil.getMouseEventTarget(e);
                    if (clickTarget) {
                        if (ViperUtil.isTag(clickTarget, 'img') === true
                            || self.viper.isOutOfBounds(clickTarget) === true
                        ) {
                            return;
                        }
                    }

                    var range = self.viper.getViperRange();
                    if (self.viper.rangeInViperBounds(range) === false) {
                        return;
                    }

                    self.moveImage(imageElement, range);
                    ViperSelection.removeAllRanges();
                    range.selectNode(imageElement);
                    ViperSelection.addRange(range);


                    // Show the image resize handles and the toolbar.
                    self.showImageResizeHandles(imageElement);
                    self.viper.fireSelectionChanged(range, true);

                    self._moveImage = null;

                    return false;
                });

                // If ESC key is pressed cancel the image move.
                ViperUtil.addEvent(document, 'keydown.ViperImagePlugin:move', function(e) {
                    if (e.which === 27) {
                        self._cancelMove();
                    }
                });
            });

            var buttonGroup = tools.createButtonGroup('vitpImageBtnGroup');
            buttonGroup.appendChild(imageButton);
            buttonGroup.appendChild(moveButton);

            toolbar.addButton(buttonGroup);

        },

        _updateInlineToolbar: function(data)
        {
            var nodeSelection = data.nodeSelection || data.range.getNodeSelection();
            var self          = this;

            if (!this._resizeImage) {
                this.hideImageResizeHandles();
            }

            if (nodeSelection && ViperUtil.isTag(nodeSelection, 'img') === true) {
                this._resizeImage = nodeSelection;
                this.showInlineToolbarButtons(data);
                nodeSelection.onload = function() {
                    self.showImageResizeHandles(nodeSelection);
                    self._inlineToolbar.update(null, nodeSelection);
                };

                this.viper.Tools.setButtonActive('vitpImage');
                this.showImageResizeHandles(nodeSelection);
                this._updateToolbars(nodeSelection);
            } else if (this._resizeImage
                && !nodeSelection
                &&  ViperUtil.isBrowser('msie', '<11') === true
            ) {
                setTimeout(
                    function() {
                        self._inlineToolbar.update(null, self._resizeImage);
                    },
                    50
                );
            }

        },

        showInlineToolbarButtons: function(data)
        {
            data.toolbar.showButton('vitpImage');
            data.toolbar.showButton('vitpImageMove');

        },

        _cancelMove: function()
        {
            // Cancel method that is called when image is moved or move event is canceled.
            // It will remove callback methods, change toolbar button statuses etc.
            this.viper.Tools.getItem('ViperImageToolbar-tooltip').hide();
            this.viper.removeCallback('Viper:mouseUp', 'ViperImagePlugin:move');
            ViperUtil.removeEvent(document, 'keydown.ViperImagePlugin:move');
            ViperUtil.removeClass(this.viper.Tools.getItem('vitpImageMove').element, 'Viper-selected');

            this._moveImage = null;

        },

        setUrlFieldValue: function(url)
        {
            if (url.indexOf('data:image') === 0) {
                this._base64ImgSRC = url;
                url = '- Dropped Image -';
            }

            this.viper.Tools.getItem('ViperImagePlugin:urlInput').setValue(url);
            this.viper.Tools.getItem('vitpImagePlugin:urlInput').setValue(url);

        },

        getImageUrl: function(url)
        {
            return url;

        },

        updateImagePreview: function(url)
        {
            if (this._lastPreviewURL === url) {
                return;
            }

            this._lastPreviewURL = url;
            ViperUtil.empty(this._previewBox);

            var self = this;
            this.setPreviewContent(false, true);
            this.loadImage(url, function(img) {
                self.setPreviewContent(img);
            });

        },

        loadImage: function(url, callback)
        {
            var img    = new Image();
            img.onload = function() {
                callback.call(this, img);
            };

            img.onerror = function() {
                callback.call(this, false);
            };

            var replacementPlugin = this.viper.getPluginManager().getPlugin('ViperReplacementPlugin');
            if (replacementPlugin && url.indexOf('data:image') === -1) {
                // Replace the url keyword.
                var self = this;
                replacementPlugin.replaceKeywords(
                    url,
                    function(replaced) {
                        self.viper.setAttribute(img, 'src', replaced);
                    }
                )

            } else {
                this.viper.setAttribute(img, 'src', url);
            }

        },

        setPreviewContent: function(img, loading)
        {
            var previewBox = this._previewBox;
            ViperUtil.setStyle(previewBox, 'display', 'block');

            if (loading === true) {
                ViperUtil.removeClass(previewBox, 'Viper-info');
                ViperUtil.setHtml(previewBox, _('Loading preview'));
                this.viper.Tools.setFieldErrors('ViperImagePlugin:urlInput', []);
            } else if (!img) {
                // Failed to load image.
                ViperUtil.removeClass(previewBox, 'Viper-info');
                ViperUtil.setStyle(previewBox, 'display', 'none');
                this.viper.Tools.setFieldErrors('ViperImagePlugin:urlInput', [_('Failed to load image')]);
            } else {
                this.viper.Tools.setFieldErrors('ViperImagePlugin:urlInput', []);
                ViperUtil.addClass(previewBox, 'Viper-info');

                var tmp = document.createElement('div');
                ViperUtil.setStyle(tmp, 'visibility', 'hidden');
                ViperUtil.setStyle(tmp, 'left', '-9999px');
                ViperUtil.setStyle(tmp, 'top', '-9999px');
                ViperUtil.setStyle(tmp, 'position', 'absolute');
                tmp.appendChild(img);
                this.viper.addElement(tmp);

                ViperUtil.setStyle(img, 'width', '');
                ViperUtil.setStyle(img, 'height', '');

                var width  = ViperUtil.getElementWidth(img);
                var height = ViperUtil.getElementHeight(img);
                ViperUtil.remove(tmp);

                img.removeAttribute('height');
                img.removeAttribute('width');

                var maxWidth  = 185;
                var maxHeight = 185;
                if (height > maxHeight && width > maxWidth) {
                    if (height > width) {
                        ViperUtil.setStyle(img, 'height', maxHeight + 'px');
                        ViperUtil.setStyle(img, 'width', 'auto');
                    } else {
                        ViperUtil.setStyle(img, 'width', maxWidth + 'px');
                        ViperUtil.setStyle(img, 'height', 'auto');
                    }
                } else if (width > maxWidth) {
                    ViperUtil.setStyle(img, 'width', maxWidth + 'px');
                    ViperUtil.setStyle(img, 'height', 'auto');
                } else if (height > maxHeight) {
                    ViperUtil.setStyle(img, 'height', maxHeight + 'px');
                    ViperUtil.setStyle(img, 'width', 'auto');
                }

                ViperUtil.empty(previewBox);
                ViperUtil.setHtml(previewBox, width + 'px x ' + height + 'px<br/>');
                previewBox.appendChild(img);
            }//end if

        },

        showImageResizeHandles: function(image)
        {
            this.hideImageResizeHandles(true);

            var self   = this;
            var rect   = ViperUtil.getBoundingRectangle(image);
            var offset = ViperUtil.getDocumentOffset();
            rect.x1 += offset.x;
            rect.x2 += offset.x;
            rect.y1 += offset.y;
            rect.y2 += offset.y;

            if (document !== image.ownerDocument) {
                var scrollCoords = ViperUtil.getScrollCoords(image.ownerDocument.defaultView);
                rect.x1 -= scrollCoords.x;
                rect.x2 -= scrollCoords.x;
                rect.y1 -= scrollCoords.y;
                rect.y2 -= scrollCoords.y;
            }

            this._resizeImage = image;

            // Create the resize box.
            if (!this._resizeBox) {
                // Determine if the image can be resized (e.g. percentage width).
                // TODO: To be safe should the parent be cloned, incase hiding parent cause page jump etc.
                // ViperUtil.setStyle(image.parentNode, 'display', 'none');
                // var widthStyle = ViperUtil.getStyle(image, 'width');
                // Viper.Util.setStyle(image.parentNode, 'display', '');

                var canResize = true;
                if (image.naturalWidth === 0 || image.naturalHeight === 0) {
                    canResize = false;
                }
                // if (widthStyle && widthStyle.indexOf('%') !== -1) {
                //     // Prevent resizing.
                //     canResize = false;
                // }

                var resizeBox   = document.createElement('div');
                this._resizeBox = resizeBox;

                var windowWidth = ViperUtil.getWindowDimensions().width;
                var sizeDiv     = document.createElement('div');
                ViperUtil.addClass(sizeDiv, 'ViperImagePlugin-sizeDiv');
                ViperUtil.addEvent(
                    sizeDiv,
                    'mousedown',
                    function (e) {
                        // Reset size.
                        self.resetImageSize(image);
                        _updateSize();
                        ViperUtil.preventDefault(e);
                        self.viper.fireCallbacks('ViperImagePlugin:imageSizeReset', {image: image});
                        self.hideImageResizeHandles();
                        self.showImageResizeHandles(image);

                    }
                );
                resizeBox.appendChild(sizeDiv);

                var _updateSize = function (force) {
                    if (force === true || ViperUtil.hasAttribute(image, 'width') === true || ViperUtil.hasAttribute(image, 'height') === true) {
                        var sizeHtml = self.getImageSizeDisplayHtml(image);
                        ViperUtil.setHtml(sizeDiv, sizeHtml);
                        ViperUtil.addClass(sizeDiv, 'visible');
                    } else {
                        ViperUtil.removeClass(sizeDiv, 'visible');
                    }
                };
                _updateSize();

                ViperUtil.addClass(resizeBox, 'ViperImagePlugin-resizeBox');

                // Set the position of the box.
                ViperUtil.setStyle(resizeBox, 'left', rect.x1 + 'px');
                ViperUtil.setStyle(resizeBox, 'top', rect.y1 + 'px');
                ViperUtil.setStyle(resizeBox, 'width', rect.x2 - rect.x1 + 'px');
                ViperUtil.setStyle(resizeBox, 'height', rect.y2 - rect.y1 + 'px');

                if (canResize === true) {
                    ViperUtil.addClass(resizeBox, 'canResize');

                    // Create the handles for each corner.
                    var _createHandle = function(className) {
                        var handle = document.createElement('div');
                        ViperUtil.addClass(handle, 'ViperImagePlugin-resizeBox-handle ViperImagePlugin-resizeBox-handle-' + className);
                        resizeBox.appendChild(handle);

                        ViperUtil.addEvent(
                            handle,
                            'mousedown.ViperImagePlugin-resize',
                            function (e) {
                                ViperUtil.preventDefault(e);

                                var posx       = e.pageX;
                                var posy       = e.pageY;
                                var ratio      = (image.height / image.width);
                                var width      = image.width;
                                var height     = image.height;
                                var naturalDim = self.getImageNaturalDimensions(image);
                                var both       = e.shiftKey;
                                var resized    = false;
                                var docs       = ViperUtil.getDocuments(true, ViperUtil.getTopDocument());

                                ViperUtil.setStyle(image, 'width', '');
                                ViperUtil.setStyle(image, 'height', '');

                                self._inlineToolbar.hide();
                                _updateSize(true);

                                ViperUtil.addEvent(
                                    docs,
                                    'mousemove.ViperImagePlugin-resize',
                                    function (e) {
                                        var diffx = e.pageX - posx;
                                        var diffy = e.pageY - posy;
                                        posx      = e.pageX;
                                        posy      = e.pageY;
                                        resized   = true;

                                        if (ViperUtil.hasClass(handle, 'ViperImagePlugin-resizeBox-handle-bottomLeft') === true
                                            || ViperUtil.hasClass(handle, 'ViperImagePlugin-resizeBox-handle-topLeft') === true
                                        ) {
                                            width = image.width - diffx;
                                        } else {
                                            width = image.width + diffx;
                                        }

                                        image.setAttribute('width', width);
                                        var widthStyle = parseInt(ViperUtil.getStyle(image, 'width').replace('px', ''));
                                        if (widthStyle !== width) {
                                            image.setAttribute('width', widthStyle);
                                            if (both !== true) {
                                                image.setAttribute('height', parseInt(widthStyle * ratio));
                                            }

                                            _updateSize();
                                            return;
                                        } else if (widthStyle > naturalDim.width) {
                                            image.setAttribute('width', naturalDim.width);
                                            if (both !== true) {
                                                image.setAttribute('height', naturalDim.height);
                                            }

                                            _updateSize();
                                            return;
                                        }

                                        if (both === true) {
                                            height += diffy;
                                            image.setAttribute('height', parseInt(height));
                                        } else {
                                            image.setAttribute('height', parseInt(width * ratio));
                                        }

                                        _updateSize();
                                        self.viper.fireCallbacks('ViperImagePlugin:imageResized', {image: image, size: rect});

                                        // Need to set the pos and size of resize box incase the image moves around.
                                        var rect = ViperUtil.getBoundingRectangle(image);
                                        if (document !== image.ownerDocument) {
                                            rect.x1 -= scrollCoords.x;
                                            rect.x2 -= scrollCoords.x;
                                            rect.y1 -= scrollCoords.y;
                                            rect.y2 -= scrollCoords.y;
                                        }

                                        ViperUtil.setStyle(resizeBox, 'left', rect.x1 + 'px');
                                        ViperUtil.setStyle(resizeBox, 'top', rect.y1 + 'px');
                                        ViperUtil.setStyle(resizeBox, 'width', rect.x2 - rect.x1 + 'px');
                                        ViperUtil.setStyle(resizeBox, 'height', rect.y2 - rect.y1 + 'px');

                                        ViperUtil.preventDefault(e);
                                        return false;
                                    }
                                );

                                ViperUtil.addEvent(
                                    docs,
                                    'mouseup.ViperImagePlugin-resize',
                                    function (e) {
                                        ViperUtil.removeEvent(docs, 'mousemove.ViperImagePlugin-resize');
                                        ViperUtil.removeEvent(docs, 'mouseup.ViperImagePlugin-resize');

                                        // If the image width/height is max then remove them.
                                        if (image.width === image.naturalWidth) {
                                            ViperUtil.removeAttr(image, 'width');
                                        }

                                        if (image.height === image.naturalHeight) {
                                            ViperUtil.removeAttr(image, 'height');
                                        }

                                        // If the style attribute is empty, remove it.
                                        if (!image.getAttribute('style')) {
                                            image.removeAttribute('style');
                                        }

                                        if (resized === true) {
                                            self.viper.contentChanged(true);
                                        }

                                        // Show the image toolbar.
                                        self._updateToolbars(image);

                                        self._inlineToolbar.update(null, image);
                                    }
                                );

                                ViperUtil.preventDefault(e);
                                return false;
                            }
                        );

                        return handle;
                    };

                    var handles         = {};
                    handles.topLeft     = _createHandle('topLeft');
                    handles.topRight    = _createHandle('topRight');
                    handles.bottomLeft  = _createHandle('bottomLeft');
                    handles.bottomRight = _createHandle('bottomRight');
                }

                this.viper.addElement(resizeBox);
            }

        },

        getImageNaturalDimensions: function(image)
        {
            var dim = {
                width: image.naturalWidth,
                height: image.naturalHeight
            };

            return dim;

        },

        hideImageResizeHandles: function(noUpdate)
        {
            ViperUtil.remove(this._resizeBox);
            this._resizeBox   = null;
            this._resizeImage = null;

        },

        resetImageSize: function(image)
        {
            ViperUtil.removeAttr(image, 'width');
            ViperUtil.removeAttr(image, 'height');

        },

        getImageSizeDisplayHtml: function(image)
        {
            var naturalDim = this.getImageNaturalDimensions(image);
            var sizeHtml = '<div class="ViperImagePlugin-size';
            if (image.width === naturalDim.width || image.height === naturalDim.height) {
                sizeHtml += ' maximumSize">' + _('Maximum');
            } else {
                sizeHtml += '">' + image.width + ' x ' + image.height;
            }

            sizeHtml += '</div><div class="ViperImagePlugin-reset">' + _('Reset Size') + '</div>';

            return sizeHtml;

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperInlineToolbarPlugin(viper)
    {
        this.viper                = viper;
        this._lineage             = null;
        this._lineageClicked      = false;
        this._currentLineageIndex = null;
        this._lineageItemSelected = false;
        this._margin              = 15;
        this._toolbarWidget       = null;
        this._selectionLineage    = [];
        this._toolbarElement      = null;

        this._subSections             = {};
        this._subSectionButtons       = {};
        this._subSectionActionWidgets = {};

        this._topToolbar  = null;
        this._buttons     = null;
        this._initialised = false;

    }

    Viper.PluginManager.addPlugin('ViperInlineToolbarPlugin', ViperInlineToolbarPlugin);

    ViperInlineToolbarPlugin.prototype = {

        init: function()
        {
            var self = this;

            this._topToolbar = this.viper.getPluginManager().getPlugin('ViperToolbarPlugin');
            this._initToolbar();

            this.viper.registerCallback('Viper:selectionChanged', 'ViperInlineToolbarPlugin', function() {
                if (self._toolbarWidget.isVisible() === false) {
                    self._setCurrentLineageIndex(null);
                }

            });

            this.viper.registerCallback('Viper:rightMouseDown', 'ViperInlineToolbarPlugin', function(e) {
                if (ViperUtil.isChildOf(e.target, self._toolbarElement) === false) {
                    self.hideToolbar();
                }
            });

            this.viper.registerCallback('Viper:mouseUp', 'ViperInlineToolbarPlugin', function(e) {
                if (ViperUtil.isChildOf(self.viper._mouseDownEvent.target, self._toolbarElement) === true) {
                    // The mouse down event happened in the Inline Toolbar so do not fire mouse up event.
                    return false;
                }
            });

            this.viper.registerCallback('Viper:getNodeSelection', 'ViperInlineToolbarPlugin', function(data) {
                var lineage         = self.getLineage();
                var currentLinIndex = self.getCurrentLineageIndex();

                var element = lineage[currentLinIndex];
                if (element && element.nodeType !== ViperUtil.TEXT_NODE) {
                    return element;
                }

                return null;
            });

        },

        setSettings: function(settings)
        {
            if (!settings) {
                return;
            }

            if (settings.buttons) {
                this._buttons = settings.buttons;

                if (this._toolbarWidget) {
                    this._toolbarWidget.orderButtons(this._buttons);
                }
            }

        },

        getToolbar: function()
        {
            return this._toolbarWidget;

        },

        _initToolbar: function()
        {
            var tools       = this.viper.Tools;
            var toolbarid   = 'ViperInlineToolbar';
            var self        = this;
            var toolbarElem = tools.createInlineToolbar(toolbarid, false, null, function(range, nodeSelection, hasActiveSection) {
                self.updateToolbar(range, nodeSelection, hasActiveSection);
            });

            this._toolbarWidget = tools.getItem(toolbarid);

            // Add lineage container to the toolbar.
            var lineage = document.createElement('ul');
            ViperUtil.addClass(lineage, 'ViperITP-lineage');
            ViperUtil.insertBefore(toolbarElem.firstChild, lineage);
            this._lineage = lineage;
            this._toolbarElement = toolbarElem;

            var toolbar = tools.getItem(toolbarid);
            this.viper.fireCallbacks('ViperInlineToolbarPlugin:initToolbar', toolbar);

            this._initialised = true;

        },

        isInitialised: function()
        {
            return this._initialised;

        },

        
        updateToolbar: function(range, nodeSelection, hasActiveSection)
        {
            if (this._lineageClicked !== true) {
                // Not selection change due to a lineage click so update the range object.
                // Note we can use cloneRange here but for whatever reason Firefox seems
                // to not do the cloning bit of cloneRange...
                this._updateOriginalSelection(range, nodeSelection);
            }

            if (this._topToolbar) {
                var bubble = this._topToolbar.getActiveBubble();
                if (bubble && bubble.getSetting('keepOpen') !== true) {
                    return false;
                }
            }

            this._lineageItemSelected = false;
            if (this._lineageClicked !== true && hasActiveSection !== true) {
                this._setCurrentLineageIndex(null);
            }

            var lineage = this._getSelectionLineage(range, nodeSelection);
            this._selectionLineage = lineage;
            if (!lineage || lineage.length === 0) {
                return false;
            }

            if (ViperUtil.isBrowser('firefox') === true
                && ViperUtil.isTag(lineage[(lineage.length - 1)], 'br') === true
            ) {
                this.hideToolbar();
                return false;
            }

            this._updateInnerContainer(range, lineage, nodeSelection);

            if (this._lineageClicked === true) {
                this._lineageClicked = false;
                return false;
            }

            var selIndex = null;
            if (hasActiveSection === true) {
                selIndex = this.getCurrentLineageIndex();
            }

            this._updateLineage(lineage, selIndex);

        },

        hideToolbar: function()
        {
            this._toolbarWidget.hide();

        },

        
        _updateInnerContainer: function(range, lineage, nodeSelection)
        {
            if (!lineage || lineage.length === 0) {
                return;
            }

            if (this._currentLineageIndex === null || this._currentLineageIndex >= lineage.length) {
                this._setCurrentLineageIndex(lineage.length - 1);
            }

            var data = {
                range: range,
                lineage: lineage,
                current: this._currentLineageIndex,
                toolbar: this._toolbarWidget,
                nodeSelection: nodeSelection
            };

            this.viper.fireCallbacks('ViperInlineToolbarPlugin:updateToolbar', data);

        },

        
        getReadableTagName: function(tagName, tag)
        {
            var readableTagName = this.viper.fireCallbacks(
                'ViperInlineToolbarPlugin:getReadableTagName',
                {
                    tagName: tagName,
                    tag: tag
                }
            );

            if (readableTagName) {
                return readableTagName;
            }

            switch (tagName) {
                case 'strong':
                    tagName = _('Bold');
                break;

                case 'u':
                    tagName = _('Underline');
                break;

                case 'em':
                case 'i':
                    tagName = _('Italic');
                break;

                case 'li':
                    tagName = _('Item');
                break;

                case 'ul':
                case 'ol':
                    tagName = _('List');
                break;

                case 'td':
                    tagName = _('Cell');
                break;

                case 'tr':
                    tagName = _('Row');
                break;

                case 'th':
                    tagName = _('Header');
                break;

                case 'a':
                    tagName = _('Link');
                break;

                case 'blockquote':
                    tagName = _('Quote');
                break;

                case 'img':
                    tagName = _('Image');
                break;

                case 'abbr':
                    tagName = _('Abbreviation');
                break;

                case 'sub':
                    tagName = _('Subscript');
                break;

                case 'sup':
                    tagName = _('Superscript');
                break;

                case 'del':
                    tagName = _('Strikethrough');
                break;

                case 'thead':
                    tagName = _('Table Header');
                break;

                case 'tfoot':
                    tagName = _('Table Footer');
                break;

                case 'tbody':
                    tagName = _('Table Body');
                break;

                default:
                    tagName = ViperUtil.ucFirst(tagName);
                break;
            }//end switch

            return tagName;

        },

        
        selectLineageItem: function(index)
        {
            var tags = ViperUtil.getTag('li', this._lineage);
            if (tags[index]) {
                ViperUtil.trigger(tags[index], 'click');
            }

        },

        getLineage: function()
        {
            this._selectionLineage = this._getSelectionLineage();
            return this._selectionLineage;

        },

        getCurrentLineageIndex: function()
        {
            if (this._currentLineageIndex !== null && this.viper.getViperRange().collapsed === false) {
                return this._currentLineageIndex;
            } else if (this._selectionLineage.length === 0) {
                 return 0;
            } else {
                return (this._selectionLineage.length - 1)
            }

        },

        remove: function()
        {
             this.viper.Tools.removeItem('ViperInlineToolbar');

        },

        
        _updateLineage: function(lineage, selIndex)
        {
            // Remove the contents of the lineage container.
            ViperUtil.empty(this._lineage);

            var viper    = this.viper;
            var c        = lineage.length;
            var self     = this;
            var linElems = [];
            selIndex     = selIndex || null;

            // Create lineage items.
            for (var i = 0; i < c; i++) {
                if (!lineage[i].tagName) {
                    continue;
                }

                var tagName = lineage[i].tagName.toLowerCase();
                var parent  = document.createElement('li');
                ViperUtil.addClass(parent, 'ViperITP-lineageItem');

                if ((i === (c - 1) && selIndex === null) || (selIndex !== null && i === selIndex)) {
                    ViperUtil.addClass(parent, 'Viper-selected');
                }

                ViperUtil.setHtml(parent, this.getReadableTagName(tagName, lineage[i]));
                this._lineage.appendChild(parent);
                linElems.push(parent);

                (function(clickElem, selectionElem, index) {
                    // When clicked set the user selection to the selected element.
                    ViperUtil.addEvent(clickElem, 'click.ViperInlineToolbarPlugin', function(e) {
                        self.viper.fireCallbacks('ViperInlineToolbarPlugin:lineageClicked');

                        // We set the _lineageClicked to true here so that when the
                        // fireSelectionChanged is called we do not update the lineage again.
                        self._lineageClicked = true;
                        self._setCurrentLineageIndex(index);

                        ViperUtil.removeClass(linElems, 'Viper-selected');
                        ViperUtil.addClass(clickElem, 'Viper-selected');

                        if (ViperUtil.isBrowser('msie') === true) {
                            // IE changes the range when the mouse is released on an element
                            // that is not part of viper causing Viper to lose focus..
                            // Use time out to set the range back in to Viper..
                            self.viper.focus();
                            setTimeout(function() {
                                self._selectNode(selectionElem);
                            }, 30);
                        } else {
                            self._selectNode(selectionElem);
                        }

                        ViperUtil.preventDefault(e);

                        return false;
                    });
                }) (parent, lineage[i], i);
            }//end for

            if (this._originalRange.collapsed === true
                || (lineage[(lineage.length - 1)].nodeType !== ViperUtil.TEXT_NODE)
            ) {
                // No need to add the 'Selection' item as its collapsed or a node is selected.
                return;
            }

            // Add the original user selection to the lineage.
            var parent = document.createElement('li');
            ViperUtil.addClass(parent, 'ViperITP-lineageItem Viper-selected');
            ViperUtil.setHtml(parent, _('Selection'));
            linElems.push(parent);
            this._lineage.appendChild(parent);

            ViperUtil.addEvent(parent, 'click.ViperInlineToolbarPlugin', function(e) {
                self.viper.fireCallbacks('ViperInlineToolbarPlugin:lineageClicked');

                // When clicked set the selection to the original selection.
                self._lineageClicked = true;

                var prevIndex = self._currentLineageIndex;
                self._setCurrentLineageIndex(lineage.length - 1);

                ViperUtil.removeClass(linElems, 'Viper-selected');
                ViperUtil.addClass(parent, 'Viper-selected');

                if (ViperUtil.isBrowser('msie') === true) {
                    // IE changes the range when the mouse is released on an element
                    // that is not part of viper causing Viper to lose focus..
                    // Use time out to set the range back in to Viper..
                    setTimeout(function() {
                        self._selectPreviousRange(lineage, prevIndex);
                    }, 50);
                } else {
                    self._selectPreviousRange(lineage, prevIndex);
                }

                ViperUtil.preventDefault(e);
                return false;
            });

        },

        _selectNode: function(node)
        {
            this.viper.focus();

            var range = this.viper.getViperRange();

            if (this._lineageItemSelected === false) {
                // Update original selection. We update it here incase the selectionHighlight
                // method changed the DOM structure (e.g. normalised textnodes), when
                // Viper is focused update the 'selection' range.
                this._updateOriginalSelection(range);
            }

            // Set the range.
            ViperSelection.removeAllRanges();
            range = this.viper.getViperRange();

            var first = range._getFirstSelectableChild(node);
            var last  = range._getLastSelectableChild(node);
            if (!first || !last) {
                range.selectNode(node);
            } else {
                range.setStart(first, 0);
                range.setEnd(last, last.data.length);
            }

            ViperSelection.addRange(range);

            this.viper.fireCallbacks('ViperInlineToolbarPlugin:lineageItemSelected', node);

            this._toolbarWidget.closeActiveSubsection(true);
            this._toolbarWidget.setVerticalUpdateOnly(true);
            this.viper.fireSelectionChanged(range, true);
            this._toolbarWidget.setVerticalUpdateOnly(false);
            this._lineageItemSelected = true;

        },

        _selectPreviousRange: function(lineage, prevIndex)
        {
            this.viper.focus();

            ViperSelection.removeAllRanges();
            var range = this.viper.getViperRange();

            if (this._originalRange.nodeType) {
                range.selectNode(this._originalRange);
            } else {
                range.setStart(this._originalRange.startContainer, this._originalRange.startOffset);
                range.setEnd(this._originalRange.endContainer, this._originalRange.endOffset);
            }

            if (ViperUtil.isBrowser('msie') === true) {
                // Another timing issue  with IE.
                setTimeout(function() {
                    ViperSelection.addRange(range);
                }, 10);
            } else {
                ViperSelection.addRange(range);
            }

            this._toolbarWidget.closeActiveSubsection(true);
            this._toolbarWidget.setVerticalUpdateOnly(true);
            this.viper.fireSelectionChanged(range, true);
            this._toolbarWidget.setVerticalUpdateOnly(false);
            this._updateOriginalSelection(range);

        },

        _setCurrentLineageIndex: function(index)
        {
            this._currentLineageIndex = index;

        },

        _updateOriginalSelection: function(range, nodeSelection)
        {
            if (nodeSelection) {
                this._originalRange = nodeSelection;
                return;
            }

            this._originalRange = {
                startContainer: range.startContainer,
                endContainer: range.endContainer,
                startOffset: range.startOffset,
                endOffset: range.endOffset,
                collapsed: range.collapsed
            };

        },

        
        _getSelectionLineage: function(range, nodeSelection)
        {
            range             = range || this.viper.getViperRange();
            var lineage       = [];
            var parent        = null;

            var nodeSelection = nodeSelection || range.getNodeSelection(range, true);

            if (nodeSelection) {
                parent = nodeSelection;
            } else {
                var startNode = range.getStartNode();
                if (!startNode) {
                    return lineage;
                } else if (startNode.nodeType == ViperUtil.TEXT_NODE
                    && (startNode.data.length === 0 || ViperUtil.isBlank(ViperUtil.trim(startNode.data)) === true)
                    && startNode.nextSibling
                    && startNode.nextSibling.nodeType === ViperUtil.TEXT_NODE
                ) {
                    // The startNode is an empty textnode, most likely due to node splitting
                    // if the next node is a text node use that instead.
                    startNode = startNode.nextSibling;
                }

                if (startNode.nodeType !== ViperUtil.TEXT_NODE || ViperUtil.isBlank(startNode.data) !== true) {
                    if (startNode.nodeType !== ViperUtil.TEXT_NODE && startNode !== range.getEndNode()) {
                        lineage.push(range.getEndNode());
                    } else {
                        if (ViperUtil.isBrowser('edge') === true
                            && startNode.nodeType === ViperUtil.TEXT_NODE
                            && range.startOffset === startNode.data.length
                            && range.collapsed === false
                            && startNode.nextSibling
                            && startNode.nextSibling.nodeType === ViperUtil.ELEMENT_NODE
                            && ViperUtil.isStubElement(startNode.nextSibling) === false
                        ) {
                            // Handle <p>text[<strong>text] text</strong></p> -> <p>text<strong>[text] text</strong></p>.
                            var firstSelectable = range._getFirstSelectableChild(startNode.nextSibling);
                            if (firstSelectable) {
                                startNode = firstSelectable;
                            }
                        }

                        lineage.push(startNode);

                        if (ViperUtil.isBrowser('msie') === true
                            && startNode.nodeType === ViperUtil.TEXT_NODE
                            && !range.getEndNode()
                            && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                            && range.endOffset >= range.endContainer.childNodes.length
                            && ViperUtil.isChildOf(startNode, range.endContainer.childNodes[(range.endContainer.childNodes.length - 1)]) === true
                        ) {
                            // When an inline tag is the last element in a block element and only last few characters of the
                            // tag is selected IE thinks this is not inside the tag but in common parent.
                            // Add the parent of startNode to lineage here.
                            lineage.push(range.endContainer.childNodes[(range.endContainer.childNodes.length - 1)]);
                        } else if ((ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true )
                            && range.startOffset === 0
                            && range.collapsed === true
                            && startNode.nodeType === ViperUtil.TEXT_NODE
                            && startNode.previousSibling
                            && startNode.previousSibling.nodeType === ViperUtil.ELEMENT_NODE
                            && ViperUtil.isStubElement(startNode.previousSibling) === false
                        ) {
                            // Handle case: <strong><a>text</a></strong>*more text.
                            // Lineage should be showing P > strong > a.
                            // Remove the previous text node.
                            lineage.pop();

                            // Get the last selectable child of the previous element.
                            var lastSelectable = range._getLastSelectableChild(startNode.previousSibling);
                            var parents        = ViperUtil.getParents(lastSelectable);
                            lineage.push(lastSelectable);
                            for (var i = 0; i < parents.length; i++) {
                                lineage.push(parents[i])
                            }

                            lineage = lineage.reverse();
                            return lineage;
                        } else if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                            && range.endContainer.nodeType === ViperUtil.TEXT_NODE
                            && range.endOffset === 0
                            && range.getPreviousContainer(range.endContainer) === range.startContainer
                            && range.endContainer.previousSibling !== range.startContainer
                        ) {
                            lineage.push(range.startContainer.parentNode);
                        }
                    }
                }
            }

            var viperElement = this.viper.getViperElement();

            if (parent === null) {
                var endNode = range.getEndNode();
                if (startNode && startNode === endNode) {
                    parent = startNode.parentNode;
                } else if (range.endContainer === endNode
                    && endNode.childNodes.length === range.endOffset
                    && startNode.parentNode === endNode.childNodes[endNode.childNodes.length - 1]
                ) {
                    parent = startNode.parentNode;
                } else {
                    parent = range.getCommonElement();
                    if (this.viper.isOutOfBounds(parent) === true) {
                        parent = viperElement;
                    }
                }
            }

            if (parent === viperElement) {
                if (ViperUtil.isBrowser('msie') === true
                    && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && range.startOffset >= range.startContainer.childNodes.length
                    && ViperUtil.isTag(range.startContainer.childNodes[range.startOffset - 1], 'a') === true
                ) {
                    lineage.push(range.startContainer.childNodes[range.startOffset - 1]);
                }

                return lineage;
            }

            if (parent) {
                lineage.push(parent);

                parent = parent.parentNode;

                while (parent && parent !== viperElement) {
                    if (parent === document) {
                        // Couldn't find the editable element (possibly changed or disabled).
                        return [];
                    }

                    lineage.push(parent);
                    parent = parent.parentNode;
                }
            }

            lineage = lineage.reverse();

            if (ViperUtil.isBrowser('msie') === true
                && range.collapsed === true
                && range.startOffset === 0
                && range.startContainer.previousSibling
                && ViperUtil.isTag(range.startContainer.previousSibling, 'a') === true
            ) {
                lineage.push(range.startContainer.previousSibling);
            } else if (ViperUtil.isBrowser('msie', '<9') === true
                && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                && range.startOffset >= range.startContainer.childNodes.length
                && ViperUtil.isTag(range.startContainer.childNodes[range.startOffset - 1], 'a') === true
            ) {
                lineage.push(range.startContainer.childNodes[range.startOffset - 1]);
            }

            return lineage;

        }

    };
})(Viper.Util, Viper.Selection, Viper._);



(function(ViperUtil, ViperSelection, _) {
    function ViperInvisibleCharPlugin(viper)
    {
        this.viper = viper;

        this._showHiddenChars = false;

    }

    Viper.PluginManager.addPlugin('ViperInvisibleCharPlugin', ViperInvisibleCharPlugin);

    ViperInvisibleCharPlugin.prototype = {

        init: function()
        {
            this._initToolbar();

            var self = this;
            this.viper.registerCallback('Viper:keyPress', 'ViperInvisibleCharPlugin', function(e) {
                if (self._showHiddenChars === false) {
                    return;
                } else if (e.which !== 32) {
                    // Make sure we are not in a space span.
                    var range     = self.viper.getViperRange();
                    var startNode = range.getStartNode();
                    if (startNode.nodeType === ViperUtil.TEXT_NODE && ViperUtil.isTag(startNode.parentNode, 'span') === true) {
                        var textNode = document.createTextNode(String.fromCharCode(e.which));
                        ViperUtil.insertAfter(startNode.parentNode, textNode);
                        range.setStart(textNode, 1);

                        range.collapse(true);
                        ViperSelection.addRange(range);
                        return false;
                    }

                    return;
                }

                var range = self.viper.getViperRange();
                if (range.collapsed !== true) {
                    return;
                }

                var startNode = range.getStartNode();
                if (!startNode || startNode.nodeType !== ViperUtil.TEXT_NODE) {
                    return;
                }

                var text   = startNode.data;
                var offset = range.startOffset;
                if (offset === 0 || (offset === 1 && ViperUtil.isTag(startNode.parentNode, 'span') === true)) {
                    if (offset === 0) {
                        if (!startNode.previousSibling || ViperUtil.isTag(startNode.previousSibling, 'span') === false) {
                            return;
                        }

                        var span = document.createElement('span');
                        ViperUtil.addClass(span, 'VICP');
                        ViperUtil.setHtml(span, '&nbsp;');
                        ViperUtil.insertAfter(startNode.previousSibling, span);
                    } else {
                        // Chrome..
                        var span = document.createElement('span');
                        ViperUtil.addClass(span, 'VICP');
                        ViperUtil.setHtml(span, '&nbsp;');
                        ViperUtil.insertAfter(startNode.parentNode, span);

                        range.setStart(span.nextSibling, 0);
                        range.collapse(true);
                        ViperSelection.addRange(range);
                    }//end if

                    return false;
                } else if (text.charCodeAt(offset - 1) === 32 || text.charCodeAt(offset - 1) === 160) {
                    var nextNode = startNode.splitText(offset);
                    var span     = document.createElement('span');
                    ViperUtil.addClass(span, 'VICP');
                    ViperUtil.setHtml(span, '&nbsp;');
                    ViperUtil.insertBefore(nextNode, span);

                    range.setStart(nextNode, 0);
                    range.collapse(false);
                    ViperSelection.addRange(range);

                    return false;
                }//end if
            });

        },

        _initToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            var self  = this;
            var tools = this.viper.Tools;

            var btn = tools.createButton('showHiddenChars', '', 'Toggle Hidden Characters', 'Viper-showHiddenChars', function() {
                if (self._showHiddenChars === false) {
                    self._showHiddenChars = true;
                    self.showHiddenChars();
                    tools.setButtonActive('showHiddenChars');
                } else {
                    self._showHiddenChars = false;
                    self.hideHiddenChars();
                    tools.setButtonInactive('showHiddenChars');
                }
            });
            toolbar.addButton(btn);

        },

        showHiddenChars: function()
        {
            var html = this.viper.getHtml();

            html = html.replace(/&nbsp;/mg, '<span class="VICP">&nbsp;</span>');
            html = html.replace(/ <span class="VICP">&nbsp;<\/span>/mg, '<span class="VICP">&nbsp;</span><span class="VICP">&nbsp;</span>');
            this.viper.setHtml(html);

        },

        hideHiddenChars: function()
        {
            var html = this.viper.getHtml();
            html     = html.replace(/<span class="VICP">&nbsp;<\/span>/mg, '&nbsp');
            this.viper.setHtml(html);

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperLangToolsPlugin(viper)
    {
        this.viper = viper;

        this._originalRange = null;

    }

    Viper.PluginManager.addPlugin('ViperLangToolsPlugin', ViperLangToolsPlugin);

    ViperLangToolsPlugin.prototype = {

        init: function()
        {
            this._initToolbar();

        },

        rangeToTag: function(tagName, titleAttribute)
        {
            if (!titleAttribute) {
                return;
            }

            var range   = this.viper.getViperRange();
            var node    = range.getNodeSelection();
            var element = null;

            if (node) {
                if (ViperUtil.isTag(node, tagName) === true) {
                    // Update attribute.
                    node.setAttribute('title', titleAttribute);
                    element = node;
                } else {
                    // There is a node selection but not of this tag, check if the tag
                    // we are looking for is one of the parents.
                    var nodeFromRange = this.getTagFromRange(range, tagName);
                    if (nodeFromRange) {
                        nodeFromRange.setAttribute('title', titleAttribute);
                        element = nodeFromRange;
                    } else {
                        element = document.createElement(tagName);
                        element.setAttribute('title', titleAttribute);

                        ViperUtil.insertBefore(node, element);
                        element.appendChild(node);
                    }
                }
            } else {
                var bookmark = this.viper.createBookmark(range);
                element = document.createElement(tagName);
                element.setAttribute('title', titleAttribute);

                var elems = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
                var c     = elems.length;
                for (var i = 0; i < c; i++) {
                    element.appendChild(elems[i]);
                }

                ViperUtil.insertBefore(bookmark.start, element);

                this.viper.removeBookmark(bookmark);
            }//end if

            range.selectNode(element);
            ViperSelection.addRange(range);

            this.viper.contentChanged();

            return element;

        },

        rangeToLang: function(langAttribute)
        {
            if (!langAttribute) {
                return;
            }

            var range   = this.viper.getViperRange();
            var node    = this.viper.getNodeSelection();
            var element = null;

            if (node && node.nodeType === ViperUtil.ELEMENT_NODE) {
                var children = ViperUtil.getSurroundedChildren(node);
                if (children.length > 0) {
                    // Most inner child.
                    node = children.pop();
                }

                var parents = ViperUtil.getSurroundingParents(node);
                ViperUtil.removeAttr(parents, 'lang');

                node.setAttribute('lang', langAttribute);
                element = node;
            } else if (range.collapsed === true) {
                var node = range.getStartNode();
                if (!node) {
                    node = range.getEndNode();
                    if (!node) {
                        return null;
                    }
                }

                if (node.nodeType === ViperUtil.TEXT_NODE) {
                    node = node.parentNode;
                }

                element = node;
            } else {
                var bookmark = this.viper.createBookmark(range);
                element = document.createElement('span');
                element.setAttribute('lang', langAttribute);

                var elems = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
                var c     = elems.length;
                for (var i = 0; i < c; i++) {
                    element.appendChild(elems[i]);
                }

                ViperUtil.insertBefore(bookmark.start, element);

                this.viper.removeBookmark(bookmark);
            }//end if

            range.selectNode(element);
            ViperSelection.addRange(range);

            this.viper.contentChanged();

            return element;

        },

        removeElement: function(elem)
        {
            if (!elem && elem.parentNode) {
                return;
            }

            var firstChild = elem.firstChild;
            var lastChild  = elem.lastChild;

            while (elem.firstChild) {
                ViperUtil.insertBefore(elem, elem.firstChild);
            }

            ViperUtil.remove(elem);

            var range = this.viper.getViperRange();
            if (firstChild === lastChild) {
                range.selectNode(firstChild);
            } else {
                range.setStart(firstChild, 0);

                if (lastChild.nodeType === ViperUtil.TEXT_NODE) {
                    range.setEnd(lastChild, lastChild.data.length);
                } else {
                    var lastSelectable = range._getLastSelectableChild(lastChild);
                    if (lastSelectable) {
                        range.setEnd(lastSelectable, lastSelectable.data.length);
                    }
                }
            }//end if

            ViperSelection.addRange(range);
            this.viper.contentChanged(false, range);

        },

        _getTagFromElement: function(element, tagName)
        {
            if (tagName && ViperUtil.isTag(element, tagName) === true) {
                return element;
            } else if (tagName === 'lang' && ViperUtil.hasAttribute(element, 'lang') === true) {
                return element;
            } else if (!tagName) {
                if (ViperUtil.isTag(element, 'abbr') === true || ViperUtil.isTag(element, 'acronym') === true) {
                    return element;
                } else if (ViperUtil.hasAttribute(element, 'lang') === true) {
                    return element;
                }
            }

            return null;

        },

        getTagFromRange: function(range, tagName)
        {
            var selectedNode = this.viper.getNodeSelection();
            if (selectedNode && selectedNode.nodeType === ViperUtil.ELEMENT_NODE) {
                var element = this._getTagFromElement(selectedNode, tagName);
                if (element) {
                    return element;
                } else {
                    var parents = ViperUtil.getSurroundingParents(selectedNode);
                    for (var i = 0; i < parents.length; i++) {
                        var element = this._getTagFromElement(parents[i], tagName);
                        if (element) {
                            return element;
                        }
                    }

                    var children = ViperUtil.getSurroundedChildren(selectedNode);
                    for (var i = 0; i < children.length; i++) {
                        var element = this._getTagFromElement(children[i], tagName);
                        if (element) {
                            return element;
                        }
                    }
                }

                return null;
            }

            var viperElem = this.viper.getViperElement();
            var common    = range.getCommonElement();
            while (common) {
                if (tagName) {
                    if (ViperUtil.isTag(common, tagName) === true) {
                        return common;
                    } else if (tagName === 'lang' && ViperUtil.hasAttribute(common, 'lang') === true) {
                        return common;
                    }
                } else {
                    if (ViperUtil.isTag(common, 'abbr') === true || ViperUtil.isTag(common, 'acronym') === true) {
                        return common;
                    } else if (ViperUtil.hasAttribute(common, 'lang') === true) {
                        return common;
                    }
                }

                if (common === viperElem || ViperUtil.isBlockElement(common) === true) {
                    break;
                }

                common = common.parentNode;
            }

            return null;

        },

        
        getSurroundingParents: function(node, tagName)
        {
            if (!node) {
                return;
            }

            var parents = [];
            var parent  = node.parentNode;
            while (parent) {
                var c = parent.childNodes.length;
                for (var i = 0; i < c; i++) {
                    var child = parent.childNodes[i];
                    if (child.nodeType == ViperUtil.ELEMENT_NODE) {
                        if (child !== node) {
                            return parents;
                        }
                    } else if (ViperUtil.isBlank(ViperUtil.trim(child.data)) !== true) {
                        return parents;
                    }
                }

                if (!tagName || ViperUtil.isTag(parent, tagName) === true) {
                    parents.push(parent);
                }

                parent = parent.parentNode;
                node   = parent;
            }

            return parents;

        },

        handleAcronym: function()
        {
            var value = ViperUtil.trim(this.viper.Tools.getItem('VLTP:acronymInput').getValue());

            if (value) {
                this.rangeToTag('acronym', value);
            } else {
                var node = this.viper.getViperRange().getNodeSelection();
                if (node) {
                    if (ViperUtil.isTag(node, 'acronym') !== true) {
                        var parents = this.getSurroundingParents(node, 'acronym');
                        for (var i = 0; i < parents.length; i++) {
                            this.removeElement(parents[i]);
                        }
                    } else {
                        this.removeElement(node);
                    }
                }
            }

        },

        handleAbbreviation: function()
        {
            var value = ViperUtil.trim(this.viper.Tools.getItem('VLTP:abbrInput').getValue());

            if (value) {
                this.rangeToTag('abbr', value);
            } else {
                var node = this.viper.getViperRange().getNodeSelection();
                if (node) {
                    if (ViperUtil.isTag(node, 'abbr') !== true) {
                        var parents = this.getSurroundingParents(node, 'abbr');
                        for (var i = 0; i < parents.length; i++) {
                            this.removeElement(parents[i]);
                        }
                    } else {
                        this.removeElement(node);
                    }
                }
            }

        },

        handleLanguage: function()
        {
            var value = ViperUtil.trim(this.viper.Tools.getItem('VLTP:langInput').getValue());

            if (value) {
                this.rangeToLang(value);
            } else {
                var node = this.viper.getViperRange().getNodeSelection();
                if (node) {
                    if (node && ViperUtil.hasAttribute(node, 'lang') === true) {
                        node.removeAttribute('lang');
                        if (!node.className && !node.id && ViperUtil.isTag(node, 'span') === true) {
                            this.removeElement(node);
                        } else {
                            this.viper.contentChanged();
                        }
                    } else {
                        var parents = this.getSurroundingParents(node);
                        for (var i = 0; i < parents.length; i++) {
                            parents[i].removeAttribute('lang');
                            if (!parents[i].className && !parents[i].id && ViperUtil.isTag(parents[i], 'span') === true) {
                                this.removeElement(parents[i]);
                            }
                        }
                    }
                }
            }

        },

        getAcronymSubSection: function()
        {
            var self  = this;
            var elem  = document.createElement('div');
            var input = this.viper.Tools.createTextbox('VLTP:acronymInput', _('Acronym'));

            elem.appendChild(input);

            return elem;

        },

        getAbbreviationSubSection: function()
        {
            var self  = this;
            var elem  = document.createElement('div');
            var input = this.viper.Tools.createTextbox('VLTP:abbrInput', _('Abbreviation'));

            elem.appendChild(input);

            return elem;

        },

        getLangSubSection: function()
        {
            var self  = this;
            var elem  = document.createElement('div');
            var input = this.viper.Tools.createTextbox('VLTP:langInput', _('Language'));

            elem.appendChild(input);

            return elem;

        },

        _selectTag: function(tagName)
        {
            // Select the whole node.
            var range   = this._originalRange.cloneRange();
            var element = this.getTagFromRange(range, tagName);
            if (element) {
                range.selectNode(element);
                ViperSelection.addRange(range);
            }

        },

        _initToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            var self  = this;
            var tools = this.viper.Tools;

            // Create the bubble.
            var contents = document.createElement('div');

            toolbar.createBubble('ViperLangToolsPlugin:bubble', _('Language Tools'), null, contents, function() {
                self._originalRange = self.viper.getViperRange().cloneRange();
            }, function() {
                tools.getItem('ViperLangToolsPlugin:bubble').hideSubSection();
            });

            var bubble = tools.getItem('ViperLangToolsPlugin:bubble');

            var toggleBtn = tools.createButton('langTools', '', _('Toggle Language Tools'), 'Viper-langTools', null, true);
            toolbar.setBubbleButton('ViperLangToolsPlugin:bubble', 'langTools');
            toolbar.addButton(toggleBtn);

            // Create all the buttons inside the bubble.
            var acronymButton = tools.createButton('ViperLangToolsPlugin:acronymButton', _('Acronym'), _('Toggle Acronym Options'), '', function() {
                bubble.showSubSection('VLTP:acronymSubSection');
                self._selectTag('acronym');
            });
            var abbrButton = tools.createButton('ViperLangToolsPlugin:abbrButton', _('Abbreviation'), _('Toggle Abbreviation Options'), '', function() {
                bubble.showSubSection('VLTP:abbreviationSubSection');
                self._selectTag('abbr');
            });
            var langButton = tools.createButton('ViperLangToolsPlugin:langButton', _('Language'), _('Toggle Language Options'), '', function() {
                bubble.showSubSection('VLTP:langSubSection');
                self._selectTag('lang');
            });
            contents.appendChild(acronymButton);
            contents.appendChild(abbrButton);
            contents.appendChild(langButton);

            // Subsections.
            bubble.addSubSection('VLTP:acronymSubSection', this.getAcronymSubSection());
            bubble.addSubSection('VLTP:abbreviationSubSection', this.getAbbreviationSubSection());
            bubble.addSubSection('VLTP:langSubSection', this.getLangSubSection());

            bubble.setSubSectionButton('VLTP:acronymSubSection', 'ViperLangToolsPlugin:acronymButton');
            bubble.setSubSectionButton('VLTP:abbreviationSubSection', 'ViperLangToolsPlugin:abbrButton');
            bubble.setSubSectionButton('VLTP:langSubSection', 'ViperLangToolsPlugin:langButton');

            bubble.setSubSectionAction('VLTP:acronymSubSection', function() {
                self.handleAcronym();
            }, ['VLTP:acronymInput']);
            bubble.setSubSectionAction('VLTP:abbreviationSubSection', function() {
                self.handleAbbreviation();
            }, ['VLTP:abbrInput']);
            bubble.setSubSectionAction('VLTP:langSubSection', function() {
                self.handleLanguage();
            }, ['VLTP:langInput']);

            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperLangToolsPlugin', function(data) {
                tools.enableButton('langTools');

                if (data.range.collapsed === true) {
                    tools.disableButton('langTools');
                    tools.disableButton('ViperLangToolsPlugin:langButton');
                    tools.disableButton('ViperLangToolsPlugin:abbrButton');
                    tools.disableButton('ViperLangToolsPlugin:acronymButton');
                } else {
                    var node = self.viper.getViperRange().getNodeSelection();
                    tools.enableButton('ViperLangToolsPlugin:langButton');
                    tools.enableButton('langTools');

                    if (node && ViperUtil.isBlockElement(node) === true) {
                        tools.disableButton('ViperLangToolsPlugin:abbrButton');
                        tools.disableButton('ViperLangToolsPlugin:acronymButton');
                    } else {
                        tools.enableButton('ViperLangToolsPlugin:abbrButton');
                        tools.enableButton('ViperLangToolsPlugin:acronymButton');
                    }
                }

                var range     = data.range;
                var tags      = ['acronym', 'abbr', 'lang'];
                var c         = tags.length;
                var hasActive = false;

                self.viper.Tools.getItem('VLTP:acronymInput').setValue('');
                self.viper.Tools.getItem('VLTP:abbrInput').setValue('');
                self.viper.Tools.getItem('VLTP:langInput').setValue('');

                tools.setButtonInactive('ViperLangToolsPlugin:abbrButton');
                tools.setButtonInactive('ViperLangToolsPlugin:acronymButton');
                tools.setButtonInactive('ViperLangToolsPlugin:langButton');

                for (var i = 0; i < c; i++) {
                    var element = self.getTagFromRange(range, tags[i]);
                    if (element) {
                        // Activate the button.
                        tools.setButtonActive('langTools');
                        hasActive = true;

                        // Also activate the button for the sub section buttons.
                        if (ViperUtil.isTag(element, 'abbr') === true) {
                            // Abbreviation.
                            tools.setButtonActive('ViperLangToolsPlugin:abbrButton');
                            self.viper.Tools.getItem('VLTP:abbrInput').setValue(element.getAttribute('title'));
                        } else if (ViperUtil.isTag(element, 'acronym') === true) {
                            // Acronym.
                            tools.setButtonActive('ViperLangToolsPlugin:acronymButton');
                            self.viper.Tools.getItem('VLTP:acronymInput').setValue(element.getAttribute('title'));
                        }

                        if (ViperUtil.hasAttribute(element, 'lang') === true) {
                            // Lang.
                            tools.setButtonActive('ViperLangToolsPlugin:langButton');
                            self.viper.Tools.getItem('VLTP:langInput').setValue(element.getAttribute('lang'));
                        }
                    }//end if
                }//end for

                if (hasActive === false) {
                    tools.setButtonInactive('langTools');
                }
            });

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperLinkPlugin(viper)
    {
        this.viper = viper;
        this._autoLinkOpensInNewWindow = false;

        this.initToolbar();
        this.initInlineToolbar();
    }

    Viper.PluginManager.addPlugin('ViperLinkPlugin', ViperLinkPlugin);

    ViperLinkPlugin.prototype = {

        init: function()
        {
            this.enableAutoLink();

        },

        setSettings: function(settings)
        {
            if (!settings) {
                return;
            }

            if (settings.autoLinkOpensInNewWindow === true) {
                this._autoLinkOpensInNewWindow = true;
            } else {
                this._autoLinkOpensInNewWindow = false;
            }

        },


        enableAutoLink: function()
        {
            var self = this;
            this.viper.registerCallback('Viper:keyUp', 'ViperLinkPlugin', function(e) {
                // Listening for the space character.
                if (e.which !== 32) {
                    return;
                }

                self._autoLink(false);

            });

            this.viper.registerCallback('Viper:beforeEnter', 'ViperLinkPlugin', function() {
                self._autoLink(true);
            });

        },

        _autoLink: function(isEnter)
        {
            var range = this.viper.getViperRange();
            if (range.collapsed !== true) {
                return;
            }

            var startNode = range.getStartNode();
            if (!startNode || startNode.nodeType !== ViperUtil.TEXT_NODE) {
                return;
            }

            var mod = 1;
            if (isEnter === true) {
                mod = 0;
            }

            // If the text node content up to the current caret position ends with
            // a URL then convert the text to an A tag.
            var text = startNode.data.substr(0, (range.startOffset - mod));
            var url  = text.match(/ ((http[s]?:\/\/|www\.)\S+)$/);
            if (!url) {
                url = text.match(/^((http[s]?:\/\/|www\.)\S+)$/);
                if (!url) {
                    return;
                }
            }

            url        = url[1];
            var length = url.length;
            var a      = document.createElement('a');

            ViperUtil.setHtml(a, url);

            if (url.match(/^[^:]+(?=:\/\/)/) === null) {
                url = 'http://' + url;
            }

            a.setAttribute('href', url);

            if (this._autoLinkOpensInNewWindow === true) {
                a.setAttribute('target', '_blank');
            }

            var nextNode = startNode.splitText((range.startOffset - mod - length));
            ViperUtil.insertBefore(nextNode, a);

            nextNode.data = nextNode.data.slice(length);

            range.setStart(nextNode, mod);
            range.collapse(true);
            ViperSelection.addRange(range);

        },

        isEmail: function(url)
        {
            return this.validateEmail(url);

        },

        
        validateEmail: function(email)
        {
            // add a simple check here to avoid heavy check below
            if(email.match(/@/g) === null)
                return false;

            var regExStr = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
            return regExStr.test(email);
        },

        getURL: function(idPrefix)
        {
            var url = ViperUtil.trim(this.viper.Tools.getItem(idPrefix + ':url').getValue());
            return url;

        },

        updateLinkAttributes: function(link, idPrefix, ignoreChange)
        {
             // Get the current values.
            var url       = this.getURL(idPrefix);
            var title     = this.viper.Tools.getItem(idPrefix + ':title').getValue();
            var newWindow = this.viper.Tools.getItem(idPrefix + ':newWindow').getValue();

            // Check if its email link.
            if (this.isEmail(url.replace(/\s*mailto:\s*/i, '')) === true) {
                url = 'mailto:' + url.replace(/\s*mailto:\s*/i, '');
                var subject = this.viper.Tools.getItem(idPrefix + ':subject').getValue();
                if (subject) {
                    url += '?subject=' + encodeURIComponent(subject);
                }
            }

            if (ViperUtil.isBrowser('msie') === true) {
                // IE for whatever reason, changed the content of the link to be the href
                // when its a mailto link.....
                var linkContent = ViperUtil.getHtml(link);
                this.viper.setAttribute(link, 'href', url);
                ViperUtil.setHtml(link, linkContent);
            } else {
                this.viper.setAttribute(link, 'href', url);
            }

            if (title) {
                this.viper.setAttribute(link, 'title', title);
            } else {
                link.removeAttribute('title');
            }

            if (newWindow === true) {
                this.viper.setAttribute(link, 'target', '_blank');
            } else {
                link.removeAttribute('target');
            }

            var range = this.viper.getViperRange();
            range.selectNode(link);
            ViperSelection.addRange(range);

            if (ignoreChange !== true) {
                this.viper.contentChanged(false, range);
            }

        },

        updateLink: function(idPrefix)
        {
            var range = this.viper.getViperRange();
            var node  = range.getNodeSelection();

            if (ViperUtil.isTag(node, 'a') === false) {
                node = this.getLinkFromRange(range);
                if (!node) {
                    return this.rangeToLink(idPrefix);
                } else {
                    this.updateLinkAttributes(node, idPrefix);
                }
            } else {
                this.updateLinkAttributes(node, idPrefix);
            }

        },

        rangeToLink: function(idPrefix)
        {
            // Get the current values.
            var url = this.viper.Tools.getItem(idPrefix + ':url').getValue();
            if (!url) {
                return;
            }

            var range = this.viper.getViperRange();
            var node  = range.getNodeSelection();
            var a     = document.createElement('a');

            if (!node && (ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true)) {
                // IE fix for Img selections.
                var prevSibling = range.startContainer.previousSibling;
                var startNode   = range.getStartNode();
                var endNode     = range.getEndNode();
                if (prevSibling
                    && ViperUtil.isTag(prevSibling, 'img') === true
                    && range.startOffset === 0
                    && range.endOffset === 0
                    && range.startContainer === range.endContainer
                ) {
                    node = prevSibling;
                } else if (ViperUtil.isTag(startNode, 'img') === true) {
                    node = startNode;
                } else if (startNode
                    && startNode.nodeType === ViperUtil.TEXT_NODE
                    && endNode
                    && endNode.nodeType === ViperUtil.TEXT_NODE
                    && ViperUtil.isTag(startNode.nextSibling, 'img') === true
                    && startNode.nextSibling === endNode.previousSibling
                ) {
                    node = startNode.nextSibling;
                }
            }

            if (node && node.nodeType === ViperUtil.ELEMENT_NODE) {
                if (ViperUtil.isStubElement(node) === true
                    || ViperUtil.isTag(node, 'ul') === true
                    || ViperUtil.isTag(node, 'ol') === true
                ) {
                    ViperUtil.insertBefore(node, a);
                    a.appendChild(node);
                } else if (this.viper.isSpecialElement(node) === true) {
                    ViperUtil.insertBefore(node, a);
                    a.appendChild(node);
                } else {
                    var prevNode = null;
                    while (node.firstChild) {
                        var firstChild = node.firstChild;
                        if (prevNode
                            && prevNode.nodeType === ViperUtil.TEXT_NODE
                            && firstChild.nodeType === ViperUtil.TEXT_NODE
                        ) {
                            prevNode.data += firstChild.data;
                            ViperUtil.remove(firstChild);
                        } else {
                            a.appendChild(firstChild);
                        }

                        prevNode = firstChild;
                    }

                    if (ViperUtil.isTag(node, 'span') === true && this.viper.isViperHighlightElement(node) === false) {
                        // Replace the span tag with the link tag, make sure its not the
                        // Viper highlight element, if it is dont copy its attributes.
                        for (var i = 0; i < node.attributes.length; i++) {
                            a.setAttribute(node.attributes[i].nodeName, node.attributes[i].nodeValue)
                        }

                        ViperUtil.insertBefore(node, a);
                        ViperUtil.remove(node);
                    } else {
                        node.appendChild(a);
                    }
                }

                this.updateLinkAttributes(a, idPrefix);
            } else {
                a = this.viper.surroundContents('a', null, range);
                this.updateLinkAttributes(a, idPrefix);
            }

            return a;

        },

        removeLink: function(linkTag)
        {
            if (!linkTag || !linkTag.parentNode) {
                return;
            }

            var bookmark = this.viper.createBookmark();

            var firstChild = linkTag.firstChild;
            var lastChild  = linkTag.lastChild;

            while (linkTag.firstChild) {
                ViperUtil.insertBefore(linkTag, linkTag.firstChild);
            }

            ViperUtil.remove(linkTag);

            this.viper.selectBookmark(bookmark);

            var self = this;
            setTimeout(function() {
                self.viper.contentChanged();
            }, 10);


        },

        removeLinks: function()
        {
            var range    = this.viper.getViperRange();
            var nodeSelection = range.getNodeSelection();
            if (nodeSelection) {
                var links = ViperUtil.getTag('a', nodeSelection);
                var c     = links.length;
                for (var i = 0; i < c; i++) {
                    var elem = links[i];
                    while (elem.firstChild) {
                        if (elem.firstChild.nodeType == ViperUtil.TEXT_NODE
                            && elem.previousSibling
                            && elem.previousSibling.nodeType === ViperUtil.TEXT_NODE
                        ) {
                            elem.previousSibling.data += elem.firstChild.data;
                            ViperUtil.remove(elem.firstChild);
                        } else {
                            ViperUtil.insertBefore(elem, elem.firstChild);
                        }
                    }

                    ViperUtil.remove(elem);
                }

                range.selectNode(nodeSelection);
                ViperSelection.addRange(range);
                this.viper.fireSelectionChanged(range, true);
            } else {
                var bookmark = this.viper.createBookmark();
                var elems = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);

                ViperUtil.walk(bookmark.start, function(elem) {
                    if (elem.nodeType === ViperUtil.ELEMENT_NODE && ViperUtil.isTag(elem, 'a') === true) {
                        var nextSibling = elem.firstChild;
                        while (elem.lastChild) {
                            ViperUtil.insertAfter(elem, elem.lastChild);
                        }

                        ViperUtil.remove(elem);

                        return nextSibling;
                    }
                }, bookmark.end);

                this.viper.selectBookmark(bookmark);
                this.viper.fireSelectionChanged(null, true);
            }//end if

            this.viper.contentChanged(true);

        },

        getLinkFromRange: function(range)
        {
            range = range || this.viper.getViperRange();

            var selectedNode = range.getNodeSelection();
            var startNode    = range.getStartNode();
            var common       = range.getCommonElement();
            if (!selectedNode && (ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true)) {
                var startNode = range.getStartNode();
                var endNode   = range.getEndNode();
                if (range.startContainer === range.endContainer
                    && range.startOffset === 0
                    && range.endOffset === 0
                    && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                    && range.startContainer.previousSibling
                    && ViperUtil.isTag(range.startContainer.previousSibling, 'img') === true
                ) {
                    startNode = range.startContainer.previousSibling;
                    common    = startNode.parentNode;
                    range.selectNode(startNode);
                    ViperSelection.addRange(range);
                } else if (startNode
                    && startNode.nodeType === ViperUtil.TEXT_NODE
                    && !range.getEndNode()
                    && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && range.endOffset >= range.endContainer.childNodes.length
                ) {
                    // When the A tag is the last element in a P tag and only last few characters of the link is selected
                    // IE thinks this is not inside the link tag.
                    var lastChild = range.endContainer.childNodes[(range.endContainer.childNodes.length - 1)];
                    if (lastChild
                        && ViperUtil.isTag(lastChild, 'a') === true
                        && ViperUtil.isChildOf(startNode, lastChild) === true
                    ) {
                        return lastChild;
                    }
                } else if (range.collapsed === true
                    && range.startOffset === 0
                    && range.startContainer.previousSibling
                    && (ViperUtil.isTag(range.startContainer.previousSibling, 'a') === true
                    || ViperUtil.inArray('a', ViperUtil.getSurroundedChildren(range.startContainer.previousSibling, true)) === true)
                ) {
                    return range.startContainer.previousSibling;
                } else if (range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && range.startOffset >= range.startContainer.childNodes.length
                    && ViperUtil.isTag(range.startContainer.childNodes[range.startOffset - 1], 'a') === true
                ) {
                    return range.startContainer.childNodes[range.startOffset - 1];
                } else if (startNode
                    && endNode
                    && startNode.parentNode === endNode.parentNode
                    && ViperUtil.isTag(startNode.parentNode, 'a') === true
                ) {
                    return startNode.parentNode;
                }
             }

            if (selectedNode && ViperUtil.isTag(selectedNode, 'a') === true) {
                return selectedNode;
            }

            var viperElem = this.viper.getViperElement();

            while (common) {
                if (ViperUtil.isTag(common, 'a') === true) {
                    return common;
                } else if (common === viperElem || ViperUtil.isBlockElement(common) === true) {
                    break;
                }

                common = common.parentNode;
            }

            return null;

        },

        selectionHasLinks: function(range)
        {
            range = range || this.viper.getViperRange();

            if (range.collapsed === true) {
                return false;
            }

            var nodeSelection = range.getNodeSelection();
            if (nodeSelection) {
                // Let the getLinkFromRange handle this.
                return false;
            }

            var contents = range.getHTMLContents();
            if (contents.toLowerCase().indexOf('<a ') >= 0) {
                if (ViperUtil.isBrowser('msie') === true || ViperUtil.isBrowser('edge') === true) {
                    var startNode = range.getStartNode();
                    var endNode   = range.getEndNode();
                    if (startNode
                        && !endNode
                        && startNode.nodeType === ViperUtil.TEXT_NODE
                        && range.endContainer.nodeType === ViperUtil.ELEMENT_NODE
                        && range.endOffset >= range.endContainer.childNodes.length
                        && ViperUtil.isChildOf(startNode, range.endContainer.childNodes[(range.endContainer.childNodes.length - 1)]) === true
                    ) {
                        // When the A tag is the last element in a P tag and only last few characters of the link is selected
                        // IE thinks this is not inside the link tag.
                        return false;
                    } else if (startNode
                        && endNode
                        && startNode.parentNode === endNode.parentNode
                        && ViperUtil.isTag(startNode.parentNode, 'a') === true
                    ) {
                        return false;
                    }
                }

                return true;
            }

            return false;

        },

        getToolbarContent: function(idPrefix)
        {
            var self      = this;
            var tools     = this.viper.Tools;
            var url       = tools.createTextbox(idPrefix + ':url', _('URL'), '', null, true);
            var title     = tools.createTextbox(idPrefix + ':title', _('Title'), '');
            var subject   = tools.createTextbox(idPrefix + ':subject', _('Subject'), '');
            var newWindow = tools.createCheckbox(idPrefix + ':newWindow', _('Open a New Window'));

            var urlRow = tools.createRow(idPrefix + ':urlRow', 'Viper-urlRow');
            urlRow.appendChild(url);

            var titleRow = tools.createRow(idPrefix + ':titleRow', 'Viper-titleRow');
            titleRow.appendChild(title);

            var subjectRow = tools.createRow(idPrefix + ':subjectRow', 'Viper-subjectRow');
            subjectRow.appendChild(subject);

            var newWindowRow = tools.createRow(idPrefix + ':newWindowRow', 'Viper-newWindowRow');
            newWindowRow.appendChild(newWindow);

            var main = document.createElement('div');
            main.appendChild(urlRow);
            main.appendChild(titleRow);
            main.appendChild(subjectRow);
            main.appendChild(newWindowRow);

            var subSectionElem = this.viper.Tools.getItem(idPrefix + ':link').element;
            ViperUtil.addClass(subSectionElem, 'Viper-externalLink');

            // URL field changed event, when the url field is changed if the url is an
            // email address then show the email address related fields.
            this.viper.registerCallback('ViperTools:changed:' + idPrefix + ':url', 'ViperLinkPlugin', function() {
                var urlValue = ViperUtil.trim(tools.getItem(idPrefix + ':url').getValue());
                if (urlValue.toLowerCase().indexOf('mailto:') === 0 || self.isEmail(urlValue) === true) {
                    // Show the subject field and hide the title field.
                    ViperUtil.removeClass(subSectionElem, 'Viper-externalLink');
                    ViperUtil.addClass(subSectionElem, 'Viper-emailLink');
                } else {
                    ViperUtil.removeClass(subSectionElem, 'Viper-emailLink');
                    ViperUtil.addClass(subSectionElem, 'Viper-externalLink');
                }
            });

            return main;

        },

        initInlineToolbar: function()
        {
            var self = this;
            this.viper.registerCallback('ViperInlineToolbarPlugin:initToolbar', 'ViperLinkPlugin', function(toolbar) {
                self.createInlineToolbar(toolbar);
            });
            this.viper.registerCallback('ViperInlineToolbarPlugin:updateToolbar', 'ViperLinkPlugin', function(data) {
                var selectionHasLinks = self.selectionHasLinks(data.range);
                if (selectionHasLinks !== true && self.showInlineToolbarIcons(data) === true) {
                    self.updateInlineToolbar(data);
                } else if (selectionHasLinks === true) {
                    self.updateInlineToolbar(data, true);
                }
            });

        },

        createInlineToolbar: function(toolbar)
        {
            var self = this;
            var main = document.createElement('div');

            toolbar.addKeepOpenTag('a');

            toolbar.makeSubSection('ViperLinkPlugin:vitp:link', main, function() {
                var range = self.viper.getViperRange();
                var node  = self.getLinkFromRange(range);
                if (node) {
                    range.selectNode(node);
                    ViperSelection.addRange(range);
                    self.viper.fireSelectionChanged(range);
                }
            });

            var insertLinkBtn = this.viper.Tools.createButton('vitpInsertLink', '', _('Toggle Link Options'), 'Viper-link');
            var removeLinkBtn = this.viper.Tools.createButton('vitpRemoveLink', '', _('Remove Link'), 'Viper-linkRemove', function() {
                var range = self.viper.getViperRange();
                var link  = self.getLinkFromRange(range);
                if (!link) {
                    self.removeLinks();
                } else {
                    self.removeLink(link);
                }
            });

            var btnGroup = this.viper.Tools.createButtonGroup('ViperLinkPlugin:vitpButtons');
            this.viper.Tools.addButtonToGroup('vitpInsertLink', 'ViperLinkPlugin:vitpButtons');
            this.viper.Tools.addButtonToGroup('vitpRemoveLink', 'ViperLinkPlugin:vitpButtons');
            toolbar.addButton(btnGroup);

            toolbar.setSubSectionButton('vitpInsertLink', 'ViperLinkPlugin:vitp:link');

            main.appendChild(this.getToolbarContent('ViperLinkPlugin:vitp'));

            toolbar.setSubSectionAction('ViperLinkPlugin:vitp:link', function() {
                self.updateLink('ViperLinkPlugin:vitp');
            }, ['ViperLinkPlugin:vitp:url', 'ViperLinkPlugin:vitp:title', 'ViperLinkPlugin:vitp:newWindow', 'ViperLinkPlugin:vitp:subject']);

        },

        updateInlineToolbar: function(data, removeLinkOnly)
        {
            if (removeLinkOnly === true) {
                data.toolbar.showButton('vitpRemoveLink');
                return;
            }

            var link = this.getLinkFromRange(data.range);
            if (link || this.selectionHasLinks(data.range) === true) {
                if (link) {
                    this.viper.Tools.setButtonActive('vitpInsertLink');
                    this.updateInlineToolbarFields(link);
                } else {
                    this.updateInlineToolbarFields();
                }

                data.toolbar.showButton('vitpInsertLink');
                data.toolbar.showButton('vitpRemoveLink');
            } else {
                data.toolbar.showButton('vitpInsertLink');
                this.updateInlineToolbarFields(link);
            }

        },

        showInlineToolbarIcons: function(data)
        {
            var inlineToolbarPlugin = this.viper.PluginManager.getPlugin('ViperInlineToolbarPlugin');

            var self          = this;
            var range         = this.viper.getCurrentRange();
            var currentIsLink = false;
            var startNode     = null;
            var endNode       = null;
            var nodeSelection = range.getNodeSelection();

            if (nodeSelection) {
                startNode = nodeSelection;
                endNode   = startNode;
            } else {
                startNode = range.getStartNode();
                endNode   = range.getEndNode();
            }

            if (startNode
                && endNode
                && ViperUtil.getFirstBlockParent(startNode) !== ViperUtil.getFirstBlockParent(endNode)
            ) {
                return false;
            }

            if (ViperUtil.isTag(data.lineage[data.current], 'a') === true) {
                // If the selection is a whole A tag then by default show the
                // link sub section.
                currentIsLink    = true;
            }

            if (currentIsLink !== true
                && (data.lineage[data.current].nodeType !== ViperUtil.TEXT_NODE
                || ViperUtil.isTag(data.lineage[data.current].parentNode, 'a') === false)
                && range.collapsed === true
            ) {
                if (range.collapsed === true && data.lineage[data.current].nodeType === ViperUtil.TEXT_NODE) {
                    var parents = ViperUtil.getParents(data.lineage[data.current].parentNode, 'a', this.viper.getViperElement());
                    if (parents.length > 0
                        || (range.startOffset === 0 && range.startContainer.previousSibling && ViperUtil.isTag(range.startContainer.previousSibling, 'a') === true)
                    ) {
                        return true;
                    } else if (range.collapsed === true
                        && range.startOffset === 0
                        && range.startContainer.previousSibling
                        && (ViperUtil.isTag(range.startContainer.previousSibling, 'a') === true
                        || ViperUtil.inArray('a', ViperUtil.getSurroundedChildren(range.startContainer.previousSibling, true)) === true)
                    ) {
                        return true;
                    }
                } else if (range.collapsed === true
                    && range.startContainer.nodeType === ViperUtil.ELEMENT_NODE
                    && range.startOffset >= range.startContainer.childNodes.length
                    && ViperUtil.isTag(range.startContainer.childNodes[range.startOffset - 1], 'a') === true
                ) {
                    return true;
                }

                return false;
            }

            return true;

        },

        initToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            // Add the Insert Link and Remove Link buttons to the toolbar.
            var tools    = this.viper.Tools;
            var btnGroup = tools.createButtonGroup('ViperLinkPlugin:vtp:btnGroup');
            var disabled = true;
            var self     = this;

            tools.createButton('insertLink', '', _('Toggle Link Options'), 'Viper-link', null, disabled);
            tools.createButton('removeLink', '', _('Remove Link'), 'Viper-linkRemove', function() {
                if (self.selectionHasLinks() === true) {
                    self.removeLinks();
                } else {
                    var link = self.getLinkFromRange();
                    self.removeLink(link);
                }
            }, disabled);

            tools.addButtonToGroup('insertLink', 'ViperLinkPlugin:vtp:btnGroup');
            tools.addButtonToGroup('removeLink', 'ViperLinkPlugin:vtp:btnGroup');
            toolbar.addButton(btnGroup);

            var main = document.createElement('div');
            toolbar.createBubble('ViperLinkPlugin:vtp:link', _('Insert Link'), main, null, function() {
                var range = self.viper.getViperRange();
                var node  = self.getLinkFromRange(range);
                if (node) {
                    range.selectNode(node);
                    ViperSelection.addRange(range);
                    self.viper.fireSelectionChanged(range);
                }
            });
            main.appendChild(this.getToolbarContent('ViperLinkPlugin:vtp'));
            toolbar.setBubbleButton('ViperLinkPlugin:vtp:link', 'insertLink');
            tools.getItem('ViperLinkPlugin:vtp:link').setSubSectionAction('ViperLinkPlugin:vtp:linkSubSection', function() {
                self.updateLink('ViperLinkPlugin:vtp');
            }, ['ViperLinkPlugin:vtp:url', 'ViperLinkPlugin:vtp:title', 'ViperLinkPlugin:vtp:newWindow', 'ViperLinkPlugin:vtp:subject']);

            // Update the buttons when the toolbar updates it self.
            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperLinkPlugin', function(data) {
                var range = data.range;

                if (self.viper.rangeInViperBounds(range) === false) {
                    return;
                }

                var selectionHasLinks = self.selectionHasLinks(range);

                if (selectionHasLinks === true) {
                    tools.setButtonInactive('insertLink');
                    tools.disableButton('insertLink');
                    tools.enableButton('removeLink');
                    return;
                }

                var link = self.getLinkFromRange(range);

                if (link) {
                    tools.setButtonActive('insertLink');
                    tools.enableButton('removeLink');
                    self.updateBubbleFields(link);
                } else {
                    var nodeSelection = self.viper.getNodeSelection();
                    var startNode     = null;
                    var endNode       = null;

                    if (nodeSelection) {
                        startNode = nodeSelection;
                        endNode   = nodeSelection;
                    } else {
                        startNode = data.range.getStartNode();
                        endNode   = data.range.getEndNode();
                    }

                    tools.setButtonInactive('insertLink');

                    if (range.collapsed === true
                        || startNode
                        && endNode
                        && ViperUtil.getFirstBlockParent(startNode) !== ViperUtil.getFirstBlockParent(endNode)
                    ) {
                        tools.disableButton('insertLink');
                        toolbar.closeBubble('ViperLinkPlugin:vtp:link');
                    } else {
                        if (nodeSelection
                            && nodeSelection.nodeType === ViperUtil.ELEMENT_NODE
                            && ViperUtil.inArray(ViperUtil.getTagName(nodeSelection), ('tr,table,thead,tfoot'.split(',')))
                        ) {
                            tools.disableButton('insertLink');
                        } else {
                            tools.enableButton('insertLink');
                        }
                    }

                    tools.disableButton('removeLink');
                    self.updateBubbleFields();
                }//end if
            });

        },

        updateBubbleFields: function(link)
        {
            var href        = '';
            var title       = '';
            var subject     = '';
            var newWindow   = false;
            var isEmailLink = false;

            if (link) {
                href  = this.viper.getAttribute(link, 'href');
                title = this.viper.getAttribute(link, 'title');

                if (link.getAttribute('target') === '_blank') {
                    newWindow = true;
                }

                if (href) {
                    if (href.indexOf('mailto:') === 0) {
                        isEmailLink   = true;
                        var subjIndex = href.indexOf('?subject=');
                        if (subjIndex >= 0) {
                            subject = href.substr(subjIndex + 9);
                            href    = href.substr(0, subjIndex);
                        }

                        href = href.replace(/\s*mailto:\s*/i, '');
                    }
                }
            }

            var main = this.viper.Tools.getItem('ViperLinkPlugin:vtp:link').element;
            if (isEmailLink === true) {
                ViperUtil.addClass(main, 'Viper-emailLink');
                ViperUtil.removeClass(main, 'Viper-externalLink');
            } else {
                ViperUtil.addClass(main, 'Viper-externalLink');
                ViperUtil.removeClass(main, 'Viper-emailLink');
            }

            var tools = this.viper.Tools;
            tools.getItem('ViperLinkPlugin:vtp:url').setValue(href || '');
            tools.getItem('ViperLinkPlugin:vtp:title').setValue(title || '');
            tools.getItem('ViperLinkPlugin:vtp:subject').setValue(decodeURIComponent(subject) || '');
            tools.getItem('ViperLinkPlugin:vtp:newWindow').setValue(newWindow);
        },

        updateInlineToolbarFields: function(link)
        {
            var href        = '';
            var title       = '';
            var subject     = '';
            var newWindow   = false;
            var isEmailLink = false;

            if (link) {
                href  = this.viper.getAttribute(link, 'href');
                title = this.viper.getAttribute(link, 'title');

                if (link.getAttribute('target') === '_blank') {
                    newWindow = true;
                }

                if (href) {
                    if (href.indexOf('mailto:') === 0) {
                        isEmailLink   = true;
                        var subjIndex = href.indexOf('?subject=');
                        if (subjIndex >= 0) {
                            subject = href.substr(subjIndex + 9);
                            href    = href.substr(0, subjIndex);
                        }

                        href = href.replace(/\s*mailto:\s*/i, '');
                    }
                }
            }

            var main = this.viper.Tools.getItem('ViperLinkPlugin:vitp:link').element;
            if (isEmailLink === true) {
                ViperUtil.addClass(main, 'Viper-emailLink');
                ViperUtil.removeClass(main, 'Viper-externalLink');
            } else {
                ViperUtil.addClass(main, 'Viper-externalLink');
                ViperUtil.removeClass(main, 'Viper-emailLink');
            }

            var tools = this.viper.Tools;
            tools.getItem('ViperLinkPlugin:vitp:url').setValue(href || '');
            tools.getItem('ViperLinkPlugin:vitp:title').setValue(title || '');
            tools.getItem('ViperLinkPlugin:vitp:subject').setValue(decodeURIComponent(subject) || '');
            tools.getItem('ViperLinkPlugin:vitp:newWindow').setValue(newWindow);

        }

    };

})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperListPlugin(viper)
    {
        this.viper = viper;
        this.toolbarPlugin = null;

        this.initInlineToolbar();
    }

    Viper.PluginManager.addPlugin('ViperListPlugin', ViperListPlugin);

    ViperListPlugin.prototype = {

        init: function()
        {
            var self = this;
            var toolbarPlugin = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (toolbarPlugin) {
                var self            = this;
                var tools           = this.viper.Tools;
                this._toolbarPlugin = toolbarPlugin;
                var toolbarButtons  = {
                    ul: 'unorderedList',
                    ol: 'orderedList',
                    indent: 'indentList',
                    outdent: 'outdentList'
                };

                var btnGroup = tools.createButtonGroup('ViperListPlugin:vtp:buttons');
                tools.createButton('unorderedList', '', _('Make Unordered List'), 'Viper-listUL', function() {
                    var statuses = self._getButtonStatuses(null, true);
                    return self._makeListButtonAction(statuses.list, 'ul');
                }, true);
                tools.createButton('orderedList', '', _('Make Ordered List'), 'Viper-listOL', function() {
                    var statuses = self._getButtonStatuses(null, true);
                    return self._makeListButtonAction(statuses.list, 'ol');
                }, true);
                tools.createButton('indentList', '', _('Indent List'), 'Viper-listIndent', function() {
                    if (self.tabRange(null, false, true) === false) {
                        self.convertRangeToList();
                    } else {
                        self.tabRange();
                    }
                }, true);
                tools.createButton('outdentList', '', _('Outdent List'), 'Viper-listOutdent', function() {
                    self.tabRange(null, true);
                }, true);
                tools.addButtonToGroup('unorderedList', 'ViperListPlugin:vtp:buttons');
                tools.addButtonToGroup('orderedList', 'ViperListPlugin:vtp:buttons');
                tools.addButtonToGroup('indentList', 'ViperListPlugin:vtp:buttons');
                tools.addButtonToGroup('outdentList', 'ViperListPlugin:vtp:buttons');
                this._toolbarPlugin.addButton(btnGroup);

                this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperListPlugin', function(data) {
                    self._updateToolbar(toolbarButtons, data.range);
                });
            }//end if

            this.viper.registerCallback('Viper:keyDown', 'ViperListPlugin', function(e) {
                if (e.which === 9) {
                    // Handle tab key.
                    var range     = self.viper.getViperRange();
                    var startNode = range.getStartNode();
                    if (!startNode) {
                        startNode = range.startContainer;
                    }

                    if (!startNode) {
                        return;
                    }

                    if (startNode.nodeType === ViperUtil.TEXT_NODE
                        && range.collapsed === false
                        && startNode.data.length === range.startOffset
                        && ViperUtil.isBrowser('msie') === true
                    ) {
                        // IE sometimes fails with range, if multiple list elements are
                        // selected and range starts from the beginning of a list item
                        // then IE thinks that the range is starting from previous element
                        // which could be a list item causing isListElement() to return
                        // true.. Here, we move range by 1 char right to fix it.
                        range.moveStart(ViperDOMRange.CHARACTER_UNIT, 1);
                        startNode = range.getStartNode();
                    }

                    var firstBlock = ViperUtil.getFirstBlockParent(startNode, null, true);
                    if (ViperUtil.isTag(firstBlock, 'li') === true) {
                        if (range.collapsed === true
                            && ViperUtil.getParents(startNode, 'td,th', self.viper.getViperElement()).length > 0
                        ) {
                            // If the list is inside a TD/TH tag and range is collapsed then do not prevent default action.
                            // This is to allow tabbing inside table cells even if the caret is in a list item.
                            return;
                        } else if (self.tabRange(range, e.shiftKey, true) === true) {
                            self.tabRange(range, e.shiftKey);
                        }

                        ViperUtil.preventDefault(e);
                        return false;
                    } else if (e.shiftKey !== true) {
                        if (ViperUtil.isTag(startNode, 'p') === true
                            || ((startNode.nodeType === ViperUtil.TEXT_NODE || ViperUtil.isStubElement(startNode) === true) && ViperUtil.isTag(ViperUtil.getFirstBlockParent(startNode), 'p') === true)
                        ) {
                            if (ViperUtil.getParents(startNode, 'td,th,blockquote', self.viper.getViperElement()).length === 0) {
                                self.convertRangeToList(range);
                                ViperUtil.preventDefault(e);
                                return false;
                            }
                        }
                    }
                }

            });

            this.viper.registerCallback('Viper:editableElementChanged', 'ViperListPlugin', function() {
                var touched = false;
                var x       = null;
                ViperUtil.addEvent(self.viper.getViperElement(), 'touchstart', function(e) {
                    x       = e.pageX;
                    touched = true;
                });

                ViperUtil.addEvent(self.viper.getViperElement(), 'touchmove', function(e) {
                    if (touched === true && x < e.pageX) {
                        self.indentListItems([e.target]);
                    } else if (touched === true && x > e.pageX) {
                        self.outdentListItems([e.target]);
                    }

                    touched = false;
                });

                ViperUtil.addEvent(self.viper.getViperElement(), 'touchend', function(e) {
                    touched = false;
                });
            });

        },

        initInlineToolbar: function()
        {
            var self = this;
            this.viper.registerCallback('ViperInlineToolbarPlugin:initToolbar', 'ViperListPlugin', function(toolbar) {
                self.createInlineToolbar(toolbar);
            });
            this.viper.registerCallback('ViperInlineToolbarPlugin:updateToolbar', 'ViperListPlugin', function(data) {
                self.updateInlineToolbar(data);
            });

        },

        createInlineToolbar: function(toolbar)
        {

            var self  = this;
            var tools = this.viper.Tools;

            var buttonGroup = tools.createButtonGroup('ViperListPlugin:vitp:buttons');
            toolbar.addButton(buttonGroup);

            tools.createButton('vitpUnorderedList', '', _('Make Unordered List'), 'Viper-listUL', function() {
                var statuses = self._getButtonStatuses();
                self._makeListButtonAction(statuses.list, 'ul');
            });

            tools.createButton('vitpOrderedList', '', _('Make Ordered List'), 'Viper-listOL', function() {
                var statuses = self._getButtonStatuses();
                self._makeListButtonAction(statuses.list, 'ol');
            });

            tools.addButtonToGroup('vitpUnorderedList', 'ViperListPlugin:vitp:buttons');
            tools.addButtonToGroup('vitpOrderedList', 'ViperListPlugin:vitp:buttons');

            tools.createButton('vitpIndentList', '', _('Indent List'), 'Viper-listIndent', function() {
                self.tabRange();
            });
            tools.createButton('vitpOutdentList', '', _('Outdent List'), 'Viper-listOutdent', function() {
                self.tabRange(null, true);
            });

            tools.addButtonToGroup('vitpIndentList', 'ViperListPlugin:vitp:buttons');
            tools.addButtonToGroup('vitpOutdentList', 'ViperListPlugin:vitp:buttons');
        },

        updateInlineToolbar: function(data)
        {
            var statuses = this._getButtonStatuses(data.range);
            if (!statuses) {
                return;
            }

            var tools = this.viper.Tools;

            if (statuses.ul === true || statuses.ol === true) {
                data.toolbar.showButton('vitpUnorderedList', !statuses.ul);
                data.toolbar.showButton('vitpOrderedList', !statuses.ol);

                if (statuses.isUL === true) {
                    tools.setButtonActive('vitpUnorderedList');
                    tools.setButtonInactive('vitpOrderedList');
                } else if (statuses.isOL === true) {
                    tools.setButtonActive('vitpOrderedList');
                    tools.setButtonInactive('vitpUnorderedList');
                }
            }

            if (statuses.increaseIndent === true || statuses.decreaseIndent === true) {
                data.toolbar.showButton('vitpIndentList', !statuses.increaseIndent);
                data.toolbar.showButton('vitpOutdentList', !statuses.decreaseIndent);
            }

        },

        unoderedList: function()
        {
            this.makeList(false);
            this.viper.contentChanged(false);
            this.viper.element.focus();

        },

        oderedList: function()
        {
            this.makeList(true);
            this.viper.contentChanged(false);
            this.viper.element.focus();

        },

        removeListItem: function(li, sameList)
        {
            if (!li || !li.parentNode) {
                return false;
            }

            var list = this._getListElement(li);
            if (!list) {
                return;
            }

            var nextLevelList = this._getListElement(list);
            if (!nextLevelList) {
                var newElem = document.createElement('p');
                while (li.firstChild) {
                    newElem.appendChild(li.firstChild);
                }
            }

            // Check if the list item we are removing is at the end of the list or
            // not. If not then we need to break the list in to two parts with the
            // removed list item (as P tag) between those lists.
            if (li.nextSibling) {
                // Create a new list for rest of the list items.
                var clone = list.cloneNode(false);
                for (var node = li.nextSibling; node; node = li.nextSibling) {
                    clone.appendChild(node);
                }

                ViperUtil.insertAfter(list, clone);
            }

            ViperUtil.remove(li);

            if (!nextLevelList) {
                ViperUtil.insertAfter(list, newElem);
            } else {
                var newElem = document.createElement('br');
                ViperUtil.insertAfter(list, newElem);
                ViperUtil.insertAfter(newElem, li.childNodes);
            }

            if (ViperUtil.getNodeTextContent(list) === '') {
                ViperUtil.remove(list);
            }

            return newElem;

        },

        makeList: function(ordered, force)
        {
            var tag = 'ul';
            if (ordered === true) {
                tag = 'ol';
            }

            var range    = this.viper.getViperRange().cloneRange();
            var bookmark = this.viper.createBookmark(range);

            if (bookmark.start.parentNode === bookmark.end.parentNode) {
                // The range is collapsed or is inside the same parent/element.
                var li   = this._getListItem(range.startContainer);
                var elem = this._getBlockParent(range.startContainer);
                if (li !== elem) {
                    li = null;
                }

                if (li !== null) {
                    var br = this._getLineBreak(bookmark.start);
                    if (br) {
                        var tmpDiv = document.createElement('div');
                        ViperUtil.insertBefore(br, tmpDiv);
                        var node = null;
                        while (node = br.nextSibling) {
                            if (node.nodeType === ViperUtil.ELEMENT_NODE && node.tagName.toLowerCase() === 'br') {
                                tmpDiv = document.createElement('div');
                                ViperUtil.insertBefore(node, tmpDiv);
                                ViperUtil.remove(br);
                                br = node;
                                continue;
                            }

                            tmpDiv.appendChild(node);
                        }

                        if (br.parentNode) {
                            ViperUtil.remove(br);
                        }

                        this.viper.selectBookmark(bookmark);
                        this.makeList(ordered, true);
                        return;
                    }//end if
                }//end if

                if (li === null || force === true) {
                    // Create a new list.
                    var list = null;
                    if (elem === null) {
                        elem = [range.startContainer];
                    } else {
                        elem = [elem];
                    }

                    var removeInsAfter = false;
                    var insertAfter    = elem[0].previousSibling;
                    if (!insertAfter) {
                        insertAfter = document.createTextNode('');
                        ViperUtil.insertBefore(elem[0], insertAfter);
                        removeInsAfter = true;
                    }

                    if (ViperUtil.isTag(elem[0], 'td') === true) {
                        var td = elem[0];
                        var p = document.createElement('p');
                        while (td.firstChild) {
                            p.appendChild(td.firstChild);
                        }

                        elem = [p];
                        list = this._makeList(tag, elem);
                        td.appendChild(list);
                    } else {
                        list = this._makeList(tag, elem);
                        ViperUtil.insertAfter(insertAfter, list);
                    }

                    this.viper.selectBookmark(bookmark);
                    return true;
                } else {
                    // Remove item from its list.
                    var listElement = this._getListElement(li);
                    var convert     = (listElement && listElement.tagName.toLowerCase() !== tag);

                    var newElem = this.removeListItem(li);

                    // Select bookmark.
                    this.viper.selectBookmark(bookmark);

                    if (convert === true) {
                        // Need to create a new list with the specified tag.
                        this.makeList(ordered);
                    }
                }//end if
            } else {
                // Range is not collapsed.
                var elements   = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
                var comParents = this._getCommonParents(elements);
                if (!comParents) {
                    return false;
                }

                var isWholeList = this._isWholeList(comParents);

                // Determine what to do with the selected elements.
                if (ViperUtil.isTag(comParents[0], 'li') === true) {
                    // If the array contains only list items and they are all the same
                    // list type then remove them from their lists.
                    var sameType = true;
                    ViperUtil.foreach(comParents, function(i) {
                        if (ViperUtil.isTag(comParents[i], 'li') !== true
                            || ViperUtil.isTag(comParents[i].parentNode, tag) !== true) {
                            sameType = false;
                            // Break.
                            return false;
                        }
                    });

                    if (sameType === true) {
                        var self = this;
                        ViperUtil.foreach(comParents, function(i) {
                            self.removeListItem(comParents[i], isWholeList);
                        });

                        // Select the range and update caret.
                        this.viper.selectBookmark(bookmark);
                        return;
                    } else {
                        // If the specified list type is same as the first selected items list type
                        // then join the rest of the elements to that list.
                        if (ViperUtil.isTag(comParents[0].parentNode, tag) === true) {
                            var firstItem = comParents.shift();
                            this._joinToList(firstItem.parentNode, comParents, firstItem);
                            // Select the range and update caret.
                            this.viper.selectBookmark(bookmark);
                            return;
                        } else {
                            var self = this;
                            // Remove the list items and then create a new list.
                            ViperUtil.foreach(comParents, function(i) {
                                self.removeListItem(comParents[i], isWholeList);
                            });

                            // Select the range and update caret.
                            this.viper.selectBookmark(bookmark);

                            // Create the new list.
                            return this.makeList(ordered);
                        }//end if
                    }//end if
                }//end if

                // Get insertion point of the new list.
                var removeInsAfter = false;
                var insertAfter    = comParents[0].previousSibling;
                if (!insertAfter) {
                    insertAfter = document.createTextNode('');
                    ViperUtil.insertBefore(comParents[0], insertAfter);
                    removeInsAfter = true;
                }

                var list = this._makeList(tag, comParents);
                ViperUtil.insertAfter(insertAfter, list);
                if (removeInsAfter === true) {
                    ViperUtil.remove(insertAfter);
                }

                this.viper.selectBookmark(bookmark);
            }//end if

        },

        canIncreaseIndent: function(range)
        {
            return this.tabRange(range, false, true);

        },

        canDecreaseIndent: function(range)
        {
            return this.tabRange(range, true, true);

        },

        tabRange: function(range, outdent, testOnly, listType)
        {
            range    = range || this.viper.getViperRange();

            var node = range.getStartNode() || range.getNodeSelection();
            if (!node) {
                node = range.startContainer;
            }

            var firstParent = null;
            if (ViperUtil.isBlockElement(node) === true) {
                firstParent = node;
            } else {
                firstParent = ViperUtil.getFirstBlockParent(node);
            }

            var listItems   = [];
            if (!firstParent || ViperUtil.isTag(firstParent, 'li') === true) {
                listItems = this._getListItemsFromRange(range, testOnly);
            }

            var bookmark = null;
            var updated  = false;
            if (listItems.length > 0) {
                if (testOnly !== true) {
                    bookmark = this.viper.createBookmark();
                }

                if (outdent !== true) {
                    updated = this.indentListItems(listItems, testOnly);
                } else {
                    updated = this.outdentListItems(listItems, testOnly);
                }
            } else if (firstParent && outdent !==  true) {
                updated  = this.convertRangeToList(range, testOnly, listType, true);
                if (updated === true && testOnly !== true) {
                    this.viper.contentChanged();
                }

                return updated;
            }

            if (testOnly !== true) {
                var self = this;
                if (ViperUtil.isBrowser('msie') === true) {
                    setTimeout(function() {
                        // Yet another tiemout for IE.
                        var bookmarkParent  = bookmark.start.parentNode;

                        self.viper.selectBookmark(bookmark);
                        self.viper.adjustRange();

                        var range    = self.viper.getCurrentRange();
                        var nextItem = self.getNextItem(range.startContainer.parentNode);
                        if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                            && range.startOffset === range.startContainer.data.length
                            && range.collapsed === true
                            && range.startContainer.parentNode !== bookmarkParent
                            && (!nextItem || nextItem === bookmarkParent)
                        ) {
                            if (bookmarkParent.firstChild.data === '') {
                                bookmarkParent.firstChild.data = ' ';
                                range.moveStart(ViperDOMRange.CHARACTER_UNIT, 1);
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            }
                        }

                        range = self.viper.getCurrentRange();
                        if (range.startContainer.nodeType === ViperUtil.TEXT_NODE
                            && range.startOffset === range.startContainer.data.length
                            && range.collapsed === true
                            && range.startContainer.parentNode !== bookmarkParent
                            && (!nextItem || nextItem === bookmarkParent)
                        ) {
                            range.moveEnd(ViperDOMRange.CHARACTER_UNIT, 1);
                            range.moveEnd(ViperDOMRange.CHARACTER_UNIT, -1);
                            range.collapse(false);
                            ViperSelection.addRange(range);
                        }

                        if (updated === true) {
                            self.viper.contentChanged();
                        }
                    }, 5);
                } else {
                    if (bookmark) {
                        this.viper.selectBookmark(bookmark);
                    }

                    this.viper.adjustRange();

                    if (updated === true) {
                        this.viper.contentChanged();
                    }
                }
            }

            return updated;

        },

        _getListItemsFromRange: function(range, testOnly, expand)
        {
            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();

            if (!startNode && !endNode && range.startContainer) {
                startNode = range.startContainer;
                if (testOnly !== true && ViperUtil.isTag(startNode, 'br') === true) {
                    var textNode = document.createTextNode('');
                    ViperUtil.insertBefore(startNode, textNode);
                    range.setStart(textNode, 0);
                    range.collapse(true);
                }
            }

            if (!endNode && startNode.nodeType === ViperUtil.ELEMENT_NODE) {
                endNode = startNode;
            }

            var listItems = [];
            if (startNode === endNode) {
                if (ViperUtil.isTag(startNode, 'ul') === true || ViperUtil.isTag(startNode, 'ol') === true) {
                    listItems.push(startNode);
                } else {
                    listItems.push(this._getListItem(startNode));
                }
            } else {
                var elems = ViperUtil.getElementsBetween(startNode, endNode);
                if (ViperUtil.inArray(startNode, elems) === false) {
                    elems.unshift(startNode);
                }

                if (ViperUtil.inArray(endNode, elems) === false) {
                    elems.push(endNode);
                }

                var c = elems.length;
                for (var i = 0; i < c; i++) {
                    var elem = elems[i];
                    if (!elems[i]) {
                        continue;
                    } else if (ViperUtil.isTag(elems[i], 'li') === false && ViperUtil.isTag(elems[i], 'ol') === false && ViperUtil.isTag(elems[i], 'ul') === false) {
                        if (elems[i].nodeType === ViperUtil.TEXT_NODE && elems[i].data.indexOf("\n") === 0) {
                            continue;
                        }

                        var li = this._getListItem(elems[i]);
                        if (li && ViperUtil.inArray(li, listItems) === false) {
                            listItems.push(li);
                        }
                    } else {
                        if (ViperUtil.inArray(elems[i], listItems) === false) {
                            listItems.push(elems[i]);
                        }

                        if (expand === true) {
                            listItems = listItems.concat(ViperUtil.getTag('li', elems[i]));
                        }
                    }
                }
            }

            return listItems;

        },

        indentListItems: function(listItems, testOnly)
        {
            if (!listItems || listItems.length === 0) {
                return false;
            }

            // If the current list items is starting with a list and ends up selecting
            // its whole sublist then move them all by 1 level.
            if (listItems.length > 1) {
                var subList = this.getSubListItem(listItems[0]);
                if (subList) {
                    var firstItem = listItems.shift();
                    if (this._isWholeList(listItems) === true) {
                        return this.indentListItem(firstItem, true, testOnly);
                    }

                    listItems.unshift(firstItem);
                }
            }

            var c = listItems.length;
            for (var i = 0; i < c; i++) {
                if (this.indentListItem(listItems[i], false, testOnly) === false) {
                    return false;
                }
            }

            return true;

        },

        indentListItem: function(li, includeSublist, testOnly)
        {
            if (!li) {
                return false;
            }

            // There is no previous list item, do not indent.
            var prevItem  = this.getPreviousItem(li);
            if (!prevItem) {
                return false;
            }

            // Check if this item has its own sub list. If there is a sub list then
            // move this item in to that list and move the sub list to the previous
            // list item.
            // Check if the previous list item has a sub list.
            var prevSubList = this.getSubListItem(prevItem);
            if (prevSubList && includeSublist !== true) {
                if (testOnly === true) {
                    return true;
                }

                // Previous item has a sub list, add this item to that sub list.
                prevSubList.appendChild(li);
            } else {
                var subList = this.getSubListItem(li);
                if (subList && includeSublist !== true) {
                    if (testOnly === true) {
                        return true;
                    }

                    var itemContents = this.getItemContents(li);
                    var newItem      = document.createElement('li');

                    // Move the contents of the item to the list.
                    while (itemContents.length > 0) {
                        newItem.appendChild(itemContents.shift());
                    }

                    this.addItemToList(newItem, subList, 0);

                    // Move the sublist to the previous item.
                    prevItem.appendChild(subList);

                    // This item is no longer needed..
                    ViperUtil.remove(li);
                } else {
                    if (testOnly === true) {
                        return true;
                    }

                    // If the previous item has a sub list then join to that.
                    if (prevSubList) {
                        prevSubList.appendChild(li);
                    } else {
                        // Create a new list using the same list type.
                        var listElement = this._getListElement(li);

                        var tagName     = ViperUtil.getTagName(listElement);
                        var newList     = document.createElement(tagName);

                        // Add the list item to this new list.
                        newList.appendChild(li);

                        // Add the new list to the previous item.
                        prevItem.appendChild(newList);
                    }
                }
            }

            return true;

        },

        outdentListItems: function(listItems, testOnly)
        {
            if (!listItems || listItems.length === 0) {
                return false;
            }

            if (this._isWholeList(listItems) === true) {
                // Get the parent list.
                var list = this._getListElement(listItems[0]);
                if (!this._getListElement(list)) {
                    // First check for sub lists.
                    for (var i = 0; i < listItems.length; i++) {
                        var li = listItems[i];
                        var subList = this.getSubListItem(li);
                        if (subList) {
                            return false;
                        }
                    }

                    if (testOnly === true) {
                        return true;
                    }

                    if (listItems.length === 1
                        && (ViperUtil.isTag(list.parentNode, 'td') === true || ViperUtil.isTag(list.parentNode, 'th') === true)
                    ) {
                        var li = listItems[0];
                        while (li.firstChild) {
                            ViperUtil.insertBefore(list, li.firstChild);
                        }
                    } else {
                        // Conver to P tags.
                        for (var i = 0; i < listItems.length; i++) {
                            var li = listItems[i];
                            var p  = document.createElement('p');
                            while (li.firstChild) {
                                p.appendChild(li.firstChild);
                            }

                            ViperUtil.insertBefore(list, p);
                        }
                    }

                    ViperUtil.remove(list);

                    return true;
                }
            }

            // If the current list items is starting with a list and ends up selecting
            // its whole sublist then move them all by 1 level.
            if (listItems.length > 1) {
                var subList = this.getSubListItem(listItems[0]);
                if (subList) {
                    var firstItem = listItems.shift();
                    if (this._isWholeList(listItems) === true) {
                        return this.outdentListItem(firstItem, testOnly);
                    }

                    listItems.unshift(firstItem);
                }
            }

            var c = listItems.length;
            for (var i = 0; i < c; i++) {
                if (this.outdentListItem(listItems[i], testOnly) === false) {
                    return false;
                }
            }

            return true;

        },

        outdentListItem: function(li, testOnly)
        {
            if (!li) {
                return false;
            }

            var list      = null;
            var isSubList = false;
            if (ViperUtil.isTag(li, 'ul') === true || ViperUtil.isTag(li, 'ol') === true) {
                list      = li;
                isSubList = true;
            } else {
                list = this._getListElement(li);
            }

            var parentListItem = this._getListItem(list);

            var siblingItems = [];
            if (isSubList !== true) {
                for (var node = li.nextSibling; node; node = node.nextSibling) {
                    if (ViperUtil.isTag(node, 'li') === true) {
                        siblingItems.push(node);
                    }
                }
            }

            if (parentListItem) {
                if (testOnly === true) {
                    return true;
                }

                if (siblingItems.length > 0) {
                    // Move these (next) siblings under an exisiting sub list or
                    // under a new list (and place the new list under the current item).
                    var subList = this.getSubListItem(li);
                    if (!subList) {
                        // Create a new list of the same type.
                        subList = document.createElement(this.getListType(li));
                        li.appendChild(subList);
                    }

                    for (var i = 0; i < siblingItems.length; i++) {
                        subList.appendChild(siblingItems[i]);
                    }
                }

                if (isSubList === true) {
                    // For each child move them after the parent list item.
                    var childItems = [];
                    for (var node = li.firstChild; node; node = node.nextSibling) {
                        if (ViperUtil.isTag(node, 'li') === true) {
                            childItems.push(node);
                        }
                    }

                    for (var i = childItems.length; i >= 0; i--) {
                        ViperUtil.insertAfter(parentListItem, childItems[i]);
                    }
                } else {
                    // Now move this list item after the parent list item.
                    ViperUtil.insertAfter(parentListItem, li);
                }

                if (ViperUtil.getTag('li', list).length === 0) {
                    // If the old list item is now empty, remove it.
                    ViperUtil.remove(list);
                }

                return true;
            } else {
                if (testOnly === true) {
                    return true;
                }

                // Convert this item to a default block tag.
                var subList = null;
                var p       = document.createElement('p');
                var bTag    = this.viper.getDefaultBlockTag();
                if (bTag !== '') {
                    while (li.firstChild) {
                        if (ViperUtil.isTag(li.firstChild, 'ul') === true || ViperUtil.isTag(li.firstChild, 'ol') === true) {
                            // Sub list needs to go after the p tag.
                            subList = li.firstChild;
                            li.removeChild(li.firstChild);
                        } else {
                            p.appendChild(li.firstChild);
                        }
                    }
                }

                // If there are more list items after this item then move them in to a
                // new list or if this item is the first in the list then just move it out.
                var firstItem = true;
                for (var node = li.previousSibling; node; node = node.previousSibling) {
                    if (ViperUtil.isTag(node, 'li') === true) {
                        firstItem = false;
                        break;
                    }
                }

                if (siblingItems.length === 0) {
                    if (firstItem === true) {
                        // This is the only item in the list.
                        if (bTag !== '') {
                            ViperUtil.insertBefore(list, p);
                        } else {
                            ViperUtil.insertBefore(list, li.childNodes);
                        }

                        ViperUtil.remove(li);
                    } else {
                        // Last item on the list. Add the p tag after the list.
                        if (bTag !== '') {
                            ViperUtil.insertAfter(list, p);
                        } else {
                            ViperUtil.insertAfter(list, li.childNodes);
                        }

                        ViperUtil.remove(li);
                    }
                } else {
                    if (firstItem === true) {
                        // This is the only item in the list.
                        if (bTag !== '') {
                            ViperUtil.insertBefore(list, p);
                        } else {
                            ViperUtil.insertBefore(list, li.childNodes);
                        }

                        ViperUtil.remove(li);
                    } else {
                        // Move the list items after this item to a new list.
                        var newList = document.createElement(ViperUtil.getTagName(list));
                        for (var i = 0; i < siblingItems.length; i++) {
                            newList.appendChild(siblingItems[i]);
                        }

                        ViperUtil.remove(li);

                        ViperUtil.insertAfter(list, newList);

                        if (bTag !== '') {
                            ViperUtil.insertAfter(list, p);
                        } else {
                            ViperUtil.insertAfter(list, li.childNodes);
                        }
                    }//end if
                }

                if (subList) {
                    // Put the sub list that was in the original list element right after
                    // the P tag.
                    ViperUtil.insertAfter(p, subList);
                }

                return true;

            }

            return false;

        },

        convertRangeToList: function(range, testOnly, listType, canJoin)
        {
            range    = range || this.viper.getViperRange();
            testOnly = testOnly || false;
            listType = listType || null;

            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();
            var bookmark  = null;

            if (testOnly !== true) {
                bookmark  = this.viper.createBookmark();
            }

            if (!startNode && !endNode) {
                startNode = range.startContainer;
                endNode   = startNode;
            } else if (startNode && !endNode && range.collapsed === true) {
                endNode = startNode;
            }

            var pElems = [];
            if (startNode === endNode) {
                var validParent = null;
                if (bookmark && bookmark.start) {
                    validParent = this._getValidParentElement(bookmark.start);
                } else {
                    validParent = this._getValidParentElement(startNode);
                }

                if (validParent) {
                    if (testOnly !== true
                        && (ViperUtil.isTag(validParent, 'td') === true || ViperUtil.isTag(validParent, 'th') === true)
                    ) {
                        return this.makeList(listType === 'ol');
                    } else {
                        pElems.push(validParent);
                    }
                }
            } else {
                var elems = null;
                if (testOnly === true) {
                    elems = ViperUtil.getElementsBetween(startNode, endNode);
                    elems.unshift(startNode);
                    elems.push(endNode);
                } else {
                    elems = ViperUtil.getElementsBetween(bookmark.start, bookmark.end);
                }

                var c     = elems.length;
                for (var i = 0; i < c; i++) {
                    if (!elems[i]) {
                        continue;
                    }

                    var p = this._getValidParentElement(elems[i]);
                    if (p && ViperUtil.inArray(p, pElems) === false) {
                        pElems.push(p);
                    } else if (!p && elems[i].nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(elems[i].data) === true) {
                        // Remove blank text nodes between these elements.
                        ViperUtil.remove(elems[i]);
                    }
                }
            }

            if (pElems.length === 0) {
                return false;
            } else if (testOnly === true) {
                return true;
            }

            // Get the previous list if there is one.
            var list  = null;
            var atEnd = true;
            if (!listType || canJoin === true) {
                for (var node = pElems[0].previousSibling; node; node = node.previousSibling) {
                    if (node.nodeType === ViperUtil.ELEMENT_NODE) {
                        if ((listType && ViperUtil.isTag(node, listType) === true)
                            || (!listType && (ViperUtil.isTag(node, 'ol') === true || ViperUtil.isTag(node, 'ul') === true))
                        ) {
                            list  = node;
                            atEnd = true;
                        }

                        break;
                    }
                }

                if (list === null) {
                    // There was no list before the first element. Check if there is a list
                    // element after the last p element.
                    for (var node = pElems[(pElems.length - 1)].nextSibling; node; node = node.nextSibling) {
                        if (node.nodeType === ViperUtil.ELEMENT_NODE) {
                            if ((listType && ViperUtil.isTag(node, listType) === true)
                                || (!listType && (ViperUtil.isTag(node, 'ol') === true || ViperUtil.isTag(node, 'ul') === true))
                            ) {
                                list  = node;
                                atEnd = false;
                            }

                            break;
                        }
                    }
                }
            }

            if (list === null) {
                // No list found, create a new list.
                list = document.createElement(listType || 'ul');
                ViperUtil.insertBefore(pElems[0], list);
                atEnd = true;
            }

            var listItems = [];
            for (var i = 0; i < pElems.length; i++) {
                var p  = pElems[i];
                var li = document.createElement('li');
                while (p.firstChild) {
                    li.appendChild(p.firstChild);
                }

                if (atEnd !== true) {
                    listItems.unshift(li);
                } else {
                    listItems.push(li);
                }

                ViperUtil.remove(p);
            }

            if (atEnd === true) {
                // Append the new list items to the end of the list.
                for (var i = 0; i < listItems.length; i++) {
                    list.appendChild(listItems[i]);
                }

                // If there is another list right after the current list, join them.
                var listType = ViperUtil.getTagName(list);
                for (var node = list.nextSibling; node; node = node.nextSibling) {
                    if (node.nodeType !== ViperUtil.TEXT_NODE) {
                        if (ViperUtil.isTag(node, listType) === true) {
                            while(node.firstChild) {
                                list.appendChild(node.firstChild);
                            }

                            ViperUtil.remove(node);
                        }

                        break;
                    } else if (ViperUtil.isBlank(ViperUtil.trim(node.data)) !== true) {
                        break;
                    }
                }
            } else {
                // To the start of the list.
                for (var i = 0; i < listItems.length; i++) {
                    ViperUtil.insertBefore(list.firstChild, listItems[i]);
                }
            }

            // Select bookmark.
            if (ViperUtil.isBrowser('msie', '<9') === true) {
                var self = this;
                setTimeout(function() {
                    self.viper.selectBookmark(bookmark);
                    self.viper.contentChanged();
                }, 10);
            } else {
                this.viper.selectBookmark(bookmark);
                this.viper.contentChanged();
            }

            // TODO: Properly fix fireNodesChanged event firing as this method maybe called by other create list method
            // which also fire nodesChanged event causing multiple history entries.
            if (canJoin === true) {
                return false;
            }

            return true;

        },

        convertRangeToParagraphs: function(range)
        {
            range = range = this.viper.getViperRange();

            var listItems = this._getListItemsFromRange(range, false, true);
            var bookmark  = this.viper.createBookmark();
            var prevElem  = null;
            var prevList  = null;

            for (var i = 0; i < listItems.length; i++) {
                if (ViperUtil.isTag(listItems[i], 'li') === false) {
                    // Must be a whole list. Gell all li tags inside it.
                    var childItems = ViperUtil.getTag('li', listItems[i]);

                    var parent = null;
                    if (!prevElem) {
                        parent   = listItems[i];
                        prevList = parent;
                    }

                    for (var j = 0; j < childItems.length; j++) {
                        var p = this.convertElement(childItems[j], 'p', true);
                        if (prevElem) {
                            ViperUtil.insertAfter(prevElem, p);
                        } else {
                            ViperUtil.insertBefore(parent, p);
                        }

                        prevElem = p;
                    }

                    prevElem = null;
                } else {
                    var parent = listItems[i].parentNode;
                    var p      = this.splitListAtItem(listItems[i]);
                    if (prevElem) {
                        ViperUtil.insertAfter(prevElem, p);
                    }

                    if (prevList !== parent) {
                        prevList = parent;
                    } else {
                        prevElem = p;
                    }
                }//end if
            }//end for

            this.viper.selectBookmark(bookmark);
            this.viper.contentChanged();

        },

        
        splitListAtItem: function(li)
        {
            var siblings = [];
            for (var node = li.nextSibling; node; node = node.nextSibling) {
                if (ViperUtil.isTag(node, 'li') === false) {
                    continue;
                }

                siblings.push(node);
            }

            // Create the new P tag.
            var listElem = li.parentNode;
            var newList  = null;

            if (siblings.length > 0) {
                // There are list items after the specified one. Move them to a new list.
                newList = document.createElement(this.getListType(li));
                for (var i = 0; i < siblings.length; i++) {
                    newList.appendChild(siblings[i]);
                }
            }

            var p = this.convertElement(li, 'p', true);
            ViperUtil.insertAfter(listElem, p);

            if (newList) {
                ViperUtil.insertAfter(p, newList);
            }

            // Move block elements inside P to after it.
            var node = p.lastChild;
            while (node) {
                var prevSibling = node.previousSibling;
                if (ViperUtil.isBlockElement(node) === true && ViperUtil.isStubElement(node) === false) {
                    ViperUtil.insertAfter(p, node);
                }

                node = prevSibling;
            }

            if (ViperUtil.getTag('li', listElem).length === 0) {
                // If the old list is now empty, remove it.
                ViperUtil.remove(listElem);
            }

            return p;

        },

        
        convertElement: function(elem, tagName, detached)
        {
            var newElem = document.createElement(tagName);
            while (elem.firstChild) {
                newElem.appendChild(elem.firstChild);
            }

            if (detached !== true) {
                ViperUtil.insertBefore(elem, newElem);
            }

            ViperUtil.remove(elem);
            return newElem;

        },

        toggleListType: function(list)
        {
            var newListType = null;
            if (ViperUtil.isTag(list, 'ol') === true) {
                newListType = 'ul';
            } else if (ViperUtil.isTag(list, 'ul') === true) {
                newListType = 'ol';
            }

            if (!newListType) {
                return false;
            }

            var newList = document.createElement(newListType);
            while (list.firstChild) {
                newList.appendChild(list.firstChild);
            }

            ViperUtil.insertBefore(list, newList);
            ViperUtil.remove(list);

            return newList;

        },

        changeListType: function(newType, range)
        {
            range = range || this.viper.getViperRange();
            var listItems = this._getListItemsFromRange(range, false, true);

            var bookmark = this.viper.createBookmark();
            var self     = this;

            var convertChildItems = function(list) {
                var children = ViperUtil.find(list, '> li');
                if (children.length === 0) {
                    return;
                }

                var newParent = null;
                var afterList = null;
                for (var i = 0; i < children.length; i++) {
                    if (ViperUtil.inArray(children[i], listItems) === true) {
                        if (newParent === null) {
                            newParent = document.createElement(newType);
                            ViperUtil.insertAfter(list, newParent);
                        }

                        newParent.appendChild(children[i]);
                        var subLists = ViperUtil.find(children[i], '> ul');
                        for (var j = 0; j < subLists.length; j++) {
                            convertChildItems(subLists[j]);
                        }
                    } else if (newParent !== null) {
                        // Create an after list.
                        if (afterList === null) {
                            afterList = document.createElement(ViperUtil.getTagName(list));
                            ViperUtil.insertAfter(newParent, afterList);
                        }

                        afterList.appendChild(children[i]);
                    }
                }

                if (ViperUtil.getTag('li', list).length === 0) {
                    ViperUtil.remove(list);
                    var joinedList = self.joinSiblingLists(newParent);
                    if (joinedList) {
                        processedParents.push(joinedList);
                    }
                }
            };

            var processedParents = [];
            for (var i = 0; i < listItems.length; i++) {
                if (!listItems[i].parentNode || ViperUtil.inArray(listItems[i].parentNode, processedParents) === true) {
                    continue;
                }

                processedParents.push(listItems[i].parentNode);
                convertChildItems(listItems[i].parentNode);
            }

            this.viper.selectBookmark(bookmark);

        },

        listToParagraphs: function(list)
        {
            var pTags = [];
            for (var node = list.firstChild; node; node = node.nextSibling) {
                if (ViperUtil.isTag(node, 'li') !== true) {
                    continue;
                }

                var p = document.createElement('p');
                while (node.firstChild) {
                    p.appendChild(node.firstChild);
                }

                ViperUtil.insertBefore(list, p);
                pTags.push(p);
            }

            if (pTags.length === 1
                && (ViperUtil.isTag(pTags[0].parentNode, 'td') === true || ViperUtil.isTag(pTags[0].parentNode, 'th') === true)
            ) {
                var cellElement = pTags[0].parentNode;

                // Remove the new new P tag so that the only content in the TD,TH is P's child nodes.
                var p = pTags[0];
                while (p.firstChild) {
                    ViperUtil.insertBefore(p, p.firstChild);
                }

                ViperUtil.remove(p);
                pTags = [cellElement];
            }

            ViperUtil.remove(list);

            return pTags;

        },

        getSubListItem: function(li)
        {
            for (var node = li.firstChild; node; node = node.nextSibling) {
                if (ViperUtil.isTag(node, 'ul') === true || ViperUtil.isTag(node, 'ol') === true) {
                    return node;
                }
            }

            return null;

        },

        addItemToList: function(li, list, pos)
        {
            if (!li || !list || ViperUtil.isTag(li, 'li') === false) {
                return false;
            }

            pos = pos || 0;

            var tags = ViperUtil.getTag('li', list);

            if (tags.length <= pos) {
                list.appendChild(li);
            } else {
                ViperUtil.insertBefore(tags[pos], li);
            }

            return true;

        },

        
        getItemContents: function(li)
        {
            var contentElements = [];
            for (var node = li.firstChild; node; node = node.nextSibling) {
                if (ViperUtil.isTag(node, 'ul') === true || ViperUtil.isTag(node, 'ol') === true) {
                    continue;
                }

                contentElements.push(node);
            }

            return contentElements;

        },

        getListType: function(li)
        {
            var list = this._getListElement(li);
            if (!list) {
                return false;
            }

            return ViperUtil.getTagName(list);

        },

        getPreviousItem: function(li)
        {
            while (li.previousSibling) {
                li = li.previousSibling;
                if (ViperUtil.isTag(li, 'li') === true) {
                    return li;
                }
            }

            return null;

        },

        getNextItem: function(li)
        {
            while (li.nextSibling) {
                li = li.nextSibling;
                if (ViperUtil.isTag(li, 'li') === true) {
                    return li;
                }
            }

            return null;

        },

        _getButtonStatuses: function(range, mainToolbar)
        {
            range         = range || this.viper.getViperRange();
            var startNode = range.getStartNode();
            var endNode   = range.getEndNode();
            var makeList  = false;
            var indent    = false;
            var canMakeUL = false;
            var canMakeOL = false;
            var isUL      = false;
            var isOL      = false;
            var list      = null;

            if (!startNode) {
                if (!range.startContainer
                    || range.startContainer !== range.endContainer
                    || (ViperUtil.isStubElement(range.startContainer) !== true && ViperUtil.isTag(range.startContainer, 'li') === false)
                ) {
                    return;
                } else {
                    startNode = range.startContainer;
                    endNode   = startNode;
                }
            }

            if (!endNode) {
                endNode = startNode;
            } else if (endNode === this.viper.getViperElement()) {
                endNode = range._getLastSelectableChild(this.viper.getViperElement());
            }

            var startParent = null;

            var listElement = null;
            if (ViperUtil.isTag(startNode, ['ul', 'ol']) === true) {
                listElement = startNode;
                startNode   = range._getFirstSelectableChild(startNode);
            } else {
                listElement = this._getListElement(startNode);
            }

            var firstBlock  = startNode;

            if (ViperUtil.isBlockElement(startNode) === false) {
                firstBlock  = ViperUtil.getFirstBlockParent(startNode);
            }

            if (listElement
                && firstBlock
                && ViperUtil.isTag(firstBlock, 'li') === false
            ) {
                // Can be converted to a list.
                makeList = true;

                if (mainToolbar === true) {
                    indent   = true;
                }
            } else if (listElement && listElement === this._getListElement(endNode)) {
                if (range.collapsed === true && mainToolbar !== true) {
                    return;
                }

                makeList = true;
                indent   = true;
            } else if (listElement) {
                if (range.collapsed === true && mainToolbar !== true) {
                    return;
                }

                makeList = true;
                indent   = true;
            } else {
                var nodeSelection = range.getNodeSelection();
                if (nodeSelection && nodeSelection !== this.viper.getViperElement()) {
                    startNode = nodeSelection;
                    endNode   = null;
                }

                if (ViperUtil.isBlockElement(startNode) === false) {
                    startParent   = ViperUtil.getFirstBlockParent(startNode);
                } else {
                    startParent = startNode;
                }

                var endParent = null;

                if (!endNode) {
                    endParent = startParent;
                } else {
                    endParent = ViperUtil.getFirstBlockParent(endNode);
                }

                if (!startParent || !endParent) {
                    return;
                } else if (startParent !== endParent
                    && ViperUtil.isTag(startParent, 'p') === true
                    && ViperUtil.isTag(endParent, 'p') === true
                    && ViperUtil.isTag(startParent.parentNode, 'blockquote') === false
                    && ViperUtil.isTag(endParent.parentNode, 'blockquote') === false
                ) {
                    makeList = true;
                    var nextSibling = startParent.nextSibling;
                    while (nextSibling && nextSibling !== endParent) {
                        if (nextSibling.nodeType === ViperUtil.ELEMENT_NODE
                            && ViperUtil.isTag(nextSibling, 'p') !== true
                        ) {
                            makeList = false;
                            break;
                        }

                        nextSibling = nextSibling.nextSibling;
                    }
                } else if (mainToolbar === true
                    && (ViperUtil.isTag(startParent, 'p') === true || ViperUtil.isTag(startParent, 'td') === true)
                    && ViperUtil.isTag(startParent.parentNode, 'blockquote') === false
                ) {
                    makeList = true;
                }
            }//end if

            if (makeList !== true && indent !== true) {
                return;
            }

            if (makeList === true) {
                if (ViperUtil.isTag(firstBlock, 'li') === true) {
                    if (ViperUtil.isTag(startNode, 'ul') === true || ViperUtil.isTag(startNode, 'ol') === true) {
                        list = startNode;
                    } else {

                        list = this._getListElement(startNode);
                    }
                }

                if (!list && this.convertRangeToList(range, true) === true) {
                    canMakeUL = true;
                    canMakeOL = true;
                } else if (ViperUtil.isTag(list, 'ol') === true) {
                    canMakeUL = true;
                    canMakeOL = true;
                    isOL      = true;
                } else if (ViperUtil.isTag(list, 'ul') === true) {
                    canMakeUL = true;
                    canMakeOL = true;
                    isUL      = true;
                }
            }

            var increaseIndent = false;
            var decreaseIndent = false;

            if (indent === true) {
                increaseIndent = this.canIncreaseIndent(range);

                if (indent === true) {
                    decreaseIndent = this.canDecreaseIndent(range);
                }
            }

            if (mainToolbar === true
                && startParent
                && ViperUtil.isTag(startParent, 'p') === true
            ) {
                increaseIndent = true;
            }

            var statuses = {
                ul: canMakeUL,
                ol: canMakeOL,
                increaseIndent: increaseIndent,
                decreaseIndent: decreaseIndent,
                list: list,
                isUL: isUL,
                isOL: isOL
            };

            return statuses;

        },

        _updateToolbar: function(toolbarButtons, range)
        {
            var toolbarPlugin = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbarPlugin) {
                return;
            }

            var tools = this.viper.Tools;

            var statuses = this._getButtonStatuses(range, true);
            if (!statuses) {
                for (var btn in toolbarButtons) {
                    tools.disableButton(toolbarButtons[btn]);
                    tools.setButtonInactive(toolbarButtons[btn]);
                }

                return;
            }

            if (statuses.ul === true) {
                tools.enableButton(toolbarButtons.ul);
                if (ViperUtil.isTag(statuses.list, 'ul') === true) {
                    tools.setButtonActive(toolbarButtons.ul);
                } else {
                    tools.setButtonInactive(toolbarButtons.ul);
                }
            } else {
                tools.disableButton(toolbarButtons.ul);
                tools.setButtonInactive(toolbarButtons.ul);
            }

            if (statuses.ol === true) {
                tools.enableButton(toolbarButtons.ol);
                if (ViperUtil.isTag(statuses.list, 'ol') === true) {
                    tools.setButtonActive(toolbarButtons.ol);
                } else {
                    tools.setButtonInactive(toolbarButtons.ol);
                }
            } else {
                tools.disableButton(toolbarButtons.ol);
                tools.setButtonInactive(toolbarButtons.ol);
            }

            if (statuses.increaseIndent === true) {
                tools.enableButton(toolbarButtons.indent);
            } else {
                tools.disableButton(toolbarButtons.indent);
            }

            if (statuses.decreaseIndent === true) {
                tools.enableButton(toolbarButtons.outdent);
            } else {
                tools.disableButton(toolbarButtons.outdent);
            }

        },

        _makeListButtonAction: function(list, listType)
        {
            var currentType = '';
            var newType     = '';
            if (!list) {
                currentType = listType;
            } else {
                currentType = ViperUtil.getTagName(list);
                if (listType !== currentType) {
                    if (currentType === 'ul') {
                        newType = 'ol';
                    } else {
                        newType = 'ul';
                    }
                } else {
                    newType = listType;
                }
            }

            if (currentType !== listType) {
                this.changeListType(newType);
                this.viper.contentChanged();
                return;
            } else if (currentType !== newType) {
                this.tabRange(null, false, false, listType);
            } else if (currentType === listType) {
                return this.convertRangeToParagraphs();
            } else {
                var bookmark = this.viper.createBookmark();
                if (bookmark.start.nextSibling && ViperUtil.isTag(bookmark.start.nextSibling, 'li') === true) {
                    ViperUtil.insertBefore(bookmark.start.nextSibling.firstChild, bookmark.start);
                }

                if (bookmark.end.previousSibling && ViperUtil.isTag(bookmark.end.previousSibling, 'li') === true) {
                    bookmark.end.previousSibling.appendChild(bookmark.end);
                }

                var pTags = this.listToParagraphs(list);
                this.viper.selectBookmark(bookmark);
                this.viper.contentChanged();
            }

        },

        _joinToList: function(listElem, elements, refNode)
        {
            var self = this;
            ViperUtil.foreach(elements, function(i) {
                var elem = elements[i];
                if (elem.parentNode !== listElem) {
                    // If elem is not a list item then create a new list item.
                    if (ViperUtil.isTag(elem, 'li') === false) {
                        elem = self._createListItem(elem);
                    }

                    if (elem) {
                        if (refNode) {
                            ViperUtil.insertAfter(refNode, elem);
                            refNode = elem;
                        } else {
                            listElem.appendChild(elem);
                        }
                    }
                }
            });

        },

        joinSiblingLists: function(list)
        {
            var listType = ViperUtil.getTagName(list);

            // Check if there is a same type list before this.
            for (var node = list.previousSibling; node; node = node.previousSibling) {
                if (node.nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(node.data)) === true) {
                    continue;
                } else if (ViperUtil.isTag(node, listType) === false) {
                    break;
                }

                // Found a previous list. Move its children to previous list.
                while (list.firstChild) {
                    node.appendChild(list.firstChild);
                }

                // Remove the original list element.
                ViperUtil.remove(list);
                list = node;
            }

            // Check if there is a list after this list.
            for (var node = list.nextSibling; node; node = node.nextSibling) {
                if (node.nodeType === ViperUtil.TEXT_NODE && ViperUtil.isBlank(ViperUtil.trim(node.data)) === true) {
                    continue;
                } else if (ViperUtil.isTag(node, listType) === false) {
                    break;
                }

                // Found a list. Move all the children of found list to the current list.
                while (node.firstChild) {
                    list.appendChild(node.firstChild);
                }

                // Remove the found list.
                ViperUtil.remove(node);
            }

            return list;

        },

        _getLineBreak: function(ref)
        {
            while (ref = ref.previousSibling) {
                if (ref.nodeType === ViperUtil.ELEMENT_NODE && ref.tagName.toLowerCase() === 'br') {
                    return ref;
                }
            }

            return null;

        },

        _getBlockParent: function(element, tag)
        {
            while (element && element !== this.viper.element) {
                if (ViperUtil.isBlockElement(element) === true) {
                    if (!tag || element.tagName.toLowerCase() === tag) {
                        return element;
                    }
                }

                element = element.parentNode;
            }

            return null;

        },

        _getCommonParents: function(elems)
        {
            // Clone array since it will be modified.
            elems = elems.concat([]);

            var parents = [];

            var eLen = elems.length;
            while (eLen > 0) {
                var elem = elems.shift();
                if (ViperUtil.isBlockElement(elem) === true) {
                    if (elem.tagName.toLowerCase() === 'ol' || elem.tagName.toLowerCase() === 'ul') {
                        // Add this list items as parents.
                        for (var listChild = elem.firstChild; listChild; listChild = listChild.nextSibling) {
                            parents.push(listChild);
                        }
                    } else {
                        parents.push(elem);
                    }
                } else {
                    while (elem) {
                        elem = elem.parentNode;
                        if (elem) {
                            if (elem === this.viper.element) {
                                break;
                            } else if (ViperUtil.isBlockElement(elem) === true) {
                                if (ViperUtil.inArray(elem, parents) === false) {
                                    parents.push(elem);
                                }

                                break;
                            }
                        }
                    }
                }//end if

                eLen = elems.length;
            }//end while

            return parents;

        },

        _makeList: function(tag, elements)
        {
            if (!elements) {
                return;
            }

            tag     = tag || 'ul';
            var eln = elements.length;

            if (eln <= 0) {
                return;
            }

            var list = document.createElement(tag);

            if (eln === 1) {
                // Check for BR tags to create list items out of those.
                // Note that the selection is ignored in this case. All BR tags
                // inside this single element will be used.
                var listItems = [];
                var listLen   = listItems.length;

                // First child might be null but we may have listItems to process.
                while (elements[0].firstChild || listLen > 0) {
                    var child = elements[0].firstChild;
                    if (child) {
                        listItems.push(child);
                    } else if (listItems.length > 0) {
                        var listItem = this._createListItem(listItems.shift());
                        if (listItem) {
                            list.appendChild(listItem);
                            while (listElem = listItems.shift()) {
                                listItem.appendChild(listElem);
                            }
                        }
                    }

                    if (child) {
                        ViperUtil.remove(child);
                    }

                    listLen = listItems.length;
                }

                ViperUtil.remove(elements[0]);
            } else {
                for (var i = 0; i < eln; i++) {
                    var listItem = this._createListItem(elements[i]);
                    if (listItem !== null) {
                        list.appendChild(listItem);
                    }
                }
            }//end if

            return list;

        },

        _createListItem: function(element)
        {
            if (!element || (element.nodeType === ViperUtil.TEXT_NODE && element.data.indexOf("\n") === 0 && ViperUtil.trim(element.data).length === 0)) {
                return null;
            }

            var li = document.createElement('li');

            // If the element is a block element then insert its children.
            if (ViperUtil.isBlockElement(element) === true) {
                if (element.childNodes && element.childNodes.length > 0) {
                    while (element.firstChild) {
                        if (element.firstChild.nodeType === ViperUtil.TEXT_NODE) {
                            if (ViperUtil.trim(element.firstChild.data).length <= 0) {
                                // Don't need empty text nodes.
                                ViperUtil.remove(element.firstChild);
                                continue;
                            }
                        }

                        li.appendChild(element.firstChild);
                    }
                }

                // Remove the empty element.
                ViperUtil.remove(element);

                // If the list element is still empty then dont return it.
                if (li.childNodes.length === 0) {
                    return null;
                }
            } else {
                li.appendChild(element);
            }//end if

            return li;

        },

        _getList: function(element)
        {
            return this._isListElement(element, null, true);

        },

        _isListElement: function(element, type, returnNode)
        {
            while (element && element !== this.viper.element) {
                if (element.nodeType === ViperUtil.ELEMENT_NODE) {
                    var tagName = element.tagName.toLowerCase();
                    if (type) {
                        if (tagName === type) {
                            if (returnNode === true) {
                                return element;
                            }

                            return true;
                        }
                    } else if (tagName === 'ul' || tagName === 'ol' || tagName === 'li') {
                        if (returnNode === true) {
                            return element;
                        }

                        return true;
                    }
                }

                element = element.parentNode;
            }//end while

            return false;

        },

        isListNode: function(node)
        {
            if (ViperUtil.isTag(node, 'ul') === true || ViperUtil.isTag(node, 'ol') === true) {
                return true;
            }

            return false;

        },

        
        _getListItem: function(element)
        {
            while (element && element !== this.viper.element) {
                if (element.tagName && element.tagName.toLowerCase() === 'li') {
                    return element;
                }

                element = element.parentNode;
            }

            return null;

        },

        _getListElement: function(element)
        {
            element = element.parentNode;
            while (element && element !== this.viper.element) {
                if (element.tagName) {
                    var tag = element.tagName.toLowerCase();
                    if (tag === 'ol' || tag === 'ul') {
                        return element;
                    }
                }

                element = element.parentNode;
            }

            return null;

        },

        _getValidParentElement: function(element)
        {
            if (!element || element === this.viper.getViperElement()) {
                return;
            }

            if (ViperUtil.isTag(element, 'p') === true || ViperUtil.isTag(element, 'td') === true) {
                return element;
            }

            return this._getValidParentElement(element.parentNode);

        },

        _isWholeList: function(elems)
        {
            var sameParent = false;
            // If only 1 item is selected then it is under same parent.
            // If first item and last item are belong to the same list element
            // then they are under same parent.
            var parentList = null;
            if (elems.length > 1) {
                var first = elems[0];
                var last  = elems[(elems.length - 1)];

                var firstParent = first.parentNode;
                var lastParent  = last.parentNode;

                if (firstParent === lastParent) {
                    parentList = firstParent;
                    sameParent = true;
                } else {
                    for (var node = last.parentNode; last; node = node.parentNode) {
                        var tagName = ViperUtil.getTagName(node);
                        if (tagName !== 'li' && tagName !== 'ol' && tagName !== 'ul') {
                            break;
                        } else if (this.getNextItem(node)) {
                            break;
                        } else if (node === firstParent) {
                            return true;
                        }
                    }
                }
            } else if (elems[0]) {
                sameParent = true;
                parentList = elems[0].parentNode;
            } else {
                return;
            }

            if (sameParent === true) {
                var count = 0;
                var child = null;
                var last  = null;
                for (child = parentList.firstChild; child; child = child.nextSibling) {
                    if (ViperUtil.isTag(child, 'li') === true) {
                        if (count === 0 && child !== elems[0]) {
                            // Not the first LI of the list.
                            return false;
                        }

                        last = child;
                        count++;
                    }
                }

                if (last === elems[(elems.length - 1)]) {
                    return true;
                }
            }

            return false;

        },

        
        handleEnter: function(li)
        {
            var content = ViperUtil.getNodeTextContent(li);
            if (ViperUtil.trim(content).length === 0 || ViperUtil.getHtml(li) === '&nbsp;') {
                // End the list.
                var parents = ViperUtil.getParents(li, 'ul,ol');
                if (parents.length > 0) {
                    var listEl = parents[0];

                    if (parents.length > 1) {
                        // If this is a nested list then move this item to one level up.
                        // List element should be inside an li tag.
                        var parentLi = parents[(parents.length - 1)].parentNode;
                        while (parentLi && ViperUtil.isTag(parentLi, 'li') === false) {
                            parentLi = parentLi.parentNode;
                        }

                        if (parentLi) {
                            ViperUtil.insertAfter(parentLi, li);
                            var range = this.viper.getCurrentRange();
                            range.setStart(li.firstChild, 0);
                            range.collapse(true);
                            return false;
                        }
                    }

                    // Insert a new paragrap after the list.
                    var p = document.createElement('p');
                    ViperUtil.setHtml(p, '&nbsp;');

                    // Clone the list elem.
                    var listClone = listEl.cloneNode(false);
                    ViperUtil.removeAttr(listClone, 'id');

                    // Move all elements after current li to the new one.
                    var c  = 0;
                    var el = li.nextSibling;
                    while (el) {
                        var elem = el;
                        el       = el.nextSibling;
                        c++;
                        ViperUtil.remove(elem);
                        listClone.appendChild(elem);
                    }

                    ViperUtil.remove(li);

                    ViperUtil.insertAfter(listEl, p);

                    if (c > 0) {
                        ViperUtil.insertAfter(p, listClone);
                    }

                    var range = this.viper.getCurrentRange();
                    range.setStart(p.firstChild, 0);
                    range.collapse(true);

                    return false;
                }//end if
            }//end if

            return true;

        },

        remove: function()
        {
            // Remove the toolbar buttons.
            ViperUtil.remove(this.viper.Tools.getItem('unorderedList').element);
            ViperUtil.remove(this.viper.Tools.getItem('orderedList').element);
            ViperUtil.remove(this.viper.Tools.getItem('indentList').element);
            ViperUtil.remove(this.viper.Tools.getItem('outdentList').element);

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperReplacementPlugin(viper)
    {
        this.viper = viper;

        this._searchPattern       = null;
        this._replacementsCallback = null;

    }

    Viper.PluginManager.addPlugin('ViperReplacementPlugin', ViperReplacementPlugin);

    ViperReplacementPlugin.prototype = {

        setSettings: function (settings) {
            if (settings.callback) {
                this.setReplacementsCallback(settings.callback);
            }

            if (settings.pattern) {
                this.setSearchPattern(settings.pattern);
            }

            var self = this;
            this.showReplacements(
                null,
                function () {
                    self.viper.getHistoryManager().clear();
                    self.viper.getHistoryManager().add();
                }
            );
        },

        isSpecialElement: function(element) {
            if (ViperUtil.hasAttribute(element, 'data-viper-keyword') === true) {
                return true;
            }

            if (element.childNodes.length !== 1) {
                return false;
            }

            return this.isSpecialElement(element.firstChild);

        },

        init: function () {
            var self = this;

            this.viper.registerCallback('Viper:editableElementChanged', 'ViperReplacementPlugin', function() {
                self.viper.getHistoryManager().clear();
                self.showReplacements(
                    null,
                    function () {
                        self.viper.getHistoryManager().add();
                    }
                );
            });

            this.viper.registerCallback('Viper:getHtml', 'ViperReplacementPlugin', function(data) {
                self.showKeywords(data.element);
            });

            this.viper.registerCallback('Viper:setHtml', 'ViperReplacementPlugin', function(data, callback) {
                self.showReplacements(data.element, callback);
                return function() {};
            });

            this.viper.registerCallback('Viper:setHtmlContent', 'ViperReplacementPlugin', function(content, callback) {
                self.showAttributeReplacements(content, function(cont) {
                    callback.call(this, cont);
                });

                return function() {};
            });

            // Enter, Shift, Control, Alt, Caps lock, esc, L-CMD, R-CMD, arrow keys.
            var ignoredKeys = [13, 16, 17, 18, 20, 27, 91, 93, 37, 38, 39, 40, 224];
            this.viper.registerCallback('Viper:keyDown', 'ViperReplacementPlugin', function(e) {
                if (ViperUtil.inArray(e.which, ignoredKeys) === true) {
                    return;
                } else if ((e.which === 88 || e.which === 67 || e.which === 86) && (e.metaKey === true || e.ctrlKey === true)) {
                    // Copy/Cut/Paste operation.
                    return;
                }

                var range     = self.viper.getViperRange();
                var startNode = range.getStartNode();
                var selNode   = range.getNodeSelection();

                if (startNode && startNode.nodeType === ViperUtil.TEXT_NODE) {
                    // Check if the caret is inside a keyword element.
                    var rep = self._getKeywordElement(startNode);
                    if (!rep) {
                        if (range.startOffset === 0) {
                            // Range is at the start of a text node so check if the previous container is a keyword
                            // element.
                            rep = self._getKeywordElement(range.getPreviousContainer(startNode, null, false, false, true));
                            if (rep) {
                                if (e.which === ViperUtil.DOM_VK_BACKSPACE || e.which === ViperUtil.DOM_VK_DELETE) {
                                    // This is a backspace. Need to remove the keyword element and prevent default
                                    // action so mo.
                                    var elem = ViperUtil.getTopSurroundingParent(rep) || rep;
                                    ViperUtil.remove(elem);
                                    self.viper.contentChanged();
                                    return false;
                                }

                                // Add a space between the keyword element and the caret container.
                                if (e.which === 32 && range.startContainer.data === '') {
                                    // The first character of this text node is a space so we need to add non breaking
                                    // space.
                                    startNode.data = String.fromCharCode(160);
                                    range.setStart(startNode, 1);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);
                                    return false;
                                } else {
                                    range.setStart(startNode, 0);
                                }

                                // When the keyDown executes insert the character after the first space character.
                                range.collapse(true);
                                ViperSelection.addRange(range);
                            } else {
                                rep = self._getKeywordElement(range.getNextContainer(startNode, null, false, false, true));
                                if (rep) {
                                    if (e.which === ViperUtil.DOM_VK_BACKSPACE || e.which === ViperUtil.DOM_VK_DELETE) {
                                        // Let the KeyboardEditor plugin handle this.
                                        return;
                                    }

                                    if (startNode.data[0] === ' ') {
                                        // The first character of this text node is a space so we need to add non breaking
                                        // space.
                                        startNode.data = String.fromCharCode(160) + startNode.data;
                                    } else if (startNode.data.length === 0) {
                                        startNode.data = String.fromCharCode(160);
                                    } else {
                                        startNode.data = ' ' + startNode.data;
                                    }

                                    range.setStart(startNode, 0);
                                    range.collapse(true);
                                    ViperSelection.addRange(range);

                                    setTimeout(
                                        function () {
                                            startNode.data = ViperUtil.rtrim(startNode.data);
                                            if (startNode.data.length > 0) {
                                                range.setStart(startNode, 1);
                                            } else {
                                                range.setStart(startNode, 0);
                                            }

                                            range.collapse(true);
                                            ViperSelection.addRange(range);
                                        },
                                        2
                                    )
                                }
                            }
                            return;
                        }//end if

                        if (!rep) {
                            return;
                        }
                    }
                } else {
                    rep = self._getKeywordElement(selNode);
                }

                if (selNode === rep) {
                    // Whole keyword element is selected. Remove it and its surrounding parents.
                    var parents  = ViperUtil.getSurroundingParents(selNode);
                    if (parents.length > 0) {
                        selNode = parents.pop();
                    }

                    // When there are text siblings its better to join them.
                    var info = self._normaliseTextNodeSiblings(selNode);
                    if (info) {
                        range.setStart(info.textNode, info.splitOffset);
                    } else {
                        var cont = range.getPreviousContainer(selNode, null, false, false, true);
                        if (!cont) {
                            cont = range.getNextContainer(selNode, null, false, false, true);
                            if (!cont) {
                                cont = document.createTextNode('');
                                ViperUtil.insertBefore(selNode, cont);
                            } else {
                                self._trimExtraSpaceFromStart(cont, true);
                            }

                            range.setStart(cont, 0);
                        } else {
                            self._trimExtraSpaceFromEnd(cont, true);
                            range.setStart(cont, cont.data.length);
                        }
                    }

                    range.collapse(true);
                    ViperSelection.addRange(range);
                    ViperUtil.remove(selNode);
                    return;
                }
            });

            if (ViperUtil.isBrowser('safari') === true) {
                this.viper.registerCallback('Viper:keyPress', 'ViperReplacementPlugin', function(e) {
                    var range     = self.viper.getViperRange();
                    var startNode = range.getStartNode();
                    var selNode   = range.getNodeSelection();
                    var rep       = self._getKeywordElement(startNode);

                    if (!rep) {
                        return;
                    }

                    if (ViperUtil.isText(range.startContainer) === true
                        && range.startOffset === range.startContainer.data.length
                        && range.collapsed === true
                    ) {
                        // Safari has issue with placing the caret outside of the keyword when caret is at the end.
                        // Handle char insertion here.
                        var char     = String.fromCharCode(e.which);
                        var textNode = rep.nextSibling;
                        if (ViperUtil.isText(textNode) === true && textNode.data.length === 0) {
                            textNode.data = char + textNode.data;
                        } else {
                            textNode = document.createTextNode(char);
                        }

                        ViperUtil.insertAfter(rep, textNode);

                        if (char === ' '
                            && textNode.nextSibling === null
                            && ViperUtil.isBlockElement(textNode.parentNode) === true
                        ) {
                            // Last text node with space requires a BR element after it.
                            textNode.parentNode.appendChild(document.createElement('br'));
                        }

                        range.setStart(textNode, 1);
                        range.collapse(true);
                        ViperSelection.addRange(range);

                        self.viper.fireNodesChanged();
                        return false;
                    }

                });
            }

            var ignoreSelectionChange = false;
            this.viper.registerCallback('Viper:selectionChanged', 'ViperReplacementPlugin', function(range) {
                if (ignoreSelectionChange === true) {
                    ignoreSelectionChange = false;
                    return;
                }

                var start        = range.getStartNode();
                var end          = range.getEndNode();
                var startKeyword = self._getKeywordElement(start);
                var endKeyword   = self._getKeywordElement(end);

                if (startKeyword !== false && startKeyword === endKeyword) {
                    // Now check if the range is at the start or end of the keyword.
                    if (range.collapsed === true && start.nodeType === ViperUtil.TEXT_NODE) {
                        if (range.startOffset === start.data.length) {
                            // At the end.
                            var textNode = startKeyword.nextSibling;
                            if (!textNode || textNode.nodeType !== ViperUtil.TEXT_NODE) {
                                textNode = document.createTextNode('');
                                ViperUtil.insertAfter(startKeyword, textNode);
                            }

                            range.setStart(textNode, 0);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            return;

                        } else if (range.startOffset === 0) {
                            // At the start.
                            // TODO: Check surrounding parents?
                            var textNode = document.createTextNode('');
                            ViperUtil.insertBefore(startKeyword, textNode);
                            range.setStart(textNode, 0);
                            range.collapse(true);
                            ViperSelection.addRange(range);
                            return;
                        }
                    }

                    if (startKeyword.firstChild.nodeType === ViperUtil.TEXT_NODE
                        && startKeyword.lastChild.nodeType === ViperUtil.TEXT_NODE
                    ) {
                        range.setStart(startKeyword.firstChild, 0);
                        range.setEnd(startKeyword.lastChild, startKeyword.lastChild.data.length);
                    } else {
                        range.selectNode(startKeyword);
                    }

                    ViperSelection.addRange(range);

                    // Need to ignore the next call to selectionChanged handler to prevent recursion.
                    ignoreSelectionChange = true;
                    self.viper.fireSelectionChanged(null, true);
                } else if (startKeyword !== false && endKeyword === false) {
                    // Start of selection is inside a keyword. Extend the range.
                    var node = startKeyword.previousSibling;
                    if (!node || node.nodeType !== ViperUtil.TEXT_NODE) {
                        node = document.createTextNode('');
                        ViperUtil.insertBefore(startKeyword, node);
                    }

                    range.setStart(node, node.data.length);
                    ViperSelection.addRange(range);
                } else if (endKeyword !== false && startKeyword === false) {
                    // Start of selection is inside a keyword. Extend the range.
                    var node = endKeyword.nextSibling;
                    if (!node || node.nodeType !== ViperUtil.TEXT_NODE) {
                        node = document.createTextNode('');
                        ViperUtil.insertAfter(endKeyword, node);
                    }

                    range.setEnd(node, 0);
                    ViperSelection.addRange(range);
                }

            });

            this.viper.registerCallback('ViperInlineToolbarPlugin:lineageItemSelected', 'ViperReplacementPlugin', function(node) {
                ignoreSelectionChange = true;
            });

            this.viper.registerCallback('Viper:attributeRemoved', 'ViperReplacementPlugin', function(data) {
                // If the removed attribute has a replacement backup attribute remove that too.
                var cloneName = 'data-viper-' + data.attribute;
                if (ViperUtil.hasAttribute(data.element, cloneName) === true) {
                    ViperUtil.removeAttr(data.element, cloneName);
                }
            });

            this.viper.addAttributeGetModifier(
                function (element, attribute, value) {
                    // Check if the element has a keyword attribute.
                    value = element.getAttribute('data-viper-' + attribute) || value;
                    return value;
                }
            );

            this.viper.addAttributeSetModifier(
                function (element, attribute, value, callback) {
                    if (self._canIgnoreAttribute(attribute, value) === true) {
                        return value;
                    }

                    // If the value has keyword it needs to be handled.
                    var regex = new RegExp(self.getReplacementRegex(), 'gi');
                    var matches = value.match(regex);
                    if (matches !== null) {
                        var keywords = {};
                        var match    = null;
                        while (match = matches.pop()) {
                            keywords[match] = '';
                        }

                        self.getKeywordReplacements(
                            keywords,
                            function(replacements) {
                                for (var keyword in keywords) {
                                    self._replaceAttributeKeyword(element, attribute, keyword, replacements[keyword], value, true);
                                }

                                callback.call(this);
                            }
                        );

                        return false;
                    } else {
                        // No keywords.. If there is a attribute backup, remove it.
                        var cloneName = 'data-viper-' + attribute;
                        if (ViperUtil.hasAttribute(element, cloneName) === true) {
                            ViperUtil.removeAttr(element, cloneName);
                        }
                    }

                    return value;
                }
            );

            this.viper.registerCallback(
                'ViperInlineToolbarPlugin:getReadableTagName',
                'ViperReplacementPlugin',
                function(data) {
                    if (data.tag && ViperUtil.hasAttribute(data.tag, 'data-viper-keyword') === true) {
                        return _('Keyword');
                    }

                    return null;
                }
            );

        },

        replaceKeywords: function (string, callback)
        {
            if (!callback) {
                return;
            }

            var regex = this.getReplacementRegex();
            if (!regex) {
                callback.call(this, string);
                return;
            }

            regex       = new RegExp(regex, 'gi');
            var matches = string.match(regex);
            if (matches) {
                this.getKeywordReplacements(
                    matches,
                    function (replacements) {
                        for (var keyword in replacements) {
                            string = string.replace(keyword, replacements[keyword]);
                        }

                        callback.call(this, string);
                    }
                );
            } else {
                callback.call(this, string);
            }

        },

        _trimExtraSpaceFromStart: function(textNode, useNbsp)
        {
            var fromIdx = -1;
            for (var i = 0; i < textNode.data.length; i++) {
                if (textNode.data[i] === ' ') {
                    fromIdx = i;
                } else {
                    break;
                }
            }

            if (useNbsp === true && fromIdx >= 0) {
                textNode.data = String.fromCharCode(160) + textNode.data.substr(fromIdx + 1);
            } else if (fromIdx > 0) {
                textNode.data = textNode.data.substr(fromIdx);
            }

        },

        _trimExtraSpaceFromEnd: function(textNode, useNbsp)
        {
            var fromIdx = -1;
            for (var i = (textNode.data.length - 1); i >= 0 ; i--) {
                var c = textNode.data[i];
                if (c === ' ') {
                    fromIdx = i;
                } else {
                    break;
                }
            }

            if (useNbsp === true && fromIdx >= 0) {
                textNode.data = textNode.data.substr(0, fromIdx) + String.fromCharCode(160);
            } else if (fromIdx > 0) {
                textNode.data = textNode.data.substr(0, fromIdx);
            }

        },

        _normaliseTextNodeSiblings: function (element)
        {
            var prevCont = element.previousSibling;
            var nextCont = element.nextSibling;
            var info     = null;

            if (prevCont
                && nextCont
                && prevCont.nodeType === ViperUtil.TEXT_NODE
                && nextCont.nodeType === ViperUtil.TEXT_NODE
            ) {
                // Both siblings
                info = {
                    splitOffset: prevCont.data.length,
                    textNode: prevCont
                };

                if (nextCont.data[0] === ' ' && prevCont.data[(prevCont.data.length - 1)] === ' ') {
                    nextCont.data = String.fromCharCode(160) + nextCont.data.substr(1);
                }

                prevCont.data += nextCont.data;
            }

            return info;

        },

        _fixRange: function (range, keywordElem, start) {
            if (start === true) {
                // Start of range is in keyword.. Move it after keyword.
                var cont = range.getPreviousContainer(keywordElem);
                range.setEnd(cont, cont.data.length);
            } else {
                var cont = range.getNextContainer(keywordElem);
                range.setStart(cont, 0);
                range.collapse(true);
            }

            return range;

        },

        _getKeywordElement: function (elem) {
            if (!elem) {
                return false;
            }

            if (ViperUtil.hasAttribute(elem, 'data-viper-keyword') === true) {
                return elem;
            }

            var viperElement = this.viper.getViperElement();
            while (elem.parentNode && elem.parentNode !== viperElement) {
                elem = elem.parentNode;
                if (ViperUtil.hasAttribute(elem, 'data-viper-keyword') === true) {
                    return elem;
                }
            }

            return false;

        },

        setReplacementsCallback: function (callback) {
            this._replacementsCallback = callback;

        },

        setSearchPattern: function (regexStr) {
            this._searchPattern = regexStr;

        },

        getReplacementRegex: function() {
            return this._searchPattern;

        },

        getReplacementsCallback: function () {
            return this._replacementsCallback;
        },

        
        showReplacements: function (element, callback) {
            element = element || this.viper.getViperElement();

            // Get all the keywords in the element.
            var cache    = {};
            var keywords = this.scanKeywords(element, cache);
            if (!keywords || ViperUtil.isEmpty(keywords) === true) {
                if (callback) {
                    callback.call(self);
                }

                return;
            }

            // Get the keyword replacements.
            var self = this;
            this.getKeywordReplacements(
                keywords,
                function(replacements) {
                    // Convert the keywords inside the text nodes.
                    self._convertContentKeywords(replacements, cache);

                    // Convert the keywords inside the attributes.
                    var content = ViperUtil.getHtml(element);
                    content     = self._convertAttributeKeywords(content, replacements, cache);
                    ViperUtil.setHtml(element, content);

                    if (callback) {
                        callback.call(self);
                    }
                }
            );

        },

        showAttributeReplacements: function(content, callback) {
            var keywords = {};
            var cache    = {};
            this._scanAttributeKeywords(content, keywords, cache);

            // Get the keyword replacements.
            var self = this;
            this.getKeywordReplacements(
                keywords,
                function(replacements) {
                    // Convert the keywords inside the attributes.
                    content = self._convertAttributeKeywords(content, replacements, cache);

                    if (callback) {
                        callback.call(self, content);
                    }
                }
            );

        },

        
        showKeywords: function (elem) {
            this._convertContentReplacementsToKeywords(elem)
            this._convertAttributeReplacementsToKeywords(elem);

        },

        _convertContentReplacementsToKeywords: function (parentElem) {
            var keywordElements = ViperUtil.find(parentElem, '[data-viper-keyword]');
            var ln              = keywordElements.length;
            for (var i = 0; i < ln; i++) {
                var keywordElem = keywordElements[i];
                var keyword  = ViperUtil.attr(keywordElem, 'data-viper-keyword');
                if (keywordElem.attributes.length > 2) {
                    // Need to keep this span tag as it has extra attributes applied to it but remove the keyword attributes.
                    ViperUtil.removeAttr(keywordElem, 'data-viper-keyword')
                    ViperUtil.removeAttr(keywordElem, 'title');

                    // Also set the content of the keyword to be the keyword.
                    ViperUtil.setHtml(keywordElem, keyword);
                } else {
                    var textNode = document.createTextNode(keyword);
                    ViperUtil.insertAfter(keywordElem, textNode);
                    ViperUtil.remove(keywordElem);
                }
            }

        },

        _convertAttributeReplacementsToKeywords: function (parentElem) {
            parentElem = parentElem || this.viper.getViperElement();

            // Find all elements.
            var elems = ViperUtil.getTag('*', parentElem);
            var ln    = elems.length;

            for (var i = 0; i < elems.length; i++) {
                for (var j = (elems[i].attributes.length - 1); j >= 0; j--) {
                    var attr = elems[i].attributes[j];
                    if (attr.nodeName === 'data-viper-attribite-keywords') {
                        // Remove the cloned attribute.
                        ViperUtil.removeAttr(elems[i], attr.nodeName);
                    } else if (attr.nodeName.indexOf('data-viper-') === 0) {
                        // Replace real attribute value with the cloned value.
                        var attrName = attr.nodeName.replace('data-viper-', '');
                        if (attrName === 'src') {
                            // Do not set the src value as the keyword. This causes 404 requests.
                            attrName = '__viper_attr_src';
                            // Remove the actual src attribute.
                            ViperUtil.removeAttr(elems[i], 'src');
                        }

                        ViperUtil.attr(elems[i], attrName, attr.value);

                        // Remove the cloned attribute.
                        ViperUtil.removeAttr(elems[i], attr.nodeName);
                    }
                }
            }
        },

        getKeywordReplacements: function (keywords, callback) {
            if (ViperUtil.isArray(keywords) === true) {
                // Convert to object.
                var keywordsObj = {};
                for (var i = 0; i < keywords.length; i++) {
                    keywordsObj[keywords[i]] = '';
                }

                keywords = keywordsObj;
            }

            // The function that is going to retrieve all the replacements.
            var repCallback = this.getReplacementsCallback();
            if (!repCallback) {
                callback.call(this, keywords);
                return;
            }

            var self = this;
            repCallback(
                keywords,
                function(replacements) {
                    callback.call(self, replacements);
                }
            );

        },

        
        scanKeywords: function (parentElem, cache) {
            if (!this.getReplacementRegex()) {
                return;
            }

            var keywords = {};
            parentElem   = parentElem || this.viper.getViperElement();
            var content  = ViperUtil.getHtml(parentElem);

            this._scanAttributeKeywords(content, keywords, cache);
            this._scanContentKeywords(parentElem, keywords, cache);

            return keywords;

        },

        _scanAttributeKeywords: function(content, keywords, cache) {
            var self = this;

            // Regex to get list of HTML tags.
            var subRegex = '\\s+([:\\w]+)(?:\\s*=\\s*("(?:[^"]+)?"|\'(?:[^\']+)?\'|[^\'">\\s]+))?';

            // Regex to get list of attributes in an HTML tag.
            var tagRegex  = new RegExp('(<[\\w:]+)(?:' + subRegex + ')+\\s*(\/?>)', 'g');
            var attrRegex = new RegExp(subRegex, 'g');

            var regex      = self.getReplacementRegex();
            if (!regex) {
                return keywords;
            }

            // Find keywords in element attributes.
            // Find all elements.
            regex = new RegExp(regex, 'gi');

            cache.attributes = {};

            content = content.replace(/__viper_attr_/g, '');

            content = content.replace(tagRegex, function(match, tagStart, a, tagEnd) {
                match = match.replace(attrRegex, function(a, attrName, attrValue) {
                    // All attribute names must be lowercase.
                    attrName = attrName.toLowerCase();
                    var res  = ' ' + attrName + '=' + attrValue + '';

                    if (!cache.attributes[res]) {
                        var matches = attrValue.match(regex);
                        if (matches !== null) {
                            cache.attributes[res] = [];
                            var match  = null;
                            while (match = matches.pop()) {
                                cache.attributes[res].push(match);
                                keywords[match] = '';
                            }
                        }
                    }

                    return res;
                });

                return match;
            });

            return keywords;
        },

        _scanContentKeywords: function (parentElem, keywords, cache) {
            parentElem = parentElem || this.viper.getViperElement();

            var regex = this.getReplacementRegex();
            if (!regex) {
                return keywords;
            }

            regex = new RegExp(regex, 'gi');

            cache.textNodes = [];

            var textNodes = ViperUtil.getTextNodes(parentElem);
            var ln        = textNodes.length;
            var prevNode  = null;
            var nodeData  = null;
            for (var i = 0; i < ln; i++) {
                var matches = textNodes[i].data.match(regex);
                if (matches !== null) {
                    var match = null;
                    while (match = matches.shift()) {
                        if (prevNode !== textNodes[i]) {
                            // New node. Each node might have more than one keyword.
                            nodeData = {
                                elem: textNodes[i],
                                keywords: []
                            };

                            cache.textNodes.push(nodeData);
                        }

                        if (ViperUtil.isset(keywords[match]) === false) {
                            keywords[match] = '';
                        }

                        nodeData.keywords.push(match);
                        prevNode = textNodes[i];
                    }
                }
            }

            return keywords;

        },

        
        _convertContentKeywords: function (replacements, cache) {
            var ln = cache.textNodes.length;
            for (var i = 0; i < ln; i++) {
                // For each element replcace its keywords from end to beginning.
                var kc = cache.textNodes[i].keywords.length;
                for (var j = (kc - 1); j >= 0; j--) {
                    var textNode = cache.textNodes[i].elem;
                    var keyword  = cache.textNodes[i].keywords[j];

                    if (textNode.data === keyword && ViperUtil.isTag(textNode.parentNode, 'span') === true) {
                        // No need to create a new element.
                        var parent = textNode.parentNode;
                        ViperUtil.attr(parent, 'data-viper-keyword', keyword);
                        ViperUtil.attr(parent, 'title', keyword);
                        ViperUtil.setHtml(parent, replacements[keyword]);
                    } else {
                        // Need to split the text node at the start of keyword and create a new text node to put the
                        // rest of the content. For this reason we have to start replacing from the end of the string.
                        var startIndex = textNode.data.lastIndexOf(keyword);
                        if (startIndex < 0) {
                            // Could not find the keyword.
                            continue;
                        }

                        var startText = textNode.data.substr(0, startIndex);
                        var endText   = textNode.data.substr(startIndex + keyword.length);

                        var newTextNode = document.createTextNode(endText);
                        textNode.data   = startText;
                        ViperUtil.insertAfter(textNode, newTextNode);

                        // Now create the new un editable element.
                        var keywordHolder = this._createUneditableElement(
                            {
                                attributes: {
                                    'data-viper-keyword': keyword,
                                    title: keyword
                                },
                                content: replacements[keyword]
                            }
                        );

                        // Add it after the original textNode.
                        ViperUtil.insertAfter(textNode, keywordHolder);
                    }//end if
                }
            }

        },

        
        _createUneditableElement: function (options) {
            if (!options) {
                options = {};
            }

            var tagName = options.tagName || 'div';
            var content = options.content || '';

            var elem = document.createElement(tagName);

            ViperUtil.setHtml(elem, content);

            if (!options.tagName && ViperUtil.hasBlockChildren(elem) !== true) {
                // There are no block elements so use a span instead.
                elem = document.createElement('span');
                ViperUtil.setHtml(elem, content);
            }

            if (options.attributes) {
                for (var attrName in options.attributes) {
                    ViperUtil.attr(elem, attrName, options.attributes[attrName]);
                }
            }

            return elem;

        },

        _convertAttributeKeywords: function (content, replacements, cache) {
            if (typeof content !== 'string') {
                content = ViperUtil.getHtml(content);
            }

            content = content.replace(/__viper_attr_/g, '');

            for (var attr in cache.attributes) {
                var attrRep = attr;
                for (var i = 0; i < cache.attributes[attr].length; i++) {
                    var keyword = cache.attributes[attr][i];
                    attrRep     = attrRep.replace(keyword, replacements[keyword]) + ' data-viper-' + ViperUtil.ltrim(attr);
                }

                content = ViperUtil.replaceAll(attr, attrRep, content);
            }

            return content;

        },

        _replaceAttributeKeyword: function(element, attribute, keyword, replacement, value, forceUpdate) {
            if (this._canIgnoreAttribute(attribute, value) === true) {
                return value;
            }

            // Copy the real attribute into a new data attribute so that it can be recovered.
            var cloneName = 'data-viper-' + attribute;
            if (forceUpdate === true || ViperUtil.hasAttribute(element, cloneName) === false) {
                ViperUtil.attr(element, cloneName, value);
            }

            // Replace the keyword with its value in the real attribute.
            var realValue = value;
            realValue     = realValue.replace(keyword, replacement);
            ViperUtil.attr(element, attribute, realValue);

            ViperUtil.attr(element, 'data-viper-attribite-keywords', 'true');

            return realValue;

        },

        _canIgnoreAttribute: function(attribute, value) {
            if (attribute === 'src' && value.indexOf('data:image') === 0) {
                // Base64 images dont need replacement.
                return true;
            }

            return false;
        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperSearchReplacePlugin(viper)
    {
        this.viper       = viper;
        this._matchCount = 0;
        this._finding = false;

    }

    Viper.PluginManager.addPlugin('ViperSearchReplacePlugin', ViperSearchReplacePlugin);

    ViperSearchReplacePlugin.prototype = {

        init: function()
        {
            this._initToolbar();

            if (ViperUtil.isBrowser('msie') === true) {
                var self = this;
                this.viper.registerCallback('Viper:viperElementFocused', 'ViperSearchReplacePlugin', function() {
                    if (self._finding === true) {
                        self.viper.removeHighlights();
                        // Prevent focus events firing as it causes the selection to be
                        // lost during searching (IE only)...
                        return false;
                    }
                });
            }

        },

        _initToolbar: function()
        {
            var toolbar = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (!toolbar) {
                return;
            }

            var self  = this;
            var tools = this.viper.Tools;

            this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperSearchReplacePlugin', function(data) {
                self.viper.Tools.enableButton('searchReplace');
            });

            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperSearchReplacePlugin', function(data) {
                self.viper.Tools.enableButton('searchReplace');
            });

            // Create Search and replace button and popup.
            var content = document.createElement('div');

            // Search text box.
            var search = tools.createTextbox('ViperSearchPlugin:searchInput', _('Search'), '');
            tools.setFieldEvent('ViperSearchPlugin:searchInput', 'keyup', function() {
                if (tools.getItem('ViperSearchPlugin:searchInput').getValue()) {
                    tools.enableButton('ViperSearchPlugin:findNext');
                } else {
                    tools.disableButton('ViperSearchPlugin:findNext');
                    tools.disableButton('ViperSearchPlugin:replace');
                    tools.disableButton('ViperSearchPlugin:replaceAll');
                }
            });
            content.appendChild(search);

            var _replace = function () {
                self.replace(tools.getItem('ViperSearchPlugin:replaceInput').getValue());
                self._updateButtonStates();
                self.viper.contentChanged(true);
                return false;
            };

            var replace = tools.createTextbox('ViperSearchPlugin:replaceInput', _('Replace'), '', function(value) {
                var search = tools.getItem('ViperSearchPlugin:searchInput').getValue();
                self.getNumberOfMatches(search);
                self.find(search, false, true);

                self._updateButtonStates();
            });
            content.appendChild(replace);

            var _replaceAll = function () {
                var replaceCount = 0;
                var fromStart    = true;
                while (self.find(tools.getItem('ViperSearchPlugin:searchInput').getValue(), false, fromStart) === true) {
                    fromStart = false;
                    self.replace(tools.getItem('ViperSearchPlugin:replaceInput').getValue());
                    replaceCount++;
                }

                self._matchCount = 0;
                self._updateButtonStates();
                self.viper.contentChanged(true);
            };

            var replaceAllBtn = tools.createButton('ViperSearchPlugin:replaceAll', _('Replace All'), _('Replace All'), 'Viper-replaceAll', function() {
                var bubble = tools.getItem('ViperSearchPlugin:bubble');
                bubble.updateSubSectionAction('ViperSearchPlugin:bubbleSubSection', _replaceAll);

                var subSection = tools.getItem('ViperSearchPlugin:bubbleSubSection');
                return subSection.form.onsubmit();
            }, true);

            var replaceBtn = tools.createButton('ViperSearchPlugin:replace', _('Replace'), _('Replace'), 'Viper-replaceText', function() {
                var bubble = tools.getItem('ViperSearchPlugin:bubble');
                bubble.updateSubSectionAction('ViperSearchPlugin:bubbleSubSection', _replace);

                var subSection = tools.getItem('ViperSearchPlugin:bubbleSubSection');
                return subSection.form.onsubmit();
            }, true);

            content.appendChild(replaceAllBtn);
            content.appendChild(replaceBtn);

            var _findNext = function () {
                // Find again.
                var found = self.find(tools.getItem('ViperSearchPlugin:searchInput').getValue());
                if (found !== true) {
                    // Try from top.
                    self.getNumberOfMatches(tools.getItem('ViperSearchPlugin:searchInput').getValue());
                    if (self._matchCount > 0) {
                        found = self.find(tools.getItem('ViperSearchPlugin:searchInput').getValue(), false, true);
                        if (found !== true) {
                            self._matchCount = 0;
                        }
                    }
                }

                self._updateButtonStates(found);
                return false;
            };

            var findNext = tools.createButton('ViperSearchPlugin:findNext', _('Find Next'), _('Find Next'), '', function() {
                var bubble = tools.getItem('ViperSearchPlugin:bubble');
                bubble.updateSubSectionAction('ViperSearchPlugin:bubbleSubSection', _findNext);

                var subSection = tools.getItem('ViperSearchPlugin:bubbleSubSection');
                return subSection.form.onsubmit();
            }, true);
            content.appendChild(findNext);

            // Create the bubble.
            var searchTools = toolbar.createBubble('ViperSearchPlugin:bubble', _('Search & Replace'), content, null, function() {
                self._matchCount = 0;
                self._updateButtonStates(false);
            });
            var searchBtn   = tools.createButton('searchReplace', '', _('Search & Replace'), 'Viper-searchReplace', null, true);
            toolbar.addButton(searchBtn);
            toolbar.setBubbleButton('ViperSearchPlugin:bubble', 'searchReplace');

            tools.getItem('ViperSearchPlugin:bubble').setSubSectionAction('ViperSearchPlugin:bubbleSubSection', function() {
                return _findNext();
            }, ['ViperSearchPlugin:searchInput'], 'ViperSearchPlugin:findNext', true);

            // Update the buttons when the toolbar updates it self.
            this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperSearchReplacePlugin', null);

        },

        _updateButtonStates: function(hasResult)
        {
            var self  = this;
            var tools = this.viper.Tools;

            var enableReplace = true;
            if (hasResult !== true && this._matchCount === 0) {
                enableReplace = false;
            }

            // These selection during these find calls may jump in to other containers
            // so clone the current selection so that we can select it again.
            var clone = this.viper.getCurrentRange();
            if (enableReplace === true) {
                tools.enableButton('ViperSearchPlugin:replace');
                tools.enableButton('ViperSearchPlugin:replaceAll');
            } else {
                tools.disableButton('ViperSearchPlugin:replace');
                tools.disableButton('ViperSearchPlugin:replaceAll');
            }

            // Fix to remove the selection from textbox.
            var val = tools.getItem('ViperSearchPlugin:searchInput').getValue();
            tools.getItem('ViperSearchPlugin:searchInput').setValue('');
            tools.getItem('ViperSearchPlugin:searchInput').setValue(val);
            val = tools.getItem('ViperSearchPlugin:replaceInput').getValue();
            tools.getItem('ViperSearchPlugin:replaceInput').setValue('');
            tools.getItem('ViperSearchPlugin:replaceInput').setValue(val);

            // Select the original range.
            ViperSelection.addRange(clone);
            this.viper.focus();

        },

        getNumberOfMatches: function(text)
        {
            this._matchCount = 0;
            var fromStart = true;
            while (this.find(text, false, fromStart) === true) {
                this._matchCount++;
                fromStart = false;
            }

            return this._matchCount;

        },

        find: function(text, backward, fromStart, testOnly, element)
        {
            var element = element || this.viper.getViperElement();
            if (!text || !element) {
                return;
            }

            if (ViperUtil.isBrowser('edge') === true) {
                return this._edgeFind.apply(this, arguments);
            }

            var rangeClone = null;
            if (testOnly) {
                rangeClone = this.viper.getCurrentRange().cloneRange();
            }

            var viperRange = null;
            if (fromStart === true) {
                if (Viper.document.activeElement
                    && Viper.document.activeElement !== this.viper.getViperElement()
                    && Viper.document.activeElement.blur
                    && Viper.document.activeElement !== document.body
                ) {
                    // Call the blur method of the active element incase its an input box etc
                    // which causes problems on IE when range is set below.
                    // Note that the above activeElement != body check is to prevent the best
                    // browser in the world changing focus to another window..
                    Viper.document.activeElement.blur();
                }

                this.viper.focus();
                viperRange = this.viper.getCurrentRange();
                viperRange.setStart(viperRange._getFirstSelectableChild(element), 0);
                viperRange.collapse(true);
                ViperSelection.addRange(viperRange);
            } else {
                if (ViperUtil.isBrowser('msie') === true && this._finding === true) {
                    try {
                        this.viper.highlightToSelection();
                    } catch (e) {}
                }
            }

            if (ViperUtil.isBrowser('msie') === true) {
                viperRange = this.viper.getCurrentRange();

                if (this.viper.rangeInViperBounds(this.viper.getCurrentRange()) === false) {
                    viperRange.setStart(viperRange._getFirstSelectableChild(element), 0);
                    viperRange.collapse(true);
                }

                // Range search.
                if (ViperUtil.isBrowser('msie', '>=9') === true) {
                    if (fromStart !== true) {
                        viperRange.collapse(false);
                    }

                    var textRange = new Viper.IERange(document.body.createTextRange());
                    textRange.setStart(viperRange.startContainer, viperRange.startOffset);
                    textRange.setEnd(viperRange.endContainer, viperRange.endOffset);
                    viperRange = textRange;
                } else {
                    viperRange.collapse(false);
                }

                this._finding = true;
                var found = viperRange.rangeObj.findText(text);
                if (testOnly !== true && found === true) {
                    try {
                        viperRange.rangeObj.select();
                    } catch (e) {
                        return false;
                    }

                    if (this.viper.rangeInViperBounds(this.viper.getCurrentRange()) === false) {
                        return false;
                    }

                    ViperSelection.addRange(this.viper.getCurrentRange());
                    this.viper.fireSelectionChanged(null, true);
                    setTimeout(function() {
                        this._finding = false;
                    }, 300);
                }

                return found;
            } else {
                this.viper.focus();
                viperRange = this.viper.getViperRange();
                ViperSelection.addRange(viperRange);

                var found = Viper.Util.getDocumentWindow().find(text, false, backward);
                if (found !== true || this.viper.rangeInViperBounds() === false) {
                    if (testOnly === true) {
                        ViperSelection.addRange(rangeClone);
                    } else {
                        // Not found or not inside Viper element.
                        ViperSelection.addRange(viperRange);
                        this.viper.focus();
                    }

                    return false;
                } else if (testOnly === true) {
                    ViperSelection.addRange(rangeClone);
                    return true;
                } else {
                    ViperSelection.addRange(this.viper.getCurrentRange());
                }
            }//end if

            return true;

        },

        _edgeFind: function (text, backward, fromStart, testOnly, element)
        {
            // MS Edge browser does not support window.find or createTextRange, which basically stops us from finding text.
            // Try finding it by scanning text nodes. For now its very simple text search in each node, does not work for
            // broken strings (e.g. "find me" in <p><strong>find</strong> me</p>).
            var element     = element || this.viper.getViperElement();
            var textNodes   = ViperUtil.getTextNodes(element);
            var range       = this.viper.getViperRange().cloneRange();
            var startNode   = range.getStartNode();
            var startOffset = (range.startOffset + 1);
            text            = text.toLowerCase();

            if (fromStart === true) {
                startNode   = null;
                startOffset = 0;
            }

            for (var i = 0; i < textNodes.length; i++) {
                var node  =  textNodes[i];
                if (startNode !== null && node !== startNode) {
                    continue;
                } else {
                    startNode = null;
                }

                var index = node.data.toLowerCase().indexOf(text, startOffset);
                if (index >= 0) {
                    range.setStart(node, index);
                    range.setEnd(node, index + text.length);

                    if (testOnly !== true) {
                        ViperSelection.addRange(range);
                    }

                    return true;
                }

                startOffset = 0;
            }

            return false;

        },

        replace: function(replacement)
        {
            var range = null;
            if (ViperUtil.isBrowser('msie') === true) {
                this.viper.highlightToSelection();
                range = this.viper.getViperRange();
            } else {
                range = this.viper.getCurrentRange();
                if (this.viper.rangeInViperBounds(range) === false) {
                    range = this.viper.getViperRange();
                }
            }

            var bookmark = this.viper.createBookmark(range);
            var newNode  = document.createTextNode(replacement);
            ViperUtil.insertBefore(bookmark.start, newNode);
            this.viper.removeBookmark(bookmark);

            range.setStart(newNode, 0);
            range.setEnd(newNode, newNode.data.length);
            ViperSelection.addRange(range);

            this._matchCount--;

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


function StyleHTML(html_source, indent_size, indent_character, max_char, brace_style)
{
    var Parser, multi_parser;

  function Parser() {

    this.pos = 0; //Parser position
    this.token = '';
    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
      parent: 'parent1',
      parentcount: 1,
      parent1: ''
    };
    this.tag_type = '';
    this.token_text = this.last_token = this.last_text = this.token_type = '';


    this.Utils = { //Uilities made available to the various functions
      whitespace: "\n\r\t ".split(''),
      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed'.split(','), //all the single tags for HTML
      extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
      in_array: function (what, arr) {
        for (var i=0; i<arr.length; i++) {
          if (what === arr[i]) {
            return true;
          }
        }
        return false;
      }
    }

    this.get_content = function () { //function to capture regular content between tags

      var input_char = '';
      var content = [];
      var space = false; //if a space is needed

      while (this.input.charAt(this.pos) !== '<') {
        if (this.pos >= this.input.length) {
          return content.length?content.join(''):['', 'TK_EOF'];
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;


        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (content.length || input_char === ' ') {
            space = true;
          }
          this.line_char_count--;
          continue; //don't want to insert unnecessary space
        }
        else if (space) {
          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached
            content.push('\n');
            for (var i=0; i<this.indent_level; i++) {
              content.push(this.indent_string);
            }
            this.line_char_count = 0;
          }
          else{
            content.push(' ');
            this.line_char_count++;
          }
          space = false;
        }
        content.push(input_char); //letter at-a-time (or string) inserted to an array
      }

      if (space === true) {
          content.push(input_char);
          space = false;
      }

      return content.length?content.join(''):'';
    }

    this.get_script = function () { //get the full content of a script to pass to js_beautify

      var input_char = '';
      var content = [];
      var reg_match = new RegExp('\<\/script' + '\>', 'igm');
      reg_match.lastIndex = this.pos;
      var reg_array = reg_match.exec(this.input);
      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script
      while(this.pos < end_script) { //get everything in between the script tags
        if (this.pos >= this.input.length) {
          return content.length?content.join(''):['', 'TK_EOF'];
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;


        content.push(input_char);
      }
      return content.length?content.join(''):''; //we might not have any content at all
    }

    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object
      if (this.tags[tag + 'count']) { //check for the existence of this tag type
        this.tags[tag + 'count']++;
        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
      }
      else { //otherwise initialize this tag type
        this.tags[tag + 'count'] = 1;
        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
      }
      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
    }

    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer
      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
        var temp_parent = this.tags.parent; //check to see if it's a closable tag.
        while (temp_parent) { //till we reach '' (the initial value);
          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
            break;
          }
          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
        }
        if (temp_parent) { //if we caught something
          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
        }
        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
        if (this.tags[tag + 'count'] == 1) {
          delete this.tags[tag + 'count'];
        }
        else {
          this.tags[tag + 'count']--;
        }
      }
    }

    this.get_tag = function () { //function to get a full tag and parse its type
      var input_char = '';
      var content = [];
      var space = false;

      do {
        if (this.pos >= this.input.length) {
          return content.length?content.join(''):['', 'TK_EOF'];
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;

        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
          space = true;
          this.line_char_count--;
          continue;
        }

        if (input_char === "'" || input_char === '"') {
          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially
            input_char += this.get_unformatted(input_char);
            space = true;
          }
        }

        if (input_char === '=') { //no space before =
          space = false;
        }

        if (content.length && content[content.length-1] !== '=' && input_char !== '>'
            && space) { //no space after = or before >
          if (this.line_char_count >= this.max_char) {
            this.print_newline(false, content);
            this.line_char_count = 0;
          }
          else {
            content.push(' ');
            this.line_char_count++;
          }
          space = false;
        }
        content.push(input_char); //inserts character at-a-time (or string)
      } while (input_char !== '>');

      var tag_complete = content.join('');
      var tag_index;
      if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends
        tag_index = tag_complete.indexOf(' ');
      }
      else { //otherwise go with the tag ending
        tag_index = tag_complete.indexOf('>');
      }
      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();
      if (tag_complete.charAt(tag_complete.length-2) === '/' ||
          this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
        this.tag_type = 'SINGLE';
      }
      else if (tag_check === 'script') { //for later script handling
        this.record_tag(tag_check);
        this.tag_type = 'SCRIPT';
      }
      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)
        this.record_tag(tag_check);
        this.tag_type = 'STYLE';
      }
      else if (tag_check === 'a') { // do not reformat the <a> links
        var comment = this.get_unformatted('</a>', tag_complete); //...delegate to get_unformatted function
        content.push(comment);
        // --> SQUIZ
        this.tag_type = 'INLINE';
        // -- SQUIZ
      }
      // --> SQUIZ
      else if (('|pre|strong|em|i|sub|sup|u|strike|span|').indexOf('|' + tag_check + '|') >= 0) {
        content.push(this.get_unformatted('</' + tag_check + '>'));
        this.tag_type = 'INLINE';
      }
      // -- SQUIZ
      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment
        if (tag_check.indexOf('[if') != -1) { //peek for <!--[if conditional comment
          if (tag_complete.indexOf('!IE') != -1) { //this type needs a closing --> so...
            var comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted
            content.push(comment);
          }
          this.tag_type = 'START';
        }
        else if (tag_check.indexOf('[endif') != -1) {//peek for <!--[endif end conditional comment
          this.tag_type = 'END';
          this.unindent();
        }
        else if (tag_check.indexOf('[cdata[') != -1) { //if it's a <[cdata[ comment...
          var comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function
          content.push(comment);
          this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags
        }
        else {
          var comment = this.get_unformatted('-->', tag_complete);
          content.push(comment);
          this.tag_type = 'SINGLE';
        }
      }
      else {
        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
          this.tag_type = 'END';
        }
        else { //otherwise it's a start-tag
          this.record_tag(tag_check); //push it on the tag stack
          this.tag_type = 'START';
        }
        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
          this.print_newline(true, this.output);
        }
      }
      return content.join(''); //returns fully formatted tag
    }

    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety

      if (orig_tag && orig_tag.indexOf(delimiter) != -1) {
        return '';
      }
      var input_char = '';
      var content = '';
      var space = true;
      do {

        if (this.pos >= this.input.length) {
          return content;
        }

        input_char = this.input.charAt(this.pos);
        this.pos++
        if (delimiter === '</pre>') {
            content += input_char;
            continue;
        }

        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (!space) {
            this.line_char_count--;
            continue;
          }
          if (input_char === '\n' || input_char === '\r') {
            content += '\n';
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            this.line_char_count = 0;
            continue;
          }
        }
        content += input_char;
        this.line_char_count++;
        space = true;


      } while (content.indexOf(delimiter) == -1);
      return content;
    }

    this.get_token = function () { //initial handler for token-retrieval
      var token;

      if (this.last_token === 'TK_TAG_SCRIPT') { //check if we need to format javascript
        var temp_token = this.get_script();
        if (typeof temp_token !== 'string') {
          return temp_token;
        }
        token = StyleHTML(temp_token,
                {indent_size: this.indent_size, indent_char: this.indent_character, indent_level: this.indent_level, brace_style: this.brace_style}); //call the JS Beautifier
        return [token, 'TK_CONTENT'];
      }
      if (this.current_mode === 'CONTENT') {
        token = this.get_content();
        if (typeof token !== 'string') {
          return token;
        }
        else {
          return [token, 'TK_CONTENT'];
        }
      }

      if(this.current_mode === 'TAG') {
        token = this.get_tag();
        if (typeof token !== 'string') {
          return token;
        }
        else {
          var tag_name_type = 'TK_TAG_' + this.tag_type;
          return [token, tag_name_type];
        }
      }
    }

    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions

      this.input = js_source || ''; //gets the input for the Parser
      this.output = [];
      this.indent_character = indent_character || ' ';
      this.indent_string = '';
      this.indent_size = indent_size || 2;
      this.brace_style = brace_style || 'collapse';
      this.indent_level = 0;
      this.max_char = max_char || 70; //maximum amount of characters per line
      this.line_char_count = 0; //count to see if max_char was exceeded

      for (var i=0; i<this.indent_size; i++) {
        this.indent_string += this.indent_character;
      }

      this.print_newline = function (ignore, arr) {
        this.line_char_count = 0;
        if (!arr || !arr.length) {
          return;
        }
        if (!ignore) { //we might want the extra line
          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {
            arr.pop();
          }
        }
        arr.push('\n');
        for (var i=0; i<this.indent_level; i++) {
          arr.push(this.indent_string);
        }
      }


      this.print_token = function (text) {
        this.output.push(text);
      }

      this.indent = function () {
        this.indent_level++;
      }

      this.unindent = function () {
        if (this.indent_level > 0) {
          this.indent_level--;
        }
      }
    }
    return this;
  }

  



  multi_parser = new Parser(); //wrapping functions Parser
  multi_parser.printer(html_source, indent_character, indent_size, 300, brace_style); //initialize starting values



  while (true) {
      var t = multi_parser.get_token();
      multi_parser.token_text = t[0];
      multi_parser.token_type = t[1];

    if (multi_parser.token_type === 'TK_EOF') {
      break;
    }


    switch (multi_parser.token_type) {
      case 'TK_TAG_START': case 'TK_TAG_SCRIPT': case 'TK_TAG_STYLE':
        multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.indent();
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_TAG_END':
        multi_parser.print_newline(true, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_TAG_SINGLE':
        //multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      // --> SQUIZ
      case 'TK_TAG_INLINE':
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      // -- SQUIZ
      case 'TK_CONTENT':
        if (multi_parser.token_text !== '') {
            // --> SQUIZ
            if (multi_parser.last_token !== 'TK_TAG_INLINE' && multi_parser.last_token !== 'TK_TAG_SINGLE') {
                multi_parser.print_newline(false, multi_parser.output);
            }
            // -- SQUIZ

            multi_parser.print_token(multi_parser.token_text);
        }
        multi_parser.current_mode = 'TAG';
        break;
    }
    multi_parser.last_token = multi_parser.token_type;
    multi_parser.last_text = multi_parser.token_text;
  }
  return multi_parser.output.join('');
}



(function(ViperUtil, ViperSelection, _) {
    function ViperSourceViewPlugin(viper)
    {
        this.viper         = viper;
        this._editor       = null;
        this._textEditor   = null;
        this._resizeHandle = null;
        this._sourceView   = null;
        this._sourceCont   = null;
        this._closeConfirm = null;
        this._isVisible    = false;

        this._originalSource = null;
        this._inNewWindow    = false;

        this._ignoreUpdate         = false;
        this._ignoreSourceUpdate   = false;
        this._newWindowContents    = '';
        this._jqueryURL            = null;
        this._containerid          = null;
        this._toolbarButtonToggles = false;
        this._aceTheme             = 'ace/theme/viper';
        this._base64Images         = {};
    }

    Viper.PluginManager.addPlugin('ViperSourceViewPlugin', ViperSourceViewPlugin);

    ViperSourceViewPlugin.prototype = {
        init: function()
        {
            var self = this;
            this.toolbarPlugin = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (this.toolbarPlugin) {
                var toggle = this.viper.Tools.createButton('sourceEditor', '', _('Toggle Source View'), 'Viper-sourceView', function() {
                    self.toggleSourceView();
                }, true);
                this.toolbarPlugin.addButton(toggle);

                this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperSourceViewPlugin', function(data) {
                    self.viper.Tools.enableButton('sourceEditor');
                });

                this.viper.registerCallback('ViperToolbarPlugin:updateToolbar', 'ViperSourceViewPlugin', function(data) {
                    self.viper.Tools.enableButton('sourceEditor');
                });
            }

            var updateTimer = null;
            this.viper.registerCallback('Viper:nodesChanged', 'ViperSourceViewPlugin', function(nodes) {
                clearTimeout(updateTimer);
                if (self._ignoreSourceUpdate === true) {
                    self._ignoreSourceUpdate = false;
                    return;
                }

                updateTimer = setTimeout(function() {
                    self.updateSourceContents();
                }, 250);
            });

            this.viper.registerCallback(['Viper:editableElementChanged', 'Viper:disabled'], 'ViperSourceViewPlugin', function(nodes) {
                if (self._toolbarButtonToggles !== true) {
                    self.hideSourceView();
                }
            });

            this.viper.registerCallback('ViperToolbarPlugin:canEnableToolbar', 'ViperSourceViewPlugin', function() {
                if (self._toolbarButtonToggles === true && self._isVisible === true) {
                    self.toolbarPlugin.disable();
                    return false;
                }
            });

            this.viper.registerCallback('ViperToolbarPlugin:disabled', 'ViperSourceViewPlugin', function() {
                if (self._toolbarButtonToggles === true && self._isVisible === true) {
                    self.viper.Tools.enableButton('sourceEditor');
                    self.viper.Tools.setButtonActive('sourceEditor');
                }
            });

            this.viper.registerCallback('Viper:getHtml', 'ViperSourceViewPlugin', function(data) {
                self._removeScrollAttribute(data.element);
                self._convertBase64ImagesToKeywords(data.element);
            });

        },

        setSettings: function(settings)
        {
            if (settings.jqueryURL) {
                this._jqueryURL = settings.jqueryURL;
            }

            if (settings.parentid) {
                this._containerid = settings.parentid;
            }

            if (settings.toolbarButtonToggles) {
                this._toolbarButtonToggles = settings.toolbarButtonToggles;
            }

            if (settings.aceTheme) {
                this._aceTheme = settings.aceTheme;
            }

        },

        isSourceChanged: function()
        {
            var value = null;
            if (this._editor) {
                value = this._editor.getSession().getValue();
            } else if (this._textEditor) {
                value = this._textEditor.value;
            }

            if (this._originalSource === value) {
                return false;
            }

            return true;

        },

        showSourceView: function(content, callback)
        {
            var self = this;
            if (!this._sourceView) {
                this._createSourceView(function() {
                    if (!content) {
                        content = self.getContents();
                    }

                    self._originalSource = content;
                    self.showSourceView(null, callback);
                });
            } else {
                if (!content) {
                    content = this.getContents();
                } else {
                    content = StyleHTML(content);
                }

                if (this._editor) {
                    // Set Ace editor content.
                    this._ignoreUpdate = true;
                    this._editor.getSession().setValue(content);

                    // Scroll to the current caret position.
                    this.scrollToText('__viper_scrollpos');

                    // Remove special scroll attribute from the actual content.
                    self._removeScrollAttribute();

                    // Remove the special scroll attribute from source view content.
                    self._editor.replaceAll('', {needle: ' __viper_scrollpos="true"'});

                    // Make sure the original source does not include the scroll attribute.
                    self._originalSource = self._editor.getSession().getValue();

                    // Show the editor.
                    if (!this._containerid) {
                        self.viper.Tools.openPopup('VSVP:popup', 800, 600);
                    } else if (this._toolbarButtonToggles === true) {
                        // Do the disabling of toolbar here when the custom container provided.
                        this._isVisible = true;
                        this.toolbarPlugin.disable();
                    }

                    this.viper.fireCallbacks('ViperSourceViewPlugin:showSourceView');

                    setTimeout(function() {
                        self._editor.resize();
                        self._editor.focus();
                        self._isVisible = true;
                    }, 50);
                } else {
                    this._textEditor.value = content;
                    this._originalSource   = this._textEditor.value;
                    this.viper.Tools.openPopup('VSVP:popup', 800, 600);
                    this._textEditor.focus();
                    this._isVisible = true;
                }

                if (callback) {
                    callback.call(this);
                }
            }//end if

        },

        hideSourceView: function(newWindow)
        {
            if (this._inNewWindow === true && this._childWindow) {
                this._childWindow.close();
                this._inNewWindow = false;
                this._childWindow = false;
                ViperUtil.remove(this._sourceView);
                this._sourceView = null;
                this._editor     = null;
            } else if (this._sourceView) {
                if (!this._containerid) {
                    if (newWindow === true) {
                        this.viper.Tools.closePopup('VSVP:popup', 'discardChanges');
                    } else {
                        this.viper.Tools.closePopup('VSVP:popup');
                    }
                }

                if (this._toolbarButtonToggles === true) {
                    // Apply changes.
                    this._isVisible = false;
                    this.updatePageContents();
                    this.toolbarPlugin.enable();
                    this.viper.Tools.setButtonInactive('sourceEditor');
                }

                this.viper.fireCallbacks('ViperSourceViewPlugin:hideSourceView');
            }

        },

        toggleSourceView: function()
        {
            if (!this._sourceView
                || (!this._sourceView.parentNode || (this._sourceView.nodeType !== ViperUtil.DOCUMENT_FRAGMENT_NODE && !this._containerid))
                || ViperUtil.getElementWidth(this._sourceView) === 0
            ) {
                this.showSourceView();
            } else {
                this.hideSourceView();
            }

        },

        updatePageContents: function(content)
        {
            var value = content;
            if (!value) {
                value = this.getSourceContents();
            }

            if (this._originalSource === value) {
                return;
            }

            value = this._convertBase64KeywordsToBase64SRC(value);
            this._base64Images = {};

            this.viper.setHtml(value);
            this.viper.fireSelectionChanged(null, true);

        },

        getSourceContents: function()
        {
            var value = '';
            if (this._editor) {
                value = this._editor.getSession().getValue();
            } else if (this._textEditor) {
                value = this._textEditor.value;
            }

            return value;

        },

        updateSourceContents: function(content)
        {
            if (!this._editor || this._isVisible !== true) {
                return;
            }

            this._ignoreUpdate = true;
            var value = content || this.getContents();

            if (this._editor) {
                this._editor.getSession().setValue(value);
            } else if (this._textEditor) {
                this._textEditor.value = value;
            }

        },

        updateOriginalSourceValue: function(content)
        {
            if (!content) {
                if (this._editor) {
                    content = this._editor.getSession().getValue();
                } else if (this._textEditor) {
                    content = this._textEditor.value;
                }
            }

            this._originalSource = content;

        },

        revertChanges: function()
        {
            this.viper.setHtml(this._originalSource);

        },

        _createSourceView: function(callback)
        {
            if (this._containerid) {
                // Custom container provided.
                this._sourceView = ViperUtil.getid(this._containerid);
                this._initAceEditor(this._sourceView, callback);
                return;
            }

            var self  = this;
            var tools = this.viper.Tools

            var content      = document.createElement('div');

            // Confirm change panel.
            var popupTop = document.createElement('div');
            ViperUtil.addClass(popupTop, 'VSVP-confirmPanel');
            var discardButton = tools.createButton('VSVP:discard', _('Discard'), _('Discard Changes'), 'VSVP-confirmButton-discard', function() {
                self.viper.Tools.closePopup('VSVP:popup', 'discardChanges');
            });
            var applyButton   = tools.createButton('VSVP:apply', _('Apply Changes'), _('Apply Changes'), 'VSVP-confirmButton-apply', function() {
                self.updatePageContents();
                self.viper.Tools.closePopup('VSVP:popup', 'applyChanges');
            });
            ViperUtil.setHtml(popupTop, '<div class="VSVP-confirmText">' + _('Would you like to apply your changes?') + '</div>');
            popupTop.appendChild(applyButton);
            popupTop.appendChild(discardButton);
            this._closeConfirm = popupTop;

            var source = document.createElement('div');
            ViperUtil.addClass(source, 'VSVP-source');
            content.appendChild(source);
            this._sourceCont = source;

            // Add the bottom section.
            var popupBottom = document.createElement('div');
            ViperUtil.addClass(popupBottom, 'VSVP-bottomPanel');

            if (ViperUtil.isBrowser('msie', '<10') === false && (this.viper.getViperPath() || this.getViperURL())) {
                var newWindowButton = tools.createButton('VSVP:newWindow', '', _('Open In new window'), 'VSVP-bottomPanel-newWindow Viper-sourceNewWindow', function() {
                    self.openInNewWindow();
                });
                popupBottom.appendChild(newWindowButton);
            }

            var applyButtonBottom = tools.createButton('VSVP:apply', _('Apply Changes'), _('Apply Changes'), 'VSVP-bottomPanel-apply', function() {
                self.updatePageContents();
                self.viper.Tools.closePopup('VSVP:popup', 'applyChanges');
            });
            popupBottom.appendChild(applyButtonBottom);

            // Create the popup.
            this._sourceView = tools.createPopup(
                'VSVP:popup',
                _('Source Editor'),
                popupTop,
                content,
                popupBottom,
                'VSVP-popup',
                true,
                true,
                null,
                function(closer) {
                    // Close callback.
                    if (closer !== 'discardChanges' && closer !== 'applyChanges') {
                        // If there are changes prevent popup from closing.
                        if (self.isSourceChanged() === true) {
                            self.showCloseConfirm();
                            return false;
                        }
                    }

                    // Hide the Confirm message.
                    self.viper.Tools.getItem('VSVP:popup').hideTop();
                    self._closeEditor();
                },
                function() {
                    if (self._editor) {
                        // Resize callback.
                        self._editor.resize();
                    }
                }
            );

            if (ViperUtil.isBrowser('msie', '<9') === true) {
                this._includeStyleHTML(function() {
                    var editor = document.createElement('textarea');
                    self._textEditor = editor;
                    self._sourceCont.appendChild(editor);
                    callback.call(self);
                });
            } else {
                this._initAceEditor(source, callback);
            }

        },

        _closeEditor: function()
        {
            var self = this;
            this._removeScrollAttribute();
            this._isVisible = false;

            if (this.viper.isEnabled() !== false) {
                this.toolbarPlugin.enable();

                setTimeout(function() {
                    self.viper.focus();
                }, 10);
            }

        },

        _initAceEditor: function(containerElement, callback)
        {
            var self = this;
            this._includeAce(function() {
                // Setup the Ace editor.
                var editor   = ace.edit(containerElement);
                self._editor = editor;
                editor.$blockScrolling = Infinity;

                self.applyEditorSettings(editor);

                // Init editor events.
                self.initEditorEvents(editor);

                callback.call(self);
            });

        },

        applyEditorSettings: function(editor)
        {
            editor.setTheme(this._aceTheme);
            editor.getSession().setUseWorker(false);
            editor.getSession().setMode("ace/mode/html");

            // Use wrapping.
            editor.getSession().setUseWrapMode(true);

            // Do not show the print margin.
            editor.renderer.setShowPrintMargin(false);

            // Highlight the active line.
            editor.setHighlightActiveLine(true);

            // Show invisible characters
            editor.setShowInvisibles(true);
            editor.renderer.$textLayer.EOL_CHAR = String.fromCharCode(8629);

            // Set the selection style to be line (other option is 'text').
            editor.setSelectionStyle('line');

            // Always show the horizontal scrollbar.
            editor.renderer.setHScrollBarAlwaysVisible(true);

            // Use spaces instead of tabs.
            editor.getSession().setUseSoftTabs(true);

        },

        showCloseConfirm: function()
        {
            this.viper.Tools.getItem('VSVP:popup').showTop();

        },

        scrollToText: function(text)
        {
            var self = this;

            if (this._editor) {
                this._editor.find(text);
                setTimeout(function() {
                    var anchor = self._editor.getSelection().getSelectionAnchor();
                    self._editor.clearSelection();
                    if (self._editor.isRowVisible(anchor.row) === false) {
                        self._editor.scrollToRow(anchor.row);
                    }

                }, 500);
            } else {
                var range = this._textEditor.createTextRange();
                if (range.findText(text) === true) {
                    range.select();
                    range.scrollIntoView();
                }
            }
        },

        replaceSelection: function(replacement)
        {
            if (this._editor) {
                this._editor.replace(replacement);
            } else {
                var selection = document.selection;
                selection.clear();
            }

        },

        initEditorEvents: function(editor)
        {
            var self = this;
            editor.getSession().addEventListener("change", function() {
                if (self._ignoreUpdate === true) {
                    self._ignoreUpdate = false;
                    return;
                } else if (self._inNewWindow === true) {
                    self._ignoreSourceUpdate = true;
                    self.updatePageContents();
                }

                self.viper.fireCallbacks('ViperSourceViewPlugin:sourceChanged');
            });

            var popup = self.viper.Tools.getItem('VSVP:popup');

            // If the ESC key is pressed close the popup.
            editor.keyBinding.addKeyboardHandler({
                handleKeyboard: function(data, hashId, keyString, n, e) {
                    if (!e) {
                        return;
                    }

                    if (!self._containerid) {
                        if (keyString === 'esc') {
                            self.viper.Tools.closePopup('VSVP:popup');
                        } else if (e.metaKey !== true
                            && e.ctrlKey !== true
                            && e.which !== 16
                        ) {
                            popup.hideTop();
                        }
                    }
                }
            });

            var onFocus = editor.onFocus;
            editor.onFocus = function() {
                if (self._toolbarButtonToggles !== true) {
                    if (self._inNewWindow !== true) {
                        self.toolbarPlugin.disable();
                    }
                }

                if (self.viper.isEnabled() === false) {
                    // Viper might have been disabled, enable it again.
                    self.viper.setEnabled(true);
                }

                onFocus.call(editor);

                if (!self._containerid) {
                    setTimeout(function() {
                        popup.hideTop();
                    }, 200);
                }
            }

            editor.onBlur = function() {
                if (self._inNewWindow !== true && self.viper.isEnabled() === true) {
                    self.toolbarPlugin.enable();
                }
            };

        },

        _includeAce: function(callback)
        {
            if (window['ace']) {
                callback.call(this);
                return;
            }

            var path = this.viper.getViperPath();
            if (!path) {
                callback.call(this);
            } else {
                var scripts  = [];

                var acePath =  path + '/Plugins/ViperSourceViewPlugin/Ace';
                scripts.push(acePath + '/ace.js');
                scripts.push(acePath + '/theme-viper.js');
                scripts.push(acePath + '/mode-html.js');

                // Include JSBeautifier.
                scripts.push(path + '/Plugins/ViperSourceViewPlugin/jsbeautifier.js');

                this._includeScripts(scripts, callback);
            }

        },

        _includeStyleHTML: function(callback)
        {
            var path = this.viper.getViperPath();
            if (!path) {
                callback.call(this);
            } else {
                this._includeScripts([path + '/Plugins/ViperSourceViewPlugin/jsbeautifier.js'], callback);
            }

        },

        openInNewWindow: function()
        {
            // Hide current editor.
            this.hideSourceView(true);
            this.toolbarPlugin.enable();

            // Add this Viper plugin object to global var.
            var viperid = 'Viper-' + this.viper.getId() + '-ViperSVP';
            window[viperid] = this;

            var childWindow = window.open('about:blank', _('Viper Source View'), "width=850,height=800,0,status=0,scrollbars=0");
            this._isVisible = true;
            childWindow.document.write(this._getFrameContent(viperid));
            this._childWindow = childWindow;
            this._inNewWindow = true;

            // Detect if the window is closed and reset SourceView..
            var interval = null;
            var self     = this;
            interval = setInterval(function() {
                if (!childWindow || childWindow.closed === true) {
                    clearInterval(interval);
                    self.hideSourceView();
                }
            }, 700);

        },

        getNewWindowContents: function()
        {
            return this._newWindowContents;

        },

        _getFrameContent: function(viperid)
        {
            var path    = this.viper.getViperPath();
            var content = '';

            if (Viper.build === true) {
                path = null;
            }

            this._newWindowContents = this.getSourceContents();

            content += '<!DOCTYPE html><html lang="en"><head>';
            content += '<meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">';
            content += '<title>' + _('Viper Source View') + '</title>';
            content += '<style type="text/css" media="screen">body {overflow: hidden;}</style>';

            if (!path) {
                var viperPath = this.getViperURL();
                content += '<link href="' + viperPath + 'viper.css" media="screen" rel="stylesheet" />';

                if (this._jqueryURL !== null) {
                    content += '<script src="' + this._jqueryURL + '" type="text/javascript" charset="utf-8"></script>';
                }

                content += '<script src="' + viperPath + 'viper.js" type="text/javascript" charset="utf-8"></script>';
            } else {
                content += '<link href="' + path + '/Css/viper_tools.css" media="screen" rel="stylesheet" />';
                content += '<link href="' + path + '/Plugins/ViperSourceViewPlugin/ViperSourceViewPlugin.css" media="screen" rel="stylesheet" />';
                content += '<script src="' + path + '/Plugins/ViperSourceViewPlugin/Ace/ace.js" type="text/javascript" charset="utf-8"></script>';
                content += '<script src="' + path + '/Plugins/ViperSourceViewPlugin/Ace/theme-viper.js" type="text/javascript" charset="utf-8"></script>';
                content += '<script src="' + path + '/Plugins/ViperSourceViewPlugin/Ace/mode-html.js" type="text/javascript" charset="utf-8"></script>';
            }

            content += '</head>';
            content += '<body id="ViperSourceViewPlugin-window" class="ViperSourceViewPlugin-window">';
            content += '<div class="Viper-popup Viper-themeDark VSVP-popup">';
            content += '<div class="VSVP-confirmPanel Viper-popup-top">';
            content += '<div class="VSVP-confirmText">' + _('Source code changes will be reflected in your edit preview window in real time.') + '</div>';
            content += '<div class="Viper-button" title="' + _('Revert Changes') + '" onclick="viperSVP.revertChanges();">' + _('Revert Changes') + '</div>';
            content += '<div class="Viper-button" title="' + _('Close Source View') + '" onclick="window.close();">' + _('Close Window') + '</div></div>';
            content += '<div class="Viper-popup-content"><pre id="editor"></pre></div></div>';
            content += '<script>';
            content += 'var viperid = "' + viperid + '";';
            content += 'var viperSVP = window.opener[viperid];';
            content += 'var editor = ace.edit("editor");';
            content += 'viperSVP.applyEditorSettings(editor);';
            content += 'viperSVP.initEditorEvents(editor);';
            content += 'viperSVP._editor = editor;';
            content += 'viperSVP.updateSourceContents(viperSVP.getNewWindowContents());';
            content += 'var editorWrapper = document.getElementById("editor").parentNode;';
            content += 'window.onresize = function() {editorWrapper.style.height = (window.innerHeight - 55) + "px";};';
            content += 'window.onresize();';
            content += '</script></body></html>';

            return content;

        },

        getViperURL: function()
        {
            var scripts = document.getElementsByTagName('script');
            var path    = null;
            var c       = scripts.length;
            for (var i = 0; i < c; i++) {
                if (scripts[i].src) {
                    if (scripts[i].src.match(/\/viper\.js/)) {
                        return scripts[i].src.replace(/\/viper.js.*/, '/');
                    }
                }
            }

            return null;

        },

        getContents: function()
        {
            if (this._editor) {
                // If the Ace editor is enabled then try to scroll the editor to the current caret position. This is done
                // by adding a special attribute to first parent element.
                var range = this.viper.getViperRange();
                var node = range.getStartNode();
                if (node) {
                    if (node.nodeType === ViperUtil.TEXT_NODE) {
                        node = node.parentNode;
                    }

                    ViperUtil.attr(node, '__viper_scrollpos', 'true');
                }
            }

            var html = this.viper.getHtml(null, {emptyTableCellContent:''});
            if (window.StyleHTML) {
                html = StyleHTML(html);
            }

            return html;

        },

        isPluginElement: function(element)
        {
            if (element !== this._sourceView && ViperUtil.isChildOf(element, this._sourceView) === false) {
                return false;
            }

            return true;

        },

        _includeScripts: function(scripts, callback)
        {
            var self = this;
            var _includeScripts = function(scripts, callback) {
                if (scripts.length === 0) {
                    callback.call(this);
                    return;
                }

                var script = scripts.shift();
                self._includeScript(script, function() {
                    _includeScripts(scripts, callback);
                });
            };

            _includeScripts(scripts.concat([]), callback);

        },


        
        _includeScript: function(src, callback) {
            var script    = document.createElement('script');
            script.onload = function() {
                script.onload = null;
                script.onreadystatechange = null;
                callback.call(this);
            };

            script.onreadystatechange = function() {
                if (/^(complete|loaded)$/.test(this.readyState) === true) {
                    script.onreadystatechange = null;
                    script.onload();
                }
            }

            script.src = src;

            if (document.head) {
                document.head.appendChild(script);
            } else {
                document.getElementsByTagName('head')[0].appendChild(script);
            }
        },

        _removeScrollAttribute: function (elem) {
            // Remove Viper scroll attribute from content.
            elem      = elem || this.viper.getViperElement();
            var elems = ViperUtil.find(elem, '[__viper_scrollpos]');
            for (var i = 0; i < elems.length; i++) {
                ViperUtil.removeAttr(elems[i], '__viper_scrollpos');
            }

        },

        _convertBase64ImagesToKeywords: function (elem) {
            this._base64Images = {};
            var tags  = ViperUtil.find(elem, '[src^="data:image/"]');
            var count = 1;
            for (var i = 0; i < tags.length; i++) {
                var alt = tags[i].alt;
                if (alt) {
                    key = tags[i].alt + '.base64';
                } else {
                    key = 'base64_image_' + (i + 1);
                }


                this._base64Images[key] = tags[i].src;
                tags[i].src = key;
            }

        },

        _convertBase64KeywordsToBase64SRC: function(content) {
            for (var key in this._base64Images) {
                content = content.replace(new RegExp(key, 'g'), this._base64Images[key]);
            }

            return content;

        }

    };

})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperTableEditorPlugin(viper)
    {
        this.viper             = viper;
        this._tools            = viper.Tools;
        this._toolbarWidget    = null;
        this.toolbarPlugin     = null;
        this.activeCell        = null;
        this._highlightElement = null;
        this._cellTools        = null;

        this._buttonClicked = false;
        this._tableRawCells = null;
        this._currentType   = null;
        this._margin        = 15;
        this._headerOptions = [null, [1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 0, 0]];

        this._targetToolbarButton = false;

    }

    Viper.PluginManager.addPlugin('ViperTableEditorPlugin', ViperTableEditorPlugin);

    ViperTableEditorPlugin.prototype = {

        init: function()
        {
            var self = this;
            var clickedInToolbar = false;

            this.viper.registerCallback('Viper:editableElementChanged', 'ViperTableEditorPlugin', function() {
                self._initTable();

                if (ViperUtil.isBrowser('firefox') === true) {
                    // Disable Firefox table editing.
                    Viper.document.execCommand("enableInlineTableEditing", false, false);
                    Viper.document.execCommand("enableObjectResizing", false, false);
                }

                var vap = self.viper.PluginManager.getPlugin('ViperAccessibilityPlugin');
                if (vap) {
                    vap.loadHTMLCS(function() {
                        var tables = ViperUtil.getTag('table', self.viper.getViperElement());
                        for (var i = 0; i < tables.length; i++) {
                            self.setTableHeaders(tables[i]);
                        }
                    });
                }
            });

            this.viper.registerCallback('ViperCopyPastePlugin:paste', 'ViperTableEditorPlugin', function() {
                var vap = self.viper.PluginManager.getPlugin('ViperAccessibilityPlugin');
                if (vap) {
                    vap.loadHTMLCS(function() {
                        var tables = ViperUtil.getTag('table', self.viper.getViperElement());
                        for (var i = 0; i < tables.length; i++) {
                            self.setTableHeaders(tables[i]);
                        }
                    });
                }
            });

            this.viper.registerCallback('Viper:setHtml', 'ViperTableEditorPlugin', function(data, callback) {
                var vap = self.viper.PluginManager.getPlugin('ViperAccessibilityPlugin');
                if (vap) {
                    vap.loadHTMLCS(function() {
                        var tables = ViperUtil.getTag('table', data.element);
                        for (var i = 0; i < tables.length; i++) {
                            self.setTableHeaders(tables[i]);
                            self._initTable(tables[i]);
                        }

                        callback.call(this);
                    });
                } else {
                    var tables = ViperUtil.getTag('table', data.element);
                    for (var i = 0; i < tables.length; i++) {
                        self._initTable(tables[i]);
                    }

                    callback.call(this);
                }

                return function() {};
            });

            this.viper.registerCallback('Viper:enabled', 'ViperTableEditorPlugin', function() {
                var tables = ViperUtil.getTag('table', self.viper.getViperElement());
                for (var i = 0; i < tables.length; i++) {
                    self._initTable(tables[i]);
                }
            });

            // Hide the toolbar when user clicks anywhere.
            this.viper.registerCallback(['Viper:mouseDown', 'ViperHistoryManager:undo'], 'ViperTableEditorPlugin', function(data) {
                if (ViperUtil.isBrowser('firefox') === true) {
                    // Disable Firefox table editing.
                    Viper.document.execCommand("enableInlineTableEditing", false, false);
                    Viper.document.execCommand("enableObjectResizing", false, false);
                }

                if (data && data.target) {
                    var cell = self._getCellElement(data.target);
                    if (cell) {
                        var range = self.viper.getViperRange();
                        if (range.collapsed !== true) {
                            // Collapse the range incase the mouse is being clicked on a selection.
                            range.collapse(true);
                            ViperSelection.addRange(range);
                        }
                    }
                }

                self.setActiveCell(null);
                clickedInToolbar = false;
                if (data && data.target) {
                    var target = ViperUtil.getMouseEventTarget(data);
                    if (target === self._toolbar || ViperUtil.isChildOf(target, self._toolbar) === true) {
                        clickedInToolbar = true;
                        if (ViperUtil.isTag(target, 'input') === true
                            || ViperUtil.isTag(target, 'textarea') === true
                        ) {
                            // Allow event to bubble so the input element can get focus etc.
                            return true;
                        }

                        return false;
                    } else if (ViperUtil.isTag(target, 'caption') === true && ViperUtil.getNodeTextContent(target) === '') {
                        target.innerHTML = '&nbsp;';
                    }
                }

                self.hideToolbar();
            });

            ViperUtil.addEvent(window, 'resize', function() {
                self.hideCellToolsIcon();
                self.removeHighlights();

                var cell = self.getActiveCell();
                if (cell && self._toolbarWidget.isVisible() === true) {
                    self._updatePosition(cell);
                    self.highlightActiveCell(self._currentType);
                }
            });

            this.viper.registerCallback('Viper:keyUp', 'ViperTableEditorPlugin', function(e) {
                var range = self.viper.getViperRange();
                try {
                    if (range.collapsed === true
                        && ViperUtil.isBrowser('msie', '<9') === true
                        && range.startContainer.nodeType === ViperUtil.TEXT_NODE
                        && ViperUtil.inArray(ViperUtil.getTagName(range.startContainer.parentNode), ['td', 'th']) === true
                    ) {
                        var ohtml = ViperUtil.getHtml(range.startContainer.parentNode);
                        var nhtml = ohtml.replace(/^&nbsp;/g, '');
                        nhtml     = nhtml.replace(/&nbsp;$/g, '');

                        if (nhtml !== ohtml && nhtml !== '') {
                            ViperUtil.setHtml(range.startContainer.parentNode, nhtml);
                        }
                    }
                } catch (e) {}
            });

            this.viper.registerCallback('Viper:keyDown', 'ViperTableEditorPlugin', function(e) {
                if (e.which === 9) {
                    // Handle tab key.
                    self.removeHighlights();

                    if (e.shiftKey === true && self.activeCell) {
                        self.moveCaretToPreviousCell();
                    } else {
                        if (self.activeCell && self.moveCaretToNextCell() === false) {
                            // Create a new row.
                            self.insertRowAfter(self.activeCell);
                            self.moveCaretToNextCell();
                        }
                    }

                    ViperUtil.preventDefault(e);
                    return false;
                } else if (e.which === 39 || e.which === 40) {
                    // Right and down arrow.
                    // If the range is at the end of a table (last cell) then move the
                    // caret outside even if there is no next sibling.
                    var range = self.viper.getCurrentRange();
                    if (range.collapsed === true) {
                        var startNode = range.getStartNode();
                        if (startNode && (ViperUtil.isTag(startNode, 'br') === true || (startNode.nodeType === ViperUtil.TEXT_NODE && range.endOffset === startNode.data.length))) {
                            var cell           = self.getActiveCell();
                            var lastSelectable = range._getLastSelectableChild(cell);
                            if (startNode === lastSelectable || (!lastSelectable && ViperUtil.isTag(startNode, 'br') === true)) {
                                if (cell && !self.getNextRow(cell.parentNode)) {
                                    // End of table.
                                    var table = self.getCellTable(cell);
                                    if (!table.nextElementSibling) {
                                        var caretNode = null;
                                        if (self.viper.getDefaultBlockTag()) {
                                            caretNode = document.createElement(self.viper.getDefaultBlockTag());
                                            ViperUtil.setHtml(caretNode, '<br/>');
                                            ViperUtil.insertAfter(table, caretNode);
                                            range.setStart(caretNode.firstChild, 0);
                                        } else {
                                            caretNode = document.createTextNode(' ');
                                            ViperUtil.insertAfter(table, caretNode);
                                            range.setStart(caretNode, 0);
                                        }

                                        range.collapse(true);
                                        ViperSelection.addRange(range);
                                    } else {
                                        self.viper.moveCaretAway(table, false);
                                    }
                                }
                            }
                        }
                    }
                } else if (ViperUtil.isInputKey(e) === true && e.which !== 13) {
                    // Not input key or enter key, hide tools.
                    self.hideCellToolsIcon();
                    self.removeHighlights();
                    self.hideToolbar();
                }//end if
            });

            this.viper.registerCallback(['Viper:clickedOutside', 'Viper:disabled'], 'ViperTableEditorPlugin', function(data) {
                self.hideCellToolsIcon();
                self.removeHighlights();
            });

            this.viper.registerCallback('ViperFormatPlugin:elementAttributeSet', 'ViperTableEditorPlugin', function(data) {
                if (data.element && ViperUtil.isTag(data.element, 'th') === true) {
                    var table      = self.getCellTable(data.element);
                    var headerAttr = ViperUtil.find(table, '[headers~="' + data.oldValue + '"]');
                    for (var i = 0; i < headerAttr.length; i++) {
                        var attr = ' ' + headerAttr[i].getAttribute('headers');
                        attr     = attr.replace(' ' + data.oldValue, (data.element.getAttribute('id') || ''));
                        headerAttr[i].setAttribute('headers', ViperUtil.trim(attr));
                    }

                    self.setTableHeaders(table);
                } else if (data.element && ViperUtil.isTag(data.element, 'table') === true) {
                    self.setTableHeaders(data.element);
                }
            });

            this.toolbarPlugin = this.viper.PluginManager.getPlugin('ViperToolbarPlugin');
            if (this.toolbarPlugin) {
                var insertTable = true;

                this.viper.registerCallback('ViperToolbarPlugin:positionUpdated', 'ViperTableEditorPlugin', function(data) {
                    if (self._targetToolbarButton === true) {
                        var activeCell = self.getActiveCell();
                        if (activeCell) {
                            self.showCellToolsIcon(activeCell, true);
                        }
                    }
                });

                this.viper.registerCallback('ViperToolbarPlugin:enabled', 'ViperTableEditorPlugin', function(data) {
                    self.viper.Tools.enableButton('insertTable');
                });

                var button = this.viper.Tools.createButton('insertTable', '', _('Insert Table'), 'Viper-table', function() {
                    var range = self.viper.getViperRange();
                    var node  = range.getStartNode();
                    if (!node) {
                        node = range.getEndNode();
                        if (!node) {
                            if (range.startContainer !== range.endContainer) {
                                return;
                            } else {
                                node = range.startContainer;
                            }
                        }
                    }

                    insertTable = true;

                    // Do not allow table insertion inside another table.
                    var parents = ViperUtil.getParents(node, 'table', self.viper.getViperElement());
                    if (parents.length > 0) {
                        insertTable = false;
                        // Show cell tools.
                        var cell = self._getCellElement(node);
                        if (cell) {
                            if (self._cellTools && ViperUtil.hasClass(self._cellTools, 'Viper-topBar') === true) {
                                self.hideCellToolsIcon();
                            } else if (ViperUtil.isBrowser('msie') === true) {
                                // This must be in a timeout to be able to calculate the bubbles position correctly.
                                setTimeout(function() {
                                    self.showCellToolsIcon(cell, true);
                                }, 10);
                            } else {
                                self.showCellToolsIcon(cell, true);
                            }
                        }
                    } else {
                        if (ViperUtil.isBrowser('msie') === true) {
                            // This must be in a timeout to be able to calculate the bubbles position correctly.
                            setTimeout(function() {
                                self.toolbarPlugin.toggleBubble('VTEP-bubble');
                            }, 10);
                        } else {
                            self.toolbarPlugin.toggleBubble('VTEP-bubble');
                        }
                    }
                }, true);
                this.toolbarPlugin.addButton(button);

                // Create the toolbar bubble.
                this._createToolbarEditorBubble();
            }

            if (this._isiPad() === false) {
                var showToolbar = false;
                this.viper.registerCallback('Viper:mouseUp', 'ViperTableEditorPlugin', function(e) {
                    var range = self.viper.getCurrentRange();
                    var target = ViperUtil.getMouseEventTarget(e);

                    if (!target) {
                        return;
                    }

                    if (target === self._toolbar || ViperUtil.isChildOf(target, self._toolbar) === true) {
                        self._buttonClicked = false;
                        return false;
                    }

                    if (range.collapsed === false
                        || ViperUtil.isTag(target, 'a') === true
                        || ViperUtil.isTag(target, 'img') === true
                    ) {
                        self.removeHighlights();
                        self.hideCellToolsIcon();
                        return true;
                    }

                    if (self.viper.isOutOfBounds(target) === true) {
                        return;
                    }

                    var cell = self._getCellElement(target);
                    if (cell) {
                        self._initTable(self.getCellTable(cell));

                        self.hideCellToolsIcon();
                        self.removeHighlights();

                        // Show cell Tools.
                        if (ViperUtil.isBrowser('msie') === true) {
                            setTimeout(function() {
                                showToolbar = true;
                                self.showCellToolsIcon(cell);
                            }, 10);
                        } else {
                            showToolbar = true;
                            self.showCellToolsIcon(cell);
                        }

                        return;
                    }

                    self.hideCellToolsIcon();
                    self.removeHighlights();

                    return true;
                });

                this.viper.registerCallback('Viper:selectionChanged', 'ViperTableEditorPlugin', function(range) {
                    var node = range.getStartNode();
                    if (!node) {
                        node = range.getEndNode();
                        if (!node) {
                            if (range.startContainer && ViperUtil.isStubElement(range.startContainer) === true) {
                                node = range.startContainer;
                            } else {
                                return;
                            }
                        }
                    }

                    if (self.viper.isOutOfBounds(node) === true) {
                        return;
                    }

                    if (self.toolbarPlugin.isDisabled() === true) {
                        self._tools.setButtonInactive('insertTable');
                    } else {
                        // Do not allow table insertion inside another table.
                        var parents = ViperUtil.getParents(node, 'table');
                        if (parents.length > 0 && self._tools) {
                            // Set the table icon as active.
                            if (self.toolbarPlugin.isDisabled() === false) {
                                self._tools.setButtonActive('insertTable');
                            }
                        } else {
                            if (ViperUtil.getParents(node, 'li', self.viper.getViperElement()).length > 0) {
                                self._tools.disableButton('insertTable');
                            } else {
                                var nodeSelection = range.getNodeSelection();
                                if (!nodeSelection || ViperUtil.isStubElement(nodeSelection) === false) {
                                    self._tools.enableButton('insertTable');
                                    self._tools.setButtonInactive('insertTable');
                                } else {
                                    self._tools.disableButton('insertTable');
                                    self._tools.setButtonInactive('insertTable');
                                }
                            }
                        }
                    }

                    if (range.collapsed === false) {
                        return;
                    }

                    if (clickedInToolbar === true || self.viper.rangeInViperBounds(range) === false) {
                        clickedInToolbar = false;
                        return;
                    }

                    if (showToolbar === false) {
                        self.hideCellToolsIcon();
                        self.hideToolbar();
                    } else {
                        showToolbar = false;
                    }
                });
            } else {
                // For iPad.
                this.viper.registerCallback('Viper:selectionChanged', 'ViperTableEditorPlugin', function(range) {
                    var startNode = range.getStartNode();
                    var cell      = self._getCellElement(startNode);
                    if (cell) {
                        self.hideCellToolsIcon();
                        self.removeHighlights();

                        showToolbar = true;
                        // Show cell Tools.
                        return self.showCellToolsIcon(cell);
                    }

                    self.hideCellToolsIcon();
                    return true;
                });
            }//end if

            if (this._isiPad() === true) {
                // During zooming hide the toolbar.
                ViperUtil.addEvent(window, 'gesturestart', function() {
                    self.hideToolbar();
                });

                this.viper.registerCallback('Viper:elementScaled', 'ViperTableEditorPlugin', function(data) {
                    if (data.element !== self._toolbar) {
                        return false;
                    }

                    if (data.scale === 1) {
                        self._margin = 15;
                    } else {
                        self._margin = (15 - (((1 - data.scale) / 0.1) * 5));
                    }

                    self.updateToolbar(self.getActiveCell(), self._currentType);
                });
            }//end if

            this._initToolbar();

        },

        _initTable: function(table)
        {
            var cells = [];
            if (!table) {
                cells = ViperUtil.getTag('td, th', this.viper.getViperElement());
            } else {
                cells = ViperUtil.getTag('td,th', table);
            }

            var c = cells.length;
            for (var i = 0; i < c; i++) {
                var html = ViperUtil.trim(ViperUtil.getHtml(cells[i]));
                if (html === '' || html === '&nbsp;') {
                    this._initCell(cells[i]);
                }
            }

        },


        
        showCellToolsIcon: function(cell, inTopBar)
        {
            if (!cell) {
                return;
            }

            this.hideToolbar();

            var toolsid = this.viper.getId() + '-ViperTEP';
            var tools   = ViperUtil.getid(toolsid);

            if (tools) {
                ViperUtil.remove(tools);
            }

            this.setActiveCell(cell);

            var self      = this;
            var showTools = function(type) {
                ViperUtil.remove(tools);
                var range = self.viper.getCurrentRange();
                range.collapse(true);
                ViperSelection.addRange(range);
                self.showTableTools(cell, type);
            };

            tools    = document.createElement('div');
            tools.id = toolsid;
            ViperUtil.addClass(tools, 'ViperITP Viper-themeDark Viper-compact Viper-visible');
            this._cellTools = tools;

            // Table, row, col and cell buttons. Initially only the table icon is visible
            // Whent he mouse is moved over the table icon, rest of the buttons become
            // visible where user can pick the tools they want to use.
            var buttonGroup = this.viper.Tools.createButtonGroup('VTEP:cellTools:buttons', 'ViperITP-tools');
            var tableBtn    = this._tools.createButton('VTEP:cellTools:table', '', _('Show Table tools'), 'Viper-table', function() {
                showTools('table');
            });
            var rowBtn = this._tools.createButton('VTEP:cellTools:row', '', _('Show Row tools'), 'Viper-tableRow Viper-hidden', function() {
                showTools('row');
            });
            var colBtn = this._tools.createButton('VTEP:cellTools:col', '', _('Show Column tools'), 'Viper-tableCol Viper-hidden', function() {
                showTools('col');
            });
            var cellBtn = this._tools.createButton('VTEP:cellTools:cell', '', _('Show Cell tools'), 'Viper-tableCell Viper-hidden', function() {
                showTools('cell');
            });
            this._tools.addButtonToGroup('VTEP:cellTools:table', 'VTEP:cellTools:buttons');
            this._tools.addButtonToGroup('VTEP:cellTools:row', 'VTEP:cellTools:buttons');
            this._tools.addButtonToGroup('VTEP:cellTools:col', 'VTEP:cellTools:buttons');
            this._tools.addButtonToGroup('VTEP:cellTools:cell', 'VTEP:cellTools:buttons');

            var btns = [rowBtn, colBtn, cellBtn];

            tools.appendChild(buttonGroup);

            var cellCoords = null;
            var toolsWidth = 42;

            if (inTopBar !== true) {
                this._targetToolbarButton = false;
                cellCoords = ViperUtil.getBoundingRectangle(cell);
            } else {
                var scrollCoords = ViperUtil.getScrollCoords();

                this._targetToolbarButton = true;
                ViperUtil.removeClass(btns, 'Viper-hidden');
                ViperUtil.setStyle(tools, 'margin-left', '-45px');
                cellCoords     = ViperUtil.getBoundingRectangle(this._tools.getItem('insertTable').element);

                if (ViperUtil.getStyle(this._tools.getItem('insertTable').element.parentNode, 'position') === 'fixed') {
                    cellCoords.y2 += (5 - scrollCoords.y);
                    ViperUtil.setStyle(tools, 'position', 'fixed');
                } else {
                    ViperUtil.setStyle(tools, 'position', 'absolute');
                }

                ViperUtil.addClass(tools, 'Viper-topBar');

                var offset = ViperUtil.getDocumentOffset();
                var left   = (Math.ceil(cellCoords.x1 + ((cellCoords.x2 - cellCoords.x1) / 2) - (toolsWidth / 2)) + 1 + offset.x);
                var top    = (cellCoords.y2 + 5 + offset.y);

                ViperUtil.setStyle(tools, 'top', top + 'px');
                ViperUtil.setStyle(tools, 'left', left + 'px');
            }

            if (this._isiPad() === false) {
                // On Hover of the buttons highlight the table/row/col/cell.
                ViperUtil.hover(tableBtn, function() {
                    self.setActiveCell(cell);
                    self.highlightActiveCell('table');
                }, function() {
                    self.removeHighlights();
                });
                ViperUtil.hover(rowBtn, function() {
                    self.setActiveCell(cell);
                    self.highlightActiveCell('row');
                }, function() {
                    self.removeHighlights();
                });
                ViperUtil.hover(colBtn, function() {
                    self.setActiveCell(cell);
                    self.highlightActiveCell('col');
                }, function() {
                    self.removeHighlights();
                });
                ViperUtil.hover(cellBtn, function() {
                    self.setActiveCell(cell);
                    self.highlightActiveCell('cell');
                }, function() {
                    self.removeHighlights();
                });

                if (this._targetToolbarButton !== true) {
                    // On hover show the list of available table properties buttons.
                    ViperUtil.hover(tools, function() {
                        self.setActiveCell(cell);
                        self.highlightActiveCell();
                        ViperUtil.removeClass(btns, 'Viper-hidden');
                        ViperUtil.setStyle(tools, 'margin-left', '-45px');
                    }, function() {
                        self.removeHighlights();
                        ViperUtil.addClass(btns, 'Viper-hidden');
                        ViperUtil.setStyle(tools, 'margin-left', '0');
                    });
                }
            } else {
                // On iPad just show the tools.
                ViperUtil.addEvent(tools, 'click', function() {
                    showTools('cell');
                });
            }//end if

            this.viper.addElement(tools);

            if (inTopBar !== true) {
                this.viper.Tools.updatePositionOfElement(tools, null, cell);
                ViperUtil.setStyle(tools, 'width', 'auto');
            }

        },

        hideCellToolsIcon: function()
        {
            if (!this._cellTools) {
                return;
            }

            var toolsid = this.viper.getId() + '-ViperTEP';
            var tools   = ViperUtil.getid(toolsid);

            if (tools) {
                ViperUtil.remove(tools);
            }

            this._cellTools = null;

        },

        showTableTools: function(cell, type)
        {
            if (!cell) {
                return;
            }

            this.updateToolbar(cell, type);

        },

        _initToolbar: function()
        {
            var tools       = this.viper.Tools;
            var toolbarid   = 'ViperTableEditor-toolbar';
            var self        = this;
            var toolbarElem = tools.createInlineToolbar(toolbarid);
            var toolbar     = tools.getItem(toolbarid);

            this._toolbarWidget = toolbar;

            // Add lineage container to the toolbar.
            var lineage = document.createElement('ul');
            ViperUtil.addClass(lineage, 'ViperITP-lineage');
            ViperUtil.insertBefore(toolbarElem.firstChild, lineage);
            this._lineage = lineage;

            // Add the table buttons.
            this._createCellProperties();
            this.viper.fireCallbacks('ViperTableEditorPlugin:initToolbar', {toolbar: toolbar, type: 'cell'});

            this._createColProperties();
            this.viper.fireCallbacks('ViperTableEditorPlugin:initToolbar', {toolbar: toolbar, type: 'col'});

            this._createRowProperties();
            this.viper.fireCallbacks('ViperTableEditorPlugin:initToolbar', {toolbar: toolbar, type: 'row'});

            this._createTableProperties();
            this.viper.fireCallbacks('ViperTableEditorPlugin:initToolbar', {toolbar: toolbar, type: 'table'});

        },

        hideToolbar: function()
        {
            this._toolbarWidget.hide();

        },

        getCurrentViewType: function()
        {
            return this._type;

        },

        
        updateToolbar: function(cell, type, activeSubSection)
        {
            this._activeSection = null;
            this._tableRawCells = null;
            this.setActiveCell(cell);

            this.removeHighlights();
            this.hideToolbar();

            this._currentType = type;

            ViperUtil.removeClass(this._toolbar, 'Viper-subSectionVisible');

            // Set highlight to active cell.
            this.highlightActiveCell();

            this._toolbarWidget.resetButtons();
            this._updateLineage(type);
            this._updateInnerContainer(cell, type, activeSubSection);
            this._updatePosition(cell, type);
            this.highlightActiveCell(type);
            this._toolbarWidget._updateSubSectionArrowPos();

            this._toolbarWidget.focusSubSection();
            this.viper.removeHighlights();

        },

        _updateInnerContainer: function(cell, type, activeSubSection)
        {
            switch (type) {
                case 'cell':
                default:
                    this._showCellProperties(cell, activeSubSection);
                break;

                case 'col':
                    this._showColProperties(cell);
                break;

                case 'row':
                    this._showRowProperties(cell);
                break;

                case 'table':
                    this._showTableProperties(cell);
                break;
            }

            var callbackData = {
                toolbar: this,
                cell: cell,
                type: type,
                toolbar: this._toolbarWidget
            };
            this.viper.fireCallbacks('ViperTableEditorPlugin:updateToolbar', callbackData);

        },

        _showCellProperties: function(cell, activeSubSection)
        {
            this._toolbarWidget.showButton('VTEP:cellProps:mergeSplitSubSectionToggle');
            this._toolbarWidget.showButton('VTEP:cellProps:settings');

            this._tools.getItem('VTEP:cellProps:heading').setValue(ViperUtil.isTag(cell, 'th'));

            if (this.getRowspan(cell) <= 1) {
                this._tools.disableButton('VTEP:cellProps:splitHoriz');
            } else {
                this._tools.enableButton('VTEP:cellProps:splitHoriz');
            }

            if (this.getColspan(cell) <= 1) {
                this._tools.disableButton('VTEP:cellProps:splitVert');
            } else {
                this._tools.enableButton('VTEP:cellProps:splitVert');
            }

            if (this.canMergeUp(cell) !== false) {
                this._tools.enableButton('VTEP:cellProps:mergeUp');
            } else {
                this._tools.disableButton('VTEP:cellProps:mergeUp');
            }

            if (this.canMergeDown(cell) !== false) {
                this._tools.enableButton('VTEP:cellProps:mergeDown');
            } else {
                this._tools.disableButton('VTEP:cellProps:mergeDown');
            }

            if (this.canMergeRight(cell) !== false) {
                this._tools.enableButton('VTEP:cellProps:mergeRight');
            } else {
                this._tools.disableButton('VTEP:cellProps:mergeRight');
            }

            if (this.canMergeLeft(cell) !== false) {
                this._tools.enableButton('VTEP:cellProps:mergeLeft');
            } else {
                this._tools.disableButton('VTEP:cellProps:mergeLeft');
            }

            if (activeSubSection === 'merge') {
                this._toolbarWidget.toggleSubSection('VTEP:cellProps:mergeSplitSubSection');
            } else {
                this._toolbarWidget.toggleSubSection('VTEP:cellProps:settingsSubSection');
            }

        },

        _showColProperties: function(cell)
        {
            this._toolbarWidget.showButton('VTEP:colProps:settings');
            this._toolbarWidget.showButton('VTEP:colProps:insBefore');
            this._toolbarWidget.showButton('VTEP:colProps:insAfter');
            this._toolbarWidget.showButton('VTEP:colProps:moveLeft');
            this._toolbarWidget.showButton('VTEP:colProps:moveRight');
            this._toolbarWidget.showButton('VTEP:colProps:remove');

            var colWidth = this.getColumnWidth(cell);
            this._tools.getItem('VTEP:colProps:width').setValue(colWidth);

            /// Heading.
            var wholeColHeading = true;
            var cells   = this._getCellsExpanded();
            var cellPos = this.getCellPosition(cell);

            for (var i = 0; i < cells.length; i++) {
                var colCell    = cells[i][cellPos.col];
                var colCellPos = this.getCellPosition(colCell);
                if (colCellPos.col === cellPos.col) {
                    if (ViperUtil.isTag(colCell, 'td') === true) {
                        wholeColHeading = false;
                        break;
                    }
                }
            }

            this._tools.getItem('VTEP:colProps:heading').setValue(wholeColHeading, true);

            // Enable/disable move col icons.
            if (this.canMoveColLeft(cell) === true) {
                this._tools.enableButton('VTEP:colProps:moveLeft');
            } else {
                this._tools.disableButton('VTEP:colProps:moveLeft');
            }

            // Enable/disable move col icons.
            if (this.canMoveColRight(cell) === true) {
                this._tools.enableButton('VTEP:colProps:moveRight');
            } else {
                this._tools.disableButton('VTEP:colProps:moveRight');
            }

            this._toolbarWidget.toggleSubSection('VTEP:colProps:settingsSubSection');

        },

        _showRowProperties: function(cell)
        {
            this._toolbarWidget.showButton('VTEP:rowProps:settings');
            this._toolbarWidget.showButton('VTEP:rowProps:insBefore');
            this._toolbarWidget.showButton('VTEP:rowProps:insAfter');
            this._toolbarWidget.showButton('VTEP:rowProps:moveUp');
            this._toolbarWidget.showButton('VTEP:rowProps:moveDown');
            this._toolbarWidget.showButton('VTEP:rowProps:remove');

            this._tools.getItem('VTEP:rowProps:heading').setValue(ViperUtil.getTag('td', cell.parentNode).length === 0);

            if (this.canMoveRowUp(cell) === false) {
                this._tools.disableButton('VTEP:rowProps:moveUp');
            } else {
                this._tools.enableButton('VTEP:rowProps:moveUp');
            }

            if (this.canMoveRowDown(cell) === false) {
                this._tools.disableButton('VTEP:rowProps:moveDown');
            } else {
                this._tools.enableButton('VTEP:rowProps:moveDown');
            }

            this._toolbarWidget.toggleSubSection('VTEP:rowProps:settingsSubSection');

        },

        _showTableProperties: function(cell)
        {
            var table = this.getCellTable(cell);
            this._toolbarWidget.showButton('VTEP:tableProps:settings');
            this._toolbarWidget.showButton('VTEP:tableProps:remove');

            var tableWidth = this.getTableWidth(table);
            this._tools.getItem('VTEP:tableProps:width').setValue(tableWidth);

            var summary = this.viper.getAttribute(table, 'summary') || '';
            this._tools.getItem('VTEP:tableProps:summary').setValue(summary);

            this._tools.getItem('VTEP:tableProps:caption').setValue((ViperUtil.getTag('caption', table).length > 0));

            this._toolbarWidget.toggleSubSection('VTEP:tableProps:settingsSubSection');

        },

        tableUpdated: function(table)
        {
            this._tableRawCells = null;
            table = table || this.getCellTable(this.activeCell);

            this.setTableHeaders(table);
            this.viper.contentChanged(true);

        },

        _isiPad: function()
        {
            if (navigator.userAgent.match(/iPad/i) !== null) {
                return true;
            }

            return false;

        },

        
        _updatePosition: function(cell, verticalOnly)
        {
            var self    = this;
            var toolbar = this._toolbarWidget.element;
            this.viper.Tools.updatePositionOfElement(toolbar, null, cell, function() {
                self.hideToolbar();
            });

        },

        _updateLineage: function(type)
        {
            var self = this;

            ViperUtil.empty(this._lineage);

            ViperUtil.removeClass(ViperUtil.getClass('Viper-selected', this._lineage), 'Viper-selected');

            // Table.
            var table = document.createElement('li');
            ViperUtil.addClass(table, 'ViperITP-lineageItem');
            ViperUtil.setHtml(table, _('Table'));
            this._lineage.appendChild(table);
            ViperUtil.addEvent(table, 'mousedown', function(e) {
                self._buttonClicked = true;
                self.updateToolbar(self.getActiveCell(), 'table');
                ViperUtil.preventDefault(e);
                return false;
            });

            if (type === 'table') {
                ViperUtil.addClass(table, 'Viper-selected');
            }

            // Row.
            var row = document.createElement('li');
            ViperUtil.addClass(row, 'ViperITP-lineageItem');
            ViperUtil.setHtml(row, _('Row'));
            this._lineage.appendChild(row);
            ViperUtil.addEvent(row, 'mousedown', function(e) {
                ViperUtil.removeClass(ViperUtil.getClass('Viper-selected', self._lineage), 'Viper-selected');
                ViperUtil.addClass(row, 'Viper-selected');
                self._buttonClicked = true;
                self.updateToolbar(self.getActiveCell(), 'row');
                ViperUtil.preventDefault(e);
                return false;
            });

            if (type === 'row') {
                ViperUtil.addClass(row, 'Viper-selected');
            }

            // Col.
            var col = document.createElement('li');
            ViperUtil.addClass(col, 'ViperITP-lineageItem');
            ViperUtil.setHtml(col, _('Column'));
            this._lineage.appendChild(col);
            ViperUtil.addEvent(col, 'mousedown', function(e) {
                self._buttonClicked = true;
                self.updateToolbar(self.getActiveCell(), 'col');
                ViperUtil.preventDefault(e);
                return false;
            });

            if (type === 'col') {
                ViperUtil.addClass(col, 'Viper-selected');
            }

            // Cell.
            var cell = document.createElement('li');
            ViperUtil.addClass(cell, 'ViperITP-lineageItem');
            ViperUtil.setHtml(cell, _('Cell'));
            this._lineage.appendChild(cell);
            ViperUtil.addEvent(cell, 'mousedown', function(e) {
                self._buttonClicked = true;
                self.updateToolbar(self.getActiveCell(), 'cell');
                ViperUtil.preventDefault(e);
                return false;
            });
            if (!type || type === 'cell') {
                ViperUtil.addClass(cell, 'Viper-selected');
            }

            setTimeout(function() {
                // Add the hover events after a few ms of showing the toolbar so that
                // if the pointer is on top of the lineage item it does not change the
                // highlighted cell.
                ViperUtil.hover(table, function() {
                    self.highlightActiveCell('table');
                }, function() {
                    self.removeHighlights();
                    self.highlightActiveCell(self._currentType);
                });

                ViperUtil.hover(row, function() {
                    self.highlightActiveCell('row');
                }, function() {
                    self.removeHighlights();
                    self.highlightActiveCell(self._currentType);
                });

                ViperUtil.hover(col, function() {
                    self.highlightActiveCell('col');
                }, function() {
                    self.removeHighlights();
                    self.highlightActiveCell(self._currentType);
                });

                ViperUtil.hover(cell, function() {
                    self.highlightActiveCell('cell');
                }, function() {
                    self.removeHighlights();
                    self.highlightActiveCell(self._currentType);
                });
            }, 100);

        },

        removeHighlights: function()
        {
            ViperUtil.remove(this._highlightElement);

        },


        highlightActiveCell: function(parentType)
        {
            parentType     = parentType || 'cell';
            var activeCell = this.getActiveCell();
            var element    = null;
            var coords     = null;

            if (!activeCell) {
                return;
            }

            switch (parentType) {
                case 'cell':
                default:
                    element = activeCell;
                break;

                case 'table':
                    var table = this.getCellTable(activeCell);
                    var tfoot = ViperUtil.getTag('tfoot', table);
                    coords    = ViperUtil.getBoundingRectangle(table);

                    if (ViperUtil.isBrowser('firefox') === true) {
                        // Caption height fix..
                        var caption = ViperUtil.getTag('caption', table);
                        if (caption.length > 0) {
                            caption    = caption[0];
                            coords.y2 += ViperUtil.getElementHeight(caption);
                        }
                    }
                break;

                case 'row':
                    if (this.getRowspan(activeCell) > 1) {
                        coords         = ViperUtil.getBoundingRectangle(activeCell.parentNode);
                        var cellCoords = ViperUtil.getBoundingRectangle(activeCell);
                        coords.y2      = cellCoords.y2;
                    } else {
                        element = activeCell.parentNode;
                    }
                break;

                case 'col':
                    // Column is a bit harder to calculate.
                    // Get the tables rectangle.
                    var table   = this.getCellTable(activeCell);
                    var caption = ViperUtil.getTag('caption', table);
                    coords      = ViperUtil.getBoundingRectangle(table);

                    if (caption.length > 0) {
                        var captionHeight = ViperUtil.getElementHeight(caption[0]);
                        coords.y1        += captionHeight;

                        if (ViperUtil.isBrowser('firefox') === true) {
                            // Firefox caption height fix.
                            coords.y2 += captionHeight;
                        }
                    }

                    // Get the width and height of the cell.
                    var cellRect = ViperUtil.getBoundingRectangle(activeCell);

                    // Modify the table coords so that the width and height only for this col.
                    coords.x1 = cellRect.x1;
                    coords.x2 = cellRect.x2;
                break;
            }//end switch

            this.removeHighlights();

            if (element && !coords) {
                coords = ViperUtil.getBoundingRectangle(element);
            }

            var offset = ViperUtil.getDocumentOffset();
            coords.x1 += offset.x;
            coords.y1 += offset.y;
            coords.x2 += offset.x;
            coords.y2 += offset.y;

            var hElem = document.createElement('div');
            ViperUtil.addClass(hElem, 'ViperITP-highlight Viper-tableHighlight');

            ViperUtil.setStyle(hElem, 'width', (coords.x2 - coords.x1) + 'px');
            ViperUtil.setStyle(hElem, 'height', (coords.y2 - coords.y1) + 'px');
            ViperUtil.setStyle(hElem, 'top', coords.y1 + 'px');
            ViperUtil.setStyle(hElem, 'left', coords.x1 + 'px');

            this.viper.addElement(hElem);
            this._highlightElement = hElem;

            ViperUtil.addEvent(hElem, 'mousedown', function(e) {
                ViperUtil.preventDefault(e);
                ViperUtil.remove(hElem);
                return false;
            });

            // Hide the highlight element when the mouse is over it. Show it again, when
            // the mouse is over the table tools bar.
            var self = this;
            ViperUtil.hover(hElem, function() {
                ViperUtil.setStyle(hElem, 'display', 'none');
            }, function() {});

            ViperUtil.hover(self._toolbarWidget.element, function() {
                ViperUtil.setStyle(hElem, 'display', 'block');
            }, function() {});

        },

        _createCellProperties: function()
        {
            var self               = this;
            var settingsContent    = document.createElement('div');
            var headingChanged     = false;
            var settingsSubSection = this._toolbarWidget.makeSubSection('VTEP:cellProps:settingsSubSection', settingsContent);
            var settingsButton     = this._tools.createButton('VTEP:cellProps:settings', '', _('Toggle Settings'), 'Viper-tableSettings');
            this._toolbarWidget.addButton(settingsButton);
            this._toolbarWidget.setSubSectionButton('VTEP:cellProps:settings', 'VTEP:cellProps:settingsSubSection');
            this._toolbarWidget.setSubSectionAction('VTEP:cellProps:settingsSubSection', function() {
                var cell = self.getActiveCell();
                if (headingChanged === true) {
                    var newCell = null;
                    if (self._tools.getItem('VTEP:cellProps:heading').getValue() === true) {
                        newCell = self.convertToHeader(cell, 'cell');
                    } else {
                        newCell = self.convertToCell(cell, 'cell');
                    }

                    self.updateToolbar(newCell, 'cell');
                }
            }, ['VTEP:cellProps:heading']);
            var heading = this._tools.createCheckbox('VTEP:cellProps:heading', _('Heading'), false, function() {
                headingChanged = true;
            });
            settingsContent.appendChild(heading);

            // Split buttons.
            this._tools.createButton('VTEP:cellProps:splitVert', '', _('Split Vertically'), 'Viper-splitVert', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.splitVertical(cell);
                self.updateToolbar(cell, 'cell', 'merge');
            });

            this._tools.createButton('VTEP:cellProps:splitHoriz', '', _('Split Horizontally'), 'Viper-splitHoriz', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.splitHorizontal(cell);
                self.updateToolbar(cell, 'cell', 'merge');
            });

            var splitBtnGroup = this._tools.createButtonGroup('VTEP:cellProps:splitButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:splitVert', 'VTEP:cellProps:splitButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:splitHoriz', 'VTEP:cellProps:splitButtons');

            // Merge buttons.
            var mergeUp = this._tools.createButton('VTEP:cellProps:mergeUp', '', _('Merge Up'), 'Viper-mergeUp', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.mergeUp(cell), 'cell', 'merge');
            });

            var mergeDown = this._tools.createButton('VTEP:cellProps:mergeDown', '', _('Merge Down'), 'Viper-mergeDown', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.mergeDown(cell), 'cell', 'merge');
            });

            var mergeLeft = this._tools.createButton('VTEP:cellProps:mergeLeft', '', _('Merge Left'), 'Viper-mergeLeft', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.mergeLeft(cell), 'cell', 'merge');
            });

            var mergeRight = this._tools.createButton('VTEP:cellProps:mergeRight', '', _('Merge Right'), 'Viper-mergeRight', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.mergeRight(cell), 'cell', 'merge');
            });

            var mergeBtnGroup = this._tools.createButtonGroup('VTEP:cellProps:mergeButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:mergeUp', 'VTEP:cellProps:mergeButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:mergeDown', 'VTEP:cellProps:mergeButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:mergeLeft', 'VTEP:cellProps:mergeButtons');
            this._tools.addButtonToGroup('VTEP:cellProps:mergeRight', 'VTEP:cellProps:mergeButtons');

            var mergeSubWrapper = document.createElement('div');
            mergeSubWrapper.appendChild(splitBtnGroup);
            mergeSubWrapper.appendChild(mergeBtnGroup);

            // Create the merge/split sub section toggle button.
            var mergeSubSection = this._toolbarWidget.makeSubSection('VTEP:cellProps:mergeSplitSubSection', mergeSubWrapper);
            var mergeSplitToggle = this._tools.createButton('VTEP:cellProps:mergeSplitSubSectionToggle', '', _('Toggle Merge/Split Options'), 'Viper-splitMerge');
            this._toolbarWidget.addButton(mergeSplitToggle);
            this._toolbarWidget.setSubSectionButton('VTEP:cellProps:mergeSplitSubSectionToggle', 'VTEP:cellProps:mergeSplitSubSection');

        },

        _createColProperties: function()
        {
            var self = this;

            var settingsContent = document.createElement('div');

            // Create the settings sub section.
            var headingChanged     = false;
            var settingsSubSection = this._toolbarWidget.makeSubSection('VTEP:colProps:settingsSubSection', settingsContent);
            var settingsButton     = this._tools.createButton('VTEP:colProps:settings', '', _('Toggle Settings'), 'Viper-tableSettings');
            this._toolbarWidget.addButton(settingsButton);
            this._toolbarWidget.setSubSectionButton('VTEP:colProps:settings', 'VTEP:colProps:settingsSubSection');
            this._toolbarWidget.setSubSectionAction('VTEP:colProps:settingsSubSection', function() {
                var cell = self.getActiveCell();
                // Set column width.
                var width = self._tools.getItem('VTEP:colProps:width').getValue();
                self.setColumnWidth(cell, width);

                if (headingChanged === true) {
                    var headingChecked = self._tools.getItem('VTEP:colProps:heading').getValue();

                    // Switch between header and normal cell.
                    var newCell = null;
                    if (headingChecked !== true) {
                        newCell = self.convertToCell(cell, 'col');
                    } else {
                        newCell = self.convertToHeader(cell, 'col');
                    }

                    self.updateToolbar(newCell, 'col');
                } else {
                    self.updateToolbar(self.getActiveCell(), 'col');
                }
            }, ['VTEP:colProps:width', 'VTEP:colProps:heading']);

            // Width.
            var width = this._tools.createTextbox('VTEP:colProps:width', _('Width'));
            settingsContent.appendChild(width);

            var heading = this._tools.createCheckbox('VTEP:colProps:heading', _('Heading'), false, function() {
                headingChanged = true;
            });
            settingsContent.appendChild(heading);

            this._tools.createButton('VTEP:colProps:insBefore', '', _('Insert Column Before'), 'Viper-addLeft', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.insertColBefore(cell);
                self.updateToolbar(cell, 'col');
            });
            this._tools.createButton('VTEP:colProps:insAfter', '', _('Insert Column After'), 'Viper-addRight', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.insertColAfter(cell);
                self.updateToolbar(cell, 'col');
            });

            var btnGroup = this._tools.createButtonGroup('VTEP:insColButtons');
            this._tools.addButtonToGroup('VTEP:colProps:insBefore', 'VTEP:insColButtons');
            this._tools.addButtonToGroup('VTEP:colProps:insAfter', 'VTEP:insColButtons');
            this._toolbarWidget.addButton(btnGroup);

            this._tools.createButton('VTEP:colProps:moveLeft', '', _('Move Left'), 'Viper-mergeLeft', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.moveColLeft(cell), 'col');
            });
            this._tools.createButton('VTEP:colProps:moveRight', '', _('Move Right'), 'Viper-mergeRight', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.moveColRight(cell), 'col');
            });

            btnGroup = this._tools.createButtonGroup('VTEP:moveColButtons');
            this._tools.addButtonToGroup('VTEP:colProps:moveLeft', 'VTEP:moveColButtons');
            this._tools.addButtonToGroup('VTEP:colProps:moveRight', 'VTEP:moveColButtons');
            this._toolbarWidget.addButton(btnGroup);

            var removeCol = this._tools.createButton('VTEP:colProps:remove', '', _('Remove Column'), 'Viper-delete', function() {
                var cell  = self.getActiveCell();
                var table = self.getCellTable(cell);
                self._buttonClicked = true;
                self.removeCol(cell);
                self.removeHighlights();
                setTimeout(function() {
                    self.hideToolbar();
                }, 50);


                self._setCaretToStart(table);
            });
            this._toolbarWidget.addButton(removeCol);

            ViperUtil.hover(removeCol, function() {
                ViperUtil.addClass(self._highlightElement, 'Viper-deleteOverlay');
            }, function() {
                ViperUtil.removeClass(self._highlightElement, 'Viper-deleteOverlay');
            });

        },

        _createRowProperties: function()
        {
            var self               = this;
            var settingsContent    = document.createElement('div');
            var headingChanged     = false;
            var settingsSubSection = this._toolbarWidget.makeSubSection('VTEP:rowProps:settingsSubSection', settingsContent);
            var settingsButton     = this._tools.createButton('VTEP:rowProps:settings', '', _('Toggle Settings'), 'Viper-tableSettings');
            this._toolbarWidget.addButton(settingsButton);
            this._toolbarWidget.setSubSectionButton('VTEP:rowProps:settings', 'VTEP:rowProps:settingsSubSection');
            this._toolbarWidget.setSubSectionAction('VTEP:rowProps:settingsSubSection', function() {
                if (headingChanged === true) {
                    var cell    = self.getActiveCell();
                    var newCell = null;
                    if (self._tools.getItem('VTEP:rowProps:heading').getValue() === true) {
                        newCell = self.convertToHeader(cell, 'row');
                    } else {
                        newCell = self.convertToCell(cell, 'row');
                    }

                    self.updateToolbar(newCell, 'row');
                }
            }, ['VTEP:rowProps:heading']);

            var heading = this._tools.createCheckbox('VTEP:rowProps:heading', _('Heading'), false, function() {
                headingChanged = true;
            });
            settingsContent.appendChild(heading);

            this._tools.createButton('VTEP:rowProps:insBefore', '', _('Insert Row Before'), 'Viper-addAbove', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.insertRowBefore(cell);
                self.updateToolbar(cell, 'row');
            });
            this._tools.createButton('VTEP:rowProps:insAfter', '', _('Insert Row After'), 'Viper-addBelow', function() {
                var cell = self.getActiveCell();
                self.insertRowAfter(cell);
                self.updateToolbar(cell, 'row');
            });
            var btnGroup = this._tools.createButtonGroup('VTEP:insRowButtons');
            this._tools.addButtonToGroup('VTEP:rowProps:insBefore', 'VTEP:insRowButtons');
            this._tools.addButtonToGroup('VTEP:rowProps:insAfter', 'VTEP:insRowButtons');
            this._toolbarWidget.addButton(btnGroup);

            this._tools.createButton('VTEP:rowProps:moveUp', '', _('Move Up'), 'Viper-mergeUp', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.moveRowUp(cell), 'row');
            });
            this._tools.createButton('VTEP:rowProps:moveDown', '', _('Move Down'), 'Viper-mergeDown', function() {
                var cell = self.getActiveCell();
                self._buttonClicked = true;
                self.updateToolbar(self.moveRowDown(cell), 'row');
            });
            btnGroup = this._tools.createButtonGroup('VTEP:moveRowButtons');
            this._tools.addButtonToGroup('VTEP:rowProps:moveUp', 'VTEP:moveRowButtons');
            this._tools.addButtonToGroup('VTEP:rowProps:moveDown', 'VTEP:moveRowButtons');
            this._toolbarWidget.addButton(btnGroup);

            var removeRow = this._tools.createButton('VTEP:rowProps:remove', '', _('Remove Row'), 'Viper-delete', function() {
                var cell  = self.getActiveCell();
                var table = self.getCellTable(cell);
                self._buttonClicked = true;
                self.removeRow(cell);
                self.removeHighlights();
                setTimeout(function() {
                    self.hideToolbar();
                }, 50);

                self._setCaretToStart(table);
            });
            this._toolbarWidget.addButton(removeRow);

            ViperUtil.hover(removeRow, function() {
                ViperUtil.addClass(self._highlightElement, 'Viper-deleteOverlay');
            }, function() {
                ViperUtil.removeClass(self._highlightElement, 'Viper-deleteOverlay');
            });

        },

        _createTableProperties: function(cell)
        {
            var self = this;

            var settingsContent = document.createElement('div');

            // Create the settings sub section.
            var settingsSubSection = this._toolbarWidget.makeSubSection('VTEP:tableProps:settingsSubSection', settingsContent);
            var settingsButton     = this._tools.createButton('VTEP:tableProps:settings', '', _('Toggle Settings'), 'Viper-tableSettings');
            this._toolbarWidget.addButton(settingsButton);
            this._toolbarWidget.setSubSectionButton('VTEP:tableProps:settings', 'VTEP:tableProps:settingsSubSection');
            this._toolbarWidget.setSubSectionAction('VTEP:tableProps:settingsSubSection', function() {
                var table = self.getCellTable(self.getActiveCell());
                self.setTableWidth(table, self._tools.getItem('VTEP:tableProps:width').getValue());
                self.viper.setAttribute(table, 'summary', self._tools.getItem('VTEP:tableProps:summary').getValue());

                var captionCheckbox = self._tools.getItem('VTEP:tableProps:caption').getValue();
                if (captionCheckbox === true) {
                    self.createCaption(table);
                } else {
                    self.removeCaption(table);
                }

                self.updateToolbar(self.getActiveCell(), 'table');
            }, ['VTEP:tableProps:width', 'VTEP:tableProps:summary', 'VTEP:tableProps:caption']);

            // Width.
            var width = this._tools.createTextbox('VTEP:tableProps:width', _('Width'), '', null, false, false, '', null, '4.5em');
            settingsContent.appendChild(width);

            // Summary.
            var tableSummary = this._tools.createTextarea('VTEP:tableProps:summary', _('Summary'), '', false, '', null, '4.5em');
            settingsContent.appendChild(tableSummary);

            // Caption.
            var caption = this._tools.createCheckbox('VTEP:tableProps:caption', _('Use Caption'));
            settingsContent.appendChild(caption);

            var remove = this._tools.createButton('VTEP:tableProps:remove', '', _('Remove Table'), 'Viper-delete', function() {
                var table = self.getCellTable(self.getActiveCell());
                self._buttonClicked = true;
                self.removeTable(table);
                self.removeHighlights();
                setTimeout(function() {
                    self.hideToolbar();
                }, 50);
            });
            this._toolbarWidget.addButton(remove);

            ViperUtil.hover(remove, function() {
                ViperUtil.addClass(self._highlightElement, 'Viper-deleteOverlay');
            }, function() {
                ViperUtil.removeClass(self._highlightElement, 'Viper-deleteOverlay');
            });

        },

        setActiveCell: function(cell)
        {
            this.activeCell = cell;

        },

        getActiveCell: function(cell)
        {
            return this.activeCell;

        },

        createTableHeader: function(table)
        {
            if (ViperUtil.getTag('thead', table).length > 0) {
                return null;
            }

            var header = document.createElement('thead');
            var tfoot  = ViperUtil.getTag('tfoot', table);
            if (tfoot.length === 0) {
                var tbody = ViperUtil.getTag('tbody', table);
                if (tbody.length === 0) {
                    table.appendChild(header);
                } else {
                    ViperUtil.insertBefore(tbody[0], header);
                }
            } else {
                ViperUtil.insertBefore(tfoot[0], header);
            }

            return header;

        },

        getTableHeader: function(table)
        {
            var header = ViperUtil.getTag('thead', table);
            if (header.length === 0) {
                return null;
            }

            return header[0];

        },

        createTableBody: function(table)
        {
            if (ViperUtil.getTag('tbody', table).length > 0) {
                return null;
            }

            var tbody = document.createElement('tbody');
            table.appendChild(tbody);

            return tbody;

        },

        getTableBody: function(table)
        {
            var tbody = ViperUtil.getTag('tbody', table);
            if (tbody.length === 0) {
                return null;
            }

            return tbody[0];

        },

        createCaption: function(table)
        {
            var caption  = null;
            var captions = ViperUtil.getTag('caption', table);
            if (captions.length > 0) {
                caption = captions[0];
            } else {
                caption = document.createElement('caption');
                ViperUtil.setHtml(caption, '&nbsp;');

                ViperUtil.insertBefore(table.firstChild, caption);
            }

            var range      = this.viper.getCurrentRange();
            var selectNode = range._getFirstSelectableChild(caption);
            range.setStart(selectNode, 0);
            range.collapse(true);
            ViperSelection.addRange(range);
            this.viper.fireSelectionChanged(null, true);

            this.removeHighlights();
            this.hideCellToolsIcon();

        },

        removeCaption: function(table)
        {
            var caption  = null;
            var captions = ViperUtil.getTag('caption', table);
            if (captions.length > 0) {
                ViperUtil.remove(captions);
            }

        },

        
        canMergeLeft: function(cell)
        {
            var cells   = this._getCellsExpanded();
            var cellPos = this.getCellPosition(cell);
            var rowspan = this.getRowspan(cell);

            if (cellPos.col === 0) {
                // First column so cannot merge left.
                return false;
            }

            var processedCells = [];
            var rowspans       = 0;
            var prevColspan    = null;
            for (var i = 0; i < rowspan; i++) {
                // Check each previous cell, make sure:
                // - First one start from current cell's row position
                // - They all have the same colspan
                // - Total rowspan must be the same as current cell's rowspan.
                var prevCell = cells[(cellPos.row + i)][(cellPos.col - 1)];
                if (ViperUtil.inArray(prevCell, processedCells) === true) {
                    continue;
                }

                processedCells.push(prevCell);

                var pos = this.getCellPosition(prevCell);
                if (i === 0 && pos.row !== cellPos.row) {
                    // First previous cell must be at the same level as the current cell.
                    return false;
                }

                rowspans += this.getRowspan(prevCell);

                if (rowspans > rowspan) {
                    // Total rowspan must be the same as current cell's rowspan.
                    return false;
                } else if (prevColspan !== null && prevColspan !== this.getColspan(prevCell)) {
                    // They all have the same colspan.
                    return false;
                }

                prevColspan = this.getColspan(prevCell);
            }//end for

            if (rowspans === rowspan) {
                // Total rowspan must be the same as current cell's rowspan.
                return processedCells;
            }

            return false;

        },

        canMergeRight: function(cell)
        {
            var cells   = this._getCellsExpanded();
            var cellPos = this.getCellPosition(cell);
            var rowspan = this.getRowspan(cell);
            var colspan = this.getColspan(cell);

            if (cell === (cells[cellPos.row][(cells[cellPos.row].length - 1)])) {
                // Last column so cannot merge right.
                return false;
            }

            var processedCells = [];
            var rowspans       = 0;
            var prevColspan    = null;
            for (var i = 0; i < rowspan; i++) {
                // Check each next cell, make sure:
                // - First one start from current cell's row position
                // - They all have the same colspan
                // - Total rowspan must be the same as current cell's rowspan.
                var nextCell = cells[(cellPos.row + i)][(cellPos.col + colspan)];
                if (ViperUtil.inArray(nextCell, processedCells) === true) {
                    continue;
                }

                processedCells.push(nextCell);

                var pos = this.getCellPosition(nextCell);
                if (i === 0 && pos.row !== cellPos.row) {
                    // First previous cell must be at the same level as the current cell.
                    return false;
                }

                rowspans += this.getRowspan(nextCell);

                if (rowspans > rowspan) {
                    // Total rowspan must be the same as current cell's rowspan.
                    return false;
                } else if (prevColspan !== null && prevColspan !== this.getColspan(nextCell)) {
                    // They all have the same colspan.
                    return false;
                }

                prevColspan = this.getColspan(nextCell);
            }//end for

            if (rowspans === rowspan) {
                // Total rowspan must be the same as current cell's rowspan.
                return processedCells;
            }

            return false;

        },

        canMergeDown: function(cell)
        {
            var rowspan = this.getRowspan(cell);
            var colNum  = this.getColNum(cell);
            var row     = cell.parentNode;
            var colspan = this.getColspan(cell);

            while (rowspan >= 1) {
                row = this.getNextRow(row, true);
                rowspan--;
            }

            if (row) {
                var cspan          = 0;
                var processedCells = [];
                var prevRowspan    = null;
                for (var i = 0; i < colspan; i++) {
                    var newCell = this.getCell(row, (colNum + i));
                    if (!newCell) {
                        return false;
                    }

                    if (ViperUtil.inArray(newCell, processedCells) === true) {
                        continue;
                    }

                    processedCells.push(newCell);

                    var newCellRowspan = this.getRowspan(newCell);
                    if (prevRowspan !== null && prevRowspan !== newCellRowspan) {
                        return false
                    }

                    prevRowspan = newCellRowspan;

                    cspan += this.getColspan(newCell);
                    if (colspan < cspan) {
                        return false;
                    }
                }//end for

                return processedCells;
            }//end if

            return false;

        },

        canMergeUp: function(cell)
        {
            var rowspan = this.getRowspan(cell);
            var colNum  = this.getColNum(cell);
            var row     = cell.parentNode;
            var newCell = null;
            var colspan = this.getColspan(cell);

            while (row && !newCell) {
                row = this.getPreviousRow(row, true);
                if (!row) {
                    return false;
                }

                newCell = this.getCell(row, colNum);
            }

            if (row) {
                var cspan          = 0;
                var processedCells = [];
                var prevRowspan    = null;
                for (var i = 0; i < colspan; i++) {
                    var newCell = this.getCell(row, (colNum + i));
                    if (!newCell) {
                        return false;
                    }

                    if (ViperUtil.inArray(newCell, processedCells) === true) {
                        continue;
                    }

                    processedCells.push(newCell);

                    var newCellRowspan = this.getRowspan(newCell);
                    if (prevRowspan !== null && prevRowspan !== newCellRowspan) {
                        return false
                    }

                    prevRowspan = newCellRowspan;

                    cspan += this.getColspan(newCell);
                    if (colspan < cspan) {
                        return false;
                    }
                }//end for

                return processedCells;
            }//end if

            return false;

        },

        mergeLeft: function(cell)
        {
            var mergeCells = this.canMergeLeft(cell);
            if (!mergeCells || mergeCells.length === 0) {
                return;
            }

            var newColspan = (this.getColspan(cell) + this.getColspan(mergeCells[0]));
            this.setColspan(cell, newColspan);

            for (var i = 0; i < mergeCells.length; i++) {
                this._moveCellContent(mergeCells[i], cell);
                ViperUtil.remove(mergeCells[i]);
            }

            var table = this.getCellTable(cell);
            if (ViperUtil.getTag('tr', table).length === 1) {
                this.setColspan(cell, 1);
            }

            this.tableUpdated();

            return cell;

        },

        mergeRight: function(cell)
        {
            var mergeCells = this.canMergeRight(cell);
            if (!mergeCells || mergeCells.length === 0) {
                return;
            }

            var newColspan = (this.getColspan(cell) + this.getColspan(mergeCells[0]));
            this.setColspan(cell, newColspan);

            for (var i = 0; i < mergeCells.length; i++) {
                this._moveCellContent(mergeCells[i], cell);
                ViperUtil.remove(mergeCells[i]);
            }

            var table = this.getCellTable(cell);
            if (ViperUtil.getTag('tr', table).length === 1) {
                this.setColspan(cell, 1);
            }

            var cells = ViperUtil.getTag('td,th', table);
            if (cells.length === 1) {
                this.setColspan(cells[0], 1);
                this.setRowspan(cells[0], 1);

                // Remove empty rows.
                var rows = ViperUtil.getTag('tr', table);
                for (var i = 0; i < rows.length; i++) {
                    if (ViperUtil.getTag('td,th', rows[i]).length === 0) {
                        ViperUtil.remove(rows[i]);
                    }
                }
            }

            this.tableUpdated();

            return cell;

        },

        mergeDown: function(cell)
        {
            var mergeCells = this.canMergeDown(cell);
            if (mergeCells.length === 0) {
                return false;
            }

            this.setActiveCell(cell);

            var parent = mergeCells[0].parentNode;

            for (var i = 0; i < mergeCells.length; i++) {
                this._moveCellContent(mergeCells[i], cell);
                ViperUtil.remove(mergeCells[i]);
            }

            var rowspan = this.getRowspan(cell) + this.getRowspan(mergeCells[0]);
            this.setRowspan(cell, rowspan);

            var cells    = this._getCellsExpanded(true);
            var rowCells = this._getRowCells(parent);
            if (rowCells.length === 0) {
                // Find the row index.
                var rows     = ViperUtil.getTag('tr', this.getCellTable(cell));
                var rowIndex = -1;
                for (var i = 0; i < rows.length; i++) {
                    if (rows[i] === parent) {
                        rowIndex = i;
                        break;
                    }
                }

                if (rowIndex >= 0) {
                    var processedCells = [];
                    cells = cells[rowIndex];
                    for (var i = 0; i < cells.length; i++) {
                        if (ViperUtil.inArray(cells[i], processedCells) === true) {
                            continue;
                        }

                        processedCells.push(cells[i]);

                        var rowspan = (this.getRowspan(cells[i]) - 1);
                        this.setRowspan(cells[i], rowspan);
                    }
                }

                ViperUtil.remove(parent);
            }//end if

            var table = this.getCellTable(cell);
            if (ViperUtil.getTag('tr', table).length === 1) {
                this.setColspan(cell, 1);
            }

            this.tableUpdated();

            return cell;

        },

        mergeUp: function(cell)
        {
            var mergeCells = this.canMergeUp(cell);
            if (mergeCells.length === 0) {
                return false;
            }

            this.setActiveCell(cell);

            var cellPos = this.getCellPosition(cell);

            var parent    = cell.parentNode;
            var firstCell = mergeCells[0];

            for (var i = 1; i < mergeCells.length; i++) {
                this.setColspan(firstCell, this.getColspan(firstCell) + this.getColspan(mergeCells[i]));
                this._moveCellContent(mergeCells[i], firstCell);
                ViperUtil.remove(mergeCells[i]);
            }

            this._moveCellContent(cell, firstCell);

            ViperUtil.remove(cell);

            var rowspan = this.getRowspan(firstCell) + this.getRowspan(cell);
            this.setRowspan(firstCell, rowspan);

            this.setActiveCell(firstCell);

            // Check if we need to remove the cell's parent row if empty.
            var cells    = this._getCellsExpanded(true);
            var rowCells = cells[cellPos.row];
            var prevPos  = this.getCellPosition(firstCell).row;
            var remove   = true;

            for (var i = 0; i < rowCells.length; i++) {
                var pos = this.getCellPosition(rowCells[i]);
                if (pos.row !== prevPos || rowspan !== this.getRowspan(rowCells[i])) {
                    remove = false;
                    break;
                }
            }

            if (remove === true) {
                // Remove row.
                ViperUtil.remove(parent);

                // Reduce rowspan.
                var processedCells = [];
                for (var i = 0; i < rowCells.length; i++) {
                    if (ViperUtil.inArray(rowCells[i], processedCells) === true) {
                        continue;
                    }

                    processedCells.push(rowCells[i]);

                    var newRowspan = (this.getRowspan(rowCells[i]) - 1);
                    this.setRowspan(rowCells[i], newRowspan);
                }
            }

            var table = this.getCellTable(firstCell);
            if (ViperUtil.getTag('tr', table).length === 1) {
                this.setColspan(firstCell, 1);
            }

            this.tableUpdated();

            return firstCell;

        },

        
        canMoveColLeft: function(cell)
        {
             var colNum = this.getColNum(cell);
             if (colNum === 0) {
                 return false;
             }

             var pos     = this.getCellPosition(cell);
             var cells   = this._getCellsExpanded(true);
             var colspan = this.getColspan(cell);

             for (var i = 0; i < cells.length; i++) {
                 var currColspan = this.getColspan(cells[i][pos.col]);
                 var prevColspan = this.getColspan(cells[i][(pos.col - 1)]);
                 var currRowspan = this.getRowspan(cells[i][pos.col]);
                 var prevRowspan = this.getRowspan(cells[i][(pos.col - 1)]);

                 if (colspan !== currColspan || currColspan !== prevColspan) {
                     return false;
                 } else if (currRowspan !== prevRowspan) {
                     return false;
                 }
             }

             return true;

        },

        canMoveColRight: function(cell)
        {
             var pos     = this.getCellPosition(cell);
             var cells   = this._getCellsExpanded(true);
             var colspan = this.getColspan(cell);

             if (!cells[pos.row][(pos.col + 1)]) {
                 return false;
             }

             for (var i = 0; i < cells.length; i++) {
                 var currColspan = this.getColspan(cells[i][pos.col]);
                 var nextColspan = this.getColspan(cells[i][(pos.col + 1)]);
                 var currRowspan = this.getRowspan(cells[i][pos.col]);
                 var nextRowspan = this.getRowspan(cells[i][(pos.col + 1)]);

                 if (colspan !== currColspan || currColspan !== nextColspan) {
                     return false;
                 } else if (currRowspan !== nextRowspan) {
                     return false;
                 }
             }

             return true;

        },

        canMoveRowUp: function(cell)
        {
            var pos = this.getCellPosition(cell);

            if (pos.row === 0) {
                return false;
            }

            var rowspan = this.getRowspan(cell);
            var cellRow = this.getCellRow(cell);
            var prevRow = this.getPreviousRow(cellRow);

            if (!prevRow) {
                return false;
            }

            var rowCellsCount    = this._getRowCellCount(cellRow);
            var prevRowCellCount = this._getRowCellCount(prevRow);

            if (rowCellsCount !== prevRowCellCount) {
                return false;
            }

            // Also need to make sure the current cell has higher or equal rowspan than
            // the rest of the column on its row and all cells must start from the current
            // row (e.g. a cell cannot be from a previous row with rowspan).
            var cells = this._getCellsExpanded();

            for (var i = 0; i < cells[pos.row].length; i++) {
                var rowCell = cells[pos.row][i];
                if (rowCell === cell) {
                    continue;
                }

                var cellPos = this.getCellPosition(rowCell);
                if (cellPos.row !== pos.row || rowspan < this.getRowspan(rowCell)) {
                    return false;
                }
            }

            return true;

        },

        canMoveRowDown: function(cell)
        {
            var pos = this.getCellPosition(cell);

            var cellRow = this.getCellRow(cell);
            var rowspan = this.getRowspan(cell);

            var nextRow = cellRow;
            for (var i = 0; i < rowspan; i++) {
                nextRow = this.getNextRow(nextRow);
                if (!nextRow) {
                    return false;
                }
            }

            var rowCellsCount    = this._getRowCellCount(cellRow);
            var nextRowCellCount = this._getRowCellCount(nextRow);

            if (rowCellsCount !== nextRowCellCount) {
                return false;
            }

            // Also need to make sure the current cell has higher or equal rowspan than
            // the rest of the column on its row and all cells must start from the current
            // row (e.g. a cell cannot be from a previous row with rowspan).
            var cells = this._getCellsExpanded();

            for (var i = 0; i < cells[pos.row].length; i++) {
                var rowCell = cells[pos.row][i];
                if (rowCell === cell) {
                    continue;
                }

                var cellPos = this.getCellPosition(rowCell);
                if (cellPos.row !== pos.row || rowspan < this.getRowspan(rowCell)) {
                    return false;
                }
            }

            return true;

        },

        moveColLeft: function(cell)
        {
            if (this.canMoveColLeft(cell) === false) {
                return false;
            }

            var pos   = this.getCellPosition(cell);
            var cells = this._getCellsExpanded(true);

            if (!cells[pos.row][(pos.col - 1)]) {
                return false;
            }

            for (var i = 0; i < cells.length; i++) {
                ViperUtil.insertBefore(cells[i][(pos.col - 1)], cells[i][pos.col]);
            }

            this.tableUpdated();

            return cell;

        },

        moveColRight: function(cell)
        {
            if (this.canMoveColRight(cell) === false) {
                return false;
            }

            var pos   = this.getCellPosition(cell);
            var cells = this._getCellsExpanded(true);

            if (!cells[pos.row][(pos.col + 1)]) {
                return false;
            }

            for (var i = 0; i < cells.length; i++) {
                ViperUtil.insertAfter(cells[i][(pos.col + 1)], cells[i][pos.col]);
            }

            this.tableUpdated();

            return cell;

        },

        moveRowUp: function(cell)
        {
            if (this.canMoveRowUp(cell) === false) {
                return false;
            }

            var cellRow = this.getCellRow(cell);
            var prevRow = this.getPreviousRow(cellRow);
            var rowspan = this.getRowspan(cell);

            for (var i = 0; i < rowspan; i++) {
                cellRow = this.getNextRow(prevRow);
                ViperUtil.insertBefore(prevRow, cellRow);
            }

            this.tableUpdated();

            return cell;

        },

        moveRowDown: function(cell)
        {
            if (this.canMoveRowDown(cell) === false) {
                return false;
            }

            var rowspan = this.getRowspan(cell);
            var cellRow = this.getCellRow(cell);

            var nextRow = cellRow;
            for (var i = 0; i < rowspan; i++) {
                nextRow = this.getNextRow(nextRow);
                if (!nextRow) {
                    return false;
                }
            }

            var startRow = nextRow;

            // If the afterRow contains cells with rowspans then we need to move the
            // current row after the rowspans.
            var cells      = this._getRowCells(startRow);
            var maxRowspan = 1;
            for (var i = 0; i < cells.length; i++) {
                var cellRowspan = this.getRowspan(cells[i]);
                if (maxRowspan < cellRowspan) {
                    maxRowspan = cellRowspan;
                }
            }

            if (maxRowspan > 1) {
                for (var i = 0; i < (maxRowspan - 1); i++) {
                    nextRow = this.getNextRow(nextRow);
                }

                afterRow = nextRow
            } else {
                afterRow = startRow;
            }

            for (var i = 0; i < rowspan; i++) {
                var prevRow = this.getPreviousRow(startRow);
                if (!prevRow) {
                    return false;
                }

                ViperUtil.insertAfter(afterRow, prevRow);
            }

            this.tableUpdated();

            return cell;

        },

        getRowspan: function(cell)
        {
            return parseInt(cell.getAttribute('rowspan') || 1);

        },

        setRowspan: function(cell, rowspan)
        {
            if (rowspan > 1) {
                cell.setAttribute('rowspan', rowspan);
            } else {
                ViperUtil.removeAttr(cell, 'rowspan');
            }

        },

        getColspan: function(cell)
        {
            return parseInt(cell.getAttribute('colspan') || 1);

        },

        setColspan: function(cell, colspan)
        {
            if (colspan > 1) {
                cell.setAttribute('colspan', colspan);
            } else {
                ViperUtil.removeAttr(cell, 'colspan');
            }

        },

        
        convertToHeader: function(cell, type, actualType)
        {
            var elem = cell;
            type     = type || 'cell';

            if (type === 'cell' && ViperUtil.isTag(cell, 'td') === false) {
                return elem;
            }

            var activeCell = this.getActiveCell();
            if (type === 'cell') {
                elem = document.createElement('th');
                while (cell.firstChild) {
                    elem.appendChild(cell.firstChild);
                }

                for (var i = 0; i < cell.attributes.length; i++) {
                    if (cell.attributes[i].nodeName.toLowerCase() === 'rowspan') {
                        this.setRowspan(elem, cell.attributes[i].nodeValue);
                    } else if (cell.attributes[i].nodeName.toLowerCase() === 'colspan') {
                        this.setColspan(elem, cell.attributes[i].nodeValue);
                    } else {
                        elem.setAttribute(cell.attributes[i].nodeName, cell.attributes[i].nodeValue);
                    }
                }

                if (cell === activeCell) {
                    this.setActiveCell(elem);
                }

                ViperUtil.insertBefore(cell, elem);
                ViperUtil.remove(cell);

                if (!actualType || actualType === 'cell') {
                    this.tableUpdated();
                }
            } else if (type === 'col') {
                // Get all column cells.
                var cells   = this._getCellsExpanded();
                var cellPos = this.getCellPosition(cell);

                for (var i = 0; i < cells.length; i++) {
                    var colCell    = cells[i][cellPos.col];
                    if (!colCell.parentNode || ViperUtil.isTag(colCell, 'th') === true) {
                        continue;
                    }

                    var colCellPos = this.getCellPosition(colCell);
                    if (colCellPos.col === cellPos.col) {
                        var newElement = this.convertToHeader(colCell, 'cell', 'col');
                        if (cell === colCell) {
                            elem = newElement;
                        }
                    }
                }

                this.tableUpdated();
            } else if (type === 'row') {
                var cellPos = this.getCellPosition(cell);
                var row     = cell.parentNode;
                var cells   = this._getRowCells(row);

                // Check if row needs to move in to a THEAD tag.
                if (ViperUtil.isTag(row.parentNode, 'thead') === false
                    && !this.getPreviousRow(row, true)
                ) {
                    var moveToThead = true;
                    var prevRowspan = null;
                    for (var i = 0; i < cells.length; i++) {
                        var rowspan = this.getRowspan(cells[i]);
                        if (prevRowspan !== null && rowspan !== prevRowspan) {
                            moveToThead = false;
                            break;
                        }

                        prevRowspan = rowspan;
                    }

                    if (moveToThead === true) {
                        var table = this.getRowTable(row);
                        // The row is not in thead and its the first row in tbody or tfoot.
                        var thead = this.getTableHeader(table);
                        if (!thead) {
                            thead = this.createTableHeader(table);
                        }

                        thead.appendChild(row);
                    }
                }

                for (var i = 0; i < cells.length; i++) {
                    var rowCell    = cells[i];
                    if (!rowCell.parentNode || ViperUtil.isTag(rowCell, 'th') === true) {
                        continue;
                    }

                    var newElement = this.convertToHeader(rowCell, 'cell', 'row');
                    if (cell === rowCell) {
                        elem = newElement;
                    }
                }

                this.tableUpdated();
            }//end if

            return elem;

        },

        
        convertToCell: function(cell, type, actualType)
        {
            var elem = cell;
            type     = type || 'cell';

            if (type === 'cell' && ViperUtil.isTag(cell, 'th') === false) {
                return elem;
            }

            var activeCell = this.getActiveCell();
            if (type === 'cell') {
                elem = document.createElement('td');
                while (cell.firstChild) {
                    elem.appendChild(cell.firstChild);
                }

                for (var i = 0; i < cell.attributes.length; i++) {
                    if (cell.attributes[i].nodeName.toLowerCase() === 'rowspan') {
                        this.setRowspan(elem, cell.attributes[i].nodeValue);
                    } else if (cell.attributes[i].nodeName.toLowerCase() === 'colspan') {
                        this.setColspan(elem, cell.attributes[i].nodeValue);
                    } else {
                        elem.setAttribute(cell.attributes[i].nodeName, cell.attributes[i].nodeValue);
                    }
                }

                if (cell === activeCell) {
                    this.setActiveCell(elem);
                }

                ViperUtil.insertBefore(cell, elem);

                var tableid = this.getCellTable(elem).id;
                var cellid  = elem.id;
                if (cellid && cellid.indexOf(tableid) === 0) {
                    cellid = cellid.replace(tableid, '');
                    if (cellid.match(/r\d+c\d+/)) {
                        elem.removeAttribute('id');
                    }
                }

                ViperUtil.remove(cell);

                if (!actualType || actualType === 'cell') {
                    this.tableUpdated();
                }
            } else if (type === 'col') {
                var cells   = this._getCellsExpanded();
                var cellPos = this.getCellPosition(cell);

                for (var i = 0; i < cells.length; i++) {
                    var colCell    = cells[i][cellPos.col];
                    if (!colCell.parentNode || ViperUtil.isTag(colCell, 'td') === true) {
                        continue;
                    }

                    var colCellPos = this.getCellPosition(colCell);
                    if (colCellPos.col === cellPos.col) {
                        var newElement = this.convertToCell(colCell, 'cell', 'col');
                        if (cell === colCell) {
                            elem = newElement;
                        }
                    }
                }

                this.tableUpdated();
            } else if (type === 'row') {
                var cellPos = this.getCellPosition(cell);
                var cells   = this._getRowCells(cell.parentNode);
                var row     = cell.parentNode;

                // Check if row needs to move in to a TBODY tag.
                if (ViperUtil.isTag(row.parentNode, 'thead') === true
                    && !this.getNextRow(row, true)
                ) {
                    var table = this.getRowTable(row);

                    // Its the last row in thead, move it down to tbody.
                    var tbody = this.getTableBody(table);
                    if (!tbody) {
                        tbody = this.createTableBody(table);
                        tbody.appendChild(row);
                    } else {
                        var rows = ViperUtil.getTag('tr', tbody);
                        if (rows.length === 0) {
                            tbody.appendChild(row);
                        } else {
                            ViperUtil.insertBefore(rows[0], row);
                        }
                    }
                }

                for (var i = 0; i < cells.length; i++) {
                    var rowCell    = cells[i];
                    if (!rowCell.parentNode || ViperUtil.isTag(rowCell, 'td') === true) {
                        continue;
                    }

                    var newElement = this.convertToCell(rowCell, 'cell', 'row');
                    if (cell === rowCell) {
                        elem = newElement;
                    }
                }

                this.tableUpdated();
            }//end if

            return elem;

        },

        setColumnWidth: function (cell, width)
        {
            if (parseInt(width) === width) {
                width = width + 'px';
            }

            var cells   = this._getCellsExpanded();
            var cellPos = this.getCellPosition(cell);

            // Find the first cell that belongs to the same column.
            for (var i = 0; i < cells.length; i++) {
                var colCell    = cells[i][cellPos.col];
                var colCellPos = this.getCellPosition(colCell);
                if (colCellPos.col === cellPos.col) {
                    ViperUtil.setStyle(colCell, 'width', width);
                    this.tableUpdated();
                    return;
                }
            }

        },

        getColumnWidth: function(cell)
        {
            var cells   = this._getCellsExpanded();
            var cellPos = this.getCellPosition(cell);

            // Find the first cell that belongs to the same column.
            for (var i = 0; i < cells.length; i++) {
                var colCell    = cells[i][cellPos.col];
                var colCellPos = this.getCellPosition(colCell);
                if (colCellPos.col === cellPos.col) {
                    return colCell.style.width || '';
                }
            }

            return '';

        },

        setTableWidth: function(table, width)
        {
            if (parseInt(width) === width) {
                width = width + 'px';
            }

            ViperUtil.setStyle(table, 'width', width);

            if (table.getAttribute('style') === '') {
                table.removeAttribute('style');
            }

            this.tableUpdated(table);

        },

        getTableWidth: function(table)
        {
            var width = table.style.width || '';
            return width;

        },

        
        splitVertical: function(cell)
        {
            if (!cell || !cell.getAttribute('colspan')) {
                return;
            }

            var tagName = ViperUtil.getTagName(cell);
            var elem    = document.createElement(tagName);
            this._initCell(elem);

            var colspan = (parseInt(cell.getAttribute('colspan')) - 1);
            this.setColspan(cell, colspan);

            var rowspan = cell.getAttribute('rowspan');
            if (rowspan > 1) {
                this.setRowspan(elem, rowspan);
            }

            ViperUtil.insertAfter(cell, elem);

            this.tableUpdated();

            return elem;

        },

        
        splitHorizontal: function(cell)
        {
            var rowspan = this.getRowspan(cell);
            if (!cell || rowspan <= 1) {
                return false;
            }

            var rows    = ViperUtil.getTag('tr', this.getCellTable(cell));
            var cellPos = this.getCellPosition(cell);
            var cells   = this._getCellsExpanded();

            // Decrease the rowspan of this cell by 1.
            this.setRowspan(cell, (rowspan - 1));

            var colspan = this.getColspan(cell);
            var newCell = document.createElement(ViperUtil.getTagName(cell));
            this._initCell(newCell);
            if (colspan > 1) {
                this.setColspan(newCell, colspan);
            }

            // Find the new cell's insertion point.
            // Next row is startRowPosition + originalRowspan - 1 (minus 1 since default rowspan is 1).
            var nextRowIndex = (cellPos.row + rowspan - 1);
            var rowCells     = this._getRowCells(rows[nextRowIndex]);

            if (rowCells.length === 0) {
                rows[nextRowIndex].appendChild(newCell);
            } else if (cellPos.col === 0) {
                ViperUtil.insertBefore(rowCells[0], newCell);
            } else {
                var cellIndex = cellPos.col;

                // Look behind to see if there is a real column.
                var inserted = false;
                while (cells[nextRowIndex][--cellIndex]) {
                    if (this.getCellPosition(cells[nextRowIndex][cellIndex]).row === nextRowIndex) {
                        inserted = true;
                        ViperUtil.insertAfter(cells[nextRowIndex][cellIndex], newCell);
                        break;
                    }
                }

                if (inserted === false) {
                    // Look forward.
                    cellIndex = cellPos.col;
                    while (cells[nextRowIndex][++cellIndex]) {
                        if (this.getCellPosition(cells[nextRowIndex][cellIndex]).row === nextRowIndex) {
                            ViperUtil.insertBefore(cells[nextRowIndex][cellIndex], newCell);
                            break;
                        }
                    }
                }
            }//end if

            this.tableUpdated();

            return newCell;

        },

        insertRowBefore: function(cell)
        {
            var cellRow  = cell.parentNode;
            var cellPos  = this.getCellPosition(cell);
            var cells    = this._getCellsExpanded();
            var rowCells = cells[cellPos.row];
            var rlen     = rowCells.length;

            var newRow = document.createElement('tr');

            var processedCells = [];
            for (var i = 0; i < rlen; i++) {
                var rowCell = rowCells[i];
                if (ViperUtil.inArray(rowCell, processedCells) === true) {
                    continue;
                }

                var rowspan = this.getRowspan(rowCell);
                if (rowspan > 1 && this.getCellPosition(rowCell).row < cellPos.row) {
                    // Increase the rowspan instead of creating a new cell.
                    this.setRowspan(rowCell, (rowspan + 1));
                } else {
                    var newCell = document.createElement(ViperUtil.getTagName(rowCell));
                    this._initCell(newCell);

                    var colspan = this.getColspan(rowCell);
                    if (colspan > 1) {
                        this.setColspan(newCell, colspan);
                    }

                    newRow.appendChild(newCell);
                }

                processedCells.push(rowCell);
            }//end for

            ViperUtil.insertBefore(cellRow, newRow);

            this.tableUpdated();

        },

        insertRowAfter: function(cell)
        {
            var rows     = ViperUtil.getTag('tr', this.getCellTable(cell));
            var cellPos  = this.getCellPosition(cell);
            var cells    = this._getCellsExpanded();
            var rowCells = cells[cellPos.row + (this.getRowspan(cell) - 1)];
            var rlen     = rowCells.length;
            var cellRow  = rows[cellPos.row + (this.getRowspan(cell) - 1)];

            var newRow = document.createElement('tr');

            var processedCells = [];
            for (var i = 0; i < rlen; i++) {
                var rowCell = rowCells[i];
                if (ViperUtil.inArray(rowCell, processedCells) === true) {
                    continue;
                }

                var rowspan = this.getRowspan(rowCell);
                if (rowspan > 1 && rowCell !== cell && (this.getCellPosition(rowCell).row + this.getRowspan(rowCell) - 1) > cellPos.row) {
                    // Increase the rowspan instead of creating a new cell.
                    this.setRowspan(rowCell, (rowspan + 1));
                } else {
                    var newCell = document.createElement(ViperUtil.getTagName(rowCell));
                    this._initCell(newCell);

                    var colspan = this.getColspan(rowCell);
                    if (colspan > 1) {
                        this.setColspan(newCell, colspan);
                    }

                    newRow.appendChild(newCell);
                }

                processedCells.push(rowCell);
            }//end for

            ViperUtil.insertAfter(cellRow, newRow);

            this.tableUpdated();

        },

        removeRow: function(cell)
        {
            var table   = this.getCellTable(cell);
            var tr      = this.getCellRow(cell);
            var cellPos = this.getCellPosition(cell);
            var cells   = this._getCellsExpanded();
            var rowspan = this.getRowspan(cell);

            var nextRowIndex = (cellPos.row + rowspan);
            var nextRow      = tr;
            for (var i = 0; i < rowspan; i++) {
                var rowToRemove = nextRow;
                nextRow         = this.getNextRow(nextRow);
                rowToRemove.parentNode.removeChild(rowToRemove);
            }

            var rowCells    = cells[cellPos.row];
            var cellsToMove = [];
            for (var i = 0; i < rowCells.length; i++) {
                var rowCell        = rowCells[i];
                var rowCellPos     = this.getCellPosition(rowCell);
                var rowCellRowspan = this.getRowspan(rowCell);
                if (rowCellPos.row !== cellPos.row || rowCellRowspan > rowspan) {
                    if (rowCellPos.row === cellPos.row) {
                        cellsToMove.push(rowCell);
                    }

                    this.setRowspan(rowCell, (rowCellRowspan - rowspan));
                }
            }

            for (var i = 0; i < cellsToMove.length; i++) {
                var rowCell        = cellsToMove[i];
                var rowCellPos     = this.getCellPosition(rowCell);
                var rowCellRowspan = this.getRowspan(rowCell);
                rowCells           = cells[(cellPos.row + rowspan)];

                var index = ViperUtil.arraySearch(rowCell, rowCells);
                if (index > 0) {
                    for (var j = (index - 1); j >= 0; j--) {
                        if (this.getCellPosition(rowCells[j]).row === nextRowIndex) {
                            ViperUtil.insertAfter(rowCells[j], rowCell);
                            break;
                        }
                    }
                } else if (index === 0) {
                    for (var j = 0; j < rowCells.length; j++) {
                        if (this.getCellPosition(rowCells[j]).row === nextRowIndex) {
                            ViperUtil.insertBefore(rowCells[j], rowCell);
                            break;
                        }
                    }
                }
            }//end for

            // If the table is now empty then remove it.
            var rows = ViperUtil.getTag('tr', table);
            if (rows.length === 0) {
                ViperUtil.remove(table);
            }

            this.tableUpdated(table);

        },

        insertColAfter: function(cell)
        {
            var table  = this.getCellTable(cell);
            var rows   = ViperUtil.getTag('tr', table);
            var rln    = rows.length;
            var colNum = (this.getColNum(cell) + (this.getColspan(cell) - 1));

            var td = null;
            for (var i = 0; i < rln; i++) {
                var col     = this.getCell(i, colNum);
                var cellPos = this.getCellPosition(col);

                if ((cellPos.col !== colNum && col !== cell) || (col !== cell && this.getColspan(col) > 1)) {
                    this.setColspan(col, (this.getColspan(col) + 1));
                } else if (cellPos.row < i) {
                    if (td) {
                        this.setRowspan(td, (this.getRowspan(td) + 1));
                    }

                    continue;
                } else {
                    td = document.createElement(col.tagName);
                    this._initCell(td);

                    ViperUtil.insertAfter(col, td);
                }
            }

            this.tableUpdated();

        },

        insertColBefore: function(cell)
        {
            var table  = this.getCellTable(cell);
            var rows   = ViperUtil.getTag('tr', table);
            var rln    = rows.length;
            var colNum = this.getColNum(cell);

            var td = null;
            for (var i = 0; i < rln; i++) {
                var col     = this.getCell(i, colNum);
                var cellPos = this.getCellPosition(col);

                if (cellPos.col !== colNum && col !== cell) {
                    this.setColspan(col, (this.getColspan(col) + 1));
                } else if (cellPos.row < i) {
                    if (td) {
                        this.setRowspan(td, (this.getRowspan(td) + 1));
                    }

                    continue;
                } else {
                    td = document.createElement(col.tagName);
                    this._initCell(td);

                    ViperUtil.insertBefore(col, td);
                }
            }

            this.tableUpdated();

        },

        getColumnCells: function(table, colNum)
        {
            if (!table) {
                return;
            }

            var cols = [];
            var rows = ViperUtil.getTag('tr', table);
            var rln  = rows.length;
            for (var i = 0; i < rln; i++) {
                cols.push(this.getCell(rows[i], colNum));
            }

            return cols;

        },

        removeCol: function(cell)
        {
            var table    = this.getCellTable(cell);
            var cellPos  = this.getCellPosition(cell);
            var cells    = this._getCellsExpanded();
            var rowCount = cells.length;
            var colspan  = this.getColspan(cell);

            var processedCells = [];
            for (var i = 0; i < rowCount; i++) {
                for (var j = cellPos.col; j < (cellPos.col + colspan); j++) {
                    var rowCell = cells[i][j];
                    if (ViperUtil.inArray(rowCell, processedCells) === true) {
                        continue;
                    }

                    var rowCellColspan = this.getColspan(rowCell);
                    if (rowCellColspan > colspan || (rowCellColspan > 1 && this.getCellPosition(rowCell).col !== cellPos.col)) {
                        // Reduce colspan.
                        this.setColspan(rowCell, (rowCellColspan - 1));
                    } else {
                        // Remove cell.
                        ViperUtil.remove(rowCell);
                    }

                    processedCells.push(rowCell);
                }
            }

            // If the table is now empty then remove it.
            var rows = ViperUtil.getTag('td', table);
            if (rows.length === 0) {
                ViperUtil.remove(table);
            }

            this.tableUpdated(table);

        },

        getNextCell: function(cell)
        {
            var pos = this.getCellPosition(cell);
            if (!pos) {
                return null;
            }

            var nextCell = this.getCell(pos.row, (pos.col + this.getColspan(cell)));
            return nextCell;

        },

        getPreviousCell: function(cell)
        {
            var pos = this.getCellPosition(cell);
            if (!pos) {
                return null;
            }

            var prevCell = this.getCell(pos.row, (pos.col - 1));
            return prevCell;

        },

        moveCaretToCell: function(cell)
        {
            if (cell) {
                var range = this.viper.getCurrentRange();
                var child = range._getFirstSelectableChild(cell);
                if (!child) {
                    this._initCell(cell);
                    child = cell.firstChild;
                }

                // IE cannot jump between cells, so select the node first and then adjust
                // its location.
                range.selectNode(child);
                range.setEnd(child, 0);
                range.collapse(false);
                ViperSelection.addRange(range);

                this.setActiveCell(cell);
                this.showCellToolsIcon(cell);

                return range;
            } else {
                this.hideCellToolsIcon();
            }

        },

        moveCaretToNextCell: function()
        {
            var range = this.viper.getCurrentRange();
            var cell  = this._getRangeCellElement(range);

            if (!cell) {
                return false;
            }

            this.setActiveCell(cell);

            var node = cell;
            while (node) {
                if (!node.nextSibling) {
                    // Get next row.
                    var nextRow = this.getNextRow(node.parentNode);
                    if (!nextRow) {
                        return false;
                    } else {
                        node = nextRow.firstChild;
                    }
                } else {
                    node = node.nextSibling;
                }

                if (ViperUtil.isTag(node, 'th') === true || ViperUtil.isTag(node, 'td') === true) {
                    break;
                }
            }

            if (!node) {
                return false;
            }

            this.moveCaretToCell(node);

            return true;

        },

        moveCaretToPreviousCell: function()
        {
            var range = this.viper.getCurrentRange();
            var cell  = this._getRangeCellElement(range);

            if (!cell) {
                return false;
            }

            this.setActiveCell(cell);

            var node = cell;
            while (node) {
                if (!node.previousSibling) {
                    // Get next row.
                    var previousRow = this.getPreviousRow(node.parentNode);
                    if (!previousRow) {
                        return false;
                    } else {
                        node = previousRow.lastChild;
                    }
                } else {
                    node = node.previousSibling;
                }

                if (ViperUtil.isTag(node, 'th') === true || ViperUtil.isTag(node, 'td') === true) {
                    break;
                }
            }

            if (!node) {
                return false;
            }

            this.moveCaretToCell(node);

            return true;

        },

        removeTable: function(table, emptyOnly)
        {
            if (emptyOnly === true) {
                // Check if the table is empty (no cols);.
                if (ViperUtil.find(table, 'tr > td').length > 0 || ViperUtil.find(table, 'tr > th').length > 0) {
                    return;
                }
            }

            if (ViperUtil.isBrowser('firefox') === true) {
                this.viper.focus();
            }

            this.hideCellToolsIcon();

            this.viper.moveCaretAway(table);

            ViperUtil.remove(table);

            this.viper.contentChanged();
        },

        getCellTable: function(cell)
        {
            if (!cell) {
                return null;
            }

            var node = cell;
            while (node) {
                if (node.nodeType === ViperUtil.ELEMENT_NODE) {
                    var tagName = node.tagName.toLowerCase();
                    if (tagName === 'table') {
                        return node;
                    }
                }

                node = node.parentNode;
            }

        },

        getRowTable: function(row, tbody)
        {
            return this.getCellTable(row);

        },

        getCellRow: function(cell)
        {
            var rows    = ViperUtil.getTag('tr', this.getCellTable(cell));
            var cellPos = this.getCellPosition(cell);
            return rows[cellPos.row];

        },

        
        _createToolbarEditorBubble: function()
        {
            var main = document.createElement('div');

            var maxRows            = 6;
            var maxCols            = 8;
            var selectedRows       = 3;
            var selectedCols       = 4;
            var selectedHeaderType = 2;

            var content    = '';
            var sizePicker = '<p class="VTEP-bubble-label Viper-sizeLabel">Size (' + selectedCols + ' x ' + selectedRows + ')</p>';
            sizePicker    += '<table class="VTEP-bubble-table Viper-sizePicker"><tbody>';
            for (var i = 0; i < maxRows; i++) {
                sizePicker += '<tr>';
                for (var j = 0; j < maxCols; j++) {
                    var classAttr = '';
                    if (selectedRows > i && selectedCols > j) {
                        classAttr = ' class="Viper-selected"';
                    }

                    sizePicker += '<td data-viper-rowcol="' + i + ', ' + j + '"' + classAttr + ' ></td>';
                }

                sizePicker += '</tr>';
            }

            sizePicker += '</tbody></table>';
            content    += sizePicker;

            var headerOpts      = this._headerOptions;
            var headerOptTitles = [_('None'), _('Left'), _('Top'), _('Both')];
            var headers = '<p class="VTEP-bubble-label Viper-headers">' + _('Headers') + '</p><div class="VTEP-bubble-headersWrapper">';
            for (var h = 0; h < headerOpts.length; h++) {
                var selected = '';
                if (h === selectedHeaderType) {
                    selected = ' Viper-selected';
                }

                headers    += '<div class="VTEP-bubble-headersTableWrapper' + selected + '">';
                headers    += '<table class="VTEP-bubble-table Viper-headers"><tbody>';
                var c = 0;
                for (var i = 0; i < 3; i++) {
                    headers += '<tr>';
                    for (var j = 0; j < 3; j++) {
                        if (headerOpts[h] && headerOpts[h][c]) {
                            headers += '<td class="Viper-hover"></td>';
                        } else {
                            headers += '<td></td>';
                        }

                        c++;
                    }

                    headers += '</tr>';
                }

                headers += '</tbody></table>';
                headers += '<span class="VTEP-bubble-headerTitle">' + headerOptTitles[h] + '</span></div>';
            }

            headers += '</div>';
            content += headers;

            ViperUtil.setHtml(main, content);

            var trs = ViperUtil.getTag('tr', ViperUtil.getClass('Viper-sizePicker', main)[0]);

            var _setRowColsActive = function(row, col) {
                selectedRows = (parseInt(row) + 1);
                selectedCols = (parseInt(col) + 1);

                ViperUtil.setHtml(ViperUtil.getClass('Viper-sizeLabel', main)[0], _('Size') + ' (' + selectedCols + ' x ' + selectedRows + ')');

                for (var i = 0; i < maxRows; i++) {
                    for (var j = 0; j < maxCols; j++) {
                        if (i <= row && j <= col) {
                            ViperUtil.addClass(trs[i].childNodes[j], 'Viper-selected');
                        } else {
                            ViperUtil.removeClass(trs[i].childNodes[j], 'Viper-selected');
                        }
                    }
                }
            };

            var _setRowColsHover = function(row, col) {

                ViperUtil.setHtml(ViperUtil.getClass('Viper-sizeLabel', main)[0], _('Size') + ' (' + (parseInt(col) + 1) + ' x ' + (parseInt(row) + 1) + ')');

                for (var i = 0; i < maxRows; i++) {
                    for (var j = 0; j < maxCols; j++) {
                        if (i <= row && j <= col) {
                            ViperUtil.addClass(trs[i].childNodes[j], 'Viper-hover');
                        } else {
                            ViperUtil.removeClass(trs[i].childNodes[j], 'Viper-hover');
                        }
                    }
                }
            };

            var tdHover        = null;
            var sizePickerElem = ViperUtil.getClass('Viper-sizePicker', main)[0];
            ViperUtil.addEvent(sizePickerElem, 'mousemove', function(e) {
                var td = ViperUtil.getMouseEventTarget(e);
                if (td !== tdHover && ViperUtil.isTag(td, 'td') === true) {
                    tdHover = td;
                    var rowcol = td.getAttribute('data-viper-rowcol').split(',');
                    _setRowColsHover(rowcol[0], rowcol[1]);
                }
            });

            ViperUtil.addEvent(sizePickerElem, 'click', function(e) {
                var td = ViperUtil.getMouseEventTarget(e);
                if (td && ViperUtil.isTag(td, 'td') === true) {
                    var rowcol = td.getAttribute('data-viper-rowcol').split(',');
                    _setRowColsActive(rowcol[0], rowcol[1]);
                }
            });

            ViperUtil.hover(sizePickerElem, function() {}, function() {
                ViperUtil.removeClass(ViperUtil.getClass('Viper-hover', sizePickerElem), 'Viper-hover');
                ViperUtil.setHtml(ViperUtil.getClass('Viper-sizeLabel', main)[0], _('Size') + ' (' + selectedRows + ' x ' + selectedCols + ')');
            })

            var headerTables       = ViperUtil.getClass('VTEP-bubble-headersTableWrapper', main);
            for (var i = 0; i < headerTables.length; i++) {
                (function(type) {
                    ViperUtil.addEvent(headerTables[type], 'click', function(e) {
                        selectedHeaderType = type;
                        ViperUtil.removeClass(headerTables, 'Viper-selected');
                        ViperUtil.addClass(headerTables[type], 'Viper-selected');
                    });
                }) (i);
            }

            var self = this;
            var insertTableBtn = this.viper.Tools.createButton('VTEP-insertTableButton', _('Insert Table'), _('Insert Table'), '', function() {
                self.toolbarPlugin.closeBubble('VTEP-bubble');
                self.insertTable(selectedRows, selectedCols, selectedHeaderType);
            });
            main.appendChild(insertTableBtn);

            this.toolbarPlugin.createBubble('VTEP-bubble', _('Insert Table'), main);
            this.toolbarPlugin.setBubbleButton('VTEP-bubble', 'insertTable', true);

        },

        insertTable: function(rows, cols, headerType, tableid)
        {
            this.viper.HistoryManager.begin();

            rows = rows || 3;
            cols = cols || 3;

            var table = document.createElement('table');
            // First hide the table so we can determine if there are borders etc.
            ViperUtil.setStyle(table, 'display', 'none');

            // Create a table id.
            if (!tableid) {
                while (!tableid) {
                    tableid   = 'table' + ViperUtil.getUniqueId().substr(-5, 5);
                    var tElem = ViperUtil.getid(tableid);
                    if (tElem) {
                        tableid = null;
                    }
                }
            }

            table.setAttribute('id', tableid);

            var tbody      = document.createElement('tbody');
            var firstCol   = null;
            var headerOpts = this._headerOptions;
            var thead      = null;

            if (headerType === 2 || headerType === 3) {
                thead = document.createElement('thead');
            }

            for (var i = 0; i < rows; i++) {
                var tr = document.createElement('tr');
                for (var j = 0; j < cols; j++) {
                    var cell     = null;
                    var isHeader = false;
                    if (headerType === 1 && j === 0) {
                        isHeader = true;
                    } else if (headerType === 2 && i === 0) {
                        isHeader = true;
                    } else if (headerType === 3 && (i === 0 || j === 0)) {
                        isHeader = true;
                    }

                    if (isHeader) {
                        cell = document.createElement('th');
                    } else {
                        cell = document.createElement('td');
                    }

                    this._initCell(cell);

                    tr.appendChild(cell);

                    if (firstCol === null) {
                        firstCol = cell;
                    }
                }//end for

                if (thead) {
                    table.appendChild(thead);
                    thead.appendChild(tr);
                    thead = null;
                } else {
                    tbody.appendChild(tr);
                }
            }//end for

            table.appendChild(tbody);

            // Insert table to the bookmarks position.
            var viperHtml = ViperUtil.trim(this.viper.getHtml());
            if (viperHtml === '' || viperHtml === '<p>&nbsp;</p>' || viperHtml === '<p></p>') {
                ViperUtil.empty(this.viper.getViperElement());
                this.viper.getViperElement().appendChild(table);
            } else {
                var prevNode = this.viper.getKeyboardHandler().splitAtRange(true);
                if (ViperUtil.isTag(prevNode, 'li') === true) {
                    prevNode.appendChild(table);
                    if (ViperUtil.isBlank(ViperUtil.getNodeTextContent(prevNode.nextSibling)) === true) {
                        ViperUtil.remove(prevNode.nextSibling);
                    }
                } else {
                    ViperUtil.insertAfter(prevNode, table);
                }
            }

            // Now determine if we need to add borders or width to this table.
            // Done over here so that if there are CSS styles applied to tables
            // then we don't override them.
            var width = parseInt(ViperUtil.getComputedStyle(table, 'width'));
            if (!width) {
                ViperUtil.setStyle(table, 'width', '100%');
            }

            var col         = ViperUtil.getTag('td,th', table)[0];
            var rightWidth  = parseFloat(ViperUtil.getComputedStyle(col, 'border-right-width'));
            var bottomWidth = parseFloat(ViperUtil.getComputedStyle(col, 'border-bottom-width'));

            if (bottomWidth === 0
                || rightWidth === 0
                || isNaN(bottomWidth) === true
                || isNaN(rightWidth) === true
            ) {
                ViperUtil.attr(table, 'border', 1);
            }

            ViperUtil.setStyle(table, 'display', '');
            if (!table.getAttribute('style')) {
                table.removeAttribute('style');
            }

            if (firstCol) {
                var range = this.viper.getCurrentRange();
                range.setStart(firstCol.firstChild, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
                this.setActiveCell(firstCol);
            }

            this.viper.contentChanged();

            this.setTableHeaders(table);

            this.viper.HistoryManager.end();

            return table;

        },

        setTableHeaders: function(table)
        {
            if (!table) {
                return;
            }

            var headers      = ViperUtil.find(table, '[headers]');
            var headersCount = headers.length;
            if (headersCount > 0) {
                for (var i = 0; i < headersCount; i++) {
                    var headersAttr = headers[i].getAttribute('headers');
                    if (headersAttr) {
                        headersAttr = ' ' + headersAttr;
                        if (headersAttr.match(/\s[\w\d]+r\d+c\d+/)) {
                            // If this is a Viper type headers attribute then remove it.
                            headers[i].removeAttribute('headers');
                        }
                    }
                }
            }

            headers = null;

            var thElements = ViperUtil.getTag('th', table);
            if (thElements.length === 0) {
                return;
            }

            var tableId = table.getAttribute('id');

            if (!tableId) {
                while (!tableId) {
                    var uniqueid = ViperUtil.getUniqueId();
                    tableId   = 'table' + uniqueid.substr((uniqueid.length - 5), 5);
                    var tElem = ViperUtil.getid(tableId);
                    if (tElem) {
                        tableId = null;
                    }
                }

                table.setAttribute('id', tableId);
            }

            var tableRows = ViperUtil.getTag('tr', table);
            for (var k = 0; k < tableRows.length; k++) {
                var row = tableRows[k];

                var cellCount = 0;
                for (var j = 0; j < row.childNodes.length; j++) {
                    var cell = row.childNodes[j];

                    // Skip text nodes.
                    if (cell.nodeType === ViperUtil.TEXT_NODE) {
                        continue;
                    }

                    if (ViperUtil.isTag(cell, 'th') === true) {
                        // This is a table header, so figure out an ID-based representation
                        // of the cell content. We'll use this later as a basis for the ID attribute
                        // although it may be prefixed with the ID of another header to make it unique.
                        var cellid = cell.getAttribute('id');
                        if (!cellid || cellid.match(/r\d+c\d+/)) {
                            cellid = tableId + 'r' + (k + 1) + 'c' + (cellCount + 1);
                            var existingElem = ViperUtil.getid(cellid);
                            if (existingElem) {
                                existingElem.removeAttribute('id');
                            }

                            cell.setAttribute('id', cellid);
                        }
                    }

                    cellCount++;
                }//end for
            }//end for

            // Get HTMLCS to give us the correct table headers...
            if (window['HTMLCS']) {
                var headers = HTMLCS.util.getCellHeaders(table);
                var c       = headers.length;
                for (var i = 0; i < c; i++) {
                    var header      = headers[i];
                    var headersAttr = header.cell.getAttribute('headers');
                    if (!headersAttr || (' ' + headersAttr).match(/\stable\d+r\d+c\d+/)) {
                        header.cell.setAttribute('headers', header.headers);
                    }
                }
            }

        },

        getHeadersContent: function(element)
        {
            var headers = element.getAttribute('headers');
            if (!headers) {
                return '';
            }

            var parts   = headers.split(' ');
            var content = [];
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];

                content.push(ViperUtil.getHtml(ViperUtil.getid(part)));
            }

            content.push(ViperUtil.getHtml(element));
            content = content.join(' ');

            return content;

        },

        getCellContent: function (table, row, column)
        {
            var rows = ViperUtil.getTag('tr', table);
            if (!rows[row]) {
                return null;
            }

            var rowElem = rows[row];

            var cols = ViperUtil.getTag('td,th', rowElem);
            if (!cols[column]) {
                return null;
            }

            return ViperUtil.getHtml(cols[column]);

        },

        _setCaretToStart: function(table)
        {
            // Set the caret to the first cell of the table.
            var cells = ViperUtil.getTag('td,th', table);
            if (cells.length > 0) {
                if (ViperUtil.getHtml(cells[0]) === '') {
                    ViperUtil.setHtml(cells[0], '&nbsp;');
                }

                var cell  = cells[0];
                var range = this.viper.getCurrentRange();
                var child = range._getFirstSelectableChild(cell);
                if (!child && cell.childNodes.length === 1) {
                    child = cell.childNodes[0];
                }

                range.setStart(child, 0);
                range.collapse(true);
                ViperSelection.addRange(range);
            }

        },

        _getRangeCellElement: function(range)
        {
            return this._getCellElement(range.getCommonElement());

        },

        _getCellElement: function(element)
        {
            var cellElement = null;
            if (ViperUtil.isTag(element, 'td') === false
                && ViperUtil.isTag(element, 'th') === false
            ) {
                // Check if any of the parents td or th.
                var parents = ViperUtil.getParents(element, null, this.viper.getViperElement());
                var plen    = parents.length;
                for (var i = 0; i < plen; i++) {
                    if (ViperUtil.isTag(parents[i], 'td') === true
                        || ViperUtil.isTag(parents[i], 'th') === true
                    ) {
                        cellElement = parents[i];
                        break;
                    }
                }
            } else {
                cellElement = element;
            }

            if (!cellElement) {
                return false;
            }

            return cellElement;

        },

        _getTableCells: function(table, stopCell)
        {
            if (!table) {
                table = this.getCellTable(this.getActiveCell());
            }

            var cells = {};
            var rows  = ViperUtil.getTag('tr', table);
            var rlen  = rows.length;
            for (var i = 0; i < rlen; i++) {
                var rowCells      = this._getRowCells(rows[i]);
                var rowCellsCount = rowCells.length;
                cells[i]          = [];
                for (var j = 0; j < rowCellsCount; j++) {
                    cells[i].push({
                        cell: rowCells[j],
                        rowspan: this.getRowspan(rowCells[j]),
                        colspan: this.getColspan(rowCells[j])
                    });

                    if (stopCell === rowCells[j]) {
                        return cells;
                    }
                }
            }

            return cells;

        },

        _getRowNum: function(row)
        {
            var table = this.getRowTable(row, true);
            var rows  = ViperUtil.getTag('tr', table);
            var rlen  = rows.length;
            for (var i = 0; i < rlen; i++) {
                if (rows[i] === row) {
                    return i;
                }
            }

            return null;

        },

        getColNum: function(cell)
        {
            if (!cell) {
                return null;
            }

            var cellNum = null;
            var cells   = this._getCellsExpanded();
            var rows    = cells.length;

            for (var i = 0; i < rows; i++) {
                var cellCount = cells[i].length;
                for (var j = 0; j < cellCount; j++) {
                    if (cells[i][j] === cell) {
                        return j;
                    }
                }
            }

            return null;

        },

        
        getCell: function(row, cell)
        {
            if (ViperUtil.isset(cell) === false) {
                return null;
            }

            if (typeof row !== 'number') {
                row = this._getRowNum(row);
            }

            var cells = this._getCellsExpanded();

            return cells[row][cell];

        },

        getCellPosition: function(cell)
        {
            var cells = this._getCellsExpanded();
            var rows  = cells.length;

            for (var i = 0; i < rows; i++) {
                var cellCount = cells[i].length;
                for (var j = 0; j < cellCount; j++) {
                    if (cells[i][j] === cell) {
                        return {
                            row: i,
                            col: j
                        };
                    }
                }
            }

            return null;

        },

        _getCellsExpanded: function(forceUpdate)
        {
            if (forceUpdate !== true && this._tableRawCells) {
                return this._tableRawCells;
            }

            var tableCells = this._getTableCells();
            var rawCells   = [];
            ViperUtil.foreach(tableCells, function(rowNum) {
                rowNum = parseInt(rowNum);
                if (!rawCells[rowNum]) {
                    rawCells[rowNum] = [];
                }

                ViperUtil.foreach(tableCells[rowNum], function(j) {
                    var rowCell  = tableCells[rowNum][j].cell;
                    var rowspan  = tableCells[rowNum][j].rowspan;
                    var colspan  = tableCells[rowNum][j].colspan;
                    var modifier = 0;
                    for (var i = 0; i < rowspan; i++) {
                        for (var k = 0; k < colspan; k++) {
                            if (!rawCells[(rowNum + i)]) {
                                rawCells[(rowNum + i)] = [];
                            }

                            while (rawCells[(rowNum + i)][(j + k + modifier)]) {
                                modifier++;
                            }

                            rawCells[(rowNum + i)][(j + k + modifier)] = rowCell;
                        }
                    }
                });
            });

            this._tableRawCells = rawCells;

            return rawCells;

        },

        getPreviousRow: function(row, ignorePrevParent)
        {
            var sourceRow = row;
            while (row = row.previousSibling) {
                if (row.nodeType === ViperUtil.ELEMENT_NODE) {
                    var tagName = row.tagName.toLowerCase();
                    if (tagName === 'tr') {
                        return row;
                    }
                }
            }

            if (ignorePrevParent !== true && ViperUtil.isTag(sourceRow.parentNode, 'tbody') === true) {
                var rows = ViperUtil.getTag('tr', ViperUtil.getTag('thead', this.getRowTable(sourceRow)));
                if (rows.length > 0) {
                    return rows[(rows.length - 1)];
                }
            }

        },

        getNextRow: function(row, ignoreNextParent)
        {
            var sourceRow = row;
            while (row = row.nextSibling) {
                if (row.nodeType === ViperUtil.ELEMENT_NODE) {
                    var tagName = row.tagName.toLowerCase();
                    if (tagName === 'tr') {
                        return row;
                    }
                }
            }

            if (ignoreNextParent !== true && ViperUtil.isTag(sourceRow.parentNode, 'thead') === true) {
                var rows = ViperUtil.getTag('tr', ViperUtil.getTag('tbody', this.getRowTable(sourceRow)));
                if (rows.length > 0) {
                    return rows[0];
                }
            }

        },

        _getRowCells: function(row)
        {
            var tags = ViperUtil.getTag('td,th', row);
            return tags;

        },

        _getRowCellCount: function(row)
        {
            var cellCount = 0;
            for (var node = row.firstChild; node; node = node.nextSibling) {
                if (ViperUtil.isTag(node, 'th') === true || ViperUtil.isTag(node, 'td') === true) {
                    cellCount += this.getColspan(node);
                }
            }

            return cellCount;

        },

        _moveCellContent: function(fromCell, toCell)
        {
            if (!fromCell || !toCell) {
                return false;
            }

            if (toCell.lastChild && ViperUtil.isTag(toCell.lastChild, 'br') === true) {
                ViperUtil.remove(toCell.lastChild);
            }

            while (fromCell.firstChild) {
                if (ViperUtil.isTag(fromCell.firstChild, 'br') === true) {
                    ViperUtil.remove(fromCell.firstChild);
                } else if (fromCell.firstChild.nodeType !== ViperUtil.TEXT_NODE
                    || ViperUtil.trim(fromCell.firstChild.data) !== ''
                ) {
                    toCell.appendChild(fromCell.firstChild);
                } else {
                    ViperUtil.remove(fromCell.firstChild);
                }
            }

            if (!toCell.lastChild) {
                this._initCell(toCell);
            }

        },

        isPluginElement: function(element)
        {
            if (element === this._highlightElement) {
                return true;
            }

            return false;

        },

        _initCell: function(cell)
        {
            if (ViperUtil.isBrowser('msie') === true) {
                if (ViperUtil.trim(ViperUtil.getHtml(cell)) === '') {
                    ViperUtil.setHtml(cell, '<br />');
                }
            } else {
                ViperUtil.setHtml(cell, '<br />');
            }

        }

    };
})(Viper.Util, Viper.Selection, Viper._);


(function(ViperUtil, ViperSelection, _) {
    function ViperToolbarPlugin(viper)
    {
        this.viper    = viper;
        this._toolbar = null;

        this._activeBubble   = null;
        this._bubbles        = {};
        this._bubbleButtons  = {};
        this._settingButtons = null;
        this._enabled        = false;
        this._enabledButtons = [];

        this.createToolbar();

        var self           = this;
        var clickedOutside = false;
        this.viper.registerCallback('Viper:selectionChanged', 'ViperToolbarPlugin', function(range) {
            if (clickedOutside === true || self.viper.rangeInViperBounds(range) === false) {
                return;
            }

            if (self._enabled !== true) {
                self.enable();
            }

            self._updateToolbar(range);
        });

        this.viper.registerCallback('Viper:editableElementChanged', 'ViperToolbarPlugin', function(range) {
                self._updateToolbar();
        });

        this.viper.registerCallback('Viper:enabled', 'ViperToolbarPlugin', function(range) {
            self._updateToolbar();
        });

        this.viper.registerCallback('Viper:disabled', 'ViperToolbarPlugin', function(range) {
                self.disable();
        });

        this.viper.registerCallback('Viper:clickedOutside', 'ViperToolbarPlugin', function(range) {
            clickedOutside = true;

            // Disable all buttons.
            self.disable();
        });

        this.viper.registerCallback('Viper:clickedInside', 'ViperToolbarPlugin', function(range) {
            clickedOutside = false;
        });

        this.viper.registerCallback('Viper:focused', 'ViperToolbarPlugin', function(range) {
            self.enable();
        });

        this.viper.registerCallback('Viper:mouseDown', 'ViperToolbarPlugin', function() {
            if (self._activeBubble) {
                var bubble = self.getBubble(self._activeBubble);
                if (bubble && bubble.getSetting('keepOpen') !== true) {
                    self.closeBubble(self._activeBubble);
                }
            }
        });

        this.viper.registerCallback('Viper:destroy', 'ViperToolbarPlugin', function(range) {
            self.remove();
        });

    }

    Viper.PluginManager.addPlugin('ViperToolbarPlugin', ViperToolbarPlugin);

    ViperToolbarPlugin.prototype = {
        init: function()
        {
            this.viper.addElement(this._toolbar);

        },

        setSettings: function(settings)
        {
            if (!settings) {
                return;
            }

            if (settings.parent) {
                var parent = settings.parent;
                if (typeof parent === 'string') {
                    parent = ViperUtil.getid(settings.parent);
                }

                this.setParentElement(parent);
            }

            if (settings.buttons) {
                this.setButtons(settings.buttons);
            }

        },

        setButtons: function(buttons)
        {
            this._settingButtons = buttons;

            // Remove all buttons that were added by other plugins.
            while(this._toolbar.firstChild) {
                this._toolbar.removeChild(this._toolbar.firstChild);
            }

            var buttonsLen = buttons.length;
            for (var i = 0; i < buttonsLen; i++) {
                if (typeof buttons[i] === 'string') {
                    // Single button.
                    var button = this.viper.Tools.getItem(buttons[i]);
                    if (!button || button.type !== 'button') {
                        throw new Error('Invalid button type: ' + buttons[i]);
                    }

                    this._toolbar.appendChild(button.element);
                } else if (buttons[i].length) {
                    // Create button group.
                    var groupid = 'ViperToolbarPlugin:buttons:' + i;
                    var group   = this.viper.Tools.createButtonGroup(groupid);

                    var subButtonsLen = buttons[i].length;
                    for (var j = 0; j < subButtonsLen; j++) {
                        var button = this.viper.Tools.getItem(buttons[i][j]);
                        if (!button || button.type !== 'button') {
                            throw new Error('Invalid button type: ' + buttons[i][j]);
                        }

                        this.viper.Tools.addButtonToGroup(buttons[i][j], groupid);
                    }

                    this._toolbar.appendChild(group);
                }
            }

            this._settingButtons = null;

        },

        createToolbar: function()
        {
            var elem = document.createElement('div');


            ViperUtil.addClass(elem, 'ViperTP-bar Viper-themeDark Viper-scalable');
            this._toolbar = elem;
            ViperUtil.addClass(this._toolbar, 'viper-inactive');
            ViperUtil.addClass(this._toolbar, this.viper.getElementHolder().className);

            ViperUtil.addEvent(elem, 'mousedown', function(e) {
                var target = ViperUtil.getMouseEventTarget(e);
                if (ViperUtil.isTag(target, 'input') !== true
                    && ViperUtil.isTag(target, 'textarea') !== true
                    && ViperUtil.isTag(target, 'select') !== true
                ) {
                    ViperUtil.preventDefault(e);
                    return false;
                }
            });

            ViperUtil.addEvent(elem, 'mouseup', function(e) {
                var target = ViperUtil.getMouseEventTarget(e);
                if (ViperUtil.isTag(target, 'input') !== true
                    && ViperUtil.isTag(target, 'textarea') !== true
                    && ViperUtil.isTag(target, 'select') !== true
                ) {
                    ViperUtil.preventDefault(e);
                    return false;
                }
            });

            if (navigator.userAgent.match(/iPad/i) !== null) {
                ViperUtil.addClass(this._toolbar, 'device-ipad');
            }

        },

        setParentElement: function(parent)
        {
            ViperUtil.setStyle(this._toolbar, 'position', 'absolute');
            ViperUtil.setStyle(this._toolbar, 'top', '0px');
            parent.appendChild(this._toolbar);

            this.positionUpdated();

        },

        positionUpdated: function()
        {
            this.positionBubble();
            this.viper.fireCallbacks('ViperToolbarPlugin:positionUpdated');

        },

        
        addButton: function(button)
        {
            if (!this._settingButtons) {
                this._toolbar.appendChild(button);
            }

        },

        createBubble: function(id, title, subSectionElement, toolsElement, openCallback, closeCallback, customClass)
        {
            title = title || '&nbsp;';

            var bubble = document.createElement('div');
            ViperUtil.addClass(bubble, 'ViperITP Viper-themeDark Viper-visible Viper-forTopbar');
            ViperUtil.setHtml(bubble, '<div class="ViperITP-header">' + title + '</div>');

            ViperUtil.addEvent(bubble, 'mousedown', function(e) {
                var target = ViperUtil.getMouseEventTarget(e);
                if (ViperUtil.isTag(target, 'input') !== true
                    && ViperUtil.isTag(target, 'textarea') !== true
                    && ViperUtil.isTag(target, 'select') !== true
                ) {
                    ViperUtil.preventDefault(e);
                    return false;
                }
            });

            if (toolsElement) {
                var wrapper = document.createElement('div');
                ViperUtil.addClass(wrapper, 'ViperITP-tools');
                bubble.appendChild(wrapper);
                wrapper.appendChild(toolsElement);
            }

            if (customClass) {
                ViperUtil.addClass(bubble, customClass);
            }

            var self = this;

            this._bubbles[id] = bubble;
            var bubbleObj     = {
                type: 'VTPBubble',
                element: bubble,
                addSubSection: function(id, element) {
                    var wrapper = ViperUtil.getClass('ViperITP-subSectionWrapper', bubble);
                    if (wrapper.length > 0) {
                        wrapper = wrapper[0];
                    } else {
                        wrapper = document.createElement('div');
                        ViperUtil.setHtml(wrapper, '<span class="Viper-subSectionArrow"></span>');
                        ViperUtil.addClass(wrapper, 'ViperITP-subSectionWrapper');
                        bubble.appendChild(wrapper);
                    }

                    var form = document.createElement('form');
                    ViperUtil.addClass(form, 'Viper-subSection');
                    form.onsubmit = function() {
                        return false;
                    };

                    var submitBtn  = document.createElement('input');
                    submitBtn.type = 'submit';
                    ViperUtil.setStyle(submitBtn, 'display', 'none');
                    form.appendChild(submitBtn);

                    form.appendChild(element);
                    wrapper.appendChild(form);

                    this._subSections[id] = form;
                    self.viper.Tools.addItem(id, {
                        type: 'VTPSubSection',
                        element: wrapper,
                        form: form
                    });

                    return element;
                },
                showSubSection: function(id) {
                    if (this._activeSubSection) {
                        if (this._activeSubSection !== id) {
                            this.hideSubSection(this._activeSubSection);
                        } else {
                            return;
                        }
                    }

                    ViperUtil.addClass(bubble, 'Viper-subSectionVisible');
                    ViperUtil.addClass(this._subSections[id], 'Viper-active');

                    if (this._subSectionButtons[id]) {
                        var button = this._subSectionButtons[id].element;
                        ViperUtil.addClass(button, 'Viper-selected');

                        // Update the position of the sub section arrow.
                        var subSectionArrow = ViperUtil.getClass('Viper-subSectionArrow', bubble)[0];
                        var pos             = ViperUtil.getBoundingRectangle(button);
                        var bubblePos       = ViperUtil.getBoundingRectangle(bubble);
                        ViperUtil.setStyle(subSectionArrow, 'left', (pos.x1 - bubblePos.x1) + ((pos.x2 - pos.x1) / 2) + 'px');
                        ViperUtil.addClass(subSectionArrow, 'Viper-visible');
                    }

                    var inputElements = ViperUtil.getTag('input[type=text], textarea', this._subSections[id]);
                    if (inputElements.length > 0 && ViperUtil.getElementHeight(inputElements[0]) > 0) {
                        try {
                            setTimeout(function() {
                                inputElements[0].focus();
                            }, 10);
                        } catch(e) {}
                    }

                    this._activeSubSection = id;
                },
                hideSubSection: function(id) {
                    id = id || this._activeSubSection;
                    ViperUtil.removeClass(bubble, 'Viper-subSectionVisible');
                    ViperUtil.removeClass(this._subSections[id], 'Viper-active');
                    this._activeSubSection = null;

                    if (this._subSectionButtons[id]) {
                        ViperUtil.removeClass(this._subSectionButtons[id].element, 'Viper-selected');
                    }
                },
                setSubSectionButton: function(sectionid, buttonid) {
                    if (!this._subSections[sectionid]) {
                        return false;
                    }

                    var button = self.viper.Tools.getItem(buttonid);
                    if (!button || !button.type === 'button') {
                        return false;
                    }

                    this._subSectionButtons[sectionid] = button;
                },
                setSubSectionAction: function(subSectionid, action, widgetids, customButtonid, noFocus) {
                    widgetids      = widgetids || [];
                    var tools      = self.viper.Tools;
                    var subSection = tools.getItem(subSectionid);
                    if (!subSection) {
                        return;
                    }

                    this.updateSubSectionAction(subSectionid, action);

                    var buttonid = customButtonid;

                    var _self = this;

                    subSection.form.onsubmit = function(e) {
                        if (e) {
                            ViperUtil.preventDefault(e);
                        }

                        if (!buttonid) {
                            buttonid = subSectionid + '-applyButton';
                        }

                        var button = tools.getItem(buttonid);
                        if (button.isEnabled() === false) {
                            return false;
                        }

                        if (noFocus !== true) {
                            self.viper.focus();
                        }

                        if (!customButtonid) {
                            tools.disableButton(subSectionid + '-applyButton');
                        }

                        var action = _self.getSubsectionAction(subSectionid);
                        if (ViperUtil.isBrowser('msie') === false) {
                            try {
                                action.call(this);
                            } catch (e) {
                                console.error(e.message);
                            }

                            setTimeout(function() {
                                // Give focus back to the form field.
                                var inputElements = ViperUtil.getTag('input[type=text], textarea', subSection.form);
                                if (inputElements.length > 0) {
                                    try {
                                        inputElements[0].focus();
                                    } catch(e) {}
                                }
                            }, 50);
                        } else {
                            // IE needs this timeout so focus works <3..
                            setTimeout(function() {
                                try {
                                    action.call(this);
                                } catch (e) {
                                    console.error(e.message);
                                }

                                setTimeout(function() {
                                    // Give focus back to the form field.
                                    var inputElements = ViperUtil.getTag('input[type=text], textarea', subSection.form);
                                    if (inputElements.length > 0) {
                                        try {
                                            inputElements[0].focus();
                                        } catch(e) {}
                                    }
                                }, 10);
                            }, 50);
                        }//end if

                        return false;
                    };

                    if (!buttonid) {
                        var button = tools.createButton(subSectionid + '-applyButton', _('Apply Changes'), _('Apply Changes'), '', subSection.form.onsubmit, true);
                        subSection.form.appendChild(button);
                    }

                    this.addSubSectionActionWidgets(subSectionid, widgetids);

                },
                updateSubSectionAction: function (subSectionid, action) {
                    this._subSectionActions[subSectionid] = action;
                },
                getSubsectionAction: function (subSectionid) {
                    return this._subSectionActions[subSectionid];
                },
                addSubSectionActionWidgets: function(subSectionid, widgetids)
                {
                    if (!this._subSectionActionWidgets[subSectionid]) {
                        this._subSectionActionWidgets[subSectionid] = [];
                    }

                    var subsec = this;
                    var tools  = self.viper.Tools;
                    for (var i = 0; i < widgetids.length; i++) {
                        this._subSectionActionWidgets[subSectionid].push(widgetids[i]);
                        (function(widgetid) {
                            self.viper.registerCallback('ViperTools:changed:' + widgetid, 'ViperToolbarPlugin', function() {
                                var subSectionWidgets = subsec._subSectionActionWidgets[subSectionid];
                                var c = subSectionWidgets.length;
                                var enable = true;
                                for (var j = 0; j < c; j++) {
                                    var widget = tools.getItem(subSectionWidgets[j]);
                                    if (widget && widget.required === true && ViperUtil.trim(widget.getValue()) === '') {
                                        enable = false;
                                        break;
                                    }
                                }

                                if (enable === true) {
                                    tools.enableButton(subSectionid + '-applyButton');
                                } else {
                                    tools.disableButton(subSectionid + '-applyButton');
                                }
                            });
                        }) (widgetids[i]);
                    }

                },
                setSetting: function(setting, value) {
                    this._settings[setting] = value;
                },
                getSetting: function(setting) {
                    return this._settings[setting];
                },
                setTitle: function(title) {
                    ViperUtil.setHtml(ViperUtil.getClass('ViperITP-header', bubble)[0], title);
                },
                getActiveSubSection: function() {
                    return this._subSections[this._activeSubSection];
                },
                _settings: {
                    keepOpen: false
                },
                _subSections: {},
                _subSectionButtons: {},
                _activeSubSection: null,
                _openCallback: openCallback,
                _closeCallback: closeCallback,
                _subSectionActionWidgets: {},
                _subSectionActions: {}
            };

            if (subSectionElement) {
                bubbleObj.addSubSection(id + 'SubSection', subSectionElement);
                if (!toolsElement) {
                    bubbleObj.showSubSection(id + 'SubSection');
                }
            }

            this.viper.Tools.addItem(id, bubbleObj);

            return bubble;

        },

        getBubble: function(id)
        {
            return this.viper.Tools.getItem(id);

        },

        setBubbleButton: function(bubbleid, buttonid, useCustomToggler)
        {
            if (!this._bubbles[bubbleid]) {
                // Throw exception not a valid bubble id.
                return false;
            }

            var bubble = this.getBubble(bubbleid);
            var button = this.viper.Tools.getItem(buttonid).element;
            var self   = this;

            this._bubbleButtons[bubbleid] = buttonid;

            if (useCustomToggler !== true) {
                ViperUtil.removeEvent(button, 'mousedown');
                ViperUtil.addEvent(button, 'mousedown', function(e) {
                    if (ViperUtil.isBrowser('msie', '<11') === true) {
                        // This block of code prevents IE moving user selection to the.
                        // button element when clicked. When the button element is removed
                        // and added back to DOM selection is not moved. Seriously, IE?
                        if (button.previousSibling) {
                            var sibling = button.previousSibling;
                            button.parentNode.removeChild(button);
                            ViperUtil.insertAfter(sibling, button);
                        } else if (button.nextSibling) {
                            var sibling = button.nextSibling;
                            button.parentNode.removeChild(button);
                            ViperUtil.insertBefore(sibling, button);
                        } else {
                            var parent = button.parentNode;
                            button.parentNode.removeChild(button);
                            parent.appendChild(button);
                        }
                    }//end if

                    if (ViperUtil.hasClass(button, 'Viper-disabled') === true) {
                        return;
                    }

                    self.toggleBubble(bubbleid);
                    ViperUtil.preventDefault(e);
                });
            }

        },

        toggleBubble: function(bubbleid)
        {
            if (!this._activeBubble || this._activeBubble !== bubbleid) {
                this.showBubble(bubbleid);
                return true;
            } else {
                this.closeBubble(bubbleid);
                return false;
            }

        },

        closeBubble: function(bubbleid)
        {
            if (!this._activeBubble) {
                return;
            }

            if (this._closeBubble(bubbleid) !== false) {
                this.viper.focus();
                this.viper.highlightToSelection();
            }

        },

        _closeBubble: function(bubbleid)
        {
            ViperUtil.removeClass(this.viper.Tools.getItem(this._bubbleButtons[bubbleid]).element, 'Viper-selected');
            var bubble     = this.viper.Tools.getItem(bubbleid);
            var bubbleElem = bubble.element;
            if (bubbleElem.parentNode && bubbleElem.parentNode.nodeType !== ViperUtil.DOCUMENT_FRAGMENT_NODE) {
                bubbleElem.parentNode.removeChild(bubbleElem);
            } else {
                return false;
            }

            if (bubble._closeCallback) {
                bubble._closeCallback.call(this);
            }

            this.viper.fireCallbacks('ViperToolbarPlugin:bubbleClosed', bubbleid);

            if (this._activeBubble === bubbleid) {
                this._activeBubble = null;
            }

            ViperUtil.removeEvent(document, 'keydown.ViperToolbarPluginSubSection');

        },

        showBubble: function(bubbleid)
        {
            if (this._activeBubble) {
                if (this._activeBubble === bubbleid) {
                    // Already showing.
                    return;
                }

                // Hide the current active bubble.
                this._closeBubble(this._activeBubble);
            }

            ViperUtil.addClass(this.viper.Tools.getItem(this._bubbleButtons[bubbleid]).element, 'Viper-selected');

            var bubble     = this.viper.Tools.getItem(bubbleid);
            var bubbleElem = bubble.element;

            if (bubble._openCallback) {
                bubble._openCallback.call(this);
            }

            if (!bubbleElem.parentNode || bubbleElem.parentNode.nodeType === ViperUtil.DOCUMENT_FRAGMENT_NODE) {
                this._toolbar.appendChild(bubbleElem);
            }

            // Before we show the bubble set all its sub section apply changes button
            // statuses to disabled.
            for (var subSectionid in bubble._subSections) {
                var applyChangesBtn = this.viper.Tools.getItem(subSectionid + '-applyButton');
                if (applyChangesBtn) {
                    this.viper.Tools.disableButton(subSectionid + '-applyButton');
                }
            }

            this.positionBubble(bubbleid);

            this._activeBubble = bubbleid;

            var inputElements = ViperUtil.getTag('input[type=text], textarea', bubbleElem);
            if (inputElements.length > 0) {
                try {
                    setTimeout(function() {
                        inputElements[0].focus();
                    }, 10);
                } catch(e) {}
            }

            var inlineToolbarPlugin = this.viper.getPluginManager().getPlugin('ViperInlineToolbarPlugin');
            if (inlineToolbarPlugin) {
                inlineToolbarPlugin.hideToolbar();
            }

            ViperUtil.removeEvent(document, 'keydown.ViperToolbarPluginSubSection');
            ViperUtil.addEvent(document, 'keydown.ViperToolbarPluginSubSection', function(e) {
                if (e.which === 13 && bubble.getActiveSubSection()) {
                    return bubble.getActiveSubSection().onsubmit();
                }
            });

        },

        getActiveBubble: function()
        {
            if (!this._activeBubble) {
                return null;
            }

            return this.getBubble(this._activeBubble);

        },

        positionBubble: function(bubbleid)
        {
            bubbleid = bubbleid || this._activeBubble;
            if (!bubbleid) {
                return;
            }

            var bubble     = this.viper.Tools.getItem(bubbleid).element;
            var button     = this.viper.Tools.getItem(this._bubbleButtons[bubbleid]).element;

            var toolsWidth = null;
            var widthStyle = bubble.style.width;

            toolsWidth = ViperUtil.getElementWidth(bubble);

            var scrollCoords = ViperUtil.getScrollCoords();
            var windowDim    = ViperUtil.getWindowDimensions();
            var elemDim      = ViperUtil.getBoundingRectangle(button);
            var toolbarDim   = ViperUtil.getBoundingRectangle(this._toolbar);

            var left = ((elemDim.x1 + ((elemDim.x2 - elemDim.x1) / 2) - (toolsWidth / 2) - scrollCoords.x) - toolbarDim.x1);

            if ((left + toolsWidth) >= windowDim.width) {
                left -= ((toolsWidth / 2) - 40);
                ViperUtil.addClass(bubble, 'Viper-orientationLeft');
            } else {
                ViperUtil.removeClass(bubble, 'Viper-orientationLeft');
            }

            ViperUtil.setStyle(bubble, 'left', left + 'px');
            ViperUtil.setStyle(bubble, 'top', '35px');

            if (!widthStyle) {
                ViperUtil.setStyle(bubble, 'width', toolsWidth + 'px');
            }

        },

        disable: function()
        {
            if (this._enabled === false) {
                return;
            }

            this._enabled = false;

            ViperUtil.removeClass(this._toolbar, 'viper-active');
            ViperUtil.addClass(this._toolbar, 'viper-inactive');

            // Close active bubble.
            if (this._activeBubble) {
                this.closeBubble(this._activeBubble);
            }

            // Get all buttons in the toolbar and disable them.
            var buttons = ViperUtil.getClass('Viper-button', this._toolbar);
            var c       = buttons.length;
            var viperid = this.viper.getId();
            var enabledButtons = [];
            for (var i = 0; i < c; i++) {
                var buttonid = buttons[i].id.replace(viperid + '-', '');
                if (this.viper.Tools.getItem(buttonid).isEnabled() === true) {
                    enabledButtons.push(buttonid);
                }

                this.viper.Tools.disableButton(buttonid);
            }

            this._enabledButtons = enabledButtons;

            this.viper.fireCallbacks('ViperToolbarPlugin:disabled');

        },

        enable: function()
        {
            if (this._enabled === true || this.viper.fireCallbacks('ViperToolbarPlugin:canEnableToolbar') === false) {
                return;
            }

            this._enabled = true;
            ViperUtil.removeClass(this._toolbar, 'viper-inactive');
            ViperUtil.addClass(this._toolbar, 'viper-active');

            while (this._enabledButtons.length) {
                this.viper.Tools.enableButton(this._enabledButtons.pop());
            }

            this.viper.fireCallbacks('ViperToolbarPlugin:enabled');

        },

        hide: function()
        {
            ViperUtil.setStyle(this._toolbar, 'display', 'none');

        },

        show: function()
        {
            ViperUtil.setStyle(this._toolbar, 'display', 'block');

        },

        isDisabled: function()
        {
            return !this._enabled;

        },

        isVisible: function()
        {
            if (ViperUtil.getStyle(this._toolbar, 'display') === 'none') {
                return false;
            }

            return true;

        },

        exists: function()
        {
            if (this._toolbar) {
                return true;
            }

            return false;

        },

        remove: function()
        {
            ViperUtil.remove(this._toolbar);

        },

        isPluginElement: function(element)
        {
            if (element !== this._toolbar && ViperUtil.isChildOf(element, this._toolbar) === false) {
                return false;
            }

            return true;

        },

        _updateToolbar: function(range)
        {
            if (this.viper.isEnabled() === false || this._enabled === false) {
                return;
            }

            if (ViperUtil.isBrowser('msie', '<11') === true) {
                // IE fix.. When a toolbar button is clicked IE moves the selection to that
                // button unless the button no longer exists... So we remove the toolbar
                // here to prevent selection changing......
                var parent = this._toolbar.parentNode;
                parent.removeChild(this._toolbar);
            }

            range = range || this.viper.getCurrentRange();

            this.viper.fireCallbacks('ViperToolbarPlugin:updateToolbar', {range: range});

            if (ViperUtil.isBrowser('msie', '<11') === true) {
                parent.appendChild(this._toolbar);
            }

        }

    };
})(Viper.Util, Viper.Selection, Viper._);

if (Viper.Translation) {Viper.Translation.add('ko', {"Locate Element":"","Show in Source View":"","Refresh Issue":"","Accessibility Auditor":"\uc6f9 \uc811\uadfc\uc131 \ud14c\uc2a4\ud2b8 \ud234","Re-checking issue":"","This issue has not been resolved":"","OK":"","Insert Character":"\ud2b9\uc218\uae30\ud638","Symbols":"\uc2ec\ubcfc","Latin":"\ub77c\ud2f4\uc2ec\ubcfc","Mathematics":"\uc218\ud559\uc2ec\ubcfc","Currency":"\ud654\ud3d0\uc2ec\ubcfc","Paste your content into the box below and it will be automatically inserted and cleaned up.":"","Avoid this step for future pastes using the keyboard shortcut %s.":"","Bold":"\uad75\uac8c","Italic":"\uae30\uc6b8\uc784","Remove Format":"","Subscript":"\uc544\ub798 \ucca8\uc790","Superscript":"\uc704 \ucca8\uc790","Strikethrough":"\ucde8\uc18c\uc120","Left Justify":"\uc67c\ucabd\uc815\ub82c","Center Justify":"\uac00\uc6b4\ub370\uc815\ub82c","Right Justify":"\uc624\ub978\ucabd\uc815\ub82c","Block Justify":"\uc591\ucabd\uc815\ub82c","Horizontal Rule":"\uac00\ub85c\uc790","Justification":"\uc815\ub82c","Toggle Justification":"\uc815\ub82c","Heading 1":"\ud5e4\ub529 1","Heading 2":"\ud5e4\ub529 2","Heading 3":"\ud5e4\ub529 3","Heading 4":"\ud5e4\ub529 4","Heading 5":"\ud5e4\ub529 5","Heading 6":"\ud5e4\ub529 6","Paragraph":"\ubb38\ub2e8","Preformatted":"","Address":"","Quote":"","Convert to Heading %s":"","Convert to %s":"","ID":"","Class":"","Toggle Formats":"","Toggle Headings":"","Anchor name (ID)":"","Class name":"","Formats":"\ud3ec\ub9f7","Headings":"","Anchor ID":"","Undo":"\ucde8\uc18c","Redo":"","Insert Image":"\uc0ac\uc9c4\ub123\uae30","Toggle Image Options":"","URL":"URL","Image is decorative":"","Alt":"","Title":"\uc81c\ubaa9","The selected image will be moved to the next location you click. To cancel press the move icon again or ESC":"","Move Image":"\uc0ac\uc9c4 \uc62e\uae30\uae30","Loading preview":"","Failed to load image":"\uc0ac\uc9c4 \ubd88\ub7ec\uc624\uae30 \uc2e4\ud328","Underline":"\ubc11\uc904","Item":"","List":"","Cell":"","Row":"","Header":"","Link":"\ub9c1\ud06c","Image":"\uc0ac\uc9c4","Selection":"\uc120\ud0dd","Acronym":"\uc57d\uce6d","Abbreviation":"\ucd95\uc57d\ud615","Language":"\uc5b8\uc5b4","Language Tools":"\uc5b8\uc5b4\ud234","Toggle Language Tools":"","Toggle Acronym Options":"","Toggle Abbreviation Options":"","Toggle Language Options":"","Subject":"","Open a New Window":"\uc0c8 \ucc3d\uc5d0 \uc5f4\uae30","Toggle Link Options":"","Remove Link":"","Insert Link":"\ub9c1\ud06c \uc0bd\uc785","Make Unordered List":"","Make Ordered List":"","Indent List":"","Outdent List":"","Search":"\ucc3e\uae30","Replace":"\ubc14\uafb8\uae30","Replace All":"\ubaa8\ub450 \ubc14\uafb8\uae30","Find Next":"","Search & Replace":"\ucc3e\uae30 & \ubc14\uafb8","Toggle Source View":"","Discard":"","Discard Changes":"","Apply Changes":"\uc801\uc6a9","Would you like to apply your changes?":"","Open In new window":"\uc0c8 \ucc3d\uc5d0 \uc5f4\uae30","Source Editor":"","Viper Source View":"\uc18c\uc2a4 \ubcf4\uae30","Source code changes will be reflected in your edit preview window in real time.":"","Revert Changes":"","Close Source View":"","Close Window":"\ucc3d \ub2eb\uae30","Insert Table":"\ud45c\uc0bd\uc785","Show Table tools":"","Show Row tools":"","Show Column tools":"","Show Cell tools":"","Table":"\ud45c","Column":"","Toggle Settings":"","Heading":"","Split Vertically":"\uc138\ub85c\ubd84\ud560","Split Horizontally":"\uac00\ub85c\ubd84\ud560","Merge Up":"","Merge Down":"","Merge Left":"","Merge Right":"","Toggle Merge\/Split Options":"","Width":"\ub108\ube44","Insert Column Before":"","Insert Column After":"","Move Left":"\uc67c\ucabd\uc73c\ub85c","Move Right":"\uc624\ub978\ucabd\uc73c\ub85c","Remove Column":"","Insert Row Before":"","Insert Row After":"","Move Up":"\uc704\ub85c ","Move Down":"\uc544\ub798\ub85c","Remove Row":"","Summary":"\uc694\uc57d ","Use Caption":"\ucea1\uc158 \uc0ac\uc6a9\ud558\uae30","Remove Table":"","None":"\uc5c6\uc74c","Left":"\uc67c\ucabd","Top":"\uc704","Both":"\ubaa8\ub450","Headers":"\uc11c\uc2dd","Size":"\uc0ac\uc774\uc988","Viper by Squiz":"Viper by Squiz","Update Changes":"\uc801\uc6a9","Not available":"","required":""});}if (Viper.Translation) {Viper.Translation.add('pl', {"Locate Element":"Znajd\u017a element","Show in Source View":"Poka\u017c w widoku kodu \u017ar\u00f3d\u0142owego","Refresh Issue":"Od\u015bwie\u017c problem","Accessibility Auditor":"Kontrola dost\u0119pno\u015bci","Re-checking issue":"Ponowne sprawdzanie problemu","This issue has not been resolved":"Problem nie zosta\u0142 rozwi\u0105zany","OK":"OK","Insert Character":"Wstaw znak","Symbols":"Symbole","Latin":"\u0141aci\u0144ski","Mathematics":"Matematyczne","Currency":"Symbole walut","Paste your content into the box below and it will be automatically inserted and cleaned up.":"Wklej tre\u015b\u0107 w poni\u017csze okienko, aby wstawi\u0107 j\u0105 automatycznie i uporz\u0105dkowa\u0107.","Avoid this step for future pastes using the keyboard shortcut %s.":"Aby unikn\u0105\u0107 tego kroku przy kolejnych operacjach wklejania, u\u017cyj skr\u00f3tu klawiaturowego %s.","Bold":"Pogrubienie","Italic":"Kursywa","Remove Format":"Usu\u0144 formatowanie","Subscript":"Indeks dolny","Superscript":"Indeks g\u00f3rny","Strikethrough":"Przekre\u015blenie","Left Justify":"Wyr\u00f3wnaj do lewej","Center Justify":"Do \u015brodka","Right Justify":"Wyr\u00f3wnaj do prawej","Block Justify":"Wyjustuj","Horizontal Rule":"Linia pozioma","Justification":"Justowanie","Toggle Justification":"Prze\u0142\u0105cz justowanie","Heading 1":"Nag\u0142\u00f3wek 1","Heading 2":"Nag\u0142\u00f3wek 2","Heading 3":"Nag\u0142\u00f3wek 3","Heading 4":"Nag\u0142\u00f3wek 4","Heading 5":"Nag\u0142\u00f3wek 5","Heading 6":"Nag\u0142\u00f3wek 6","Paragraph":"Akapit","Preformatted":"Wst\u0119pnie sformatowane","Address":"Adres","Quote":"Cytat","Convert to Heading %s":"Zamie\u0144 na nag\u0142\u00f3wek %s","Convert to %s":"Zamie\u0144 na %s","ID":"ID","Class":"Klasa","Toggle Formats":"Prze\u0142\u0105cz formaty","Toggle Headings":"Prze\u0142\u0105cz nag\u0142\u00f3wki","Anchor name (ID)":"Nazwa kotwicy (ID)","Class name":"Nazwa klasy","Formats":"Formaty","Headings":"Nag\u0142\u00f3wki","Anchor ID":"ID kotwicy","Undo":"Cofnij","Redo":"Wykonaj ponownie","Insert Image":"Wstaw obraz","Toggle Image Options":"Prze\u0142\u0105czaj opcje obraz\u00f3w","URL":"URL","Image is decorative":"Obraz dekoracyjny","Alt":"Alt","Title":"Tytu\u0142","The selected image will be moved to the next location you click. To cancel press the move icon again or ESC":"Wybrany obraz zostanie przeniesiony do nast\u0119pnej zaznaczonej lokalizacji. Aby anulowa\u0107, ponownie naci\u015bnij ikon\u0119 Przenie\u015b lub ESC.","Move Image":"Przenie\u015b obraz","Loading preview":"\u0141adowanie podgl\u0105du","Failed to load image":"B\u0142\u0105d wczytywania obrazu","Underline":"Podkre\u015blenie","Item":"Punkt","List":"Lista","Cell":"Kom\u00f3rka","Row":"Wiersz","Header":"Nag\u0142\u00f3wek","Link":"Link","Image":"Obraz","Selection":"Wyb\u00f3r","Acronym":"Skr\u00f3towiec","Abbreviation":"Skr\u00f3t","Language":"J\u0119zyk","Language Tools":"Narz\u0119dzia j\u0119zykowe","Toggle Language Tools":"Prze\u0142\u0105czaj narz\u0119dzia j\u0119zykowe","Toggle Acronym Options":"Prze\u0142\u0105czaj opcje skr\u00f3towc\u00f3w","Toggle Abbreviation Options":"Prze\u0142\u0105czaj opcje skr\u00f3t\u00f3w","Toggle Language Options":"Prze\u0142\u0105czaj opcje j\u0119zykowe","Subject":"Temat","Open a New Window":"Otw\u00f3rz nowe okno","Toggle Link Options":"Prze\u0142\u0105czaj opcje link\u00f3w","Remove Link":"Usu\u0144 link","Insert Link":"Wstaw link","Make Unordered List":"Utw\u00f3rz list\u0119 wypunktowan\u0105 ","Make Ordered List":"Utw\u00f3rz list\u0119 numerowan\u0105","Indent List":"Zwi\u0119ksz wci\u0119cie","Outdent List":"Zmniejsz wci\u0119cie","Search":"Szukaj","Replace":"Zamie\u0144","Replace All":"Zamie\u0144 wszystko","Find Next":"Znajd\u017a nast\u0119pny","Search & Replace":"Szukaj i zamie\u0144","Toggle Source View":"Prze\u0142\u0105czaj widok kodu \u017ar\u00f3d\u0142owego","Discard":"Porzu\u0107","Discard Changes":"Porzu\u0107 zmiany","Apply Changes":"Zastosuj zmiany","Would you like to apply your changes?":"Czy chcesz zastosowa\u0107 zmiany?","Open In new window":"Otw\u00f3rz w nowym oknie","Source Editor":"Edytor kodu \u017ar\u00f3d\u0142owego","Viper Source View":"Widok kodu \u017ar\u00f3d\u0142owego Viper","Source code changes will be reflected in your edit preview window in real time.":"Zmiany w kodzie \u017ar\u00f3d\u0142owym b\u0119d\u0105 widoczne w oknie podgl\u0105du edycji w czasie rzeczywistym.","Revert Changes":"Cofnij zmiany","Close Source View":"Zamknij widok kodu \u017ar\u00f3d\u0142owego","Close Window":"Zamknij okno","Insert Table":"Wstaw tabel\u0119","Show Table tools":"Poka\u017c narz\u0119dzia tabeli","Show Row tools":"Poka\u017c narz\u0119dzia wiersza","Show Column tools":"Poka\u017c narz\u0119dzia kolumny","Show Cell tools":"Poka\u017c narz\u0119dzia kom\u00f3rki","Table":"Tabela","Column":"Kolumna","Toggle Settings":"Prze\u0142\u0105cz ustawienia","Heading":"Nag\u0142\u00f3wek","Split Vertically":"Podziel pionowo","Split Horizontally":"Podziel poziomo","Merge Up":"Po\u0142\u0105cz w g\u00f3r\u0119","Merge Down":"Po\u0142\u0105cz w d\u00f3\u0142","Merge Left":"Po\u0142\u0105cz w lewo","Merge Right":"Po\u0142\u0105cz w prawo","Toggle Merge\/Split Options":"Prze\u0142\u0105cz opcje Po\u0142\u0105cz\/Podziel","Width":"Szeroko\u015b\u0107","Insert Column Before":"Wstaw kolumn\u0119 z lewej","Insert Column After":"Wstaw kolumn\u0119 z prawej","Move Left":"Przesu\u0144 w lewo","Move Right":"Przesu\u0144 w prawo","Remove Column":"Usu\u0144 kolumn\u0119","Insert Row Before":"Wstaw wiersz powy\u017cej","Insert Row After":"Wstaw wiersz poni\u017cej","Move Up":"Przesu\u0144 w g\u00f3r\u0119","Move Down":"Przesu\u0144 w d\u00f3\u0142","Remove Row":"Usu\u0144 wiersz","Summary":"Podsumowanie","Use Caption":"U\u017cyj podpisu","Remove Table":"Usu\u0144 tabel\u0119","None":"Brak","Left":"Lewa","Top":"G\u00f3ra","Both":"Oba","Headers":"Nag\u0142\u00f3wki","Size":"Rozmiar","Viper by Squiz":"Viper firmy Squiz","Update Changes":"Aktualizuj zmiany","Not available":"Niedost\u0119pne","required":"wymagane"});}if (Viper.Translation) {Viper.Translation.add('tr', {"Locate Element":"Elemani Bul","Show in Source View":"Kaynak'ta G\u00f6ster","Refresh Issue":"Sorunu Yenile","Accessibility Auditor":"Eri\u015filebilirlik Denet\u00e7isi","Re-checking issue":"Denetimi tekrarla","This issue has not been resolved":"Bu sorun \u00e7\u00f6z\u00fclm\u00fc\u015f de\u011fil","OK":"Tamam","Insert Character":"Karakter Ekle","Symbols":"Semboller","Latin":"Latin","Mathematics":"Matematik","Currency":"D\u00f6viz","Paste your content into the box below and it will be automatically inserted and cleaned up.":"\u0130\u00e7eriginizi a\u015fa\u011f\u0131daki kutuya yap\u0131\u015ft\u0131r\u0131n ve otomatik olarak temizlenip eklenicektir. ","Avoid this step for future pastes using the keyboard shortcut %s.":"\u0130lerideki yap\u0131\u015ft\u0131rmalarda %s klavye k\u0131sayolunu kullanarak bu ad\u0131m\u0131 atlayabilirsiniz.","Bold":"Kal\u0131n","Italic":"\u0130talik","Remove Format":"Bi\u00e7imi Kald\u0131r","Subscript":"Alt Simge","Superscript":"\u00dcst Simge","Strikethrough":"\u00dcst\u00fc \u00c7izgili","Left Justify":"Sola Dayali","Center Justify":"Ortalanm\u0131\u015f","Right Justify":"Sa\u011fa Dayal\u0131","Block Justify":"\u0130ki Kenara Yaslanm\u0131\u015f","Horizontal Rule":"Yatay \u00c7izgi","Justification":"Hiza","Toggle Justification":"Hiza Ayarlar\u0131","Heading 1":"Ba\u015fl\u0131k 1","Heading 2":"Ba\u015fl\u0131k 2","Heading 3":"Ba\u015fl\u0131k 3","Heading 4":"Ba\u015fl\u0131k 4","Heading 5":"Ba\u015fl\u0131k 5","Heading 6":"Ba\u015fl\u0131k 6","Paragraph":"Paragraf","Preformatted":"\u00d6nceden Bi\u00e7imlendirilmi\u015f","Address":"Adres","Quote":"Al\u0131nt\u0131","Convert to Heading %s":"Ba\u015fl\u0131k %s eleman\u0131na d\u00f6n\u00fc\u015ft\u00fcr","Convert to %s":"%s eleman\u0131na d\u00f6n\u00fc\u015ft\u00fcr","ID":"Kimlik","Class":"Sinif","Toggle Formats":"Bi\u00e7imler","Toggle Headings":"Ba\u015fl\u0131klar","Anchor name (ID)":"\u00c7apa Ad\u0131","Class name":"Bi\u00e7im S\u0131n\u0131f\u0131 \u0130smi","Formats":"Bi\u00e7imler","Headings":"Ba\u015fl\u0131klar","Anchor ID":"\u00c7apa Kimli\u011fi","Undo":"Geri Al","Redo":"Tekrarla","Insert Image":"Resim","Toggle Image Options":"Resim Ayarlar\u0131","URL":"URL","Image is decorative":"Dekoratif resim","Alt":"Alternatif Yaz\u0131","Title":"Ba\u015flik","The selected image will be moved to the next location you click. To cancel, press the move icon again, or ESC":"Se\u00e7ilen resim birdahaki t\u0131klad\u0131\u011f\u0131n\u0131z konuma ta\u015f\u0131nacakt\u0131r. \u0130ptal etmek i\u00e7in tekrar konum de\u011fi\u015ftirme simgesine  veya ESC tu\u015funa bas\u0131n.","Move Image":"Resimi Yerle\u015ftir","Loading preview":"\u00d6n izleme y\u00fckleniyor","Failed to load image":"Resim y\u00fcklenemedi","Underline":"Alt\u0131 \u00c7izgili","Item":"Liste \u00f6\u011fesi","List":"Liste","Cell":"H\u00fccre","Row":"Sat\u0131r","Header":"Ba\u015fl\u0131k","Link":"Ba\u011flant\u0131","Image":"Resim","Selection":"Se\u00e7im","Acronym":"K\u0131saltma","Abbreviation":"K\u0131saltma","Language":"Dil","Language Tools":"Dil Ara\u00e7lar\u0131","Toggle Language Tools":"Dil Ara\u00e7lar\u0131","Toggle Acronym Options":"Kisaltma Ara\u00e7lar\u0131","Toggle Abbreviation Options":"Kisaltma Ara\u00e7lar\u0131","Toggle Language Options":"Dil Se\u00e7enekleri","Subject":"Konu","Open a New Window":"Yeni Pencere","Toggle Link Options":"Ba\u011flant\u0131 Ayarlar\u0131","Remove Link":"Ba\u011flant\u0131y\u0131 Kald\u0131r","Insert Link":"Ba\u011flant\u0131 Ekle","Make Unordered List":"S\u0131ras\u0131z Liste ","Make Ordered List":"S\u0131ral\u0131 Liste","Indent List":"Girintiyi Artt\u0131r","Outdent List":"Girintiyi Azalt","Search":"Bul","Replace":"De\u011fi\u015ftir","Replace All":"Hepsini De\u011fi\u015ftir","Find Next":"Sonraki","Search & Replace":"Bul ve De\u011fi\u015ftir","Toggle Source View":"Kaynak G\u00f6r\u00fcn\u00fcm\u00fc","Discard":"Vazge\u00e7","Discard Changes":"De\u011fi\u015fikliklerden Vazge\u00e7","Apply Changes":"De\u011fi\u015fiklikleri Uygula","Would you like to apply your changes?":"De\u011fi\u015fiklikleri uygulamak istermisiniz?","Open In new window":"Yeni pencerede a\u00e7","Source Editor":"Kaynak G\u00f6r\u00fcn\u00fcm\u00fc","Viper Source View":"Viper Kaynak G\u00f6r\u00fcn\u00fcm\u00fc","Source code changes will be reflected in your edit preview window in real time.":"Kaynak kodu de\u011fi\u015fiklikleri ayn\u0131 zamanda d\u00fczenleme \u00f6nizleme penceresinde yans\u0131yacakt\u0131r.","Revert Changes":"De\u011fi\u015fiklikleri Geri Al","Close Source View":"Kaynak G\u00f6r\u00fcn\u00fcm\u00fcn\u00fc Kapat","Close Window":"Pencereyi Kapat","Insert Table":"Tablo Ekle","Show Table tools":"Tablo Ayarlar\u0131n\u0131 G\u00f6ster","Show Row tools":"Sat\u0131r Ayarlar\u0131n\u0131 G\u00f6ster","Show Column tools":"S\u00fctun Ayarlar\u0131n\u0131 G\u00f6ster","Show Cell tools":"H\u00fccre Ayarlar\u0131n\u0131 G\u00f6ster","Table":"Tablo","Column":"S\u00fctun","Toggle Settings":"Ayarlar","Heading":"Ba\u015fl\u0131k","Split Vertically":"Dikey B\u00f6l","Split Horizontally":"Yatay B\u00f6l","Merge Up":"Yukar\u0131 ile Birle\u015ftir","Merge Down":"A\u015fa\u011f\u0131daki ile Birle\u015ftir","Merge Left":"Soldaki ile Birle\u015ftir","Merge Right":"Sa\u011fdaki ile Birle\u015ftir","Toggle Merge\/Split Options":"Birle\u015ftirme\/Ay\u0131rma Ayarlar\u0131","Width":"Geni\u015flik","Insert Column Before":"\u00d6ne S\u00fctun Ekle","Insert Column After":"Sonra S\u00fctun Ekle","Move Left":"Soldaki ile De\u011fi\u015ftir","Move Right":"Sa\u011fdaki ile De\u011fi\u015ftir","Remove Column":"S\u00fctunu Sil","Insert Row Before":"Yukar\u0131 Sat\u0131r Ekle","Insert Row After":"A\u015fa\u011f\u0131 Sat\u0131r Ekle","Move Up":"Yukar\u0131daki ile De\u011fi\u015ftir","Move Down":"A\u015fa\u011fidaki ile De\u011fi\u015ftir","Remove Row":"Sat\u0131r\u0131 Sil","Summary":"\u00d6zet","Use Caption":"Ba\u015fl\u0131k Kullan","Remove Table":"Tabloyu Sil","None":"Yok","Left":"Sol","Top":"\u00dcst","Both":"Her \u0130kisi","Headers":"Ba\u015fl\u0131klar","Size":"Boyut","Viper by Squiz":"Squiz'den Viper","Update Changes":"De\u011fi\u015fiklikleri G\u00fcncelle\u015ftir","Not available":"Kullan\u0131lamaz","required":"zorunlu","Custom Class":"\u00d6zel S\u0131n\u0131f","Choose Styles":"Stiller Se\u00e7imi"});}if (Viper.Util.isBrowser('msie', '<9') === false) {
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // strict mode


if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
    return;


var define = function(module, deps, payload) {
    if (typeof module !== "string") {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality define()ed using the function above
 */
var _require = function(parentId, module, callback) {
    if (typeof module === "string") {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback && callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && require.original)
                return;
            params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
    }
};

var require = function(module, callback) {
    var packagedModule = _require("", module, callback);
    if (packagedModule == undefined && require.original)
        return require.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _require(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
        require.original = root.require;
        root.require = require;
        root.require.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

define("ace/lib/regexp",["require","exports","module"], function(require, exports, module) {
"use strict";

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };
    if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

define("ace/lib/es5-shim",["require","exports","module"], function(require, exports, module) {

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;

        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(require, exports, module) {
"use strict";

require("./regexp");
require("./es5-shim");

});

define("ace/lib/dom",["require","exports","module"], function(require, exports, module) {
"use strict";

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
}

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.hasCssClass = function(el, name) {
    var classes = (el.className || "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if(add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
        return null;

    var style;

    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";

    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = doc.createElementNS
            ? doc.createElementNS(XHTML_NS, "style")
            : doc.createElement("style");

        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        exports.getDocumentHead(doc).appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        exports.getDocumentHead(doc).appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) +
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};

exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};

if (typeof document == "undefined") {
    exports.importCssString = function() {};
    return;
}

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
        el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
        return el.textContent;
    };
}
else {
    exports.setInnerText = function(el, innerText) {
        el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
        return el.innerText;
    };
}

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});

define("ace/lib/oop",["require","exports","module"], function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(require, exports, module) {
"use strict";

require("./fixoldbrowsers");

var oop = require("./oop");
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
          219: '[', 220: '\\',221: ']', 222: '\''
        }
    };
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';

    (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {
            ret.KEY_MODS[i] = mods.filter(function(x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

define("ace/lib/useragent",["require","exports","module"], function(require, exports, module) {
"use strict";
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};
if (typeof navigator != "object")
    return;

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE =
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie

exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

});

define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var keys = require("./keys");
var useragent = require("./useragent");

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback.call(elem, window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
    if (e.preventDefault) {
        return e.button;
    }
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        exports.removeListener(document, "mousemove", eventHandler, true);
        exports.removeListener(document, "mouseup", onMouseUp, true);
        exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);

    return onMouseUp;
};

exports.addTouchMoveListener = function (el, callback) {
    if ("ontouchmove" in el) {
        var startx, starty;
        exports.addListener(el, "touchstart", function (e) {
            var touchObj = e.changedTouches[0];
            startx = touchObj.clientX;
            starty = touchObj.clientY;
        });
        exports.addListener(el, "touchmove", function (e) {
            var factor = 1,
            touchObj = e.changedTouches[0];

            e.wheelX = -(touchObj.clientX - startx) / factor;
            e.wheelY = -(touchObj.clientY - starty) / factor;

            startx = touchObj.clientX;
            starty = touchObj.clientY;

            callback(e);
        });
    }
};

exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
        exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        });
    } else if ("onwheel" in el) {
        exports.addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }

            callback(e);
        });
    } else {
        exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        });
    }
};

exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    exports.addListener(el, "mousedown", function(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }

        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    });

    if (useragent.isOldIE) {
        exports.addListener(el, "dblclick", function(e) {
            clicks = 2;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
            eventHandler[callbackName]("mousedown", e);
            eventHandler[callbackName](eventNames[clicks], e);
        });
    }
};

var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
    ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    }
    : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
        if (pressedKeys[91] || pressedKeys[92])
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }

    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }

    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
        keyCode = -1;
    }

    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }

    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }

    return callback(e, hashId, keyCode);
}

var pressedKeys = null;
var ts = 0;
exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        });

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        });

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        });

        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    }
};
function resetPressedKeys(e) {
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}


exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

define("ace/lib/lang",["require","exports","module"], function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject( array[i] );
        else
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    var cons = obj.constructor;
    if (cons === RegExp)
        return obj;

    copy = cons();
    for (var key in obj) {
        copy[key] = deepCopy(obj[key]);
    }
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };

    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    if (useragent.isOldIE) text.style.top = "-1000px";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\x01\x01";

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}

    event.addListener(text, "blur", function(e) {
        host.onBlur(e);
        isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
        isFocused = true;
        host.onFocus(e);
        resetSelection();
    });
    this.focus = function() {
        if (tempStyle) return text.focus();
        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "-1000px";
        text.focus();
        setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "-1000px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        inComposition = true;

        if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
        }
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e){}

        inComposition = false;
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    if (!text.setSelectionRange && text.createTextRange) {
        text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
        };
        isAllSelected = function(text) {
            try {
                var range = text.ownerDocument.selection.createRange();
            }catch(e) {}
            if (!range || range.parentElement() != text) return false;
                return range.text == text.value;
        }
    }
    if (useragent.isOldIE) {
        var inPropertyChange = false;
        var onPropertyChange = function(e){
            if (inPropertyChange)
                return;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
                return;
            if (e && data == PLACEHOLDER[0])
                return syncProperty.schedule();

            sendText(data);
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
        };
        var syncProperty = lang.delayedCall(onPropertyChange);
        event.addListener(text, "propertychange", onPropertyChange);

        var keytable = { 13:1, 27:1 };
        event.addListener(text, "keyup", function (e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
                setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0)||0) < 129) {
                return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
        });
        event.addListener(text, "keydown", function (e) {
            syncProperty.schedule(50);
        });
    }

    var onSelect = function(e) {
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb};
    this.getInputHandler = function() {return inputHandler};
    var afterContextMenu = false;

    var sendText = function(data) {
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else {
            if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);

            if (data)
                host.onTextInput(data);
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };

    var handleClipboardData = function(e, data) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
        if (data) {
            return clipboardData.setData(mime, data) !== false;
        } else {
            return clipboardData.getData(mime);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };

    var onCut = function(e) {
        doCopy(e, true);
    };

    var onCopy = function(e) {
        doCopy(e, false);
    };

    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        });
    }
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
        inComposition = {};
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (!host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        var val = text.value.replace(/\x01/g, "");
        if (inComposition.lastValue === val) return;

        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
                return;
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
    };



    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule()});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule()});
        event.addListener(text, "keydown", function(){syncComposition.schedule()});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };

    this.moveToMouse = function(e, bringToFront) {
        if (!bringToFront && useragent.isOldIE)
            return;
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + "height:" + text.style.height + ";"
            + (useragent.isIE ? "opacity:0.1;" : "");

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        };
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;
        if (useragent.isWin && !useragent.isOldIE)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, useragent.isOldIE ? 200 : 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);
};

exports.TextInput = TextInput;
});

define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var DRAG_OFFSET = 0; // pixels

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty)
                editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            editor.textInput.onContextMenu(ev.domEvent);
            return; // stopping event here breaks contextmenu on ff mac
        }

        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        editor.$blockScrolling++;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
        editor.$blockScrolling--;
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }

        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime||0);

        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

    this.onTouchMove = function (ev) {
        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime || 0);

        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}

(function() {
    this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function() {
        return this.$element || this.$init();
    };
    this.setText = function(text) {
        dom.setInnerText(this.getElement(), text);
    };
    this.setHtml = function(html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };
    this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };

    this.hide = function() {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
        }
    };
    this.getHeight = function() {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function() {
        return this.getElement().offsetWidth;
    };

}).call(Tooltip.prototype);

exports.Tooltip = Tooltip;
});

define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module) {
"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var event = require("../lib/event");
var Tooltip = require("../tooltip").Tooltip;

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor.removeEventListener("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    });

    editor.on("changeSession", hideTooltip);
}

function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}

oop.inherits(GutterTooltip, Tooltip);

(function(){
    this.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };

}).call(GutterTooltip.prototype);



exports.GutterHandler = GutterHandler;

});

define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;

    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;

    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {

    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };

    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };

    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;

        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;

        var editor = this.editor;


        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };

    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };

}).call(MouseEvent.prototype);

});

define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.$blockScrolling += 1;
        editor.selection.fromOrientedRange(range);
        editor.$blockScrolling -= 1;
        if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});

define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";
var dom = require("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}

});

define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }

    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};

    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];

    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"no use strict";

var oop = require("./oop");
var EventEmitter = require("./event_emitter").EventEmitter;

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
}

var AppConfig = function() {
    this.$defaultOptions = {};
};

(function() {
    oop.implement(this, EventEmitter);
    this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);

        return this;
    };

    this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };

    this.setDefaultValue = function(path, name, value) {
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };

    this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };

    this.warn = warn;
    this.reportError = reportError;

}).call(AppConfig.prototype);

exports.AppConfig = AppConfig;

});

define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(require, exports, module) {
"no use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var net = require("./lib/net");
var AppConfig = require("./lib/app_config").AppConfig;

module.exports = exports = new AppConfig();

var global = (function() {
    return this || typeof window != "undefined" && window;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    options[key] = value;
};

exports.all = function() {
    return lang.copyObject(options);
};
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = require(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        require([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
};
init(true);function init(packaged) {

    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);

    if (!global.document)
        return "";

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;

    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
};

exports.init = init;

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

});

define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;
var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
var config = require("../config");

var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
        if (!document.hasFocus || !document.hasFocus())
            window.focus();
        editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
    if (editor.renderer.scrollBarV) {
        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
        if (useragent.isIE) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
        }
    }
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", focusEditor);

    event.addListener(gutterEl, "mousedown", function(e) {
        editor.focus();
        return event.preventDefault(e);
    });

    editor.on("mousemove", function(e){
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;

        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;

        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        } else {
            renderer.setCursorStyle("");
        }
    });
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };

    this.onTouchMove = function (name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.MouseHandler = MouseHandler;
});

define("ace/mouse/fold_handler",["require","exports","module"], function(require, exports, module) {
"use strict";

function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module) {
"use strict";

var keyUtil  = require("../lib/keys");
var event = require("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };

    this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 &&
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        var success = this.$callKeyboardHandlers(-1, text);
        if (!success)
            this.$editor.commands.exec("insertstring", this.$editor, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

define("ace/range",["require","exports","module"], function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            };
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCursor");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };
    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };
    this.getCursor = function() {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead();
        else
            return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
        }

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
            this.$isEmpty = true;
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, -tabSize);
            else
                this.moveCursorBy(0, -1);
        }
    };
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, tabSize);
            else
                this.moveCursorBy(0, 1);
        }
    };
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var match, index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        if (chars === 0) {
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);

        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
                docPos.row++;
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
            func.call(null, this);
            var end = this.getCursor();
            return Range.fromPoints(start,end);
        } catch(e) {
            return Range.fromPoints(start,start);
        } finally {
            this.moveCursorToPosition(start);
        }
    };

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else
                data = data[0];
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});

define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module) {
"use strict";

var config = require("./config");
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }

        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }

        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };

    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    },

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift()
                startState = stack.shift()
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }

                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 2000),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);

        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };

    this.reportError = config.reportError;

}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

var TextHighlightRules = function() {

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next != "string") {
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                            rule.nextState = prefix + rule.nextState;
                    } else {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                if (rule.include || typeof rule == "string") {
                    var includeName = rule.include || rule;
                    var toInsert = rules[includeName];
                } else if (Array.isArray(rule))
                    toInsert = rule;

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    i--;
                    toInsert = null;
                }

                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
            : function(value) {return keywords[value] || defaultToken };
    };

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module) {
"use strict";

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    }

    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    }

    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    }

    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    }

    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {}
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    }

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});

define("ace/unicode",["require","exports","module"], function(require, exports, module) {
"use strict";
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
};

});

define("ace/token_iterator",["require","exports","module"], function(require, exports, module) {
"use strict";
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() {
    this.stepBackward = function() {
        this.$tokenIndex -= 1;

        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }

        return this.$rowTokens[this.$tokenIndex];
    };
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }

        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentTokenRow = function () {
        return this.$row;
    };
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;

        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }

        return column;
    };
    this.getCurrentTokenPosition = function() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    };

}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module) {
"use strict";

var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var Behaviour = require("./behaviour").Behaviour;
var unicode = require("../unicode");
var lang = require("../lib/lang");
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
    this.$behaviour = new Behaviour();
};

(function() {

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
    );

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === 'comment')
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };

            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
                return true;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
            }
        }

        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent',
            'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              };
            } (this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
            state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };

    this.getKeywords = function(append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };

    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/apply_delta",["require","exports","module"], function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {

    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
}
});

define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);

    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;

        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };

    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }

    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }

        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);

        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);

        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);

        return this.clonePos(end);
    };

    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };

    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };

    this.pos = function(row, column) {
        return {row: row, column: column};
    };

    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };

        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });

        return this.clonePos(end);
    };
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);

        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);

        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length );
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!range instanceof Range)
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }

        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }

        if (isInsert && delta.lines.length > 20000)
            this.$splitAndapplyLargeDelta(delta, 20000);
        applyDelta(this.$lines, delta, doNotValidate);
        this._signal("change", delta);
    };

    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length;
        var row = delta.start.row;
        var column = delta.start.column;
        var from = 0, to = 0;
        do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
                delta.lines = chunk;
                delta.start.row = row + from;
                delta.start.column = column;
                break;
            }
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        } while(true);
    };
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;

        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines ++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;

        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    };
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };

    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    this.$updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    this.MAX_RANGES = 500;

    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };

    this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);

        if (!pos || pos.kind == "inside")
            return null;

        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;

        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";
var Range = require("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.call(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function() {
        var removed = [];
        var list = this.ranges;

        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });

        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }

        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(delta) {
        if (delta.action == "insert"){
            var start = delta.start;
            var end = delta.end;
        } else {
            var end = delta.start;
            var start = delta.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;

        var colDiff = -start.column + end.column;
        var ranges = this.ranges;

        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
                continue;
            if (r.start.row > startRow)
                break;

            if (r.start.row == startRow && r.start.column >= start.column ) {
                if (r.start.column == start.column && this.$insertRight) {
                } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                    continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                        r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var RangeList = require("../range_list").RangeList;
var oop = require("../lib/oop")
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;

        if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold);
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterEnd = this.subFolds[j];

        if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);

        return fold;
    };

    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;

function Folding() {
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    }
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;

        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if(start < last) {
                    if(start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0;//in one fold
                }
                break;
            } else if(end >= first){
                if (start >= first) //fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;

        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        if (!(startRow < endRow ||
            startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);

        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;

        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if(placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while(token && re.test(token.type));
                iterator.stepForward();
            }

            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);

            if (dir != -1) {
                do {
                    token = iterator.stepForward();
                } while(token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");

        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;

        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;

        this.$foldMode = foldMode;

        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._emit("changeAnnotation");

        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }

        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    }

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };

        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement)
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };

    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return;
        }

        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return;
            }
        }

        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all)
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }

        return range;
    };



    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});

        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;

        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    }
}

exports.Folding = Folding;

});

define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };

    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column-1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }

        return range;
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;

        while (true) {

            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            value = token.value;
            valueIndex = value.length - 1;
        }

        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }

        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var config = require("./config");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = require("./search_highlight").SearchHighlight;

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.$foldData.toString = function() {
        return this.join("\n");
    };
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
};


(function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };
    this.getDocument = function() {
        return this.doc;
    };
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(delta) {
        this.$modified = true;

        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    };
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
    };
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };

    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function() {
        return this.$tabSize;
    };
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function() {
        return this.$overwrite;
    };
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    };
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function() {
        return this.$annotations || [];
    };
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };

    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode)
            return;

        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;


        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
        }
    };

    this.$stopWorker = function() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };

    this.$startWorker = function() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };

    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
        return this.doc.getLength();
    };
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function(range) {
        return this.doc.remove(range);
    };
    this.removeFullLines = function(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var delta = deltas[0];
        var range, point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.start, delta.end);
            lastDeltaIsInsert = true;
        } else {
            range = Range.fromPoints(delta.start, delta.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
                lastDeltaIsInsert = true;
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                lastDeltaIsInsert = false;
            }
        }
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    };
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    };
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;

        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").
                replace(/12/g, function() {
                    len -= 1;
                }).
                replace(/2/g, function() {
                    len -= 1;
                });

            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
            h = 0
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };

    this.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    }
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                var splitIndex = Math.floor(screenRow - row);
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    this.$setFontMetrics = function(fm) {
    };

    this.destroy = function() {
        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
        }
        this.$stopWorker();
    };
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    };

}).call(EditSession.prototype);

require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },
    wrapMethod: {
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: { initialValue: true },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val)},
        get: function() {return this.doc.getNewLineMode()},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val) },
        get: function() { return this.$modeId }
    }
});

exports.EditSession = EditSession;
});

define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var Search = function() {
    this.$options = {};
};

(function() {
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
        this.$options = options;
    };
    this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(range, row, offset) {
            if (!range.start) {
                var column = range.offset + (offset || 0);
                firstRange = new Range(row, column, row, column + range.length);
                if (!range.length && options.start && options.start.start
                    && options.skipCurrent != false && firstRange.isEqual(options.start)
                ) {
                    firstRange = null;
                    return false;
                }
            } else
                firstRange = range;
            return true;
        });

        return firstRange;
    };
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;

                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;

                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;

            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;

        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }

        return replacement;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;

        var callback;
        if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
                var startIndex = line.search(re[0]);
                if (startIndex == -1)
                    return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(row + i);
                    if (line.search(re[i]) == -1)
                        return;
                }

                var endIndex = line.match(re[len - 1])[0].length;

                var range = new Range(row, startIndex, row + len - 1, endIndex);
                if (re.offset == 1) {
                    range.start.row--;
                    range.start.column = Number.MAX_VALUE;
                } else if (offset)
                    range.start.column += offset;

                if (callback(range))
                    return true;
            };
        } else if (options.backwards) {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = matches.length-1; i >= 0; i--)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        } else {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = 0; i < matches.length; i++)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        }

        var lineIterator = this.$lineIterator(session, options);

        return {
            forEach: function(_callback) {
                callback = _callback;
                lineIterator.forEach(matchIterator);
            }
        };
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = "\\b" + needle + "\\b";

        var modifier = options.caseSensitive ? "gm" : "gmi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        if (parts[0] == "") {
            re.shift();
            re.offset = 1;
        } else {
            re.offset = 0;
        }
        return re;
    };

    this.$lineIterator = function(session, options) {
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        var forEach = backwards ? function(callback) {
                var row = start.row;

                var line = session.getLine(row).substring(0, start.column);
                if (callback(line, row))
                    return;

                for (row--; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;
            } : function(callback) {
                var row = start.row;

                var line = session.getLine(row).substr(start.column);
                if (callback(line, row, start.column))
                    return;

                for (row = row+1; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;
            };

        return {forEach: forEach};
    };

}).call(Search.prototype);

exports.Search = Search;
});

define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var keyUtil = require("../lib/keys");
var useragent = require("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}

function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}

MultiHashHandler.prototype = HashHandler.prototype;

(function() {


    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };

    this.bindKey = function(key, command, position) {
        if (typeof key == "object") {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || key});

        key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };

    function getPosition(command) {
        return typeof command == "object" && command.bindKey
            && command.bindKey.position || 0;
    }
    this._addCommandToBinding = function(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }

            if (typeof position != "number") {
                if (position || command.isDefault)
                    position = -100;
                else
                   position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;

            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }

        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }

        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    };

    this.getStatusText = function(editor, data) {
        return data.$keyChain || "";
    };

}).call(HashHandler.prototype);

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;
});

define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, MultiHashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }

        if (typeof command === "string")
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");
var config = require("../config");
var Range = require("../range").Range;

function bindKey(win, mac) {
    return {win: win, mac: mac};
}
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "Ctrl-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) {
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext();
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    exec: function(editor) {
    },
    readOnly: true
},
{
    name: "cut",
    exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
        }
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) {
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "expandtoline",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "joinlines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}];

});

define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");
var TokenIterator = require("./token_iterator").TokenIterator;
var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();

    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));

    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._signal("editor", this);
};

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
        function last(a) {return a[a.length - 1]}

        this.selections = [];
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

        this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
            this.$blockScrolling++;
    };

    this.endOperation = function(e) {
        if (this.curOp) {
            if (e && e.returnValue === false)
                return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0)
                this.$blockScrolling--;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }

            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
        if (this.session == session)
            return;
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.removeEventListener("change", this.$onDocumentChange);
            this.session.removeEventListener("changeMode", this.$onChangeMode);
            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
            this.session.removeEventListener("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.removeEventListener("changeCursor", this.$onCursorChange);
            selection.removeEventListener("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.addEventListener("change", this.$onDocumentChange);
            this.renderer.setSession(session);

            this.$onChangeMode = this.onChangeMode.bind(this);
            session.addEventListener("changeMode", this.$onChangeMode);

            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);

            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.addEventListener("changeTabSize", this.$onChangeTabSize);

            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);

            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.addEventListener("changeWrapMode", this.$onChangeWrapMode);

            this.$onChangeFold = this.onChangeFold.bind(this);
            session.addEventListener("changeFold", this.$onChangeFold);

            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);

            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);

            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);

            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);

            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.addEventListener("changeOverwrite", this.$onCursorChange);

            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);

            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);

            this.selection = session.getSelection();
            this.selection.addEventListener("changeCursor", this.$onCursorChange);

            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.addEventListener("changeSelection", this.$onSelectionChange);

            this.onChangeMode();

            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;

            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });

        this.curOp = null;

        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});
    };
    this.getSession = function() {
        return this.session;
    };
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };
    this.getValue = function() {
        return this.session.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.resize = function(force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function(theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function() {
        return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container, "fontSize");
    };
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
                var range = session.$mode.getMatching(self.session);
            }
            if (range)
                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.$highlightTags = function() {
        if (this.$highlightTagPending)
            return;
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;

            var session = self.session;
            if (!session || !session.bgTokenizer) return;

            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();

            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }

            if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                    return;
            }

            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();

            if (prevToken.value == '<'){
                do {
                    prevToken = token;
                    token = iterator.stepForward();

                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<'){
                            depth++;
                        } else if (prevToken.value === '</'){
                            depth--;
                        }
                    }

                } while (token && depth >= 0);
            } else {
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();

                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<') {
                            depth++;
                        } else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                } while (prevToken && depth <= 0);
                iterator.stepForward();
            }

            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }

            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column+token.value.length);
            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }

            if (range && !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.focus = function() {
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };
    this.isFocused = function() {
        return this.textInput.isFocused();
    };
    this.blur = function() {
        this.textInput.blur();
    };
    this.onFocus = function(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };
    this.onBlur = function(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
    };
    this.onDocumentChange = function(delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);
        this.$cursorChange();
        this.$updateHighlightActiveLine();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change",
                "this will be disabled in the next version",
                "set editor.$blockScrolling = Infinity to disable this message"
            );
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
        var text = this.getSelectedText();
        this._signal("copy", text);
        return text;
    };
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };
    this.onCut = function() {
        this.commands.exec("cut", this);
    };
    this.onPaste = function(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    };

    this.$handlePaste = function(e) {
        if (typeof e == "string")
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;

            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                return this.commands.exec("insertstring", this, text);

            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    this.session.remove(range);

                this.session.insert(range.start, lines[i]);
            }
        }
    };

    this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }

        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({row: cursor.row+1, column: 0}, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
    };
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }

        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        }
    };
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function() {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function() {
        this.$moveLines(-1, false);
    };
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function() {
        this.$moveLines(1, true);
    };
    this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;

            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }

            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };
    this.clearSelection = function() {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();

        if (!token) return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };

        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                        break;
                    }
                }
            }
            else if (token && token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }

                if (prevToken.value === '<') {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }

                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);
        if (!matchType)
            return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1)
                var tag = token.value;
            else
                return;

            range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();

                    if (prevToken) {
                        if (prevToken.type.indexOf('tag-close') !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth[tag]++;
                            }
                            else if (prevToken.value === '</') {
                                depth[tag]--;
                            }

                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    pos = range.end;
            }
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                } else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    };
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session) {
            this.session.destroy();
        }
    };
    this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.removeEventListener("changeSelection", onChangeSelection);
            this.renderer.removeEventListener("afterRender", onAfterRender);
            this.renderer.removeEventListener("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.$resetCursorStyle();
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val)}
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showLineNumbers: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});

exports.Editor = Editor;
});

define("ace/undomanager",["require","exports","module"], function(require, exports, module) {
"use strict";
var UndoManager = function() {
    this.reset();
};

(function() {
    this.execute = function(options) {
        var deltaSets = options.args[0];
        this.$doc  = options.args[1];
        if (options.merge && this.hasUndo()){
            this.dirtyCounter--;
            deltaSets = this.$undoStack.pop().concat(deltaSets);
        }
        this.$undoStack.push(deltaSets);
        this.$redoStack = [];
        if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };
    this.undo = function(dontSelect) {
        var deltaSets = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltaSets) {
            undoSelectionRange = this.$doc.undoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$redoStack.push(deltaSets);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };
    this.redo = function(dontSelect) {
        var deltaSets = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSets) {
            redoSelectionRange =
                this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$undoStack.push(deltaSets);
            this.dirtyCounter++;
        }
        return redoSelectionRange;
    };
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };
    this.markClean = function() {
        this.dirtyCounter = 0;
    };
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };
    this.$serializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $serializeDelta);
    };
    this.$deserializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
    };

    function $serializeDelta(delta){
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines.length == 1 ? null : delta.lines,
            text: delta.lines.length == 1 ? delta.lines[0] : null,
        };
    }

    function $deserializeDelta(delta) {
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines || [delta.text]
        };
    }

    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
        var deltaSets_new = new Array(deltaSets_old.length);
        for (var i = 0; i < deltaSets_old.length; i++) {
            var deltaSet_old = deltaSets_old[i];
            var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};

            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                var delta_old = deltaSet_old.deltas[j];
                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
            }

            deltaSets_new[i] = deltaSet_new;
        }
        return deltaSets_new;
    }

}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});

define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);

    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};

            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
        } else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;

        var gutterRenderer = session.gutterRenderer || this.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                    cell = this.$cells.pop();
                    this.element.removeChild(cell.element);
                }
                break;
            }

            cell = this.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }

            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }

        this.element.style.height = config.minHeight + "px";

        if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;

        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$fixedWidth = false;

    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
            getWidth: function() {return ""},
            getText: function() {return ""}
        };
    };

    this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
    };

    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };

    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});

define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var dom = require("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };

    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        var config = config || this.config;
        if (!config)
            return;

        this.config = config;


        var html = [];
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        this.element.innerHTML = html.join("");
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0;
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange,
                clazz + (row == start  ? " ace_start" : "") + " ace_br"
                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                layerConfig, row == end ? 0 : 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        stringBuilder.push(
            "<div class='", clazz, " ace_br1 ace_start' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle, "'></div>"
        );
        top = this.$getTop(range.end.row, config);
        var width = range.end.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, " ace_br12' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);

        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        stringBuilder.push(
            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle || "", "'></div>"
        );
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;

    this.$updateEolChar = function() {
        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
           ? this.EOL_CHAR_LF
           : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    }

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
    };

    this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    }

    this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
                    + lang.stringRepeat(this.TAB_CHAR, i)
                    + "</span>");
            } else {
                tabStr.push(lang.stringRepeat(" ", i));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
                className += " ace_invisible";
                spaceClass = " ace_invisible_space";
                tabClass = " ace_invisible_tab";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
            } else{
                var spaceContent = lang.stringRepeat(" ", this.tabSize);
                var tabContent = spaceContent;
            }

            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                var html = [];
                this.$renderLine(
                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                lineElement.innerHTML = html.join("");
            }
            row++;
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

            } else {
                while(container.firstChild)
                    fragment.appendChild(container.firstChild);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element.innerHTML = html.join("");
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
                return self.showInvisibles
                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
                    : c;
            } else if (c == "&") {
                return "&#38;";
            } else if (c == "<") {
                return "&#60;";
            } else if (c == ">") {
                return "&#62;";
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (b) {
                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
            return value.substr(cols);
        } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
        }
        return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px'>"
                        );
                    }

                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
        if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
    };
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);


        if (!onlyContents) {
            stringBuilder.push(
                "<div class='ace_line' style='height:",
                    this.config.lineHeight * (
                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                    ), "px'>"
            );
        }

        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
                this.$renderSimpleLine(stringBuilder, tokens);
        }

        if (this.showInvisibles) {
            if (foldLine)
                row = foldLine.end.row

            stringBuilder.push(
                "<span class='ace_invisible ace_invisible_eol'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
            );
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});

define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var isIE8;

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);

    if (isIE8 === undefined)
        isIE8 = !("opacity" in this.element.style);

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = (isIE8
        ? this.$updateVisibility
        : this.$updateOpacity).bind(this);
};

(function() {

    this.$updateVisibility = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
    };
    this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
    };


    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking){
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval){
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking && !isIE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (this.$updateOpacity).bind(this);
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }

        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;

        if (this.smoothBlinking) {
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
        }

        var blink = function(){
            this.timeoutId = setTimeout(function() {
                update(false);
            }, 0.6 * this.blinkInterval);
        }.bind(this);

        this.intervalId = setInterval(function() {
            update(true);
            blink();
        }, this.blinkInterval);

        blink();
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

            if (!this.drawCursor) {
                style.left = pixelPos.left + "px";
                style.top = pixelPos.top + "px";
                style.width = config.characterWidth + "px";
                style.height = config.lineHeight + "px";
            } else {
                this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };

    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    renderer.$scrollbarWidth =
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };
    this.getWidth = function() {
        return this.isVisible ? this.width : 0;
    };
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = this.element.scrollTop = scrollTop;
        }
    };

}).call(VScrollBar.prototype);
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module) {
"use strict";

var event = require("./lib/event");


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {


    this.schedule = function(change) {
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CHAR_COUNT = 0;

var FontMetrics = exports.FontMetrics = function(parentEl, interval) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);

    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);

    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);


    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);

    if (!CHAR_COUNT)
        this.$testFractionalRect();
    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);

    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);

    this.$characterSize = {width: 0, height: 0};

    this.$testFractionalRect = function() {
        var el = dom.createElement("div");
        this.$setMeasureNodeStyles(el.style);
        el.style.width = "0.2px";
        document.documentElement.appendChild(el);
        var w = el.getBoundingClientRect().width;
        if (w > 0 && w < 1)
            CHAR_COUNT = 50;
        else
            CHAR_COUNT = 100;
        el.parentNode.removeChild(el);
    };

    this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };

    this.setPolling = function(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };

    this.$measureSizes = function() {
        if (CHAR_COUNT === 50) {
            var rect = null;
            try {
               rect = this.$measureNode.getBoundingClientRect();
            } catch(e) {
               rect = {width: 0, height:0 };
            };
            var size = {
                height: rect.height,
                width: rect.width / CHAR_COUNT
            };
        } else {
            var size = {
                height: this.$measureNode.clientHeight,
                width: this.$measureNode.clientWidth / CHAR_COUNT
            };
        }
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };

    this.$measureCharWidth = function(ch) {
        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };

    this.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };

}).call(FontMetrics.prototype);

});

define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var config = require("./config");
var useragent = require("./lib/useragent");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var HScrollBar = require("./scrollbar").HScrollBar;
var VScrollBar = require("./scrollbar").VScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var FontMetrics = require("./layer/font_metrics").FontMetrics;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";

dom.importCssString(editorCss, "ace_editor.css");

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");
    this.$keepTextAreaAtCursor = !useragent.isOldIE;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar =
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container, 500);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1,
        gutterOffset: 1
    };

    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
    };
    this.setSession = function(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;

        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);

        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode()
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
    };

    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);


        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };

    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;

            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

            this.gutterWidth = gutterWidth;

            this.scrollBarH.element.style.left =
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());

            this.scrollBarH.element.style.right =
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes |= this.CHANGE_FULL;
        }

        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
        }
    };
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets")
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";

        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
        return this.container;
    };
    this.getMouseEventTarget = function() {
        return this.scroller;
    };
    this.getTextAreaContainer = function() {
        return this.container;
    };
    this.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor)
            return;
        var config = this.layerConfig;
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;

        var style = this.textarea.style;
        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
        }

        var w = this.characterWidth;
        if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0]+2);
            h += 2;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth;
        style.height = h + "px";
        style.width = w + "px";
        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
        style.top = Math.min(posTop, this.$size.height - h) + "px";
    };
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
        return this.layerConfig.firstRow - 1 + flint;
    };
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };

    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };

    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };

    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return;
        }
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }

        this._signal("beforeRender");
        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
        }
        if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender");
    };


    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.max(
            (this.$minLines||1) * this.lineHeight,
            Math.min(maxHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        var vScroll = height > maxHeight;

        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }

            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;

            this._signal("autosize");
        }
    };

    this.$computeLayerConfig = function() {
        var session = this.session;
        var size = this.$size;

        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();

        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = size.scrollerHeight + this.lineHeight;

        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;

        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft,
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine)
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }

        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
            height : this.$size.scrollerHeight
        };

        return changes;
    };

    this.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;

        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

        if (scrollTop + topMargin > top) {
            if (offset)
                top -= offset * this.$size.scrollerHeight;
            if (top === 0)
                top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;

        if (fromValue == toValue)
            return;

        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }

        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };
    this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var col = Math.round(
            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
        );

        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(position) {
        if (!this.$composition)
            this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
            };

        this.$keepTextAreaAtCursor = true;
        dom.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
        if (!this.$composition)
            return;

        dom.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
    };
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module.cssClass)
                return;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container.ownerDocument
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };
    this.getTheme = function() {
        return this.$themeId;
    };
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };

    this.setCursorStyle = function(style) {
        if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
    };
    this.setMouseCursor = function(cursorStyle) {
        this.scroller.style.cursor = cursorStyle;
    };
    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
        initialValue: true
    },
    showLineNumbers: {
        set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val) },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var net = require("../lib/net");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var config = require("../config");

var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (require.nameToUrl && !require.toUrl)
        require.toUrl = require.nameToUrl;

    if (config.get("packaged") || !require.toUrl) {
        workerUrl = workerUrl || config.moduleUrl(mod, "worker");
    } else {
        var normalizePath = this.$normalizePath;
        workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

        var tlns = {};
        topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
        });
    }

    try {
        this.$worker = new Worker(workerUrl);
    } catch(e) {
        if (e instanceof window.DOMException) {
            var blob = this.$workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);

            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
        } else {
            throw e;
        }
    }
    this.$worker.postMessage({
        init : true,
        tlns : tlns,
        module : mod,
        classname : classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
        var msg = e.data;
        switch(msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };

    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if(this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

    this.$workerBlob = function(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([script], {"type": "application/javascript"});
        } catch (e) { // Backwards-compatibility
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
        _self.messageBuffer.push(e);
        if (main) {
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    };
    this.setEmitSync = function(val) { emitSync = val };

    var processNext = function() {
        var msg = _self.messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (_self.messageBuffer.length)
            processNext();
    });
};

UIWorkerClient.prototype = WorkerClient.prototype;

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;

});

define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module) {
"use strict";

var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;

    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };

    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth =  undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        var pos = this.$pos;

        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(pos.row, pos.column);
        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.pos.on("change", function(event) {
            session.removeMarker(_self.markerId);
            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
        });
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
        if(this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            anchor.on("change", function(event) {
                session.removeMarker(anchor.markerId);
                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
            });
        });
    };
    this.hideOtherMarkers = function() {
        if(!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function(delta) {
        var range = delta;
        if(range.start.row !== range.end.row) return;
        if(range.start.row !== this.pos.row) return;
        if (this.$updating) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;

        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
            var distanceFromStart = range.start.column - this.pos.column;
            this.length += lengthDiff;
            if(!this.session.$fromUndo) {
                if(delta.action === 'insert') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.insertMergedLines(newPos, delta.lines);
                    }
                } else if(delta.action === 'remove') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
                if(range.start.column === this.pos.column && delta.action === 'insert') {
                    setTimeout(function() {
                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            var newPos = {row: other.row, column: other.column - lengthDiff};
                            if(other.row === range.start.row && range.start.column < other.column)
                                newPos.column += lengthDiff;
                            other.setPosition(newPos.row, newPos.column);
                        }
                    }.bind(this), 0);
                }
                else if(range.start.column === this.pos.column && delta.action === 'remove') {
                    setTimeout(function() {
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            if(other.row === range.start.row && range.start.column < other.column) {
                                other.setPosition(other.row, other.column - lengthDiff);
                            }
                        }
                    }.bind(this), 0);
                }
            }
            this.pos._emit("change", {value: this.pos});
            for (var i = 0; i < this.others.length; i++) {
                this.others[i]._emit("change", {value: this.others[i]});
            }
        }
        this.$updating = false;
    };

    this.onCursorChange = function(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };
    this.detach = function() {
        this.session.removeMarker(this.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.pos.detach();
        for (var i = 0; i < this.others.length; i++) {
            this.others[i].detach();
        }
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function() {
        if(this.$undoStackDepth === -1)
            throw Error("Canceling placeholders only supported with undo manager attached to session.");
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

var event = require("../lib/event");
var useragent = require("../lib/useragent");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();

    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }

    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }

    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };

    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;

    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }

    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);


        editor.$blockScrolling++;
        editor.inVirtualSelectionMode = true;

        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;

            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
        };
        editor.$blockScrolling++;
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }

        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
        else
            selection.moveToPosition(pos);
        editor.$blockScrolling--;

        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module) {
exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];
exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
}];

var HashHandler = require("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module) {

var RangeList = require("./range_list").RangeList;
var Range = require("./range").Range;
var Selection = require("./selection").Selection;
var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
var event = require("./lib/event");
var lang = require("./lib/lang");
var commands = require("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = require("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = require("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
        else if(this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    this.splitIntoLines = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
                if (isBackwards)
                    var start = range.end, end = range.start;
                else
                    var start = range.start, end = range.end;

                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
            }

            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);

            for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));

            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);

            rectSel.forEach(this.addRange, this);
        }
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn),
                this.session.screenToDocumentPosition(row, endColumn)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);
var Editor = require("./editor").Editor;
(function() {
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;

        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();

        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);

        return result;
    };
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };

    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
        }
    };
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);

        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        this.$blockScrolling += 1;
        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);

        this.$blockScrolling -= 1;

        return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
    };
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });

        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);

                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW, " ")
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change",  this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change",  this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change",  this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change",  this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}

exports.MultiSelect = MultiSelect;


require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});



});

define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel)
                break;

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var Range = require("./range").Range;


function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);

    this.session.on("change", this.updateOnChange);
    this.session.on("changeEditor", this.$onChangeEditor);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount)
                screenRows +=w.rowCount;
        });
        return screenRows;
    };

    this.$onChangeEditor = function(e) {
        this.attach(e.editor);
    };

    this.attach = function(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;

        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function(e) {
        var editor = this.editor;
        if (!editor)
            return;

        this.editor = null;
        editor.widgetManager = null;

        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnChange = function(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;

        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
        } else if (delta.action == 'remove') {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };

    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());

        this.session.lineWidgets[w.row] = w;

        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
        }

        if (!w.coverGutter) {
            w.el.style.zIndex = 3;
        }
        if (!w.pixelHeight) {
            w.pixelHeight = w.el.offsetHeight;
        }
        if (w.rowCount == null)
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;

        this.session._emit("changeFold", {data:{start:{row: w.row}}});

        this.$updateRows();
        this.renderWidgets(null, renderer);
        return w;
    };

    this.removeLineWidget = function(w) {
        w._inDocument = false;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets)
            this.session.lineWidgets[w.row] = undefined;
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };

    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };

    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;

        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }

            w.h = w.el.offsetHeight;

            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }

            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };

    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

        while (first > 0 && !lineWidgets[first])
            first--;

        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;

            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";

            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";

            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };

}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});

define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module) {
"use strict";
var LineWidgets = require("../line_widgets").LineWidgets;
var dom = require("../lib/dom");
var Range = require("../range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;

    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;

    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;

    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }


    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }

    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.lineWidgets && session.lineWidgets[row];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);

    var w = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div")
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;

    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";

    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");

    el.appendChild(dom.createElement("div"));

    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };

    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };

    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);

    editor.session.widgetManager.addLineWidget(w);

    w.el.onmousedown = editor.focus.bind(editor);

    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var dom = require("./lib/dom");
var event = require("./lib/event");

var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./placeholder");
require("./multi_select");
require("./mode/folding/fold_mode");
require("./theme/textmate");
require("./ext/error_marker");

exports.config = require("./config");
exports.require = require;
exports.edit = function(el) {
    if (typeof(el) == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = dom.getInnerText(el);
        el.innerHTML = '';
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el));
    editor.setSession(doc);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
}
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
});
            (function() {
                window.require(["ace/ace"], function(a) {
                    a && a.config.init(true);
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                });
            })();
        

define('ace/theme/viper', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {
    exports.isDark = false;
    exports.cssClass = "ace-chrome";
    exports.cssText = "";
    var dom = require("../lib/dom");
    dom.importCssString(exports.cssText, exports.cssClass);
});

define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        },
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
}

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var JavaScriptHighlightRules = function(options) {
    var keywordMapper = this.createKeywordMapper({
        "variable.language":
            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
            "Namespace|QName|XML|XMLList|"                                             + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
            "SyntaxError|TypeError|URIError|"                                          +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|"                                               +
            "JSON|Math|"                                                               + // Other
            "this|arguments|prototype|window|document"                                 , // Pseudo
        "keyword":
            "const|yield|import|get|set|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type":
            "const|let|var|function",
        "constant.language":
            "null|Infinity|NaN|undefined",
        "support.function":
            "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
    var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-6][0-7]?|" + // oct
        "37[0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";

    this.$rules = {
        "no_regex" : [
            {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment"
            },
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : /\/\*/,
                next : "comment"
            }, {
                token : "string",
                regex : "'(?=.)",
                next  : "qstring"
            }, {
                token : "string",
                regex : '"(?=.)',
                next  : "qqstring"
            }, {
                token : "constant.numeric", // hex
                regex : /0[xX][0-9a-fA-F]+\b/
            }, {
                token : "constant.numeric", // float
                regex : /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
            }, {
                token : [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
                ],
                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "keyword",
                regex : "(?:" + kwBeforeRe + ")\\b",
                next : "start"
            }, {
                token : ["punctuation.operator", "support.function"],
                regex : /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.function.dom"],
                regex : /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.constant"],
                regex : /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token : ["support.constant"],
                regex : /that\b/
            }, {
                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token : keywordMapper,
                regex : identifierRe
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
                next  : "start"
            }, {
                token : "punctuation.operator",
                regex : /[?:,;.]/,
                next  : "start"
            }, {
                token : "paren.lparen",
                regex : /[\[({]/,
                next  : "start"
            }, {
                token : "paren.rparen",
                regex : /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : "\\/\\*",
                next : "comment_regex_allowed"
            }, {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment_regex_allowed"
            }, {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token : "text",
                regex : "\\s+|^$",
                next : "start"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                token : "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token : "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token : "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "function_arguments": [
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: "[, ]+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qqstring"
            }, {
                token : "string",
                regex : '"|$',
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qstring"
            }, {
                token : "string",
                regex : "'|$",
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };


    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                    return "paren";
                }
                if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token : "string.quasi.start",
            regex : /`/,
            push  : [{
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "paren.quasi.start",
                regex : /\${/,
                push  : "start"
            }, {
                token : "string.quasi.end",
                regex : /`/,
                next  : "pop"
            }, {
                defaultToken: "string.quasi"
            }]
        });
    }

    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("no_regex") ]);

    this.normalizeRules();
};

oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};

var CstyleBehaviour = function() {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);

                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;

                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};


CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {

    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);

        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }

        var fw = this._getFoldWidgetBase(session, foldStyle, row);

        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart

        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);

        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);

        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);

            var range = session.getCommentFoldRange(row, i + match[0].length, 1);

            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }

            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };

    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);

            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }

        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;

        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var Range = require("../range").Range;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;

    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(results) {
            session.setAnnotations(results.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/javascript";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/mode/css_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var supportType = exports.supportType = "animation-fill-mode|alignment-adjust|alignment-baseline|animation-delay|animation-direction|animation-duration|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animation|appearance|azimuth|backface-visibility|background-attachment|background-break|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|background|baseline-shift|binding|bleed|bookmark-label|bookmark-level|bookmark-state|bookmark-target|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|border|bottom|box-align|box-decoration-break|box-direction|box-flex-group|box-flex|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side|clear|clip|color-profile|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|crop|cue-after|cue-before|cue|cursor|direction|display|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|elevation|empty-cells|fit|fit-position|float-offset|float|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|font|grid-columns|grid-rows|hanging-punctuation|height|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|icon|image-orientation|image-rendering|image-resolution|inline-box-align|left|letter-spacing|line-height|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|line-stacking|list-style-image|list-style-position|list-style-type|list-style|margin-bottom|margin-left|margin-right|margin-top|margin|mark-after|mark-before|mark|marks|marquee-direction|marquee-play-count|marquee-speed|marquee-style|max-height|max-width|min-height|min-width|move-to|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|orphans|outline-color|outline-offset|outline-style|outline-width|outline|overflow-style|overflow-x|overflow-y|overflow|padding-bottom|padding-left|padding-right|padding-top|padding|page-break-after|page-break-before|page-break-inside|page-policy|page|pause-after|pause-before|pause|perspective-origin|perspective|phonemes|pitch-range|pitch|play-during|pointer-events|position|presentation-level|punctuation-trim|quotes|rendering-intent|resize|rest-after|rest-before|rest|richness|right|rotation-point|rotation|ruby-align|ruby-overhang|ruby-position|ruby-span|size|speak-header|speak-numeral|speak-punctuation|speak|speech-rate|stress|string-set|table-layout|target-name|target-new|target-position|target|text-align-last|text-align|text-decoration|text-emphasis|text-height|text-indent|text-justify|text-outline|text-shadow|text-transform|text-wrap|top|transform-origin|transform-style|transform|transition-delay|transition-duration|transition-property|transition-timing-function|transition|unicode-bidi|vertical-align|visibility|voice-balance|voice-duration|voice-family|voice-pitch-range|voice-pitch|voice-rate|voice-stress|voice-volume|volume|white-space-collapse|white-space|widows|width|word-break|word-spacing|word-wrap|z-index";
var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
var pseudoClasses  = exports.pseudoClasses =  "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

var CssHighlightRules = function() {

    var keywordMapper = this.createKeywordMapper({
        "support.function": supportFunction,
        "support.constant": supportConstant,
        "support.type": supportType,
        "support.constant.color": supportConstantColor,
        "support.constant.fonts": supportConstantFonts
    }, "text", true);

    this.$rules = {
        "start" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "@.*?{",
            push:  "media"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "media" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "\\}",
            next:  "pop"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "comment" : [{
            token : "comment",
            regex : "\\*\\/",
            next : "pop"
        }, {
            defaultToken : "comment"
        }],

        "ruleset" : [
        {
            token : "paren.rparen",
            regex : "\\}",
            next:   "pop"
        }, {
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token : "string", // single line
            regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
        }, {
            token : "string", // single line
            regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
        }, {
            token : ["constant.numeric", "keyword"],
            regex : "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
        }, {
            token : "constant.numeric",
            regex : numRe
        }, {
            token : "constant.numeric",  // hex6 color
            regex : "#[a-f0-9]{6}"
        }, {
            token : "constant.numeric", // hex3 color
            regex : "#[a-f0-9]{3}"
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex : pseudoElements
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex : pseudoClasses
        }, {
            token : ["support.function", "string", "support.function"],
            regex : "(url\\()(.*)(\\))"
        }, {
            token : keywordMapper,
            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
        }, {
            caseInsensitive: true
        }]
    };

    this.normalizeRules();
};

oop.inherits(CssHighlightRules, TextHighlightRules);

exports.CssHighlightRules = CssHighlightRules;

});

define("ace/mode/behaviour/css",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;

var CssBehaviour = function () {

    this.inherit(CstyleBehaviour);

    this.add("colon", "insertion", function (state, action, editor, session, text) {
        if (text === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ':') {
                    return {
                       text: '',
                       selection: [1, 1]
                    }
                }
                if (!line.substring(cursor.column).match(/^\s*;/)) {
                    return {
                       text: ':;',
                       selection: [1, 1]
                    }
                }
            }
        }
    });

    this.add("colon", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ';') {
                    range.end.column ++;
                    return range;
                }
            }
        }
    });

    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
        if (text === ';') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
                return {
                   text: '',
                   selection: [1, 1]
                }
            }
        }
    });

}
oop.inherits(CssBehaviour, CstyleBehaviour);

exports.CssBehaviour = CssBehaviour;
});

define("ace/mode/css",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/css_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/css","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CssBehaviour = require("./behaviour/css").CssBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.foldingRules = "cStyle";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/css";
}).call(Mode.prototype);

exports.Mode = Mode;

});

define("ace/mode/xml_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var XmlHighlightRules = function(normalize) {
    var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

    this.$rules = {
        start : [
            {token : "string.cdata.xml", regex : "<\\!\\[CDATA\\[", next : "cdata"},
            {
                token : ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                regex : "(<\\?)(xml)(?=[\\s])", next : "xml_decl", caseInsensitive: true
            },
            {
                token : ["punctuation.instruction.xml", "keyword.instruction.xml"],
                regex : "(<\\?)(" + tagRegex + ")", next : "processing_instruction",
            },
            {token : "comment.xml", regex : "<\\!--", next : "comment"},
            {
                token : ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                regex : "(<\\!)(DOCTYPE)(?=[\\s])", next : "doctype", caseInsensitive: true
            },
            {include : "tag"},
            {token : "text.end-tag-open.xml", regex: "</"},
            {token : "text.tag-open.xml", regex: "<"},
            {include : "reference"},
            {defaultToken : "text.xml"}
        ],

        xml_decl : [{
            token : "entity.other.attribute-name.decl-attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.decl-attribute-equals.xml",
            regex : "="
        }, {
            include: "whitespace"
        }, {
            include: "string"
        }, {
            token : "punctuation.xml-decl.xml",
            regex : "\\?>",
            next : "start"
        }],

        processing_instruction : [
            {token : "punctuation.instruction.xml", regex : "\\?>", next : "start"},
            {defaultToken : "instruction.xml"}
        ],

        doctype : [
            {include : "whitespace"},
            {include : "string"},
            {token : "xml-pe.doctype.xml", regex : ">", next : "start"},
            {token : "xml-pe.xml", regex : "[-_a-zA-Z0-9:]+"},
            {token : "punctuation.int-subset", regex : "\\[", push : "int_subset"}
        ],

        int_subset : [{
            token : "text.xml",
            regex : "\\s+"
        }, {
            token: "punctuation.int-subset.xml",
            regex: "]",
            next: "pop"
        }, {
            token : ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
            regex : "(<\\!)(" + tagRegex + ")",
            push : [{
                token : "text",
                regex : "\\s+"
            },
            {
                token : "punctuation.markup-decl.xml",
                regex : ">",
                next : "pop"
            },
            {include : "string"}]
        }],

        cdata : [
            {token : "string.cdata.xml", regex : "\\]\\]>", next : "start"},
            {token : "text.xml", regex : "\\s+"},
            {token : "text.xml", regex : "(?:[^\\]]|\\](?!\\]>))+"}
        ],

        comment : [
            {token : "comment.xml", regex : "-->", next : "start"},
            {defaultToken : "comment.xml"}
        ],

        reference : [{
            token : "constant.language.escape.reference.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        attr_reference : [{
            token : "constant.language.escape.reference.attribute-value.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        tag : [{
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
            regex : "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
            ]
        }],

        tag_whitespace : [
            {token : "text.tag-whitespace.xml", regex : "\\s+"}
        ],
        whitespace : [
            {token : "text.whitespace.xml", regex : "\\s+"}
        ],
        string: [{
            token : "string.xml",
            regex : "'",
            push : [
                {token : "string.xml", regex: "'", next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }, {
            token : "string.xml",
            regex : '"',
            push : [
                {token : "string.xml", regex: '"', next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }],

        attributes: [{
            token : "entity.other.attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "="
        }, {
            include: "tag_whitespace"
        }, {
            include: "attribute_value"
        }],

        attribute_value: [{
            token : "string.attribute-value.xml",
            regex : "'",
            push : [
                {token : "string.attribute-value.xml", regex: "'", next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }, {
            token : "string.attribute-value.xml",
            regex : '"',
            push : [
                {token : "string.attribute-value.xml", regex: '"', next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }]
    };

    if (this.constructor === XmlHighlightRules)
        this.normalizeRules();
};


(function() {

    this.embedTagRules = function(HighlightRules, prefix, tag){
        this.$rules.tag.unshift({
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(<)(" + tag + "(?=\\s|>|$))",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : prefix + "start"}
            ]
        });

        this.$rules[tag + "-end"] = [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>",  next: "start",
                onMatch : function(value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
            }}
        ]

        this.embedRules(HighlightRules, prefix, [{
            token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(</)(" + tag + "(?=\\s|>|$))",
            next: tag + "-end"
        }, {
            token: "string.cdata.xml",
            regex : "<\\!\\[CDATA\\["
        }, {
            token: "string.cdata.xml",
            regex : "\\]\\]>"
        }]);
    };

}).call(TextHighlightRules.prototype);

oop.inherits(XmlHighlightRules, TextHighlightRules);

exports.XmlHighlightRules = XmlHighlightRules;
});

define("ace/mode/html_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/css_highlight_rules","ace/mode/javascript_highlight_rules","ace/mode/xml_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;

var tagMap = lang.createMap({
    a           : 'anchor',
    button 	    : 'form',
    form        : 'form',
    img         : 'image',
    input       : 'form',
    label       : 'form',
    option      : 'form',
    script      : 'script',
    select      : 'form',
    textarea    : 'form',
    style       : 'style',
    table       : 'table',
    tbody       : 'table',
    td          : 'table',
    tfoot       : 'table',
    th          : 'table',
    tr          : 'table'
});

var HtmlHighlightRules = function() {
    XmlHighlightRules.call(this);

    this.addRules({
        attributes: [{
            include : "tag_whitespace"
        }, {
            token : "entity.other.attribute-name.xml",
            regex : "[-_a-zA-Z0-9:.]+"
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "=",
            push : [{
                include: "tag_whitespace"
            }, {
                token : "string.unquoted.attribute-value.html",
                regex : "[^<>='\"`\\s]+",
                next : "pop"
            }, {
                token : "empty",
                regex : "",
                next : "pop"
            }]
        }, {
            include : "attribute_value"
        }],
        tag: [{
            token : function(start, tag) {
                var group = tagMap[tag];
                return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
                    "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
            },
            regex : "(</?)([-_a-zA-Z0-9:.]+)",
            next: "tag_stuff"
        }],
        tag_stuff: [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
        ],
    });

    this.embedTagRules(CssHighlightRules, "css-", "style");
    this.embedTagRules(JavaScriptHighlightRules, "js-", "script");

    if (this.constructor === HtmlHighlightRules)
        this.normalizeRules();
};

oop.inherits(HtmlHighlightRules, XmlHighlightRules);

exports.HtmlHighlightRules = HtmlHighlightRules;
});

define("ace/mode/behaviour/xml",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

var XmlBehaviour = function () {

    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            }

            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                return {
                    text: "",
                    selection: [1, 1]
                };
            }

            if (!token)
                token = iterator.stepBackward();

            if (!token)
                return;

            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
                return {
                    text: quote + quote,
                    selection: [1, 1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
        if (text == '>') {
            var position = editor.getCursorPosition();
            var iterator = new TokenIterator(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();
            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
                return;
            if (is(token, "reference.attribute-value"))
                return;
            if (is(token, "attribute-value")) {
                var firstChar = token.value.charAt(0);
                if (firstChar == '"' || firstChar == "'") {
                    var lastChar = token.value.charAt(token.value.length - 1);
                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
                        return;
                }
            }
            while (!is(token, "tag-name")) {
                token = iterator.stepBackward();
            }

            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();
            if (is(iterator.stepBackward(), "end-tag-open"))
                return;

            var element = token.value;
            if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);

            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                 return;

            return {
               text: ">" + "</" + element + ">",
               selection: [1, 1]
            };
        }
    });

    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
        if (text == "\n") {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (token && token.type.indexOf("tag-close") !== -1) {
                if (token.value == "/>")
                    return;
                while (token && token.type.indexOf("tag-name") === -1) {
                    token = iterator.stepBackward();
                }

                if (!token) {
                    return;
                }

                var tag = token.value;
                var row = iterator.getCurrentTokenRow();
                token = iterator.stepBackward();
                if (!token || token.type.indexOf("end-tag") !== -1) {
                    return;
                }

                if (this.voidElements && !this.voidElements[tag]) {
                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);
                    var line = session.getLine(row);
                    var nextIndent = this.$getIndent(line);
                    var indent = nextIndent + session.getTabString();

                    if (nextToken && nextToken.value === "</") {
                        return {
                            text: "\n" + indent + "\n" + nextIndent,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        return {
                            text: "\n" + indent
                        };
                    }
                }
            }
        }
    });

};

oop.inherits(XmlBehaviour, Behaviour);

exports.XmlBehaviour = XmlBehaviour;
});

define("ace/mode/folding/mixed",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(defaultMode, subModes) {
    this.defaultMode = defaultMode;
    this.subModes = subModes;
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {


    this.$getMode = function(state) {
        if (typeof state != "string")
            state = state[0];
        for (var key in this.subModes) {
            if (state.indexOf(key) === 0)
                return this.subModes[key];
        }
        return null;
    };

    this.$tryMode = function(state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
    };

    this.getFoldWidget = function(session, foldStyle, row) {
        return (
            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||
            this.$tryMode(session.getState(row), session, foldStyle, row) ||
            this.defaultMode.getFoldWidget(session, foldStyle, row)
        );
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row-1));

        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.$getMode(session.getState(row));

        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.defaultMode;

        return mode.getFoldWidgetRange(session, foldStyle, row);
    };

}).call(FoldMode.prototype);

});

define("ace/mode/folding/xml",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/range","ace/mode/folding/fold_mode","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var lang = require("../../lib/lang");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;
var TokenIterator = require("../../token_iterator").TokenIterator;

var FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {
    BaseFoldMode.call(this);
    this.voidElements = voidElements || {};
    this.optionalEndTags = oop.mixin({}, this.voidElements);
    if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);

};
oop.inherits(FoldMode, BaseFoldMode);

var Tag = function() {
    this.tagName = "";
    this.closing = false;
    this.selfClosing = false;
    this.start = {row: 0, column: 0};
    this.end = {row: 0, column: 0};
};

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

(function() {

    this.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);

        if (!tag)
            return "";

        if (tag.closing || (!tag.tagName && tag.selfClosing))
            return foldStyle == "markbeginend" ? "end" : "";

        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
            return "";

        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
            return "";

        return "start";
    };
    this._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (is(token, "tag-open")) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, "end-tag-open");
                token = tokens[++i];
                if (!token)
                    return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i < tokens.length; i++) {
                    token = tokens[i];
                    tag.end.column += token.value.length;
                    if (is(token, "tag-close")) {
                        tag.selfClosing = token.value == '/>';
                        break;
                    }
                }
                return tag;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == '/>';
                return tag;
            }
            tag.start.column += token.value.length;
        }

        return null;
    };

    this._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            column += token.value.length;
            if (column < startColumn)
                continue;
            if (is(token, "end-tag-open")) {
                token = tokens[i + 1];
                if (token && token.value == tagName)
                    return true;
            }
        }
        return false;
    };
    this._readTagForward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                iterator.stepForward();
                return tag;
            }
        } while(token = iterator.stepForward());

        return null;
    };

    this._readTagBackward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
                iterator.stepBackward();
                return tag;
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
            }
        } while(token = iterator.stepBackward());

        return null;
    };

    this._pop = function(stack, tag) {
        while (stack.length) {

            var top = stack[stack.length-1];
            if (!tag || top.tagName == tag.tagName) {
                return stack.pop();
            }
            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                stack.pop();
                continue;
            } else {
                return null;
            }
        }
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);

        if (!firstTag)
            return null;

        var isBackward = firstTag.closing || firstTag.selfClosing;
        var stack = [];
        var tag;

        if (!isBackward) {
            var iterator = new TokenIterator(session, row, firstTag.start.column);
            var start = {
                row: row,
                column: firstTag.start.column + firstTag.tagName.length + 2
            };
            if (firstTag.start.row == firstTag.end.row)
                start.column = firstTag.end.column;
            while (tag = this._readTagForward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }

                if (tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0)
                        return Range.fromPoints(start, tag.start);
                }
                else {
                    stack.push(tag);
                }
            }
        }
        else {
            var iterator = new TokenIterator(session, row, firstTag.end.column);
            var end = {
                row: row,
                column: firstTag.start.column
            };

            while (tag = this._readTagBackward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }

                if (!tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0) {
                        tag.start.column += tag.tagName.length + 2;
                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
                            tag.start.column = tag.end.column;
                        return Range.fromPoints(tag.start, end);
                    }
                }
                else {
                    stack.push(tag);
                }
            }
        }

    };

}).call(FoldMode.prototype);

});

define("ace/mode/folding/html",["require","exports","module","ace/lib/oop","ace/mode/folding/mixed","ace/mode/folding/xml","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var MixedFoldMode = require("./mixed").FoldMode;
var XmlFoldMode = require("./xml").FoldMode;
var CStyleFoldMode = require("./cstyle").FoldMode;

var FoldMode = exports.FoldMode = function(voidElements, optionalTags) {
    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
        "js-": new CStyleFoldMode(),
        "css-": new CStyleFoldMode()
    });
};

oop.inherits(FoldMode, MixedFoldMode);

});

define("ace/mode/html_completions",["require","exports","module","ace/token_iterator"], function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;

var commonAttributes = [
    "accesskey",
    "class",
    "contenteditable",
    "contextmenu",
    "dir",
    "draggable",
    "dropzone",
    "hidden",
    "id",
    "inert",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
];

var eventAttributes = [
    "onabort",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextmenu",
    "oncuechange",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmousedown",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onpause",
    "onplay",
    "onplaying",
    "onprogress",
    "onratechange",
    "onreset",
    "onscroll",
    "onseeked",
    "onseeking",
    "onselect",
    "onshow",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "onvolumechange",
    "onwaiting"
];

var globalAttributes = commonAttributes.concat(eventAttributes);

var attributeMap = {
    "html": ["manifest"],
    "head": [],
    "title": [],
    "base": ["href", "target"],
    "link": ["href", "hreflang", "rel", "media", "type", "sizes"],
    "meta": ["http-equiv", "name", "content", "charset"],
    "style": ["type", "media", "scoped"],
    "script": ["charset", "type", "src", "defer", "async"],
    "noscript": ["href"],
    "body": ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onmessage", "onoffline", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload"],
    "section": [],
    "nav": [],
    "article": ["pubdate"],
    "aside": [],
    "h1": [],
    "h2": [],
    "h3": [],
    "h4": [],
    "h5": [],
    "h6": [],
    "header": [],
    "footer": [],
    "address": [],
    "main": [],
    "p": [],
    "hr": [],
    "pre": [],
    "blockquote": ["cite"],
    "ol": ["start", "reversed"],
    "ul": [],
    "li": ["value"],
    "dl": [],
    "dt": [],
    "dd": [],
    "figure": [],
    "figcaption": [],
    "div": [],
    "a": ["href", "target", "ping", "rel", "media", "hreflang", "type"],
    "em": [],
    "strong": [],
    "small": [],
    "s": [],
    "cite": [],
    "q": ["cite"],
    "dfn": [],
    "abbr": [],
    "data": [],
    "time": ["datetime"],
    "code": [],
    "var": [],
    "samp": [],
    "kbd": [],
    "sub": [],
    "sup": [],
    "i": [],
    "b": [],
    "u": [],
    "mark": [],
    "ruby": [],
    "rt": [],
    "rp": [],
    "bdi": [],
    "bdo": [],
    "span": [],
    "br": [],
    "wbr": [],
    "ins": ["cite", "datetime"],
    "del": ["cite", "datetime"],
    "img": ["alt", "src", "height", "width", "usemap", "ismap"],
    "iframe": ["name", "src", "height", "width", "sandbox", "seamless"],
    "embed": ["src", "height", "width", "type"],
    "object": ["param", "data", "type", "height" , "width", "usemap", "name", "form", "classid"],
    "param": ["name", "value"],
    "video": ["src", "autobuffer", "autoplay", "loop", "controls", "width", "height", "poster"],
    "audio": ["src", "autobuffer", "autoplay", "loop", "controls"],
    "source": ["src", "type", "media"],
    "track": ["kind", "src", "srclang", "label", "default"],
    "canvas": ["width", "height"],
    "map": ["name"],
    "area": ["shape", "coords", "href", "hreflang", "alt", "target", "media", "rel", "ping", "type"],
    "svg": [],
    "math": [],
    "table": ["summary"],
    "caption": [],
    "colgroup": ["span"],
    "col": ["span"],
    "tbody": [],
    "thead": [],
    "tfoot": [],
    "tr": [],
    "td": ["headers", "rowspan", "colspan"],
    "th": ["headers", "rowspan", "colspan", "scope"],
    "form": ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"],
    "fieldset": ["disabled", "form", "name"],
    "legend": [],
    "label": ["form", "for"],
    "input": ["type", "accept", "alt", "autocomplete", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "list", "max", "maxlength", "min", "multiple", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "width", "files", "value"],
    "button": ["autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "value", "type"],
    "select": ["autofocus", "disabled", "form", "multiple", "name", "size"],
    "datalist": [],
    "optgroup": ["disabled", "label"],
    "option": ["disabled", "selected", "label", "value"],
    "textarea": ["autofocus", "disabled", "form", "maxlength", "name", "placeholder", "readonly", "required", "rows", "cols", "wrap"],
    "keygen": ["autofocus", "challenge", "disabled", "form", "keytype", "name"],
    "output": ["for", "form", "name"],
    "progress": ["value", "max"],
    "meter": ["value", "min", "max", "low", "high", "optimum"],
    "details": ["open"],
    "summary": [],
    "command": ["type", "label", "icon", "disabled", "checked", "radiogroup", "command"],
    "menu": ["type", "label"],
    "dialog": ["open"]
};

var elements = Object.keys(attributeMap);

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

function findTagName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "tag-name")){
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}

var HtmlCompletions = function() {

};

(function() {

    this.getCompletions = function(state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);

        if (!token)
            return [];
        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
            return this.getTagCompletions(state, session, pos, prefix);
        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
            return this.getAttributeCompetions(state, session, pos, prefix);

        return [];
    };

    this.getTagCompletions = function(state, session, pos, prefix) {
        return elements.map(function(element){
            return {
                value: element,
                meta: "tag",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getAttributeCompetions = function(state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
            return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
            attributes = attributes.concat(attributeMap[tagName]);
        }
        return attributes.map(function(attribute){
            return {
                caption: attribute,
                snippet: attribute + '="$0"',
                meta: "attribute",
                score: Number.MAX_VALUE
            };
        });
    };

}).call(HtmlCompletions.prototype);

exports.HtmlCompletions = HtmlCompletions;
});

define("ace/mode/html",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/javascript","ace/mode/css","ace/mode/html_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/html","ace/mode/html_completions","ace/worker/worker_client"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextMode = require("./text").Mode;
var JavaScriptMode = require("./javascript").Mode;
var CssMode = require("./css").Mode;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
var HtmlFoldMode = require("./folding/html").FoldMode;
var HtmlCompletions = require("./html_completions").HtmlCompletions;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

var Mode = function(options) {
    this.fragmentContext = options && options.fragmentContext;
    this.HighlightRules = HtmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();

    this.createModeDelegates({
        "js-": JavaScriptMode,
        "css-": CssMode
    });

    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
};
oop.inherits(Mode, TextMode);

(function() {

    this.blockComment = {start: "<!--", end: "-->"};

    this.voidElements = lang.arrayToMap(voidElements);

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.createWorker = function(session) {
        if (this.constructor != Mode)
            return;
        var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        if (this.fragmentContext)
            worker.call("setOptions", [{context: this.fragmentContext}]);

        worker.on("error", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/html";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        },
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
}

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

define("ace/mode/css_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var supportType = exports.supportType = "animation-fill-mode|alignment-adjust|alignment-baseline|animation-delay|animation-direction|animation-duration|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animation|appearance|azimuth|backface-visibility|background-attachment|background-break|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|background|baseline-shift|binding|bleed|bookmark-label|bookmark-level|bookmark-state|bookmark-target|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|border|bottom|box-align|box-decoration-break|box-direction|box-flex-group|box-flex|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side|clear|clip|color-profile|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|crop|cue-after|cue-before|cue|cursor|direction|display|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|elevation|empty-cells|fit|fit-position|float-offset|float|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|font|grid-columns|grid-rows|hanging-punctuation|height|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|icon|image-orientation|image-rendering|image-resolution|inline-box-align|left|letter-spacing|line-height|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|line-stacking|list-style-image|list-style-position|list-style-type|list-style|margin-bottom|margin-left|margin-right|margin-top|margin|mark-after|mark-before|mark|marks|marquee-direction|marquee-play-count|marquee-speed|marquee-style|max-height|max-width|min-height|min-width|move-to|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|orphans|outline-color|outline-offset|outline-style|outline-width|outline|overflow-style|overflow-x|overflow-y|overflow|padding-bottom|padding-left|padding-right|padding-top|padding|page-break-after|page-break-before|page-break-inside|page-policy|page|pause-after|pause-before|pause|perspective-origin|perspective|phonemes|pitch-range|pitch|play-during|pointer-events|position|presentation-level|punctuation-trim|quotes|rendering-intent|resize|rest-after|rest-before|rest|richness|right|rotation-point|rotation|ruby-align|ruby-overhang|ruby-position|ruby-span|size|speak-header|speak-numeral|speak-punctuation|speak|speech-rate|stress|string-set|table-layout|target-name|target-new|target-position|target|text-align-last|text-align|text-decoration|text-emphasis|text-height|text-indent|text-justify|text-outline|text-shadow|text-transform|text-wrap|top|transform-origin|transform-style|transform|transition-delay|transition-duration|transition-property|transition-timing-function|transition|unicode-bidi|vertical-align|visibility|voice-balance|voice-duration|voice-family|voice-pitch-range|voice-pitch|voice-rate|voice-stress|voice-volume|volume|white-space-collapse|white-space|widows|width|word-break|word-spacing|word-wrap|z-index";
var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
var pseudoClasses  = exports.pseudoClasses =  "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

var CssHighlightRules = function() {

    var keywordMapper = this.createKeywordMapper({
        "support.function": supportFunction,
        "support.constant": supportConstant,
        "support.type": supportType,
        "support.constant.color": supportConstantColor,
        "support.constant.fonts": supportConstantFonts
    }, "text", true);

    this.$rules = {
        "start" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "@.*?{",
            push:  "media"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "media" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "\\}",
            next:  "pop"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "comment" : [{
            token : "comment",
            regex : "\\*\\/",
            next : "pop"
        }, {
            defaultToken : "comment"
        }],

        "ruleset" : [
        {
            token : "paren.rparen",
            regex : "\\}",
            next:   "pop"
        }, {
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token : "string", // single line
            regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
        }, {
            token : "string", // single line
            regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
        }, {
            token : ["constant.numeric", "keyword"],
            regex : "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
        }, {
            token : "constant.numeric",
            regex : numRe
        }, {
            token : "constant.numeric",  // hex6 color
            regex : "#[a-f0-9]{6}"
        }, {
            token : "constant.numeric", // hex3 color
            regex : "#[a-f0-9]{3}"
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex : pseudoElements
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex : pseudoClasses
        }, {
            token : ["support.function", "string", "support.function"],
            regex : "(url\\()(.*)(\\))"
        }, {
            token : keywordMapper,
            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
        }, {
            caseInsensitive: true
        }]
    };

    this.normalizeRules();
};

oop.inherits(CssHighlightRules, TextHighlightRules);

exports.CssHighlightRules = CssHighlightRules;

});

define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var JavaScriptHighlightRules = function(options) {
    var keywordMapper = this.createKeywordMapper({
        "variable.language":
            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
            "Namespace|QName|XML|XMLList|"                                             + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
            "SyntaxError|TypeError|URIError|"                                          +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|"                                               +
            "JSON|Math|"                                                               + // Other
            "this|arguments|prototype|window|document"                                 , // Pseudo
        "keyword":
            "const|yield|import|get|set|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type":
            "const|let|var|function",
        "constant.language":
            "null|Infinity|NaN|undefined",
        "support.function":
            "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
    var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-6][0-7]?|" + // oct
        "37[0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";

    this.$rules = {
        "no_regex" : [
            {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment"
            },
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : /\/\*/,
                next : "comment"
            }, {
                token : "string",
                regex : "'(?=.)",
                next  : "qstring"
            }, {
                token : "string",
                regex : '"(?=.)',
                next  : "qqstring"
            }, {
                token : "constant.numeric", // hex
                regex : /0[xX][0-9a-fA-F]+\b/
            }, {
                token : "constant.numeric", // float
                regex : /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
            }, {
                token : [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
                ],
                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "keyword",
                regex : "(?:" + kwBeforeRe + ")\\b",
                next : "start"
            }, {
                token : ["punctuation.operator", "support.function"],
                regex : /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.function.dom"],
                regex : /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.constant"],
                regex : /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token : ["support.constant"],
                regex : /that\b/
            }, {
                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token : keywordMapper,
                regex : identifierRe
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
                next  : "start"
            }, {
                token : "punctuation.operator",
                regex : /[?:,;.]/,
                next  : "start"
            }, {
                token : "paren.lparen",
                regex : /[\[({]/,
                next  : "start"
            }, {
                token : "paren.rparen",
                regex : /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : "\\/\\*",
                next : "comment_regex_allowed"
            }, {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment_regex_allowed"
            }, {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token : "text",
                regex : "\\s+|^$",
                next : "start"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                token : "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token : "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token : "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "function_arguments": [
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: "[, ]+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qqstring"
            }, {
                token : "string",
                regex : '"|$',
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qstring"
            }, {
                token : "string",
                regex : "'|$",
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };


    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                    return "paren";
                }
                if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token : "string.quasi.start",
            regex : /`/,
            push  : [{
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "paren.quasi.start",
                regex : /\${/,
                push  : "start"
            }, {
                token : "string.quasi.end",
                regex : /`/,
                next  : "pop"
            }, {
                defaultToken: "string.quasi"
            }]
        });
    }

    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("no_regex") ]);

    this.normalizeRules();
};

oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

define("ace/mode/xml_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var XmlHighlightRules = function(normalize) {
    var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

    this.$rules = {
        start : [
            {token : "string.cdata.xml", regex : "<\\!\\[CDATA\\[", next : "cdata"},
            {
                token : ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                regex : "(<\\?)(xml)(?=[\\s])", next : "xml_decl", caseInsensitive: true
            },
            {
                token : ["punctuation.instruction.xml", "keyword.instruction.xml"],
                regex : "(<\\?)(" + tagRegex + ")", next : "processing_instruction",
            },
            {token : "comment.xml", regex : "<\\!--", next : "comment"},
            {
                token : ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                regex : "(<\\!)(DOCTYPE)(?=[\\s])", next : "doctype", caseInsensitive: true
            },
            {include : "tag"},
            {token : "text.end-tag-open.xml", regex: "</"},
            {token : "text.tag-open.xml", regex: "<"},
            {include : "reference"},
            {defaultToken : "text.xml"}
        ],

        xml_decl : [{
            token : "entity.other.attribute-name.decl-attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.decl-attribute-equals.xml",
            regex : "="
        }, {
            include: "whitespace"
        }, {
            include: "string"
        }, {
            token : "punctuation.xml-decl.xml",
            regex : "\\?>",
            next : "start"
        }],

        processing_instruction : [
            {token : "punctuation.instruction.xml", regex : "\\?>", next : "start"},
            {defaultToken : "instruction.xml"}
        ],

        doctype : [
            {include : "whitespace"},
            {include : "string"},
            {token : "xml-pe.doctype.xml", regex : ">", next : "start"},
            {token : "xml-pe.xml", regex : "[-_a-zA-Z0-9:]+"},
            {token : "punctuation.int-subset", regex : "\\[", push : "int_subset"}
        ],

        int_subset : [{
            token : "text.xml",
            regex : "\\s+"
        }, {
            token: "punctuation.int-subset.xml",
            regex: "]",
            next: "pop"
        }, {
            token : ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
            regex : "(<\\!)(" + tagRegex + ")",
            push : [{
                token : "text",
                regex : "\\s+"
            },
            {
                token : "punctuation.markup-decl.xml",
                regex : ">",
                next : "pop"
            },
            {include : "string"}]
        }],

        cdata : [
            {token : "string.cdata.xml", regex : "\\]\\]>", next : "start"},
            {token : "text.xml", regex : "\\s+"},
            {token : "text.xml", regex : "(?:[^\\]]|\\](?!\\]>))+"}
        ],

        comment : [
            {token : "comment.xml", regex : "-->", next : "start"},
            {defaultToken : "comment.xml"}
        ],

        reference : [{
            token : "constant.language.escape.reference.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        attr_reference : [{
            token : "constant.language.escape.reference.attribute-value.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        tag : [{
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
            regex : "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
            ]
        }],

        tag_whitespace : [
            {token : "text.tag-whitespace.xml", regex : "\\s+"}
        ],
        whitespace : [
            {token : "text.whitespace.xml", regex : "\\s+"}
        ],
        string: [{
            token : "string.xml",
            regex : "'",
            push : [
                {token : "string.xml", regex: "'", next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }, {
            token : "string.xml",
            regex : '"',
            push : [
                {token : "string.xml", regex: '"', next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }],

        attributes: [{
            token : "entity.other.attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "="
        }, {
            include: "tag_whitespace"
        }, {
            include: "attribute_value"
        }],

        attribute_value: [{
            token : "string.attribute-value.xml",
            regex : "'",
            push : [
                {token : "string.attribute-value.xml", regex: "'", next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }, {
            token : "string.attribute-value.xml",
            regex : '"',
            push : [
                {token : "string.attribute-value.xml", regex: '"', next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }]
    };

    if (this.constructor === XmlHighlightRules)
        this.normalizeRules();
};


(function() {

    this.embedTagRules = function(HighlightRules, prefix, tag){
        this.$rules.tag.unshift({
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(<)(" + tag + "(?=\\s|>|$))",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : prefix + "start"}
            ]
        });

        this.$rules[tag + "-end"] = [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>",  next: "start",
                onMatch : function(value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
            }}
        ]

        this.embedRules(HighlightRules, prefix, [{
            token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(</)(" + tag + "(?=\\s|>|$))",
            next: tag + "-end"
        }, {
            token: "string.cdata.xml",
            regex : "<\\!\\[CDATA\\["
        }, {
            token: "string.cdata.xml",
            regex : "\\]\\]>"
        }]);
    };

}).call(TextHighlightRules.prototype);

oop.inherits(XmlHighlightRules, TextHighlightRules);

exports.XmlHighlightRules = XmlHighlightRules;
});

define("ace/mode/html_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/css_highlight_rules","ace/mode/javascript_highlight_rules","ace/mode/xml_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;

var tagMap = lang.createMap({
    a           : 'anchor',
    button 	    : 'form',
    form        : 'form',
    img         : 'image',
    input       : 'form',
    label       : 'form',
    option      : 'form',
    script      : 'script',
    select      : 'form',
    textarea    : 'form',
    style       : 'style',
    table       : 'table',
    tbody       : 'table',
    td          : 'table',
    tfoot       : 'table',
    th          : 'table',
    tr          : 'table'
});

var HtmlHighlightRules = function() {
    XmlHighlightRules.call(this);

    this.addRules({
        attributes: [{
            include : "tag_whitespace"
        }, {
            token : "entity.other.attribute-name.xml",
            regex : "[-_a-zA-Z0-9:.]+"
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "=",
            push : [{
                include: "tag_whitespace"
            }, {
                token : "string.unquoted.attribute-value.html",
                regex : "[^<>='\"`\\s]+",
                next : "pop"
            }, {
                token : "empty",
                regex : "",
                next : "pop"
            }]
        }, {
            include : "attribute_value"
        }],
        tag: [{
            token : function(start, tag) {
                var group = tagMap[tag];
                return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
                    "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
            },
            regex : "(</?)([-_a-zA-Z0-9:.]+)",
            next: "tag_stuff"
        }],
        tag_stuff: [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
        ],
    });

    this.embedTagRules(CssHighlightRules, "css-", "style");
    this.embedTagRules(JavaScriptHighlightRules, "js-", "script");

    if (this.constructor === HtmlHighlightRules)
        this.normalizeRules();
};

oop.inherits(HtmlHighlightRules, XmlHighlightRules);

exports.HtmlHighlightRules = HtmlHighlightRules;
});

define("ace/mode/php_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules","ace/mode/html_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;

var PhpLangHighlightRules = function() {
    var docComment = DocCommentHighlightRules;
    var builtinFunctions = lang.arrayToMap(
        ('abs|acos|acosh|addcslashes|addslashes|aggregate|aggregate_info|aggregate_methods|aggregate_methods_by_list|aggregate_methods_by_regexp|' +
        'aggregate_properties|aggregate_properties_by_list|aggregate_properties_by_regexp|aggregation_info|amqpconnection|amqpexchange|amqpqueue|' +
        'apache_child_terminate|apache_get_modules|apache_get_version|apache_getenv|apache_lookup_uri|apache_note|apache_request_headers|' +
        'apache_reset_timeout|apache_response_headers|apache_setenv|apc_add|apc_bin_dump|apc_bin_dumpfile|apc_bin_load|apc_bin_loadfile|' +
        'apc_cache_info|apc_cas|apc_clear_cache|apc_compile_file|apc_dec|apc_define_constants|apc_delete|apc_delete_file|apc_exists|apc_fetch|' +
        'apc_inc|apc_load_constants|apc_sma_info|apc_store|apciterator|apd_breakpoint|apd_callstack|apd_clunk|apd_continue|apd_croak|' +
        'apd_dump_function_table|apd_dump_persistent_resources|apd_dump_regular_resources|apd_echo|apd_get_active_symbols|apd_set_pprof_trace|' +
        'apd_set_session|apd_set_session_trace|apd_set_session_trace_socket|appenditerator|array|array_change_key_case|array_chunk|array_combine|' +
        'array_count_values|array_diff|array_diff_assoc|array_diff_key|array_diff_uassoc|array_diff_ukey|array_fill|array_fill_keys|array_filter|' +
        'array_flip|array_intersect|array_intersect_assoc|array_intersect_key|array_intersect_uassoc|array_intersect_ukey|array_key_exists|' +
        'array_keys|array_map|array_merge|array_merge_recursive|array_multisort|array_pad|array_pop|array_product|array_push|array_rand|' +
        'array_reduce|array_replace|array_replace_recursive|array_reverse|array_search|array_shift|array_slice|array_splice|array_sum|array_udiff|' +
        'array_udiff_assoc|array_udiff_uassoc|array_uintersect|array_uintersect_assoc|array_uintersect_uassoc|array_unique|array_unshift|' +
        'array_values|array_walk|array_walk_recursive|arrayaccess|arrayiterator|arrayobject|arsort|asin|asinh|asort|assert|assert_options|atan|' +
        'atan2|atanh|audioproperties|badfunctioncallexception|badmethodcallexception|base64_decode|base64_encode|base_convert|basename|' +
        'bbcode_add_element|bbcode_add_smiley|bbcode_create|bbcode_destroy|bbcode_parse|bbcode_set_arg_parser|bbcode_set_flags|bcadd|bccomp|bcdiv|' +
        'bcmod|bcmul|bcompiler_load|bcompiler_load_exe|bcompiler_parse_class|bcompiler_read|bcompiler_write_class|bcompiler_write_constant|' +
        'bcompiler_write_exe_footer|bcompiler_write_file|bcompiler_write_footer|bcompiler_write_function|bcompiler_write_functions_from_file|' +
        'bcompiler_write_header|bcompiler_write_included_filename|bcpow|bcpowmod|bcscale|bcsqrt|bcsub|bin2hex|bind_textdomain_codeset|bindec|' +
        'bindtextdomain|bson_decode|bson_encode|bumpValue|bzclose|bzcompress|bzdecompress|bzerrno|bzerror|bzerrstr|bzflush|bzopen|bzread|bzwrite|' +
        'cachingiterator|cairo|cairo_create|cairo_font_face_get_type|cairo_font_face_status|cairo_font_options_create|cairo_font_options_equal|' +
        'cairo_font_options_get_antialias|cairo_font_options_get_hint_metrics|cairo_font_options_get_hint_style|' +
        'cairo_font_options_get_subpixel_order|cairo_font_options_hash|cairo_font_options_merge|cairo_font_options_set_antialias|' +
        'cairo_font_options_set_hint_metrics|cairo_font_options_set_hint_style|cairo_font_options_set_subpixel_order|cairo_font_options_status|' +
        'cairo_format_stride_for_width|cairo_image_surface_create|cairo_image_surface_create_for_data|cairo_image_surface_create_from_png|' +
        'cairo_image_surface_get_data|cairo_image_surface_get_format|cairo_image_surface_get_height|cairo_image_surface_get_stride|' +
        'cairo_image_surface_get_width|cairo_matrix_create_scale|cairo_matrix_create_translate|cairo_matrix_invert|cairo_matrix_multiply|' +
        'cairo_matrix_rotate|cairo_matrix_transform_distance|cairo_matrix_transform_point|cairo_matrix_translate|cairo_pattern_add_color_stop_rgb|' +
        'cairo_pattern_add_color_stop_rgba|cairo_pattern_create_for_surface|cairo_pattern_create_linear|cairo_pattern_create_radial|' +
        'cairo_pattern_create_rgb|cairo_pattern_create_rgba|cairo_pattern_get_color_stop_count|cairo_pattern_get_color_stop_rgba|' +
        'cairo_pattern_get_extend|cairo_pattern_get_filter|cairo_pattern_get_linear_points|cairo_pattern_get_matrix|' +
        'cairo_pattern_get_radial_circles|cairo_pattern_get_rgba|cairo_pattern_get_surface|cairo_pattern_get_type|cairo_pattern_set_extend|' +
        'cairo_pattern_set_filter|cairo_pattern_set_matrix|cairo_pattern_status|cairo_pdf_surface_create|cairo_pdf_surface_set_size|' +
        'cairo_ps_get_levels|cairo_ps_level_to_string|cairo_ps_surface_create|cairo_ps_surface_dsc_begin_page_setup|' +
        'cairo_ps_surface_dsc_begin_setup|cairo_ps_surface_dsc_comment|cairo_ps_surface_get_eps|cairo_ps_surface_restrict_to_level|' +
        'cairo_ps_surface_set_eps|cairo_ps_surface_set_size|cairo_scaled_font_create|cairo_scaled_font_extents|cairo_scaled_font_get_ctm|' +
        'cairo_scaled_font_get_font_face|cairo_scaled_font_get_font_matrix|cairo_scaled_font_get_font_options|cairo_scaled_font_get_scale_matrix|' +
        'cairo_scaled_font_get_type|cairo_scaled_font_glyph_extents|cairo_scaled_font_status|cairo_scaled_font_text_extents|' +
        'cairo_surface_copy_page|cairo_surface_create_similar|cairo_surface_finish|cairo_surface_flush|cairo_surface_get_content|' +
        'cairo_surface_get_device_offset|cairo_surface_get_font_options|cairo_surface_get_type|cairo_surface_mark_dirty|' +
        'cairo_surface_mark_dirty_rectangle|cairo_surface_set_device_offset|cairo_surface_set_fallback_resolution|cairo_surface_show_page|' +
        'cairo_surface_status|cairo_surface_write_to_png|cairo_svg_surface_create|cairo_svg_surface_restrict_to_version|' +
        'cairo_svg_version_to_string|cairoantialias|cairocontent|cairocontext|cairoexception|cairoextend|cairofillrule|cairofilter|cairofontface|' +
        'cairofontoptions|cairofontslant|cairofonttype|cairofontweight|cairoformat|cairogradientpattern|cairohintmetrics|cairohintstyle|' +
        'cairoimagesurface|cairolineargradient|cairolinecap|cairolinejoin|cairomatrix|cairooperator|cairopath|cairopattern|cairopatterntype|' +
        'cairopdfsurface|cairopslevel|cairopssurface|cairoradialgradient|cairoscaledfont|cairosolidpattern|cairostatus|cairosubpixelorder|' +
        'cairosurface|cairosurfacepattern|cairosurfacetype|cairosvgsurface|cairosvgversion|cairotoyfontface|cal_days_in_month|cal_from_jd|cal_info|' +
        'cal_to_jd|calcul_hmac|calculhmac|call_user_func|call_user_func_array|call_user_method|call_user_method_array|callbackfilteriterator|ceil|' +
        'chdb|chdb_create|chdir|checkdate|checkdnsrr|chgrp|chmod|chop|chown|chr|chroot|chunk_split|class_alias|class_exists|class_implements|' +
        'class_parents|classkit_import|classkit_method_add|classkit_method_copy|classkit_method_redefine|classkit_method_remove|' +
        'classkit_method_rename|clearstatcache|clone|closedir|closelog|collator|com|com_addref|com_create_guid|com_event_sink|com_get|' +
        'com_get_active_object|com_invoke|com_isenum|com_load|com_load_typelib|com_message_pump|com_print_typeinfo|com_propget|com_propput|' +
        'com_propset|com_release|com_set|compact|connection_aborted|connection_status|connection_timeout|constant|construct|construct|construct|' +
        'convert_cyr_string|convert_uudecode|convert_uuencode|copy|cos|cosh|count|count_chars|countable|counter_bump|counter_bump_value|' +
        'counter_create|counter_get|counter_get_meta|counter_get_named|counter_get_value|counter_reset|counter_reset_value|crack_check|' +
        'crack_closedict|crack_getlastmessage|crack_opendict|crc32|create_function|crypt|ctype_alnum|ctype_alpha|ctype_cntrl|ctype_digit|' +
        'ctype_graph|ctype_lower|ctype_print|ctype_punct|ctype_space|ctype_upper|ctype_xdigit|cubrid_affected_rows|cubrid_bind|' +
        'cubrid_client_encoding|cubrid_close|cubrid_close_prepare|cubrid_close_request|cubrid_col_get|cubrid_col_size|cubrid_column_names|' +
        'cubrid_column_types|cubrid_commit|cubrid_connect|cubrid_connect_with_url|cubrid_current_oid|cubrid_data_seek|cubrid_db_name|' +
        'cubrid_disconnect|cubrid_drop|cubrid_errno|cubrid_error|cubrid_error_code|cubrid_error_code_facility|cubrid_error_msg|cubrid_execute|' +
        'cubrid_fetch|cubrid_fetch_array|cubrid_fetch_assoc|cubrid_fetch_field|cubrid_fetch_lengths|cubrid_fetch_object|cubrid_fetch_row|' +
        'cubrid_field_flags|cubrid_field_len|cubrid_field_name|cubrid_field_seek|cubrid_field_table|cubrid_field_type|cubrid_free_result|' +
        'cubrid_get|cubrid_get_autocommit|cubrid_get_charset|cubrid_get_class_name|cubrid_get_client_info|cubrid_get_db_parameter|' +
        'cubrid_get_server_info|cubrid_insert_id|cubrid_is_instance|cubrid_list_dbs|cubrid_load_from_glo|cubrid_lob_close|cubrid_lob_export|' +
        'cubrid_lob_get|cubrid_lob_send|cubrid_lob_size|cubrid_lock_read|cubrid_lock_write|cubrid_move_cursor|cubrid_new_glo|cubrid_next_result|' +
        'cubrid_num_cols|cubrid_num_fields|cubrid_num_rows|cubrid_ping|cubrid_prepare|cubrid_put|cubrid_query|cubrid_real_escape_string|' +
        'cubrid_result|cubrid_rollback|cubrid_save_to_glo|cubrid_schema|cubrid_send_glo|cubrid_seq_drop|cubrid_seq_insert|cubrid_seq_put|' +
        'cubrid_set_add|cubrid_set_autocommit|cubrid_set_db_parameter|cubrid_set_drop|cubrid_unbuffered_query|cubrid_version|curl_close|' +
        'curl_copy_handle|curl_errno|curl_error|curl_exec|curl_getinfo|curl_init|curl_multi_add_handle|curl_multi_close|curl_multi_exec|' +
        'curl_multi_getcontent|curl_multi_info_read|curl_multi_init|curl_multi_remove_handle|curl_multi_select|curl_setopt|curl_setopt_array|' +
        'curl_version|current|cyrus_authenticate|cyrus_bind|cyrus_close|cyrus_connect|cyrus_query|cyrus_unbind|date|date_add|date_create|' +
        'date_create_from_format|date_date_set|date_default_timezone_get|date_default_timezone_set|date_diff|date_format|date_get_last_errors|' +
        'date_interval_create_from_date_string|date_interval_format|date_isodate_set|date_modify|date_offset_get|date_parse|date_parse_from_format|' +
        'date_sub|date_sun_info|date_sunrise|date_sunset|date_time_set|date_timestamp_get|date_timestamp_set|date_timezone_get|date_timezone_set|' +
        'dateinterval|dateperiod|datetime|datetimezone|db2_autocommit|db2_bind_param|db2_client_info|db2_close|db2_column_privileges|db2_columns|' +
        'db2_commit|db2_conn_error|db2_conn_errormsg|db2_connect|db2_cursor_type|db2_escape_string|db2_exec|db2_execute|db2_fetch_array|' +
        'db2_fetch_assoc|db2_fetch_both|db2_fetch_object|db2_fetch_row|db2_field_display_size|db2_field_name|db2_field_num|db2_field_precision|' +
        'db2_field_scale|db2_field_type|db2_field_width|db2_foreign_keys|db2_free_result|db2_free_stmt|db2_get_option|db2_last_insert_id|' +
        'db2_lob_read|db2_next_result|db2_num_fields|db2_num_rows|db2_pclose|db2_pconnect|db2_prepare|db2_primary_keys|db2_procedure_columns|' +
        'db2_procedures|db2_result|db2_rollback|db2_server_info|db2_set_option|db2_special_columns|db2_statistics|db2_stmt_error|db2_stmt_errormsg|' +
        'db2_table_privileges|db2_tables|dba_close|dba_delete|dba_exists|dba_fetch|dba_firstkey|dba_handlers|dba_insert|dba_key_split|dba_list|' +
        'dba_nextkey|dba_open|dba_optimize|dba_popen|dba_replace|dba_sync|dbase_add_record|dbase_close|dbase_create|dbase_delete_record|' +
        'dbase_get_header_info|dbase_get_record|dbase_get_record_with_names|dbase_numfields|dbase_numrecords|dbase_open|dbase_pack|' +
        'dbase_replace_record|dbplus_add|dbplus_aql|dbplus_chdir|dbplus_close|dbplus_curr|dbplus_errcode|dbplus_errno|dbplus_find|dbplus_first|' +
        'dbplus_flush|dbplus_freealllocks|dbplus_freelock|dbplus_freerlocks|dbplus_getlock|dbplus_getunique|dbplus_info|dbplus_last|dbplus_lockrel|' +
        'dbplus_next|dbplus_open|dbplus_prev|dbplus_rchperm|dbplus_rcreate|dbplus_rcrtexact|dbplus_rcrtlike|dbplus_resolve|dbplus_restorepos|' +
        'dbplus_rkeys|dbplus_ropen|dbplus_rquery|dbplus_rrename|dbplus_rsecindex|dbplus_runlink|dbplus_rzap|dbplus_savepos|dbplus_setindex|' +
        'dbplus_setindexbynumber|dbplus_sql|dbplus_tcl|dbplus_tremove|dbplus_undo|dbplus_undoprepare|dbplus_unlockrel|dbplus_unselect|' +
        'dbplus_update|dbplus_xlockrel|dbplus_xunlockrel|dbx_close|dbx_compare|dbx_connect|dbx_error|dbx_escape_string|dbx_fetch_row|dbx_query|' +
        'dbx_sort|dcgettext|dcngettext|deaggregate|debug_backtrace|debug_print_backtrace|debug_zval_dump|decbin|dechex|decoct|define|' +
        'define_syslog_variables|defined|deg2rad|delete|dgettext|die|dio_close|dio_fcntl|dio_open|dio_read|dio_seek|dio_stat|dio_tcsetattr|' +
        'dio_truncate|dio_write|dir|directoryiterator|dirname|disk_free_space|disk_total_space|diskfreespace|dl|dngettext|dns_check_record|' +
        'dns_get_mx|dns_get_record|dom_import_simplexml|domainexception|domattr|domattribute_name|domattribute_set_value|domattribute_specified|' +
        'domattribute_value|domcharacterdata|domcomment|domdocument|domdocument_add_root|domdocument_create_attribute|' +
        'domdocument_create_cdata_section|domdocument_create_comment|domdocument_create_element|domdocument_create_element_ns|' +
        'domdocument_create_entity_reference|domdocument_create_processing_instruction|domdocument_create_text_node|domdocument_doctype|' +
        'domdocument_document_element|domdocument_dump_file|domdocument_dump_mem|domdocument_get_element_by_id|domdocument_get_elements_by_tagname|' +
        'domdocument_html_dump_mem|domdocument_xinclude|domdocumentfragment|domdocumenttype|domdocumenttype_entities|' +
        'domdocumenttype_internal_subset|domdocumenttype_name|domdocumenttype_notations|domdocumenttype_public_id|domdocumenttype_system_id|' +
        'domelement|domelement_get_attribute|domelement_get_attribute_node|domelement_get_elements_by_tagname|domelement_has_attribute|' +
        'domelement_remove_attribute|domelement_set_attribute|domelement_set_attribute_node|domelement_tagname|domentity|domentityreference|' +
        'domexception|domimplementation|domnamednodemap|domnode|domnode_add_namespace|domnode_append_child|domnode_append_sibling|' +
        'domnode_attributes|domnode_child_nodes|domnode_clone_node|domnode_dump_node|domnode_first_child|domnode_get_content|' +
        'domnode_has_attributes|domnode_has_child_nodes|domnode_insert_before|domnode_is_blank_node|domnode_last_child|domnode_next_sibling|' +
        'domnode_node_name|domnode_node_type|domnode_node_value|domnode_owner_document|domnode_parent_node|domnode_prefix|domnode_previous_sibling|' +
        'domnode_remove_child|domnode_replace_child|domnode_replace_node|domnode_set_content|domnode_set_name|domnode_set_namespace|' +
        'domnode_unlink_node|domnodelist|domnotation|domprocessinginstruction|domprocessinginstruction_data|domprocessinginstruction_target|' +
        'domtext|domxml_new_doc|domxml_open_file|domxml_open_mem|domxml_version|domxml_xmltree|domxml_xslt_stylesheet|domxml_xslt_stylesheet_doc|' +
        'domxml_xslt_stylesheet_file|domxml_xslt_version|domxpath|domxsltstylesheet_process|domxsltstylesheet_result_dump_file|' +
        'domxsltstylesheet_result_dump_mem|dotnet|dotnet_load|doubleval|each|easter_date|easter_days|echo|empty|emptyiterator|' +
        'enchant_broker_describe|enchant_broker_dict_exists|enchant_broker_free|enchant_broker_free_dict|enchant_broker_get_error|' +
        'enchant_broker_init|enchant_broker_list_dicts|enchant_broker_request_dict|enchant_broker_request_pwl_dict|enchant_broker_set_ordering|' +
        'enchant_dict_add_to_personal|enchant_dict_add_to_session|enchant_dict_check|enchant_dict_describe|enchant_dict_get_error|' +
        'enchant_dict_is_in_session|enchant_dict_quick_check|enchant_dict_store_replacement|enchant_dict_suggest|end|ereg|ereg_replace|eregi|' +
        'eregi_replace|error_get_last|error_log|error_reporting|errorexception|escapeshellarg|escapeshellcmd|eval|event_add|event_base_free|' +
        'event_base_loop|event_base_loopbreak|event_base_loopexit|event_base_new|event_base_priority_init|event_base_set|event_buffer_base_set|' +
        'event_buffer_disable|event_buffer_enable|event_buffer_fd_set|event_buffer_free|event_buffer_new|event_buffer_priority_set|' +
        'event_buffer_read|event_buffer_set_callback|event_buffer_timeout_set|event_buffer_watermark_set|event_buffer_write|event_del|event_free|' +
        'event_new|event_set|exception|exec|exif_imagetype|exif_read_data|exif_tagname|exif_thumbnail|exit|exp|expect_expectl|expect_popen|explode|' +
        'expm1|export|export|extension_loaded|extract|ezmlm_hash|fam_cancel_monitor|fam_close|fam_monitor_collection|fam_monitor_directory|' +
        'fam_monitor_file|fam_next_event|fam_open|fam_pending|fam_resume_monitor|fam_suspend_monitor|fbsql_affected_rows|fbsql_autocommit|' +
        'fbsql_blob_size|fbsql_change_user|fbsql_clob_size|fbsql_close|fbsql_commit|fbsql_connect|fbsql_create_blob|fbsql_create_clob|' +
        'fbsql_create_db|fbsql_data_seek|fbsql_database|fbsql_database_password|fbsql_db_query|fbsql_db_status|fbsql_drop_db|fbsql_errno|' +
        'fbsql_error|fbsql_fetch_array|fbsql_fetch_assoc|fbsql_fetch_field|fbsql_fetch_lengths|fbsql_fetch_object|fbsql_fetch_row|' +
        'fbsql_field_flags|fbsql_field_len|fbsql_field_name|fbsql_field_seek|fbsql_field_table|fbsql_field_type|fbsql_free_result|' +
        'fbsql_get_autostart_info|fbsql_hostname|fbsql_insert_id|fbsql_list_dbs|fbsql_list_fields|fbsql_list_tables|fbsql_next_result|' +
        'fbsql_num_fields|fbsql_num_rows|fbsql_password|fbsql_pconnect|fbsql_query|fbsql_read_blob|fbsql_read_clob|fbsql_result|fbsql_rollback|' +
        'fbsql_rows_fetched|fbsql_select_db|fbsql_set_characterset|fbsql_set_lob_mode|fbsql_set_password|fbsql_set_transaction|fbsql_start_db|' +
        'fbsql_stop_db|fbsql_table_name|fbsql_tablename|fbsql_username|fbsql_warnings|fclose|fdf_add_doc_javascript|fdf_add_template|fdf_close|' +
        'fdf_create|fdf_enum_values|fdf_errno|fdf_error|fdf_get_ap|fdf_get_attachment|fdf_get_encoding|fdf_get_file|fdf_get_flags|fdf_get_opt|' +
        'fdf_get_status|fdf_get_value|fdf_get_version|fdf_header|fdf_next_field_name|fdf_open|fdf_open_string|fdf_remove_item|fdf_save|' +
        'fdf_save_string|fdf_set_ap|fdf_set_encoding|fdf_set_file|fdf_set_flags|fdf_set_javascript_action|fdf_set_on_import_javascript|fdf_set_opt|' +
        'fdf_set_status|fdf_set_submit_form_action|fdf_set_target_frame|fdf_set_value|fdf_set_version|feof|fflush|fgetc|fgetcsv|fgets|fgetss|file|' +
        'file_exists|file_get_contents|file_put_contents|fileatime|filectime|filegroup|fileinode|filemtime|fileowner|fileperms|filepro|' +
        'filepro_fieldcount|filepro_fieldname|filepro_fieldtype|filepro_fieldwidth|filepro_retrieve|filepro_rowcount|filesize|filesystemiterator|' +
        'filetype|filter_has_var|filter_id|filter_input|filter_input_array|filter_list|filter_var|filter_var_array|filteriterator|finfo_buffer|' +
        'finfo_close|finfo_file|finfo_open|finfo_set_flags|floatval|flock|floor|flush|fmod|fnmatch|fopen|forward_static_call|' +
        'forward_static_call_array|fpassthru|fprintf|fputcsv|fputs|fread|frenchtojd|fribidi_log2vis|fscanf|fseek|fsockopen|fstat|ftell|ftok|' +
        'ftp_alloc|ftp_cdup|ftp_chdir|ftp_chmod|ftp_close|ftp_connect|ftp_delete|ftp_exec|ftp_fget|ftp_fput|ftp_get|ftp_get_option|ftp_login|' +
        'ftp_mdtm|ftp_mkdir|ftp_nb_continue|ftp_nb_fget|ftp_nb_fput|ftp_nb_get|ftp_nb_put|ftp_nlist|ftp_pasv|ftp_put|ftp_pwd|ftp_quit|ftp_raw|' +
        'ftp_rawlist|ftp_rename|ftp_rmdir|ftp_set_option|ftp_site|ftp_size|ftp_ssl_connect|ftp_systype|ftruncate|func_get_arg|func_get_args|' +
        'func_num_args|function_exists|fwrite|gc_collect_cycles|gc_disable|gc_enable|gc_enabled|gd_info|gearmanclient|gearmanjob|gearmantask|' +
        'gearmanworker|geoip_continent_code_by_name|geoip_country_code3_by_name|geoip_country_code_by_name|geoip_country_name_by_name|' +
        'geoip_database_info|geoip_db_avail|geoip_db_filename|geoip_db_get_all_info|geoip_id_by_name|geoip_isp_by_name|geoip_org_by_name|' +
        'geoip_record_by_name|geoip_region_by_name|geoip_region_name_by_code|geoip_time_zone_by_country_and_region|getMeta|getNamed|getValue|' +
        'get_browser|get_called_class|get_cfg_var|get_class|get_class_methods|get_class_vars|get_current_user|get_declared_classes|' +
        'get_declared_interfaces|get_defined_constants|get_defined_functions|get_defined_vars|get_extension_funcs|get_headers|' +
        'get_html_translation_table|get_include_path|get_included_files|get_loaded_extensions|get_magic_quotes_gpc|get_magic_quotes_runtime|' +
        'get_meta_tags|get_object_vars|get_parent_class|get_required_files|get_resource_type|getallheaders|getconstant|getconstants|getconstructor|' +
        'getcwd|getdate|getdefaultproperties|getdoccomment|getendline|getenv|getextension|getextensionname|getfilename|gethostbyaddr|gethostbyname|' +
        'gethostbynamel|gethostname|getimagesize|getinterfacenames|getinterfaces|getlastmod|getmethod|getmethods|getmodifiers|getmxrr|getmygid|' +
        'getmyinode|getmypid|getmyuid|getname|getnamespacename|getopt|getparentclass|getproperties|getproperty|getprotobyname|getprotobynumber|' +
        'getrandmax|getrusage|getservbyname|getservbyport|getshortname|getstartline|getstaticproperties|getstaticpropertyvalue|gettext|' +
        'gettimeofday|gettype|glob|globiterator|gmagick|gmagickdraw|gmagickpixel|gmdate|gmmktime|gmp_abs|gmp_add|gmp_and|gmp_clrbit|gmp_cmp|' +
        'gmp_com|gmp_div|gmp_div_q|gmp_div_qr|gmp_div_r|gmp_divexact|gmp_fact|gmp_gcd|gmp_gcdext|gmp_hamdist|gmp_init|gmp_intval|gmp_invert|' +
        'gmp_jacobi|gmp_legendre|gmp_mod|gmp_mul|gmp_neg|gmp_nextprime|gmp_or|gmp_perfect_square|gmp_popcount|gmp_pow|gmp_powm|gmp_prob_prime|' +
        'gmp_random|gmp_scan0|gmp_scan1|gmp_setbit|gmp_sign|gmp_sqrt|gmp_sqrtrem|gmp_strval|gmp_sub|gmp_testbit|gmp_xor|gmstrftime|' +
        'gnupg_adddecryptkey|gnupg_addencryptkey|gnupg_addsignkey|gnupg_cleardecryptkeys|gnupg_clearencryptkeys|gnupg_clearsignkeys|gnupg_decrypt|' +
        'gnupg_decryptverify|gnupg_encrypt|gnupg_encryptsign|gnupg_export|gnupg_geterror|gnupg_getprotocol|gnupg_import|gnupg_init|gnupg_keyinfo|' +
        'gnupg_setarmor|gnupg_seterrormode|gnupg_setsignmode|gnupg_sign|gnupg_verify|gopher_parsedir|grapheme_extract|grapheme_stripos|' +
        'grapheme_stristr|grapheme_strlen|grapheme_strpos|grapheme_strripos|grapheme_strrpos|grapheme_strstr|grapheme_substr|gregoriantojd|' +
        'gupnp_context_get_host_ip|gupnp_context_get_port|gupnp_context_get_subscription_timeout|gupnp_context_host_path|gupnp_context_new|' +
        'gupnp_context_set_subscription_timeout|gupnp_context_timeout_add|gupnp_context_unhost_path|gupnp_control_point_browse_start|' +
        'gupnp_control_point_browse_stop|gupnp_control_point_callback_set|gupnp_control_point_new|gupnp_device_action_callback_set|' +
        'gupnp_device_info_get|gupnp_device_info_get_service|gupnp_root_device_get_available|gupnp_root_device_get_relative_location|' +
        'gupnp_root_device_new|gupnp_root_device_set_available|gupnp_root_device_start|gupnp_root_device_stop|gupnp_service_action_get|' +
        'gupnp_service_action_return|gupnp_service_action_return_error|gupnp_service_action_set|gupnp_service_freeze_notify|gupnp_service_info_get|' +
        'gupnp_service_info_get_introspection|gupnp_service_introspection_get_state_variable|gupnp_service_notify|gupnp_service_proxy_action_get|' +
        'gupnp_service_proxy_action_set|gupnp_service_proxy_add_notify|gupnp_service_proxy_callback_set|gupnp_service_proxy_get_subscribed|' +
        'gupnp_service_proxy_remove_notify|gupnp_service_proxy_set_subscribed|gupnp_service_thaw_notify|gzclose|gzcompress|gzdecode|gzdeflate|' +
        'gzencode|gzeof|gzfile|gzgetc|gzgets|gzgetss|gzinflate|gzopen|gzpassthru|gzputs|gzread|gzrewind|gzseek|gztell|gzuncompress|gzwrite|' +
        'halt_compiler|haruannotation|haruannotation_setborderstyle|haruannotation_sethighlightmode|haruannotation_seticon|' +
        'haruannotation_setopened|harudestination|harudestination_setfit|harudestination_setfitb|harudestination_setfitbh|harudestination_setfitbv|' +
        'harudestination_setfith|harudestination_setfitr|harudestination_setfitv|harudestination_setxyz|harudoc|harudoc_addpage|' +
        'harudoc_addpagelabel|harudoc_construct|harudoc_createoutline|harudoc_getcurrentencoder|harudoc_getcurrentpage|harudoc_getencoder|' +
        'harudoc_getfont|harudoc_getinfoattr|harudoc_getpagelayout|harudoc_getpagemode|harudoc_getstreamsize|harudoc_insertpage|harudoc_loadjpeg|' +
        'harudoc_loadpng|harudoc_loadraw|harudoc_loadttc|harudoc_loadttf|harudoc_loadtype1|harudoc_output|harudoc_readfromstream|' +
        'harudoc_reseterror|harudoc_resetstream|harudoc_save|harudoc_savetostream|harudoc_setcompressionmode|harudoc_setcurrentencoder|' +
        'harudoc_setencryptionmode|harudoc_setinfoattr|harudoc_setinfodateattr|harudoc_setopenaction|harudoc_setpagelayout|harudoc_setpagemode|' +
        'harudoc_setpagesconfiguration|harudoc_setpassword|harudoc_setpermission|harudoc_usecnsencodings|harudoc_usecnsfonts|' +
        'harudoc_usecntencodings|harudoc_usecntfonts|harudoc_usejpencodings|harudoc_usejpfonts|harudoc_usekrencodings|harudoc_usekrfonts|' +
        'haruencoder|haruencoder_getbytetype|haruencoder_gettype|haruencoder_getunicode|haruencoder_getwritingmode|haruexception|harufont|' +
        'harufont_getascent|harufont_getcapheight|harufont_getdescent|harufont_getencodingname|harufont_getfontname|harufont_gettextwidth|' +
        'harufont_getunicodewidth|harufont_getxheight|harufont_measuretext|haruimage|haruimage_getbitspercomponent|haruimage_getcolorspace|' +
        'haruimage_getheight|haruimage_getsize|haruimage_getwidth|haruimage_setcolormask|haruimage_setmaskimage|haruoutline|' +
        'haruoutline_setdestination|haruoutline_setopened|harupage|harupage_arc|harupage_begintext|harupage_circle|harupage_closepath|' +
        'harupage_concat|harupage_createdestination|harupage_createlinkannotation|harupage_createtextannotation|harupage_createurlannotation|' +
        'harupage_curveto|harupage_curveto2|harupage_curveto3|harupage_drawimage|harupage_ellipse|harupage_endpath|harupage_endtext|' +
        'harupage_eofill|harupage_eofillstroke|harupage_fill|harupage_fillstroke|harupage_getcharspace|harupage_getcmykfill|harupage_getcmykstroke|' +
        'harupage_getcurrentfont|harupage_getcurrentfontsize|harupage_getcurrentpos|harupage_getcurrenttextpos|harupage_getdash|' +
        'harupage_getfillingcolorspace|harupage_getflatness|harupage_getgmode|harupage_getgrayfill|harupage_getgraystroke|harupage_getheight|' +
        'harupage_gethorizontalscaling|harupage_getlinecap|harupage_getlinejoin|harupage_getlinewidth|harupage_getmiterlimit|harupage_getrgbfill|' +
        'harupage_getrgbstroke|harupage_getstrokingcolorspace|harupage_gettextleading|harupage_gettextmatrix|harupage_gettextrenderingmode|' +
        'harupage_gettextrise|harupage_gettextwidth|harupage_gettransmatrix|harupage_getwidth|harupage_getwordspace|harupage_lineto|' +
        'harupage_measuretext|harupage_movetextpos|harupage_moveto|harupage_movetonextline|harupage_rectangle|harupage_setcharspace|' +
        'harupage_setcmykfill|harupage_setcmykstroke|harupage_setdash|harupage_setflatness|harupage_setfontandsize|harupage_setgrayfill|' +
        'harupage_setgraystroke|harupage_setheight|harupage_sethorizontalscaling|harupage_setlinecap|harupage_setlinejoin|harupage_setlinewidth|' +
        'harupage_setmiterlimit|harupage_setrgbfill|harupage_setrgbstroke|harupage_setrotate|harupage_setsize|harupage_setslideshow|' +
        'harupage_settextleading|harupage_settextmatrix|harupage_settextrenderingmode|harupage_settextrise|harupage_setwidth|harupage_setwordspace|' +
        'harupage_showtext|harupage_showtextnextline|harupage_stroke|harupage_textout|harupage_textrect|hasconstant|hash|hash_algos|hash_copy|' +
        'hash_file|hash_final|hash_hmac|hash_hmac_file|hash_init|hash_update|hash_update_file|hash_update_stream|hasmethod|hasproperty|header|' +
        'header_register_callback|header_remove|headers_list|headers_sent|hebrev|hebrevc|hex2bin|hexdec|highlight_file|highlight_string|' +
        'html_entity_decode|htmlentities|htmlspecialchars|htmlspecialchars_decode|http_build_cookie|http_build_query|http_build_str|http_build_url|' +
        'http_cache_etag|http_cache_last_modified|http_chunked_decode|http_date|http_deflate|http_get|http_get_request_body|' +
        'http_get_request_body_stream|http_get_request_headers|http_head|http_inflate|http_match_etag|http_match_modified|' +
        'http_match_request_header|http_negotiate_charset|http_negotiate_content_type|http_negotiate_language|http_parse_cookie|http_parse_headers|' +
        'http_parse_message|http_parse_params|http_persistent_handles_clean|http_persistent_handles_count|http_persistent_handles_ident|' +
        'http_post_data|http_post_fields|http_put_data|http_put_file|http_put_stream|http_redirect|http_request|http_request_body_encode|' +
        'http_request_method_exists|http_request_method_name|http_request_method_register|http_request_method_unregister|http_response_code|' +
        'http_send_content_disposition|http_send_content_type|http_send_data|http_send_file|http_send_last_modified|http_send_status|' +
        'http_send_stream|http_support|http_throttle|httpdeflatestream|httpdeflatestream_construct|httpdeflatestream_factory|' +
        'httpdeflatestream_finish|httpdeflatestream_flush|httpdeflatestream_update|httpinflatestream|httpinflatestream_construct|' +
        'httpinflatestream_factory|httpinflatestream_finish|httpinflatestream_flush|httpinflatestream_update|httpmessage|httpmessage_addheaders|' +
        'httpmessage_construct|httpmessage_detach|httpmessage_factory|httpmessage_fromenv|httpmessage_fromstring|httpmessage_getbody|' +
        'httpmessage_getheader|httpmessage_getheaders|httpmessage_gethttpversion|httpmessage_getparentmessage|httpmessage_getrequestmethod|' +
        'httpmessage_getrequesturl|httpmessage_getresponsecode|httpmessage_getresponsestatus|httpmessage_gettype|httpmessage_guesscontenttype|' +
        'httpmessage_prepend|httpmessage_reverse|httpmessage_send|httpmessage_setbody|httpmessage_setheaders|httpmessage_sethttpversion|' +
        'httpmessage_setrequestmethod|httpmessage_setrequesturl|httpmessage_setresponsecode|httpmessage_setresponsestatus|httpmessage_settype|' +
        'httpmessage_tomessagetypeobject|httpmessage_tostring|httpquerystring|httpquerystring_construct|httpquerystring_get|httpquerystring_mod|' +
        'httpquerystring_set|httpquerystring_singleton|httpquerystring_toarray|httpquerystring_tostring|httpquerystring_xlate|httprequest|' +
        'httprequest_addcookies|httprequest_addheaders|httprequest_addpostfields|httprequest_addpostfile|httprequest_addputdata|' +
        'httprequest_addquerydata|httprequest_addrawpostdata|httprequest_addssloptions|httprequest_clearhistory|httprequest_construct|' +
        'httprequest_enablecookies|httprequest_getcontenttype|httprequest_getcookies|httprequest_getheaders|httprequest_gethistory|' +
        'httprequest_getmethod|httprequest_getoptions|httprequest_getpostfields|httprequest_getpostfiles|httprequest_getputdata|' +
        'httprequest_getputfile|httprequest_getquerydata|httprequest_getrawpostdata|httprequest_getrawrequestmessage|' +
        'httprequest_getrawresponsemessage|httprequest_getrequestmessage|httprequest_getresponsebody|httprequest_getresponsecode|' +
        'httprequest_getresponsecookies|httprequest_getresponsedata|httprequest_getresponseheader|httprequest_getresponseinfo|' +
        'httprequest_getresponsemessage|httprequest_getresponsestatus|httprequest_getssloptions|httprequest_geturl|httprequest_resetcookies|' +
        'httprequest_send|httprequest_setcontenttype|httprequest_setcookies|httprequest_setheaders|httprequest_setmethod|httprequest_setoptions|' +
        'httprequest_setpostfields|httprequest_setpostfiles|httprequest_setputdata|httprequest_setputfile|httprequest_setquerydata|' +
        'httprequest_setrawpostdata|httprequest_setssloptions|httprequest_seturl|httprequestpool|httprequestpool_attach|httprequestpool_construct|' +
        'httprequestpool_destruct|httprequestpool_detach|httprequestpool_getattachedrequests|httprequestpool_getfinishedrequests|' +
        'httprequestpool_reset|httprequestpool_send|httprequestpool_socketperform|httprequestpool_socketselect|httpresponse|httpresponse_capture|' +
        'httpresponse_getbuffersize|httpresponse_getcache|httpresponse_getcachecontrol|httpresponse_getcontentdisposition|' +
        'httpresponse_getcontenttype|httpresponse_getdata|httpresponse_getetag|httpresponse_getfile|httpresponse_getgzip|httpresponse_getheader|' +
        'httpresponse_getlastmodified|httpresponse_getrequestbody|httpresponse_getrequestbodystream|httpresponse_getrequestheaders|' +
        'httpresponse_getstream|httpresponse_getthrottledelay|httpresponse_guesscontenttype|httpresponse_redirect|httpresponse_send|' +
        'httpresponse_setbuffersize|httpresponse_setcache|httpresponse_setcachecontrol|httpresponse_setcontentdisposition|' +
        'httpresponse_setcontenttype|httpresponse_setdata|httpresponse_setetag|httpresponse_setfile|httpresponse_setgzip|httpresponse_setheader|' +
        'httpresponse_setlastmodified|httpresponse_setstream|httpresponse_setthrottledelay|httpresponse_status|hw_array2objrec|hw_changeobject|' +
        'hw_children|hw_childrenobj|hw_close|hw_connect|hw_connection_info|hw_cp|hw_deleteobject|hw_docbyanchor|hw_docbyanchorobj|' +
        'hw_document_attributes|hw_document_bodytag|hw_document_content|hw_document_setcontent|hw_document_size|hw_dummy|hw_edittext|hw_error|' +
        'hw_errormsg|hw_free_document|hw_getanchors|hw_getanchorsobj|hw_getandlock|hw_getchildcoll|hw_getchildcollobj|hw_getchilddoccoll|' +
        'hw_getchilddoccollobj|hw_getobject|hw_getobjectbyquery|hw_getobjectbyquerycoll|hw_getobjectbyquerycollobj|hw_getobjectbyqueryobj|' +
        'hw_getparents|hw_getparentsobj|hw_getrellink|hw_getremote|hw_getremotechildren|hw_getsrcbydestobj|hw_gettext|hw_getusername|hw_identify|' +
        'hw_incollections|hw_info|hw_inscoll|hw_insdoc|hw_insertanchors|hw_insertdocument|hw_insertobject|hw_mapid|hw_modifyobject|hw_mv|' +
        'hw_new_document|hw_objrec2array|hw_output_document|hw_pconnect|hw_pipedocument|hw_root|hw_setlinkroot|hw_stat|hw_unlock|hw_who|' +
        'hwapi_attribute|hwapi_attribute_key|hwapi_attribute_langdepvalue|hwapi_attribute_value|hwapi_attribute_values|hwapi_checkin|' +
        'hwapi_checkout|hwapi_children|hwapi_content|hwapi_content_mimetype|hwapi_content_read|hwapi_copy|hwapi_dbstat|hwapi_dcstat|' +
        'hwapi_dstanchors|hwapi_dstofsrcanchor|hwapi_error_count|hwapi_error_reason|hwapi_find|hwapi_ftstat|hwapi_hgcsp|hwapi_hwstat|' +
        'hwapi_identify|hwapi_info|hwapi_insert|hwapi_insertanchor|hwapi_insertcollection|hwapi_insertdocument|hwapi_link|hwapi_lock|hwapi_move|' +
        'hwapi_new_content|hwapi_object|hwapi_object_assign|hwapi_object_attreditable|hwapi_object_count|hwapi_object_insert|hwapi_object_new|' +
        'hwapi_object_remove|hwapi_object_title|hwapi_object_value|hwapi_objectbyanchor|hwapi_parents|hwapi_reason_description|hwapi_reason_type|' +
        'hwapi_remove|hwapi_replace|hwapi_setcommittedversion|hwapi_srcanchors|hwapi_srcsofdst|hwapi_unlock|hwapi_user|hwapi_userlist|hypot|' +
        'ibase_add_user|ibase_affected_rows|ibase_backup|ibase_blob_add|ibase_blob_cancel|ibase_blob_close|ibase_blob_create|ibase_blob_echo|' +
        'ibase_blob_get|ibase_blob_import|ibase_blob_info|ibase_blob_open|ibase_close|ibase_commit|ibase_commit_ret|ibase_connect|ibase_db_info|' +
        'ibase_delete_user|ibase_drop_db|ibase_errcode|ibase_errmsg|ibase_execute|ibase_fetch_assoc|ibase_fetch_object|ibase_fetch_row|' +
        'ibase_field_info|ibase_free_event_handler|ibase_free_query|ibase_free_result|ibase_gen_id|ibase_maintain_db|ibase_modify_user|' +
        'ibase_name_result|ibase_num_fields|ibase_num_params|ibase_param_info|ibase_pconnect|ibase_prepare|ibase_query|ibase_restore|' +
        'ibase_rollback|ibase_rollback_ret|ibase_server_info|ibase_service_attach|ibase_service_detach|ibase_set_event_handler|ibase_timefmt|' +
        'ibase_trans|ibase_wait_event|iconv|iconv_get_encoding|iconv_mime_decode|iconv_mime_decode_headers|iconv_mime_encode|iconv_set_encoding|' +
        'iconv_strlen|iconv_strpos|iconv_strrpos|iconv_substr|id3_get_frame_long_name|id3_get_frame_short_name|id3_get_genre_id|id3_get_genre_list|' +
        'id3_get_genre_name|id3_get_tag|id3_get_version|id3_remove_tag|id3_set_tag|id3v2attachedpictureframe|id3v2frame|id3v2tag|idate|' +
        'idn_to_ascii|idn_to_unicode|idn_to_utf8|ifx_affected_rows|ifx_blobinfile_mode|ifx_byteasvarchar|ifx_close|ifx_connect|ifx_copy_blob|' +
        'ifx_create_blob|ifx_create_char|ifx_do|ifx_error|ifx_errormsg|ifx_fetch_row|ifx_fieldproperties|ifx_fieldtypes|ifx_free_blob|' +
        'ifx_free_char|ifx_free_result|ifx_get_blob|ifx_get_char|ifx_getsqlca|ifx_htmltbl_result|ifx_nullformat|ifx_num_fields|ifx_num_rows|' +
        'ifx_pconnect|ifx_prepare|ifx_query|ifx_textasvarchar|ifx_update_blob|ifx_update_char|ifxus_close_slob|ifxus_create_slob|ifxus_free_slob|' +
        'ifxus_open_slob|ifxus_read_slob|ifxus_seek_slob|ifxus_tell_slob|ifxus_write_slob|ignore_user_abort|iis_add_server|iis_get_dir_security|' +
        'iis_get_script_map|iis_get_server_by_comment|iis_get_server_by_path|iis_get_server_rights|iis_get_service_state|iis_remove_server|' +
        'iis_set_app_settings|iis_set_dir_security|iis_set_script_map|iis_set_server_rights|iis_start_server|iis_start_service|iis_stop_server|' +
        'iis_stop_service|image2wbmp|image_type_to_extension|image_type_to_mime_type|imagealphablending|imageantialias|imagearc|imagechar|' +
        'imagecharup|imagecolorallocate|imagecolorallocatealpha|imagecolorat|imagecolorclosest|imagecolorclosestalpha|imagecolorclosesthwb|' +
        'imagecolordeallocate|imagecolorexact|imagecolorexactalpha|imagecolormatch|imagecolorresolve|imagecolorresolvealpha|imagecolorset|' +
        'imagecolorsforindex|imagecolorstotal|imagecolortransparent|imageconvolution|imagecopy|imagecopymerge|imagecopymergegray|' +
        'imagecopyresampled|imagecopyresized|imagecreate|imagecreatefromgd|imagecreatefromgd2|imagecreatefromgd2part|imagecreatefromgif|' +
        'imagecreatefromjpeg|imagecreatefrompng|imagecreatefromstring|imagecreatefromwbmp|imagecreatefromxbm|imagecreatefromxpm|' +
        'imagecreatetruecolor|imagedashedline|imagedestroy|imageellipse|imagefill|imagefilledarc|imagefilledellipse|imagefilledpolygon|' +
        'imagefilledrectangle|imagefilltoborder|imagefilter|imagefontheight|imagefontwidth|imageftbbox|imagefttext|imagegammacorrect|imagegd|' +
        'imagegd2|imagegif|imagegrabscreen|imagegrabwindow|imageinterlace|imageistruecolor|imagejpeg|imagelayereffect|imageline|imageloadfont|' +
        'imagepalettecopy|imagepng|imagepolygon|imagepsbbox|imagepsencodefont|imagepsextendfont|imagepsfreefont|imagepsloadfont|imagepsslantfont|' +
        'imagepstext|imagerectangle|imagerotate|imagesavealpha|imagesetbrush|imagesetpixel|imagesetstyle|imagesetthickness|imagesettile|' +
        'imagestring|imagestringup|imagesx|imagesy|imagetruecolortopalette|imagettfbbox|imagettftext|imagetypes|imagewbmp|imagexbm|imagick|' +
        'imagick_adaptiveblurimage|imagick_adaptiveresizeimage|imagick_adaptivesharpenimage|imagick_adaptivethresholdimage|imagick_addimage|' +
        'imagick_addnoiseimage|imagick_affinetransformimage|imagick_animateimages|imagick_annotateimage|imagick_appendimages|imagick_averageimages|' +
        'imagick_blackthresholdimage|imagick_blurimage|imagick_borderimage|imagick_charcoalimage|imagick_chopimage|imagick_clear|imagick_clipimage|' +
        'imagick_clippathimage|imagick_clone|imagick_clutimage|imagick_coalesceimages|imagick_colorfloodfillimage|imagick_colorizeimage|' +
        'imagick_combineimages|imagick_commentimage|imagick_compareimagechannels|imagick_compareimagelayers|imagick_compareimages|' +
        'imagick_compositeimage|imagick_construct|imagick_contrastimage|imagick_contraststretchimage|imagick_convolveimage|imagick_cropimage|' +
        'imagick_cropthumbnailimage|imagick_current|imagick_cyclecolormapimage|imagick_decipherimage|imagick_deconstructimages|' +
        'imagick_deleteimageartifact|imagick_despeckleimage|imagick_destroy|imagick_displayimage|imagick_displayimages|imagick_distortimage|' +
        'imagick_drawimage|imagick_edgeimage|imagick_embossimage|imagick_encipherimage|imagick_enhanceimage|imagick_equalizeimage|' +
        'imagick_evaluateimage|imagick_extentimage|imagick_flattenimages|imagick_flipimage|imagick_floodfillpaintimage|imagick_flopimage|' +
        'imagick_frameimage|imagick_fximage|imagick_gammaimage|imagick_gaussianblurimage|imagick_getcolorspace|imagick_getcompression|' +
        'imagick_getcompressionquality|imagick_getcopyright|imagick_getfilename|imagick_getfont|imagick_getformat|imagick_getgravity|' +
        'imagick_gethomeurl|imagick_getimage|imagick_getimagealphachannel|imagick_getimageartifact|imagick_getimagebackgroundcolor|' +
        'imagick_getimageblob|imagick_getimageblueprimary|imagick_getimagebordercolor|imagick_getimagechanneldepth|' +
        'imagick_getimagechanneldistortion|imagick_getimagechanneldistortions|imagick_getimagechannelextrema|imagick_getimagechannelmean|' +
        'imagick_getimagechannelrange|imagick_getimagechannelstatistics|imagick_getimageclipmask|imagick_getimagecolormapcolor|' +
        'imagick_getimagecolors|imagick_getimagecolorspace|imagick_getimagecompose|imagick_getimagecompression|imagick_getimagecompressionquality|' +
        'imagick_getimagedelay|imagick_getimagedepth|imagick_getimagedispose|imagick_getimagedistortion|imagick_getimageextrema|' +
        'imagick_getimagefilename|imagick_getimageformat|imagick_getimagegamma|imagick_getimagegeometry|imagick_getimagegravity|' +
        'imagick_getimagegreenprimary|imagick_getimageheight|imagick_getimagehistogram|imagick_getimageindex|imagick_getimageinterlacescheme|' +
        'imagick_getimageinterpolatemethod|imagick_getimageiterations|imagick_getimagelength|imagick_getimagemagicklicense|imagick_getimagematte|' +
        'imagick_getimagemattecolor|imagick_getimageorientation|imagick_getimagepage|imagick_getimagepixelcolor|imagick_getimageprofile|' +
        'imagick_getimageprofiles|imagick_getimageproperties|imagick_getimageproperty|imagick_getimageredprimary|imagick_getimageregion|' +
        'imagick_getimagerenderingintent|imagick_getimageresolution|imagick_getimagesblob|imagick_getimagescene|imagick_getimagesignature|' +
        'imagick_getimagesize|imagick_getimagetickspersecond|imagick_getimagetotalinkdensity|imagick_getimagetype|imagick_getimageunits|' +
        'imagick_getimagevirtualpixelmethod|imagick_getimagewhitepoint|imagick_getimagewidth|imagick_getinterlacescheme|imagick_getiteratorindex|' +
        'imagick_getnumberimages|imagick_getoption|imagick_getpackagename|imagick_getpage|imagick_getpixeliterator|imagick_getpixelregioniterator|' +
        'imagick_getpointsize|imagick_getquantumdepth|imagick_getquantumrange|imagick_getreleasedate|imagick_getresource|imagick_getresourcelimit|' +
        'imagick_getsamplingfactors|imagick_getsize|imagick_getsizeoffset|imagick_getversion|imagick_hasnextimage|imagick_haspreviousimage|' +
        'imagick_identifyimage|imagick_implodeimage|imagick_labelimage|imagick_levelimage|imagick_linearstretchimage|imagick_liquidrescaleimage|' +
        'imagick_magnifyimage|imagick_mapimage|imagick_mattefloodfillimage|imagick_medianfilterimage|imagick_mergeimagelayers|imagick_minifyimage|' +
        'imagick_modulateimage|imagick_montageimage|imagick_morphimages|imagick_mosaicimages|imagick_motionblurimage|imagick_negateimage|' +
        'imagick_newimage|imagick_newpseudoimage|imagick_nextimage|imagick_normalizeimage|imagick_oilpaintimage|imagick_opaquepaintimage|' +
        'imagick_optimizeimagelayers|imagick_orderedposterizeimage|imagick_paintfloodfillimage|imagick_paintopaqueimage|' +
        'imagick_painttransparentimage|imagick_pingimage|imagick_pingimageblob|imagick_pingimagefile|imagick_polaroidimage|imagick_posterizeimage|' +
        'imagick_previewimages|imagick_previousimage|imagick_profileimage|imagick_quantizeimage|imagick_quantizeimages|imagick_queryfontmetrics|' +
        'imagick_queryfonts|imagick_queryformats|imagick_radialblurimage|imagick_raiseimage|imagick_randomthresholdimage|imagick_readimage|' +
        'imagick_readimageblob|imagick_readimagefile|imagick_recolorimage|imagick_reducenoiseimage|imagick_removeimage|imagick_removeimageprofile|' +
        'imagick_render|imagick_resampleimage|imagick_resetimagepage|imagick_resizeimage|imagick_rollimage|imagick_rotateimage|' +
        'imagick_roundcorners|imagick_sampleimage|imagick_scaleimage|imagick_separateimagechannel|imagick_sepiatoneimage|' +
        'imagick_setbackgroundcolor|imagick_setcolorspace|imagick_setcompression|imagick_setcompressionquality|imagick_setfilename|' +
        'imagick_setfirstiterator|imagick_setfont|imagick_setformat|imagick_setgravity|imagick_setimage|imagick_setimagealphachannel|' +
        'imagick_setimageartifact|imagick_setimagebackgroundcolor|imagick_setimagebias|imagick_setimageblueprimary|imagick_setimagebordercolor|' +
        'imagick_setimagechanneldepth|imagick_setimageclipmask|imagick_setimagecolormapcolor|imagick_setimagecolorspace|imagick_setimagecompose|' +
        'imagick_setimagecompression|imagick_setimagecompressionquality|imagick_setimagedelay|imagick_setimagedepth|imagick_setimagedispose|' +
        'imagick_setimageextent|imagick_setimagefilename|imagick_setimageformat|imagick_setimagegamma|imagick_setimagegravity|' +
        'imagick_setimagegreenprimary|imagick_setimageindex|imagick_setimageinterlacescheme|imagick_setimageinterpolatemethod|' +
        'imagick_setimageiterations|imagick_setimagematte|imagick_setimagemattecolor|imagick_setimageopacity|imagick_setimageorientation|' +
        'imagick_setimagepage|imagick_setimageprofile|imagick_setimageproperty|imagick_setimageredprimary|imagick_setimagerenderingintent|' +
        'imagick_setimageresolution|imagick_setimagescene|imagick_setimagetickspersecond|imagick_setimagetype|imagick_setimageunits|' +
        'imagick_setimagevirtualpixelmethod|imagick_setimagewhitepoint|imagick_setinterlacescheme|imagick_setiteratorindex|imagick_setlastiterator|' +
        'imagick_setoption|imagick_setpage|imagick_setpointsize|imagick_setresolution|imagick_setresourcelimit|imagick_setsamplingfactors|' +
        'imagick_setsize|imagick_setsizeoffset|imagick_settype|imagick_shadeimage|imagick_shadowimage|imagick_sharpenimage|imagick_shaveimage|' +
        'imagick_shearimage|imagick_sigmoidalcontrastimage|imagick_sketchimage|imagick_solarizeimage|imagick_spliceimage|imagick_spreadimage|' +
        'imagick_steganoimage|imagick_stereoimage|imagick_stripimage|imagick_swirlimage|imagick_textureimage|imagick_thresholdimage|' +
        'imagick_thumbnailimage|imagick_tintimage|imagick_transformimage|imagick_transparentpaintimage|imagick_transposeimage|' +
        'imagick_transverseimage|imagick_trimimage|imagick_uniqueimagecolors|imagick_unsharpmaskimage|imagick_valid|imagick_vignetteimage|' +
        'imagick_waveimage|imagick_whitethresholdimage|imagick_writeimage|imagick_writeimagefile|imagick_writeimages|imagick_writeimagesfile|' +
        'imagickdraw|imagickdraw_affine|imagickdraw_annotation|imagickdraw_arc|imagickdraw_bezier|imagickdraw_circle|imagickdraw_clear|' +
        'imagickdraw_clone|imagickdraw_color|imagickdraw_comment|imagickdraw_composite|imagickdraw_construct|imagickdraw_destroy|' +
        'imagickdraw_ellipse|imagickdraw_getclippath|imagickdraw_getcliprule|imagickdraw_getclipunits|imagickdraw_getfillcolor|' +
        'imagickdraw_getfillopacity|imagickdraw_getfillrule|imagickdraw_getfont|imagickdraw_getfontfamily|imagickdraw_getfontsize|' +
        'imagickdraw_getfontstyle|imagickdraw_getfontweight|imagickdraw_getgravity|imagickdraw_getstrokeantialias|imagickdraw_getstrokecolor|' +
        'imagickdraw_getstrokedasharray|imagickdraw_getstrokedashoffset|imagickdraw_getstrokelinecap|imagickdraw_getstrokelinejoin|' +
        'imagickdraw_getstrokemiterlimit|imagickdraw_getstrokeopacity|imagickdraw_getstrokewidth|imagickdraw_gettextalignment|' +
        'imagickdraw_gettextantialias|imagickdraw_gettextdecoration|imagickdraw_gettextencoding|imagickdraw_gettextundercolor|' +
        'imagickdraw_getvectorgraphics|imagickdraw_line|imagickdraw_matte|imagickdraw_pathclose|imagickdraw_pathcurvetoabsolute|' +
        'imagickdraw_pathcurvetoquadraticbezierabsolute|imagickdraw_pathcurvetoquadraticbezierrelative|' +
        'imagickdraw_pathcurvetoquadraticbeziersmoothabsolute|imagickdraw_pathcurvetoquadraticbeziersmoothrelative|imagickdraw_pathcurvetorelative|' +
        'imagickdraw_pathcurvetosmoothabsolute|imagickdraw_pathcurvetosmoothrelative|imagickdraw_pathellipticarcabsolute|' +
        'imagickdraw_pathellipticarcrelative|imagickdraw_pathfinish|imagickdraw_pathlinetoabsolute|imagickdraw_pathlinetohorizontalabsolute|' +
        'imagickdraw_pathlinetohorizontalrelative|imagickdraw_pathlinetorelative|imagickdraw_pathlinetoverticalabsolute|' +
        'imagickdraw_pathlinetoverticalrelative|imagickdraw_pathmovetoabsolute|imagickdraw_pathmovetorelative|imagickdraw_pathstart|' +
        'imagickdraw_point|imagickdraw_polygon|imagickdraw_polyline|imagickdraw_pop|imagickdraw_popclippath|imagickdraw_popdefs|' +
        'imagickdraw_poppattern|imagickdraw_push|imagickdraw_pushclippath|imagickdraw_pushdefs|imagickdraw_pushpattern|imagickdraw_rectangle|' +
        'imagickdraw_render|imagickdraw_rotate|imagickdraw_roundrectangle|imagickdraw_scale|imagickdraw_setclippath|imagickdraw_setcliprule|' +
        'imagickdraw_setclipunits|imagickdraw_setfillalpha|imagickdraw_setfillcolor|imagickdraw_setfillopacity|imagickdraw_setfillpatternurl|' +
        'imagickdraw_setfillrule|imagickdraw_setfont|imagickdraw_setfontfamily|imagickdraw_setfontsize|imagickdraw_setfontstretch|' +
        'imagickdraw_setfontstyle|imagickdraw_setfontweight|imagickdraw_setgravity|imagickdraw_setstrokealpha|imagickdraw_setstrokeantialias|' +
        'imagickdraw_setstrokecolor|imagickdraw_setstrokedasharray|imagickdraw_setstrokedashoffset|imagickdraw_setstrokelinecap|' +
        'imagickdraw_setstrokelinejoin|imagickdraw_setstrokemiterlimit|imagickdraw_setstrokeopacity|imagickdraw_setstrokepatternurl|' +
        'imagickdraw_setstrokewidth|imagickdraw_settextalignment|imagickdraw_settextantialias|imagickdraw_settextdecoration|' +
        'imagickdraw_settextencoding|imagickdraw_settextundercolor|imagickdraw_setvectorgraphics|imagickdraw_setviewbox|imagickdraw_skewx|' +
        'imagickdraw_skewy|imagickdraw_translate|imagickpixel|imagickpixel_clear|imagickpixel_construct|imagickpixel_destroy|imagickpixel_getcolor|' +
        'imagickpixel_getcolorasstring|imagickpixel_getcolorcount|imagickpixel_getcolorvalue|imagickpixel_gethsl|imagickpixel_issimilar|' +
        'imagickpixel_setcolor|imagickpixel_setcolorvalue|imagickpixel_sethsl|imagickpixeliterator|imagickpixeliterator_clear|' +
        'imagickpixeliterator_construct|imagickpixeliterator_destroy|imagickpixeliterator_getcurrentiteratorrow|' +
        'imagickpixeliterator_getiteratorrow|imagickpixeliterator_getnextiteratorrow|imagickpixeliterator_getpreviousiteratorrow|' +
        'imagickpixeliterator_newpixeliterator|imagickpixeliterator_newpixelregioniterator|imagickpixeliterator_resetiterator|' +
        'imagickpixeliterator_setiteratorfirstrow|imagickpixeliterator_setiteratorlastrow|imagickpixeliterator_setiteratorrow|' +
        'imagickpixeliterator_synciterator|imap_8bit|imap_alerts|imap_append|imap_base64|imap_binary|imap_body|imap_bodystruct|imap_check|' +
        'imap_clearflag_full|imap_close|imap_create|imap_createmailbox|imap_delete|imap_deletemailbox|imap_errors|imap_expunge|imap_fetch_overview|' +
        'imap_fetchbody|imap_fetchheader|imap_fetchmime|imap_fetchstructure|imap_fetchtext|imap_gc|imap_get_quota|imap_get_quotaroot|imap_getacl|' +
        'imap_getmailboxes|imap_getsubscribed|imap_header|imap_headerinfo|imap_headers|imap_last_error|imap_list|imap_listmailbox|imap_listscan|' +
        'imap_listsubscribed|imap_lsub|imap_mail|imap_mail_compose|imap_mail_copy|imap_mail_move|imap_mailboxmsginfo|imap_mime_header_decode|' +
        'imap_msgno|imap_num_msg|imap_num_recent|imap_open|imap_ping|imap_qprint|imap_rename|imap_renamemailbox|imap_reopen|' +
        'imap_rfc822_parse_adrlist|imap_rfc822_parse_headers|imap_rfc822_write_address|imap_savebody|imap_scan|imap_scanmailbox|imap_search|' +
        'imap_set_quota|imap_setacl|imap_setflag_full|imap_sort|imap_status|imap_subscribe|imap_thread|imap_timeout|imap_uid|imap_undelete|' +
        'imap_unsubscribe|imap_utf7_decode|imap_utf7_encode|imap_utf8|implementsinterface|implode|import_request_variables|in_array|include|' +
        'include_once|inclued_get_data|inet_ntop|inet_pton|infiniteiterator|ingres_autocommit|ingres_autocommit_state|ingres_charset|ingres_close|' +
        'ingres_commit|ingres_connect|ingres_cursor|ingres_errno|ingres_error|ingres_errsqlstate|ingres_escape_string|ingres_execute|' +
        'ingres_fetch_array|ingres_fetch_assoc|ingres_fetch_object|ingres_fetch_proc_return|ingres_fetch_row|ingres_field_length|ingres_field_name|' +
        'ingres_field_nullable|ingres_field_precision|ingres_field_scale|ingres_field_type|ingres_free_result|ingres_next_error|ingres_num_fields|' +
        'ingres_num_rows|ingres_pconnect|ingres_prepare|ingres_query|ingres_result_seek|ingres_rollback|ingres_set_environment|' +
        'ingres_unbuffered_query|ini_alter|ini_get|ini_get_all|ini_restore|ini_set|innamespace|inotify_add_watch|inotify_init|inotify_queue_len|' +
        'inotify_read|inotify_rm_watch|interface_exists|intl_error_name|intl_get_error_code|intl_get_error_message|intl_is_failure|' +
        'intldateformatter|intval|invalidargumentexception|invoke|invokeargs|ip2long|iptcembed|iptcparse|is_a|is_array|is_bool|is_callable|is_dir|' +
        'is_double|is_executable|is_file|is_finite|is_float|is_infinite|is_int|is_integer|is_link|is_long|is_nan|is_null|is_numeric|is_object|' +
        'is_readable|is_real|is_resource|is_scalar|is_soap_fault|is_string|is_subclass_of|is_uploaded_file|is_writable|is_writeable|isabstract|' +
        'iscloneable|isdisabled|isfinal|isinstance|isinstantiable|isinterface|isinternal|isiterateable|isset|issubclassof|isuserdefined|iterator|' +
        'iterator_apply|iterator_count|iterator_to_array|iteratoraggregate|iteratoriterator|java_last_exception_clear|java_last_exception_get|' +
        'jddayofweek|jdmonthname|jdtofrench|jdtogregorian|jdtojewish|jdtojulian|jdtounix|jewishtojd|join|jpeg2wbmp|json_decode|json_encode|' +
        'json_last_error|jsonserializable|judy|judy_type|judy_version|juliantojd|kadm5_chpass_principal|kadm5_create_principal|' +
        'kadm5_delete_principal|kadm5_destroy|kadm5_flush|kadm5_get_policies|kadm5_get_principal|kadm5_get_principals|kadm5_init_with_password|' +
        'kadm5_modify_principal|key|krsort|ksort|lcfirst|lcg_value|lchgrp|lchown|ldap_8859_to_t61|ldap_add|ldap_bind|ldap_close|ldap_compare|' +
        'ldap_connect|ldap_count_entries|ldap_delete|ldap_dn2ufn|ldap_err2str|ldap_errno|ldap_error|ldap_explode_dn|ldap_first_attribute|' +
        'ldap_first_entry|ldap_first_reference|ldap_free_result|ldap_get_attributes|ldap_get_dn|ldap_get_entries|ldap_get_option|ldap_get_values|' +
        'ldap_get_values_len|ldap_list|ldap_mod_add|ldap_mod_del|ldap_mod_replace|ldap_modify|ldap_next_attribute|ldap_next_entry|' +
        'ldap_next_reference|ldap_parse_reference|ldap_parse_result|ldap_read|ldap_rename|ldap_sasl_bind|ldap_search|ldap_set_option|' +
        'ldap_set_rebind_proc|ldap_sort|ldap_start_tls|ldap_t61_to_8859|ldap_unbind|lengthexception|levenshtein|libxml_clear_errors|' +
        'libxml_disable_entity_loader|libxml_get_errors|libxml_get_last_error|libxml_set_streams_context|libxml_use_internal_errors|libxmlerror|' +
        'limititerator|link|linkinfo|list|locale|localeconv|localtime|log|log10|log1p|logicexception|long2ip|lstat|ltrim|lzf_compress|' +
        'lzf_decompress|lzf_optimized_for|m_checkstatus|m_completeauthorizations|m_connect|m_connectionerror|m_deletetrans|m_destroyconn|' +
        'm_destroyengine|m_getcell|m_getcellbynum|m_getcommadelimited|m_getheader|m_initconn|m_initengine|m_iscommadelimited|m_maxconntimeout|' +
        'm_monitor|m_numcolumns|m_numrows|m_parsecommadelimited|m_responsekeys|m_responseparam|m_returnstatus|m_setblocking|m_setdropfile|m_setip|' +
        'm_setssl|m_setssl_cafile|m_setssl_files|m_settimeout|m_sslcert_gen_hash|m_transactionssent|m_transinqueue|m_transkeyval|m_transnew|' +
        'm_transsend|m_uwait|m_validateidentifier|m_verifyconnection|m_verifysslcert|magic_quotes_runtime|mail|' +
        'mailparse_determine_best_xfer_encoding|mailparse_msg_create|mailparse_msg_extract_part|mailparse_msg_extract_part_file|' +
        'mailparse_msg_extract_whole_part_file|mailparse_msg_free|mailparse_msg_get_part|mailparse_msg_get_part_data|mailparse_msg_get_structure|' +
        'mailparse_msg_parse|mailparse_msg_parse_file|mailparse_rfc822_parse_addresses|mailparse_stream_encode|mailparse_uudecode_all|main|max|' +
        'maxdb_affected_rows|maxdb_autocommit|maxdb_bind_param|maxdb_bind_result|maxdb_change_user|maxdb_character_set_name|maxdb_client_encoding|' +
        'maxdb_close|maxdb_close_long_data|maxdb_commit|maxdb_connect|maxdb_connect_errno|maxdb_connect_error|maxdb_data_seek|maxdb_debug|' +
        'maxdb_disable_reads_from_master|maxdb_disable_rpl_parse|maxdb_dump_debug_info|maxdb_embedded_connect|maxdb_enable_reads_from_master|' +
        'maxdb_enable_rpl_parse|maxdb_errno|maxdb_error|maxdb_escape_string|maxdb_execute|maxdb_fetch|maxdb_fetch_array|maxdb_fetch_assoc|' +
        'maxdb_fetch_field|maxdb_fetch_field_direct|maxdb_fetch_fields|maxdb_fetch_lengths|maxdb_fetch_object|maxdb_fetch_row|maxdb_field_count|' +
        'maxdb_field_seek|maxdb_field_tell|maxdb_free_result|maxdb_get_client_info|maxdb_get_client_version|maxdb_get_host_info|maxdb_get_metadata|' +
        'maxdb_get_proto_info|maxdb_get_server_info|maxdb_get_server_version|maxdb_info|maxdb_init|maxdb_insert_id|maxdb_kill|maxdb_master_query|' +
        'maxdb_more_results|maxdb_multi_query|maxdb_next_result|maxdb_num_fields|maxdb_num_rows|maxdb_options|maxdb_param_count|maxdb_ping|' +
        'maxdb_prepare|maxdb_query|maxdb_real_connect|maxdb_real_escape_string|maxdb_real_query|maxdb_report|maxdb_rollback|' +
        'maxdb_rpl_parse_enabled|maxdb_rpl_probe|maxdb_rpl_query_type|maxdb_select_db|maxdb_send_long_data|maxdb_send_query|maxdb_server_end|' +
        'maxdb_server_init|maxdb_set_opt|maxdb_sqlstate|maxdb_ssl_set|maxdb_stat|maxdb_stmt_affected_rows|maxdb_stmt_bind_param|' +
        'maxdb_stmt_bind_result|maxdb_stmt_close|maxdb_stmt_close_long_data|maxdb_stmt_data_seek|maxdb_stmt_errno|maxdb_stmt_error|' +
        'maxdb_stmt_execute|maxdb_stmt_fetch|maxdb_stmt_free_result|maxdb_stmt_init|maxdb_stmt_num_rows|maxdb_stmt_param_count|maxdb_stmt_prepare|' +
        'maxdb_stmt_reset|maxdb_stmt_result_metadata|maxdb_stmt_send_long_data|maxdb_stmt_sqlstate|maxdb_stmt_store_result|maxdb_store_result|' +
        'maxdb_thread_id|maxdb_thread_safe|maxdb_use_result|maxdb_warning_count|mb_check_encoding|mb_convert_case|mb_convert_encoding|' +
        'mb_convert_kana|mb_convert_variables|mb_decode_mimeheader|mb_decode_numericentity|mb_detect_encoding|mb_detect_order|mb_encode_mimeheader|' +
        'mb_encode_numericentity|mb_encoding_aliases|mb_ereg|mb_ereg_match|mb_ereg_replace|mb_ereg_search|mb_ereg_search_getpos|' +
        'mb_ereg_search_getregs|mb_ereg_search_init|mb_ereg_search_pos|mb_ereg_search_regs|mb_ereg_search_setpos|mb_eregi|mb_eregi_replace|' +
        'mb_get_info|mb_http_input|mb_http_output|mb_internal_encoding|mb_language|mb_list_encodings|mb_output_handler|mb_parse_str|' +
        'mb_preferred_mime_name|mb_regex_encoding|mb_regex_set_options|mb_send_mail|mb_split|mb_strcut|mb_strimwidth|mb_stripos|mb_stristr|' +
        'mb_strlen|mb_strpos|mb_strrchr|mb_strrichr|mb_strripos|mb_strrpos|mb_strstr|mb_strtolower|mb_strtoupper|mb_strwidth|' +
        'mb_substitute_character|mb_substr|mb_substr_count|mcrypt_cbc|mcrypt_cfb|mcrypt_create_iv|mcrypt_decrypt|mcrypt_ecb|' +
        'mcrypt_enc_get_algorithms_name|mcrypt_enc_get_block_size|mcrypt_enc_get_iv_size|mcrypt_enc_get_key_size|mcrypt_enc_get_modes_name|' +
        'mcrypt_enc_get_supported_key_sizes|mcrypt_enc_is_block_algorithm|mcrypt_enc_is_block_algorithm_mode|mcrypt_enc_is_block_mode|' +
        'mcrypt_enc_self_test|mcrypt_encrypt|mcrypt_generic|mcrypt_generic_deinit|mcrypt_generic_end|mcrypt_generic_init|mcrypt_get_block_size|' +
        'mcrypt_get_cipher_name|mcrypt_get_iv_size|mcrypt_get_key_size|mcrypt_list_algorithms|mcrypt_list_modes|mcrypt_module_close|' +
        'mcrypt_module_get_algo_block_size|mcrypt_module_get_algo_key_size|mcrypt_module_get_supported_key_sizes|mcrypt_module_is_block_algorithm|' +
        'mcrypt_module_is_block_algorithm_mode|mcrypt_module_is_block_mode|mcrypt_module_open|mcrypt_module_self_test|mcrypt_ofb|md5|md5_file|' +
        'mdecrypt_generic|memcache|memcache_debug|memcached|memory_get_peak_usage|memory_get_usage|messageformatter|metaphone|method_exists|mhash|' +
        'mhash_count|mhash_get_block_size|mhash_get_hash_name|mhash_keygen_s2k|microtime|mime_content_type|min|ming_keypress|' +
        'ming_setcubicthreshold|ming_setscale|ming_setswfcompression|ming_useconstants|ming_useswfversion|mkdir|mktime|money_format|mongo|' +
        'mongobindata|mongocode|mongocollection|mongoconnectionexception|mongocursor|mongocursorexception|mongocursortimeoutexception|mongodate|' +
        'mongodb|mongodbref|mongoexception|mongogridfs|mongogridfscursor|mongogridfsexception|mongogridfsfile|mongoid|mongoint32|mongoint64|' +
        'mongomaxkey|mongominkey|mongoregex|mongotimestamp|move_uploaded_file|mpegfile|mqseries_back|mqseries_begin|mqseries_close|mqseries_cmit|' +
        'mqseries_conn|mqseries_connx|mqseries_disc|mqseries_get|mqseries_inq|mqseries_open|mqseries_put|mqseries_put1|mqseries_set|' +
        'mqseries_strerror|msession_connect|msession_count|msession_create|msession_destroy|msession_disconnect|msession_find|msession_get|' +
        'msession_get_array|msession_get_data|msession_inc|msession_list|msession_listvar|msession_lock|msession_plugin|msession_randstr|' +
        'msession_set|msession_set_array|msession_set_data|msession_timeout|msession_uniq|msession_unlock|msg_get_queue|msg_queue_exists|' +
        'msg_receive|msg_remove_queue|msg_send|msg_set_queue|msg_stat_queue|msql|msql_affected_rows|msql_close|msql_connect|msql_create_db|' +
        'msql_createdb|msql_data_seek|msql_db_query|msql_dbname|msql_drop_db|msql_error|msql_fetch_array|msql_fetch_field|msql_fetch_object|' +
        'msql_fetch_row|msql_field_flags|msql_field_len|msql_field_name|msql_field_seek|msql_field_table|msql_field_type|msql_fieldflags|' +
        'msql_fieldlen|msql_fieldname|msql_fieldtable|msql_fieldtype|msql_free_result|msql_list_dbs|msql_list_fields|msql_list_tables|' +
        'msql_num_fields|msql_num_rows|msql_numfields|msql_numrows|msql_pconnect|msql_query|msql_regcase|msql_result|msql_select_db|msql_tablename|' +
        'mssql_bind|mssql_close|mssql_connect|mssql_data_seek|mssql_execute|mssql_fetch_array|mssql_fetch_assoc|mssql_fetch_batch|' +
        'mssql_fetch_field|mssql_fetch_object|mssql_fetch_row|mssql_field_length|mssql_field_name|mssql_field_seek|mssql_field_type|' +
        'mssql_free_result|mssql_free_statement|mssql_get_last_message|mssql_guid_string|mssql_init|mssql_min_error_severity|' +
        'mssql_min_message_severity|mssql_next_result|mssql_num_fields|mssql_num_rows|mssql_pconnect|mssql_query|mssql_result|mssql_rows_affected|' +
        'mssql_select_db|mt_getrandmax|mt_rand|mt_srand|multipleiterator|mysql_affected_rows|mysql_client_encoding|mysql_close|mysql_connect|' +
        'mysql_create_db|mysql_data_seek|mysql_db_name|mysql_db_query|mysql_drop_db|mysql_errno|mysql_error|mysql_escape_string|mysql_fetch_array|' +
        'mysql_fetch_assoc|mysql_fetch_field|mysql_fetch_lengths|mysql_fetch_object|mysql_fetch_row|mysql_field_flags|mysql_field_len|' +
        'mysql_field_name|mysql_field_seek|mysql_field_table|mysql_field_type|mysql_free_result|mysql_get_client_info|mysql_get_host_info|' +
        'mysql_get_proto_info|mysql_get_server_info|mysql_info|mysql_insert_id|mysql_list_dbs|mysql_list_fields|mysql_list_processes|' +
        'mysql_list_tables|mysql_num_fields|mysql_num_rows|mysql_pconnect|mysql_ping|mysql_query|mysql_real_escape_string|mysql_result|' +
        'mysql_select_db|mysql_set_charset|mysql_stat|mysql_tablename|mysql_thread_id|mysql_unbuffered_query|mysqli|mysqli_bind_param|' +
        'mysqli_bind_result|mysqli_client_encoding|mysqli_connect|mysqli_disable_reads_from_master|mysqli_disable_rpl_parse|mysqli_driver|' +
        'mysqli_enable_reads_from_master|mysqli_enable_rpl_parse|mysqli_escape_string|mysqli_execute|mysqli_fetch|mysqli_get_metadata|' +
        'mysqli_master_query|mysqli_param_count|mysqli_report|mysqli_result|mysqli_rpl_parse_enabled|mysqli_rpl_probe|mysqli_rpl_query_type|' +
        'mysqli_send_long_data|mysqli_send_query|mysqli_set_opt|mysqli_slave_query|mysqli_stmt|mysqli_warning|mysqlnd_ms_get_stats|' +
        'mysqlnd_ms_query_is_select|mysqlnd_ms_set_user_pick_server|mysqlnd_qc_change_handler|mysqlnd_qc_clear_cache|mysqlnd_qc_get_cache_info|' +
        'mysqlnd_qc_get_core_stats|mysqlnd_qc_get_handler|mysqlnd_qc_get_query_trace_log|mysqlnd_qc_set_user_handlers|natcasesort|natsort|' +
        'ncurses_addch|ncurses_addchnstr|ncurses_addchstr|ncurses_addnstr|ncurses_addstr|ncurses_assume_default_colors|ncurses_attroff|' +
        'ncurses_attron|ncurses_attrset|ncurses_baudrate|ncurses_beep|ncurses_bkgd|ncurses_bkgdset|ncurses_border|ncurses_bottom_panel|' +
        'ncurses_can_change_color|ncurses_cbreak|ncurses_clear|ncurses_clrtobot|ncurses_clrtoeol|ncurses_color_content|ncurses_color_set|' +
        'ncurses_curs_set|ncurses_def_prog_mode|ncurses_def_shell_mode|ncurses_define_key|ncurses_del_panel|ncurses_delay_output|ncurses_delch|' +
        'ncurses_deleteln|ncurses_delwin|ncurses_doupdate|ncurses_echo|ncurses_echochar|ncurses_end|ncurses_erase|ncurses_erasechar|ncurses_filter|' +
        'ncurses_flash|ncurses_flushinp|ncurses_getch|ncurses_getmaxyx|ncurses_getmouse|ncurses_getyx|ncurses_halfdelay|ncurses_has_colors|' +
        'ncurses_has_ic|ncurses_has_il|ncurses_has_key|ncurses_hide_panel|ncurses_hline|ncurses_inch|ncurses_init|ncurses_init_color|' +
        'ncurses_init_pair|ncurses_insch|ncurses_insdelln|ncurses_insertln|ncurses_insstr|ncurses_instr|ncurses_isendwin|ncurses_keyok|' +
        'ncurses_keypad|ncurses_killchar|ncurses_longname|ncurses_meta|ncurses_mouse_trafo|ncurses_mouseinterval|ncurses_mousemask|ncurses_move|' +
        'ncurses_move_panel|ncurses_mvaddch|ncurses_mvaddchnstr|ncurses_mvaddchstr|ncurses_mvaddnstr|ncurses_mvaddstr|ncurses_mvcur|' +
        'ncurses_mvdelch|ncurses_mvgetch|ncurses_mvhline|ncurses_mvinch|ncurses_mvvline|ncurses_mvwaddstr|ncurses_napms|ncurses_new_panel|' +
        'ncurses_newpad|ncurses_newwin|ncurses_nl|ncurses_nocbreak|ncurses_noecho|ncurses_nonl|ncurses_noqiflush|ncurses_noraw|' +
        'ncurses_pair_content|ncurses_panel_above|ncurses_panel_below|ncurses_panel_window|ncurses_pnoutrefresh|ncurses_prefresh|ncurses_putp|' +
        'ncurses_qiflush|ncurses_raw|ncurses_refresh|ncurses_replace_panel|ncurses_reset_prog_mode|ncurses_reset_shell_mode|ncurses_resetty|' +
        'ncurses_savetty|ncurses_scr_dump|ncurses_scr_init|ncurses_scr_restore|ncurses_scr_set|ncurses_scrl|ncurses_show_panel|ncurses_slk_attr|' +
        'ncurses_slk_attroff|ncurses_slk_attron|ncurses_slk_attrset|ncurses_slk_clear|ncurses_slk_color|ncurses_slk_init|ncurses_slk_noutrefresh|' +
        'ncurses_slk_refresh|ncurses_slk_restore|ncurses_slk_set|ncurses_slk_touch|ncurses_standend|ncurses_standout|ncurses_start_color|' +
        'ncurses_termattrs|ncurses_termname|ncurses_timeout|ncurses_top_panel|ncurses_typeahead|ncurses_ungetch|ncurses_ungetmouse|' +
        'ncurses_update_panels|ncurses_use_default_colors|ncurses_use_env|ncurses_use_extended_names|ncurses_vidattr|ncurses_vline|ncurses_waddch|' +
        'ncurses_waddstr|ncurses_wattroff|ncurses_wattron|ncurses_wattrset|ncurses_wborder|ncurses_wclear|ncurses_wcolor_set|ncurses_werase|' +
        'ncurses_wgetch|ncurses_whline|ncurses_wmouse_trafo|ncurses_wmove|ncurses_wnoutrefresh|ncurses_wrefresh|ncurses_wstandend|' +
        'ncurses_wstandout|ncurses_wvline|newinstance|newinstanceargs|newt_bell|newt_button|newt_button_bar|newt_centered_window|newt_checkbox|' +
        'newt_checkbox_get_value|newt_checkbox_set_flags|newt_checkbox_set_value|newt_checkbox_tree|newt_checkbox_tree_add_item|' +
        'newt_checkbox_tree_find_item|newt_checkbox_tree_get_current|newt_checkbox_tree_get_entry_value|newt_checkbox_tree_get_multi_selection|' +
        'newt_checkbox_tree_get_selection|newt_checkbox_tree_multi|newt_checkbox_tree_set_current|newt_checkbox_tree_set_entry|' +
        'newt_checkbox_tree_set_entry_value|newt_checkbox_tree_set_width|newt_clear_key_buffer|newt_cls|newt_compact_button|' +
        'newt_component_add_callback|newt_component_takes_focus|newt_create_grid|newt_cursor_off|newt_cursor_on|newt_delay|newt_draw_form|' +
        'newt_draw_root_text|newt_entry|newt_entry_get_value|newt_entry_set|newt_entry_set_filter|newt_entry_set_flags|newt_finished|newt_form|' +
        'newt_form_add_component|newt_form_add_components|newt_form_add_hot_key|newt_form_destroy|newt_form_get_current|newt_form_run|' +
        'newt_form_set_background|newt_form_set_height|newt_form_set_size|newt_form_set_timer|newt_form_set_width|newt_form_watch_fd|' +
        'newt_get_screen_size|newt_grid_add_components_to_form|newt_grid_basic_window|newt_grid_free|newt_grid_get_size|newt_grid_h_close_stacked|' +
        'newt_grid_h_stacked|newt_grid_place|newt_grid_set_field|newt_grid_simple_window|newt_grid_v_close_stacked|newt_grid_v_stacked|' +
        'newt_grid_wrapped_window|newt_grid_wrapped_window_at|newt_init|newt_label|newt_label_set_text|newt_listbox|newt_listbox_append_entry|' +
        'newt_listbox_clear|newt_listbox_clear_selection|newt_listbox_delete_entry|newt_listbox_get_current|newt_listbox_get_selection|' +
        'newt_listbox_insert_entry|newt_listbox_item_count|newt_listbox_select_item|newt_listbox_set_current|newt_listbox_set_current_by_key|' +
        'newt_listbox_set_data|newt_listbox_set_entry|newt_listbox_set_width|newt_listitem|newt_listitem_get_data|newt_listitem_set|' +
        'newt_open_window|newt_pop_help_line|newt_pop_window|newt_push_help_line|newt_radio_get_current|newt_radiobutton|newt_redraw_help_line|' +
        'newt_reflow_text|newt_refresh|newt_resize_screen|newt_resume|newt_run_form|newt_scale|newt_scale_set|newt_scrollbar_set|' +
        'newt_set_help_callback|newt_set_suspend_callback|newt_suspend|newt_textbox|newt_textbox_get_num_lines|newt_textbox_reflowed|' +
        'newt_textbox_set_height|newt_textbox_set_text|newt_vertical_scrollbar|newt_wait_for_key|newt_win_choice|newt_win_entries|newt_win_menu|' +
        'newt_win_message|newt_win_messagev|newt_win_ternary|next|ngettext|nl2br|nl_langinfo|norewinditerator|normalizer|notes_body|notes_copy_db|' +
        'notes_create_db|notes_create_note|notes_drop_db|notes_find_note|notes_header_info|notes_list_msgs|notes_mark_read|notes_mark_unread|' +
        'notes_nav_create|notes_search|notes_unread|notes_version|nsapi_request_headers|nsapi_response_headers|nsapi_virtual|nthmac|number_format|' +
        'numberformatter|oauth|oauth_get_sbs|oauth_urlencode|oauthexception|oauthprovider|ob_clean|ob_deflatehandler|ob_end_clean|ob_end_flush|' +
        'ob_etaghandler|ob_flush|ob_get_clean|ob_get_contents|ob_get_flush|ob_get_length|ob_get_level|ob_get_status|ob_gzhandler|ob_iconv_handler|' +
        'ob_implicit_flush|ob_inflatehandler|ob_list_handlers|ob_start|ob_tidyhandler|oci_bind_array_by_name|oci_bind_by_name|oci_cancel|' +
        'oci_client_version|oci_close|oci_collection_append|oci_collection_assign|oci_collection_element_assign|oci_collection_element_get|' +
        'oci_collection_free|oci_collection_max|oci_collection_size|oci_collection_trim|oci_commit|oci_connect|oci_define_by_name|oci_error|' +
        'oci_execute|oci_fetch|oci_fetch_all|oci_fetch_array|oci_fetch_assoc|oci_fetch_object|oci_fetch_row|oci_field_is_null|oci_field_name|' +
        'oci_field_precision|oci_field_scale|oci_field_size|oci_field_type|oci_field_type_raw|oci_free_statement|oci_internal_debug|oci_lob_append|' +
        'oci_lob_close|oci_lob_copy|oci_lob_eof|oci_lob_erase|oci_lob_export|oci_lob_flush|oci_lob_free|oci_lob_getbuffering|oci_lob_import|' +
        'oci_lob_is_equal|oci_lob_load|oci_lob_read|oci_lob_rewind|oci_lob_save|oci_lob_savefile|oci_lob_seek|oci_lob_setbuffering|oci_lob_size|' +
        'oci_lob_tell|oci_lob_truncate|oci_lob_write|oci_lob_writetemporary|oci_lob_writetofile|oci_new_collection|oci_new_connect|oci_new_cursor|' +
        'oci_new_descriptor|oci_num_fields|oci_num_rows|oci_parse|oci_password_change|oci_pconnect|oci_result|oci_rollback|oci_server_version|' +
        'oci_set_action|oci_set_client_identifier|oci_set_client_info|oci_set_edition|oci_set_module_name|oci_set_prefetch|oci_statement_type|' +
        'ocibindbyname|ocicancel|ocicloselob|ocicollappend|ocicollassign|ocicollassignelem|ocicollgetelem|ocicollmax|ocicollsize|ocicolltrim|' +
        'ocicolumnisnull|ocicolumnname|ocicolumnprecision|ocicolumnscale|ocicolumnsize|ocicolumntype|ocicolumntyperaw|ocicommit|ocidefinebyname|' +
        'ocierror|ociexecute|ocifetch|ocifetchinto|ocifetchstatement|ocifreecollection|ocifreecursor|ocifreedesc|ocifreestatement|ociinternaldebug|' +
        'ociloadlob|ocilogoff|ocilogon|ocinewcollection|ocinewcursor|ocinewdescriptor|ocinlogon|ocinumcols|ociparse|ociplogon|ociresult|' +
        'ocirollback|ocirowcount|ocisavelob|ocisavelobfile|ociserverversion|ocisetprefetch|ocistatementtype|ociwritelobtofile|ociwritetemporarylob|' +
        'octdec|odbc_autocommit|odbc_binmode|odbc_close|odbc_close_all|odbc_columnprivileges|odbc_columns|odbc_commit|odbc_connect|odbc_cursor|' +
        'odbc_data_source|odbc_do|odbc_error|odbc_errormsg|odbc_exec|odbc_execute|odbc_fetch_array|odbc_fetch_into|odbc_fetch_object|' +
        'odbc_fetch_row|odbc_field_len|odbc_field_name|odbc_field_num|odbc_field_precision|odbc_field_scale|odbc_field_type|odbc_foreignkeys|' +
        'odbc_free_result|odbc_gettypeinfo|odbc_longreadlen|odbc_next_result|odbc_num_fields|odbc_num_rows|odbc_pconnect|odbc_prepare|' +
        'odbc_primarykeys|odbc_procedurecolumns|odbc_procedures|odbc_result|odbc_result_all|odbc_rollback|odbc_setoption|odbc_specialcolumns|' +
        'odbc_statistics|odbc_tableprivileges|odbc_tables|openal_buffer_create|openal_buffer_data|openal_buffer_destroy|openal_buffer_get|' +
        'openal_buffer_loadwav|openal_context_create|openal_context_current|openal_context_destroy|openal_context_process|openal_context_suspend|' +
        'openal_device_close|openal_device_open|openal_listener_get|openal_listener_set|openal_source_create|openal_source_destroy|' +
        'openal_source_get|openal_source_pause|openal_source_play|openal_source_rewind|openal_source_set|openal_source_stop|openal_stream|opendir|' +
        'openlog|openssl_cipher_iv_length|openssl_csr_export|openssl_csr_export_to_file|openssl_csr_get_public_key|openssl_csr_get_subject|' +
        'openssl_csr_new|openssl_csr_sign|openssl_decrypt|openssl_dh_compute_key|openssl_digest|openssl_encrypt|openssl_error_string|' +
        'openssl_free_key|openssl_get_cipher_methods|openssl_get_md_methods|openssl_get_privatekey|openssl_get_publickey|openssl_open|' +
        'openssl_pkcs12_export|openssl_pkcs12_export_to_file|openssl_pkcs12_read|openssl_pkcs7_decrypt|openssl_pkcs7_encrypt|openssl_pkcs7_sign|' +
        'openssl_pkcs7_verify|openssl_pkey_export|openssl_pkey_export_to_file|openssl_pkey_free|openssl_pkey_get_details|openssl_pkey_get_private|' +
        'openssl_pkey_get_public|openssl_pkey_new|openssl_private_decrypt|openssl_private_encrypt|openssl_public_decrypt|openssl_public_encrypt|' +
        'openssl_random_pseudo_bytes|openssl_seal|openssl_sign|openssl_verify|openssl_x509_check_private_key|openssl_x509_checkpurpose|' +
        'openssl_x509_export|openssl_x509_export_to_file|openssl_x509_free|openssl_x509_parse|openssl_x509_read|ord|outeriterator|' +
        'outofboundsexception|outofrangeexception|output_add_rewrite_var|output_reset_rewrite_vars|overflowexception|overload|override_function|' +
        'ovrimos_close|ovrimos_commit|ovrimos_connect|ovrimos_cursor|ovrimos_exec|ovrimos_execute|ovrimos_fetch_into|ovrimos_fetch_row|' +
        'ovrimos_field_len|ovrimos_field_name|ovrimos_field_num|ovrimos_field_type|ovrimos_free_result|ovrimos_longreadlen|ovrimos_num_fields|' +
        'ovrimos_num_rows|ovrimos_prepare|ovrimos_result|ovrimos_result_all|ovrimos_rollback|pack|parentiterator|parse_ini_file|parse_ini_string|' +
        'parse_str|parse_url|parsekit_compile_file|parsekit_compile_string|parsekit_func_arginfo|passthru|pathinfo|pclose|pcntl_alarm|pcntl_exec|' +
        'pcntl_fork|pcntl_getpriority|pcntl_setpriority|pcntl_signal|pcntl_signal_dispatch|pcntl_sigprocmask|pcntl_sigtimedwait|pcntl_sigwaitinfo|' +
        'pcntl_wait|pcntl_waitpid|pcntl_wexitstatus|pcntl_wifexited|pcntl_wifsignaled|pcntl_wifstopped|pcntl_wstopsig|pcntl_wtermsig|' +
        'pdf_activate_item|pdf_add_annotation|pdf_add_bookmark|pdf_add_launchlink|pdf_add_locallink|pdf_add_nameddest|pdf_add_note|pdf_add_outline|' +
        'pdf_add_pdflink|pdf_add_table_cell|pdf_add_textflow|pdf_add_thumbnail|pdf_add_weblink|pdf_arc|pdf_arcn|pdf_attach_file|pdf_begin_document|' +
        'pdf_begin_font|pdf_begin_glyph|pdf_begin_item|pdf_begin_layer|pdf_begin_page|pdf_begin_page_ext|pdf_begin_pattern|pdf_begin_template|' +
        'pdf_begin_template_ext|pdf_circle|pdf_clip|pdf_close|pdf_close_image|pdf_close_pdi|pdf_close_pdi_page|pdf_closepath|' +
        'pdf_closepath_fill_stroke|pdf_closepath_stroke|pdf_concat|pdf_continue_text|pdf_create_3dview|pdf_create_action|pdf_create_annotation|' +
        'pdf_create_bookmark|pdf_create_field|pdf_create_fieldgroup|pdf_create_gstate|pdf_create_pvf|pdf_create_textflow|pdf_curveto|' +
        'pdf_define_layer|pdf_delete|pdf_delete_pvf|pdf_delete_table|pdf_delete_textflow|pdf_encoding_set_char|pdf_end_document|pdf_end_font|' +
        'pdf_end_glyph|pdf_end_item|pdf_end_layer|pdf_end_page|pdf_end_page_ext|pdf_end_pattern|pdf_end_template|pdf_endpath|pdf_fill|' +
        'pdf_fill_imageblock|pdf_fill_pdfblock|pdf_fill_stroke|pdf_fill_textblock|pdf_findfont|pdf_fit_image|pdf_fit_pdi_page|pdf_fit_table|' +
        'pdf_fit_textflow|pdf_fit_textline|pdf_get_apiname|pdf_get_buffer|pdf_get_errmsg|pdf_get_errnum|pdf_get_font|pdf_get_fontname|' +
        'pdf_get_fontsize|pdf_get_image_height|pdf_get_image_width|pdf_get_majorversion|pdf_get_minorversion|pdf_get_parameter|' +
        'pdf_get_pdi_parameter|pdf_get_pdi_value|pdf_get_value|pdf_info_font|pdf_info_matchbox|pdf_info_table|pdf_info_textflow|pdf_info_textline|' +
        'pdf_initgraphics|pdf_lineto|pdf_load_3ddata|pdf_load_font|pdf_load_iccprofile|pdf_load_image|pdf_makespotcolor|pdf_moveto|pdf_new|' +
        'pdf_open_ccitt|pdf_open_file|pdf_open_gif|pdf_open_image|pdf_open_image_file|pdf_open_jpeg|pdf_open_memory_image|pdf_open_pdi|' +
        'pdf_open_pdi_document|pdf_open_pdi_page|pdf_open_tiff|pdf_pcos_get_number|pdf_pcos_get_stream|pdf_pcos_get_string|pdf_place_image|' +
        'pdf_place_pdi_page|pdf_process_pdi|pdf_rect|pdf_restore|pdf_resume_page|pdf_rotate|pdf_save|pdf_scale|pdf_set_border_color|' +
        'pdf_set_border_dash|pdf_set_border_style|pdf_set_char_spacing|pdf_set_duration|pdf_set_gstate|pdf_set_horiz_scaling|pdf_set_info|' +
        'pdf_set_info_author|pdf_set_info_creator|pdf_set_info_keywords|pdf_set_info_subject|pdf_set_info_title|pdf_set_layer_dependency|' +
        'pdf_set_leading|pdf_set_parameter|pdf_set_text_matrix|pdf_set_text_pos|pdf_set_text_rendering|pdf_set_text_rise|pdf_set_value|' +
        'pdf_set_word_spacing|pdf_setcolor|pdf_setdash|pdf_setdashpattern|pdf_setflat|pdf_setfont|pdf_setgray|pdf_setgray_fill|pdf_setgray_stroke|' +
        'pdf_setlinecap|pdf_setlinejoin|pdf_setlinewidth|pdf_setmatrix|pdf_setmiterlimit|pdf_setpolydash|pdf_setrgbcolor|pdf_setrgbcolor_fill|' +
        'pdf_setrgbcolor_stroke|pdf_shading|pdf_shading_pattern|pdf_shfill|pdf_show|pdf_show_boxed|pdf_show_xy|pdf_skew|pdf_stringwidth|pdf_stroke|' +
        'pdf_suspend_page|pdf_translate|pdf_utf16_to_utf8|pdf_utf32_to_utf16|pdf_utf8_to_utf16|pdo|pdo_cubrid_schema|pdo_pgsqllobcreate|' +
        'pdo_pgsqllobopen|pdo_pgsqllobunlink|pdo_sqlitecreateaggregate|pdo_sqlitecreatefunction|pdoexception|pdostatement|pfsockopen|' +
        'pg_affected_rows|pg_cancel_query|pg_client_encoding|pg_close|pg_connect|pg_connection_busy|pg_connection_reset|pg_connection_status|' +
        'pg_convert|pg_copy_from|pg_copy_to|pg_dbname|pg_delete|pg_end_copy|pg_escape_bytea|pg_escape_string|pg_execute|pg_fetch_all|' +
        'pg_fetch_all_columns|pg_fetch_array|pg_fetch_assoc|pg_fetch_object|pg_fetch_result|pg_fetch_row|pg_field_is_null|pg_field_name|' +
        'pg_field_num|pg_field_prtlen|pg_field_size|pg_field_table|pg_field_type|pg_field_type_oid|pg_free_result|pg_get_notify|pg_get_pid|' +
        'pg_get_result|pg_host|pg_insert|pg_last_error|pg_last_notice|pg_last_oid|pg_lo_close|pg_lo_create|pg_lo_export|pg_lo_import|pg_lo_open|' +
        'pg_lo_read|pg_lo_read_all|pg_lo_seek|pg_lo_tell|pg_lo_unlink|pg_lo_write|pg_meta_data|pg_num_fields|pg_num_rows|pg_options|' +
        'pg_parameter_status|pg_pconnect|pg_ping|pg_port|pg_prepare|pg_put_line|pg_query|pg_query_params|pg_result_error|pg_result_error_field|' +
        'pg_result_seek|pg_result_status|pg_select|pg_send_execute|pg_send_prepare|pg_send_query|pg_send_query_params|pg_set_client_encoding|' +
        'pg_set_error_verbosity|pg_trace|pg_transaction_status|pg_tty|pg_unescape_bytea|pg_untrace|pg_update|pg_version|php_check_syntax|' +
        'php_ini_loaded_file|php_ini_scanned_files|php_logo_guid|php_sapi_name|php_strip_whitespace|php_uname|phpcredits|phpinfo|phpversion|pi|' +
        'png2wbmp|popen|pos|posix_access|posix_ctermid|posix_errno|posix_get_last_error|posix_getcwd|posix_getegid|posix_geteuid|posix_getgid|' +
        'posix_getgrgid|posix_getgrnam|posix_getgroups|posix_getlogin|posix_getpgid|posix_getpgrp|posix_getpid|posix_getppid|posix_getpwnam|' +
        'posix_getpwuid|posix_getrlimit|posix_getsid|posix_getuid|posix_initgroups|posix_isatty|posix_kill|posix_mkfifo|posix_mknod|posix_setegid|' +
        'posix_seteuid|posix_setgid|posix_setpgid|posix_setsid|posix_setuid|posix_strerror|posix_times|posix_ttyname|posix_uname|pow|preg_filter|' +
        'preg_grep|preg_last_error|preg_match|preg_match_all|preg_quote|preg_replace|preg_replace_callback|preg_split|prev|print|print_r|' +
        'printer_abort|printer_close|printer_create_brush|printer_create_dc|printer_create_font|printer_create_pen|printer_delete_brush|' +
        'printer_delete_dc|printer_delete_font|printer_delete_pen|printer_draw_bmp|printer_draw_chord|printer_draw_elipse|printer_draw_line|' +
        'printer_draw_pie|printer_draw_rectangle|printer_draw_roundrect|printer_draw_text|printer_end_doc|printer_end_page|printer_get_option|' +
        'printer_list|printer_logical_fontheight|printer_open|printer_select_brush|printer_select_font|printer_select_pen|printer_set_option|' +
        'printer_start_doc|printer_start_page|printer_write|printf|proc_close|proc_get_status|proc_nice|proc_open|proc_terminate|property_exists|' +
        'ps_add_bookmark|ps_add_launchlink|ps_add_locallink|ps_add_note|ps_add_pdflink|ps_add_weblink|ps_arc|ps_arcn|ps_begin_page|' +
        'ps_begin_pattern|ps_begin_template|ps_circle|ps_clip|ps_close|ps_close_image|ps_closepath|ps_closepath_stroke|ps_continue_text|ps_curveto|' +
        'ps_delete|ps_end_page|ps_end_pattern|ps_end_template|ps_fill|ps_fill_stroke|ps_findfont|ps_get_buffer|ps_get_parameter|ps_get_value|' +
        'ps_hyphenate|ps_include_file|ps_lineto|ps_makespotcolor|ps_moveto|ps_new|ps_open_file|ps_open_image|ps_open_image_file|' +
        'ps_open_memory_image|ps_place_image|ps_rect|ps_restore|ps_rotate|ps_save|ps_scale|ps_set_border_color|ps_set_border_dash|' +
        'ps_set_border_style|ps_set_info|ps_set_parameter|ps_set_text_pos|ps_set_value|ps_setcolor|ps_setdash|ps_setflat|ps_setfont|ps_setgray|' +
        'ps_setlinecap|ps_setlinejoin|ps_setlinewidth|ps_setmiterlimit|ps_setoverprintmode|ps_setpolydash|ps_shading|ps_shading_pattern|ps_shfill|' +
        'ps_show|ps_show2|ps_show_boxed|ps_show_xy|ps_show_xy2|ps_string_geometry|ps_stringwidth|ps_stroke|ps_symbol|ps_symbol_name|' +
        'ps_symbol_width|ps_translate|pspell_add_to_personal|pspell_add_to_session|pspell_check|pspell_clear_session|pspell_config_create|' +
        'pspell_config_data_dir|pspell_config_dict_dir|pspell_config_ignore|pspell_config_mode|pspell_config_personal|pspell_config_repl|' +
        'pspell_config_runtogether|pspell_config_save_repl|pspell_new|pspell_new_config|pspell_new_personal|pspell_save_wordlist|' +
        'pspell_store_replacement|pspell_suggest|putenv|px_close|px_create_fp|px_date2string|px_delete|px_delete_record|px_get_field|px_get_info|' +
        'px_get_parameter|px_get_record|px_get_schema|px_get_value|px_insert_record|px_new|px_numfields|px_numrecords|px_open_fp|px_put_record|' +
        'px_retrieve_record|px_set_blob_file|px_set_parameter|px_set_tablename|px_set_targetencoding|px_set_value|px_timestamp2string|' +
        'px_update_record|qdom_error|qdom_tree|quoted_printable_decode|quoted_printable_encode|quotemeta|rad2deg|radius_acct_open|' +
        'radius_add_server|radius_auth_open|radius_close|radius_config|radius_create_request|radius_cvt_addr|radius_cvt_int|radius_cvt_string|' +
        'radius_demangle|radius_demangle_mppe_key|radius_get_attr|radius_get_vendor_attr|radius_put_addr|radius_put_attr|radius_put_int|' +
        'radius_put_string|radius_put_vendor_addr|radius_put_vendor_attr|radius_put_vendor_int|radius_put_vendor_string|' +
        'radius_request_authenticator|radius_send_request|radius_server_secret|radius_strerror|rand|range|rangeexception|rar_wrapper_cache_stats|' +
        'rararchive|rarentry|rarexception|rawurldecode|rawurlencode|read_exif_data|readdir|readfile|readgzfile|readline|readline_add_history|' +
        'readline_callback_handler_install|readline_callback_handler_remove|readline_callback_read_char|readline_clear_history|' +
        'readline_completion_function|readline_info|readline_list_history|readline_on_new_line|readline_read_history|readline_redisplay|' +
        'readline_write_history|readlink|realpath|realpath_cache_get|realpath_cache_size|recode|recode_file|recode_string|recursivearrayiterator|' +
        'recursivecachingiterator|recursivecallbackfilteriterator|recursivedirectoryiterator|recursivefilteriterator|recursiveiterator|' +
        'recursiveiteratoriterator|recursiveregexiterator|recursivetreeiterator|reflection|reflectionclass|reflectionexception|reflectionextension|' +
        'reflectionfunction|reflectionfunctionabstract|reflectionmethod|reflectionobject|reflectionparameter|reflectionproperty|reflector|' +
        'regexiterator|register_shutdown_function|register_tick_function|rename|rename_function|require|require_once|reset|resetValue|' +
        'resourcebundle|restore_error_handler|restore_exception_handler|restore_include_path|return|rewind|rewinddir|rmdir|round|rpm_close|' +
        'rpm_get_tag|rpm_is_valid|rpm_open|rpm_version|rrd_create|rrd_error|rrd_fetch|rrd_first|rrd_graph|rrd_info|rrd_last|rrd_lastupdate|' +
        'rrd_restore|rrd_tune|rrd_update|rrd_xport|rrdcreator|rrdgraph|rrdupdater|rsort|rtrim|runkit_class_adopt|runkit_class_emancipate|' +
        'runkit_constant_add|runkit_constant_redefine|runkit_constant_remove|runkit_function_add|runkit_function_copy|runkit_function_redefine|' +
        'runkit_function_remove|runkit_function_rename|runkit_import|runkit_lint|runkit_lint_file|runkit_method_add|runkit_method_copy|' +
        'runkit_method_redefine|runkit_method_remove|runkit_method_rename|runkit_return_value_used|runkit_sandbox_output_handler|' +
        'runkit_superglobals|runtimeexception|samconnection_commit|samconnection_connect|samconnection_constructor|samconnection_disconnect|' +
        'samconnection_errno|samconnection_error|samconnection_isconnected|samconnection_peek|samconnection_peekall|samconnection_receive|' +
        'samconnection_remove|samconnection_rollback|samconnection_send|samconnection_setDebug|samconnection_subscribe|samconnection_unsubscribe|' +
        'sammessage_body|sammessage_constructor|sammessage_header|sca_createdataobject|sca_getservice|sca_localproxy_createdataobject|' +
        'sca_soapproxy_createdataobject|scandir|sdo_das_changesummary_beginlogging|sdo_das_changesummary_endlogging|' +
        'sdo_das_changesummary_getchangeddataobjects|sdo_das_changesummary_getchangetype|sdo_das_changesummary_getoldcontainer|' +
        'sdo_das_changesummary_getoldvalues|sdo_das_changesummary_islogging|sdo_das_datafactory_addpropertytotype|sdo_das_datafactory_addtype|' +
        'sdo_das_datafactory_getdatafactory|sdo_das_dataobject_getchangesummary|sdo_das_relational_applychanges|sdo_das_relational_construct|' +
        'sdo_das_relational_createrootdataobject|sdo_das_relational_executepreparedquery|sdo_das_relational_executequery|' +
        'sdo_das_setting_getlistindex|sdo_das_setting_getpropertyindex|sdo_das_setting_getpropertyname|sdo_das_setting_getvalue|' +
        'sdo_das_setting_isset|sdo_das_xml_addtypes|sdo_das_xml_create|sdo_das_xml_createdataobject|sdo_das_xml_createdocument|' +
        'sdo_das_xml_document_getrootdataobject|sdo_das_xml_document_getrootelementname|sdo_das_xml_document_getrootelementuri|' +
        'sdo_das_xml_document_setencoding|sdo_das_xml_document_setxmldeclaration|sdo_das_xml_document_setxmlversion|sdo_das_xml_loadfile|' +
        'sdo_das_xml_loadstring|sdo_das_xml_savefile|sdo_das_xml_savestring|sdo_datafactory_create|sdo_dataobject_clear|' +
        'sdo_dataobject_createdataobject|sdo_dataobject_getcontainer|sdo_dataobject_getsequence|sdo_dataobject_gettypename|' +
        'sdo_dataobject_gettypenamespaceuri|sdo_exception_getcause|sdo_list_insert|sdo_model_property_getcontainingtype|' +
        'sdo_model_property_getdefault|sdo_model_property_getname|sdo_model_property_gettype|sdo_model_property_iscontainment|' +
        'sdo_model_property_ismany|sdo_model_reflectiondataobject_construct|sdo_model_reflectiondataobject_export|' +
        'sdo_model_reflectiondataobject_getcontainmentproperty|sdo_model_reflectiondataobject_getinstanceproperties|' +
        'sdo_model_reflectiondataobject_gettype|sdo_model_type_getbasetype|sdo_model_type_getname|sdo_model_type_getnamespaceuri|' +
        'sdo_model_type_getproperties|sdo_model_type_getproperty|sdo_model_type_isabstracttype|sdo_model_type_isdatatype|sdo_model_type_isinstance|' +
        'sdo_model_type_isopentype|sdo_model_type_issequencedtype|sdo_sequence_getproperty|sdo_sequence_insert|sdo_sequence_move|seekableiterator|' +
        'sem_acquire|sem_get|sem_release|sem_remove|serializable|serialize|session_cache_expire|session_cache_limiter|session_commit|' +
        'session_decode|session_destroy|session_encode|session_get_cookie_params|session_id|session_is_registered|session_module_name|session_name|' +
        'session_pgsql_add_error|session_pgsql_get_error|session_pgsql_get_field|session_pgsql_reset|session_pgsql_set_field|session_pgsql_status|' +
        'session_regenerate_id|session_register|session_save_path|session_set_cookie_params|session_set_save_handler|session_start|' +
        'session_unregister|session_unset|session_write_close|setCounterClass|set_error_handler|set_exception_handler|set_file_buffer|' +
        'set_include_path|set_magic_quotes_runtime|set_socket_blocking|set_time_limit|setcookie|setlocale|setproctitle|setrawcookie|' +
        'setstaticpropertyvalue|setthreadtitle|settype|sha1|sha1_file|shell_exec|shm_attach|shm_detach|shm_get_var|shm_has_var|shm_put_var|' +
        'shm_remove|shm_remove_var|shmop_close|shmop_delete|shmop_open|shmop_read|shmop_size|shmop_write|show_source|shuffle|signeurlpaiement|' +
        'similar_text|simplexml_import_dom|simplexml_load_file|simplexml_load_string|simplexmlelement|simplexmliterator|sin|sinh|sizeof|sleep|snmp|' +
        'snmp2_get|snmp2_getnext|snmp2_real_walk|snmp2_set|snmp2_walk|snmp3_get|snmp3_getnext|snmp3_real_walk|snmp3_set|snmp3_walk|' +
        'snmp_get_quick_print|snmp_get_valueretrieval|snmp_read_mib|snmp_set_enum_print|snmp_set_oid_numeric_print|snmp_set_oid_output_format|' +
        'snmp_set_quick_print|snmp_set_valueretrieval|snmpget|snmpgetnext|snmprealwalk|snmpset|snmpwalk|snmpwalkoid|soapclient|soapfault|' +
        'soapheader|soapparam|soapserver|soapvar|socket_accept|socket_bind|socket_clear_error|socket_close|socket_connect|socket_create|' +
        'socket_create_listen|socket_create_pair|socket_get_option|socket_get_status|socket_getpeername|socket_getsockname|socket_last_error|' +
        'socket_listen|socket_read|socket_recv|socket_recvfrom|socket_select|socket_send|socket_sendto|socket_set_block|socket_set_blocking|' +
        'socket_set_nonblock|socket_set_option|socket_set_timeout|socket_shutdown|socket_strerror|socket_write|solr_get_version|solrclient|' +
        'solrclientexception|solrdocument|solrdocumentfield|solrexception|solrgenericresponse|solrillegalargumentexception|' +
        'solrillegaloperationexception|solrinputdocument|solrmodifiableparams|solrobject|solrparams|solrpingresponse|solrquery|solrqueryresponse|' +
        'solrresponse|solrupdateresponse|solrutils|sort|soundex|sphinxclient|spl_autoload|spl_autoload_call|spl_autoload_extensions|' +
        'spl_autoload_functions|spl_autoload_register|spl_autoload_unregister|spl_classes|spl_object_hash|splbool|spldoublylinkedlist|splenum|' +
        'splfileinfo|splfileobject|splfixedarray|splfloat|splheap|splint|split|spliti|splmaxheap|splminheap|splobjectstorage|splobserver|' +
        'splpriorityqueue|splqueue|splstack|splstring|splsubject|spltempfileobject|spoofchecker|sprintf|sql_regcase|sqlite3|sqlite3result|' +
        'sqlite3stmt|sqlite_array_query|sqlite_busy_timeout|sqlite_changes|sqlite_close|sqlite_column|sqlite_create_aggregate|' +
        'sqlite_create_function|sqlite_current|sqlite_error_string|sqlite_escape_string|sqlite_exec|sqlite_factory|sqlite_fetch_all|' +
        'sqlite_fetch_array|sqlite_fetch_column_types|sqlite_fetch_object|sqlite_fetch_single|sqlite_fetch_string|sqlite_field_name|' +
        'sqlite_has_more|sqlite_has_prev|sqlite_key|sqlite_last_error|sqlite_last_insert_rowid|sqlite_libencoding|sqlite_libversion|sqlite_next|' +
        'sqlite_num_fields|sqlite_num_rows|sqlite_open|sqlite_popen|sqlite_prev|sqlite_query|sqlite_rewind|sqlite_seek|sqlite_single_query|' +
        'sqlite_udf_decode_binary|sqlite_udf_encode_binary|sqlite_unbuffered_query|sqlite_valid|sqrt|srand|sscanf|ssdeep_fuzzy_compare|' +
        'ssdeep_fuzzy_hash|ssdeep_fuzzy_hash_filename|ssh2_auth_hostbased_file|ssh2_auth_none|ssh2_auth_password|ssh2_auth_pubkey_file|' +
        'ssh2_connect|ssh2_exec|ssh2_fetch_stream|ssh2_fingerprint|ssh2_methods_negotiated|ssh2_publickey_add|ssh2_publickey_init|' +
        'ssh2_publickey_list|ssh2_publickey_remove|ssh2_scp_recv|ssh2_scp_send|ssh2_sftp|ssh2_sftp_lstat|ssh2_sftp_mkdir|ssh2_sftp_readlink|' +
        'ssh2_sftp_realpath|ssh2_sftp_rename|ssh2_sftp_rmdir|ssh2_sftp_stat|ssh2_sftp_symlink|ssh2_sftp_unlink|ssh2_shell|ssh2_tunnel|stat|' +
        'stats_absolute_deviation|stats_cdf_beta|stats_cdf_binomial|stats_cdf_cauchy|stats_cdf_chisquare|stats_cdf_exponential|stats_cdf_f|' +
        'stats_cdf_gamma|stats_cdf_laplace|stats_cdf_logistic|stats_cdf_negative_binomial|stats_cdf_noncentral_chisquare|stats_cdf_noncentral_f|' +
        'stats_cdf_poisson|stats_cdf_t|stats_cdf_uniform|stats_cdf_weibull|stats_covariance|stats_den_uniform|stats_dens_beta|stats_dens_cauchy|' +
        'stats_dens_chisquare|stats_dens_exponential|stats_dens_f|stats_dens_gamma|stats_dens_laplace|stats_dens_logistic|' +
        'stats_dens_negative_binomial|stats_dens_normal|stats_dens_pmf_binomial|stats_dens_pmf_hypergeometric|stats_dens_pmf_poisson|stats_dens_t|' +
        'stats_dens_weibull|stats_harmonic_mean|stats_kurtosis|stats_rand_gen_beta|stats_rand_gen_chisquare|stats_rand_gen_exponential|' +
        'stats_rand_gen_f|stats_rand_gen_funiform|stats_rand_gen_gamma|stats_rand_gen_ibinomial|stats_rand_gen_ibinomial_negative|' +
        'stats_rand_gen_int|stats_rand_gen_ipoisson|stats_rand_gen_iuniform|stats_rand_gen_noncenral_chisquare|stats_rand_gen_noncentral_f|' +
        'stats_rand_gen_noncentral_t|stats_rand_gen_normal|stats_rand_gen_t|stats_rand_get_seeds|stats_rand_phrase_to_seeds|stats_rand_ranf|' +
        'stats_rand_setall|stats_skew|stats_standard_deviation|stats_stat_binomial_coef|stats_stat_correlation|stats_stat_gennch|' +
        'stats_stat_independent_t|stats_stat_innerproduct|stats_stat_noncentral_t|stats_stat_paired_t|stats_stat_percentile|stats_stat_powersum|' +
        'stats_variance|stomp|stomp_connect_error|stomp_version|stompexception|stompframe|str_getcsv|str_ireplace|str_pad|str_repeat|str_replace|' +
        'str_rot13|str_shuffle|str_split|str_word_count|strcasecmp|strchr|strcmp|strcoll|strcspn|stream_bucket_append|stream_bucket_make_writeable|' +
        'stream_bucket_new|stream_bucket_prepend|stream_context_create|stream_context_get_default|stream_context_get_options|' +
        'stream_context_get_params|stream_context_set_default|stream_context_set_option|stream_context_set_params|stream_copy_to_stream|' +
        'stream_encoding|stream_filter_append|stream_filter_prepend|stream_filter_register|stream_filter_remove|stream_get_contents|' +
        'stream_get_filters|stream_get_line|stream_get_meta_data|stream_get_transports|stream_get_wrappers|stream_is_local|' +
        'stream_notification_callback|stream_register_wrapper|stream_resolve_include_path|stream_select|stream_set_blocking|stream_set_read_buffer|' +
        'stream_set_timeout|stream_set_write_buffer|stream_socket_accept|stream_socket_client|stream_socket_enable_crypto|stream_socket_get_name|' +
        'stream_socket_pair|stream_socket_recvfrom|stream_socket_sendto|stream_socket_server|stream_socket_shutdown|stream_supports_lock|' +
        'stream_wrapper_register|stream_wrapper_restore|stream_wrapper_unregister|streamwrapper|strftime|strip_tags|stripcslashes|stripos|' +
        'stripslashes|stristr|strlen|strnatcasecmp|strnatcmp|strncasecmp|strncmp|strpbrk|strpos|strptime|strrchr|strrev|strripos|strrpos|strspn|' +
        'strstr|strtok|strtolower|strtotime|strtoupper|strtr|strval|substr|substr_compare|substr_count|substr_replace|svm|svmmodel|svn_add|' +
        'svn_auth_get_parameter|svn_auth_set_parameter|svn_blame|svn_cat|svn_checkout|svn_cleanup|svn_client_version|svn_commit|svn_delete|' +
        'svn_diff|svn_export|svn_fs_abort_txn|svn_fs_apply_text|svn_fs_begin_txn2|svn_fs_change_node_prop|svn_fs_check_path|' +
        'svn_fs_contents_changed|svn_fs_copy|svn_fs_delete|svn_fs_dir_entries|svn_fs_file_contents|svn_fs_file_length|svn_fs_is_dir|svn_fs_is_file|' +
        'svn_fs_make_dir|svn_fs_make_file|svn_fs_node_created_rev|svn_fs_node_prop|svn_fs_props_changed|svn_fs_revision_prop|svn_fs_revision_root|' +
        'svn_fs_txn_root|svn_fs_youngest_rev|svn_import|svn_log|svn_ls|svn_mkdir|svn_repos_create|svn_repos_fs|svn_repos_fs_begin_txn_for_commit|' +
        'svn_repos_fs_commit_txn|svn_repos_hotcopy|svn_repos_open|svn_repos_recover|svn_revert|svn_status|svn_update|swf_actiongeturl|' +
        'swf_actiongotoframe|swf_actiongotolabel|swf_actionnextframe|swf_actionplay|swf_actionprevframe|swf_actionsettarget|swf_actionstop|' +
        'swf_actiontogglequality|swf_actionwaitforframe|swf_addbuttonrecord|swf_addcolor|swf_closefile|swf_definebitmap|swf_definefont|' +
        'swf_defineline|swf_definepoly|swf_definerect|swf_definetext|swf_endbutton|swf_enddoaction|swf_endshape|swf_endsymbol|swf_fontsize|' +
        'swf_fontslant|swf_fonttracking|swf_getbitmapinfo|swf_getfontinfo|swf_getframe|swf_labelframe|swf_lookat|swf_modifyobject|swf_mulcolor|' +
        'swf_nextid|swf_oncondition|swf_openfile|swf_ortho|swf_ortho2|swf_perspective|swf_placeobject|swf_polarview|swf_popmatrix|swf_posround|' +
        'swf_pushmatrix|swf_removeobject|swf_rotate|swf_scale|swf_setfont|swf_setframe|swf_shapearc|swf_shapecurveto|swf_shapecurveto3|' +
        'swf_shapefillbitmapclip|swf_shapefillbitmaptile|swf_shapefilloff|swf_shapefillsolid|swf_shapelinesolid|swf_shapelineto|swf_shapemoveto|' +
        'swf_showframe|swf_startbutton|swf_startdoaction|swf_startshape|swf_startsymbol|swf_textwidth|swf_translate|swf_viewport|swfaction|' +
        'swfbitmap|swfbutton|swfdisplayitem|swffill|swffont|swffontchar|swfgradient|swfmorph|swfmovie|swfprebuiltclip|swfshape|swfsound|' +
        'swfsoundinstance|swfsprite|swftext|swftextfield|swfvideostream|swish_construct|swish_getmetalist|swish_getpropertylist|swish_prepare|' +
        'swish_query|swishresult_getmetalist|swishresult_stem|swishresults_getparsedwords|swishresults_getremovedstopwords|swishresults_nextresult|' +
        'swishresults_seekresult|swishsearch_execute|swishsearch_resetlimit|swishsearch_setlimit|swishsearch_setphrasedelimiter|' +
        'swishsearch_setsort|swishsearch_setstructure|sybase_affected_rows|sybase_close|sybase_connect|sybase_data_seek|' +
        'sybase_deadlock_retry_count|sybase_fetch_array|sybase_fetch_assoc|sybase_fetch_field|sybase_fetch_object|sybase_fetch_row|' +
        'sybase_field_seek|sybase_free_result|sybase_get_last_message|sybase_min_client_severity|sybase_min_error_severity|' +
        'sybase_min_message_severity|sybase_min_server_severity|sybase_num_fields|sybase_num_rows|sybase_pconnect|sybase_query|sybase_result|' +
        'sybase_select_db|sybase_set_message_handler|sybase_unbuffered_query|symlink|sys_get_temp_dir|sys_getloadavg|syslog|system|tag|tan|tanh|' +
        'tcpwrap_check|tempnam|textdomain|tidy|tidy_access_count|tidy_config_count|tidy_diagnose|tidy_error_count|tidy_get_error_buffer|' +
        'tidy_get_output|tidy_load_config|tidy_reset_config|tidy_save_config|tidy_set_encoding|tidy_setopt|tidy_warning_count|tidynode|time|' +
        'time_nanosleep|time_sleep_until|timezone_abbreviations_list|timezone_identifiers_list|timezone_location_get|timezone_name_from_abbr|' +
        'timezone_name_get|timezone_offset_get|timezone_open|timezone_transitions_get|timezone_version_get|tmpfile|token_get_all|token_name|' +
        'tokyotyrant|tokyotyrantquery|tokyotyranttable|tostring|tostring|touch|transliterator|traversable|trigger_error|trim|uasort|ucfirst|' +
        'ucwords|udm_add_search_limit|udm_alloc_agent|udm_alloc_agent_array|udm_api_version|udm_cat_list|udm_cat_path|udm_check_charset|' +
        'udm_check_stored|udm_clear_search_limits|udm_close_stored|udm_crc32|udm_errno|udm_error|udm_find|udm_free_agent|udm_free_ispell_data|' +
        'udm_free_res|udm_get_doc_count|udm_get_res_field|udm_get_res_param|udm_hash32|udm_load_ispell_data|udm_open_stored|udm_set_agent_param|' +
        'uksort|umask|underflowexception|unexpectedvalueexception|uniqid|unixtojd|unlink|unpack|unregister_tick_function|unserialize|unset|' +
        'urldecode|urlencode|use_soap_error_handler|user_error|usleep|usort|utf8_decode|utf8_encode|v8js|v8jsexception|var_dump|var_export|variant|' +
        'variant_abs|variant_add|variant_and|variant_cast|variant_cat|variant_cmp|variant_date_from_timestamp|variant_date_to_timestamp|' +
        'variant_div|variant_eqv|variant_fix|variant_get_type|variant_idiv|variant_imp|variant_int|variant_mod|variant_mul|variant_neg|variant_not|' +
        'variant_or|variant_pow|variant_round|variant_set|variant_set_type|variant_sub|variant_xor|version_compare|vfprintf|virtual|' +
        'vpopmail_add_alias_domain|vpopmail_add_alias_domain_ex|vpopmail_add_domain|vpopmail_add_domain_ex|vpopmail_add_user|vpopmail_alias_add|' +
        'vpopmail_alias_del|vpopmail_alias_del_domain|vpopmail_alias_get|vpopmail_alias_get_all|vpopmail_auth_user|vpopmail_del_domain|' +
        'vpopmail_del_domain_ex|vpopmail_del_user|vpopmail_error|vpopmail_passwd|vpopmail_set_user_quota|vprintf|vsprintf|w32api_deftype|' +
        'w32api_init_dtype|w32api_invoke_function|w32api_register_function|w32api_set_call_method|wddx_add_vars|wddx_deserialize|wddx_packet_end|' +
        'wddx_packet_start|wddx_serialize_value|wddx_serialize_vars|win32_continue_service|win32_create_service|win32_delete_service|' +
        'win32_get_last_control_message|win32_pause_service|win32_ps_list_procs|win32_ps_stat_mem|win32_ps_stat_proc|win32_query_service_status|' +
        'win32_set_service_status|win32_start_service|win32_start_service_ctrl_dispatcher|win32_stop_service|wincache_fcache_fileinfo|' +
        'wincache_fcache_meminfo|wincache_lock|wincache_ocache_fileinfo|wincache_ocache_meminfo|wincache_refresh_if_changed|' +
        'wincache_rplist_fileinfo|wincache_rplist_meminfo|wincache_scache_info|wincache_scache_meminfo|wincache_ucache_add|wincache_ucache_cas|' +
        'wincache_ucache_clear|wincache_ucache_dec|wincache_ucache_delete|wincache_ucache_exists|wincache_ucache_get|wincache_ucache_inc|' +
        'wincache_ucache_info|wincache_ucache_meminfo|wincache_ucache_set|wincache_unlock|wordwrap|xattr_get|xattr_list|xattr_remove|xattr_set|' +
        'xattr_supported|xdiff_file_bdiff|xdiff_file_bdiff_size|xdiff_file_bpatch|xdiff_file_diff|xdiff_file_diff_binary|xdiff_file_merge3|' +
        'xdiff_file_patch|xdiff_file_patch_binary|xdiff_file_rabdiff|xdiff_string_bdiff|xdiff_string_bdiff_size|xdiff_string_bpatch|' +
        'xdiff_string_diff|xdiff_string_diff_binary|xdiff_string_merge3|xdiff_string_patch|xdiff_string_patch_binary|xdiff_string_rabdiff|' +
        'xhprof_disable|xhprof_enable|xhprof_sample_disable|xhprof_sample_enable|xml_error_string|xml_get_current_byte_index|' +
        'xml_get_current_column_number|xml_get_current_line_number|xml_get_error_code|xml_parse|xml_parse_into_struct|xml_parser_create|' +
        'xml_parser_create_ns|xml_parser_free|xml_parser_get_option|xml_parser_set_option|xml_set_character_data_handler|xml_set_default_handler|' +
        'xml_set_element_handler|xml_set_end_namespace_decl_handler|xml_set_external_entity_ref_handler|xml_set_notation_decl_handler|' +
        'xml_set_object|xml_set_processing_instruction_handler|xml_set_start_namespace_decl_handler|xml_set_unparsed_entity_decl_handler|xmlreader|' +
        'xmlrpc_decode|xmlrpc_decode_request|xmlrpc_encode|xmlrpc_encode_request|xmlrpc_get_type|xmlrpc_is_fault|xmlrpc_parse_method_descriptions|' +
        'xmlrpc_server_add_introspection_data|xmlrpc_server_call_method|xmlrpc_server_create|xmlrpc_server_destroy|' +
        'xmlrpc_server_register_introspection_callback|xmlrpc_server_register_method|xmlrpc_set_type|xmlwriter_end_attribute|xmlwriter_end_cdata|' +
        'xmlwriter_end_comment|xmlwriter_end_document|xmlwriter_end_dtd|xmlwriter_end_dtd_attlist|xmlwriter_end_dtd_element|' +
        'xmlwriter_end_dtd_entity|xmlwriter_end_element|xmlwriter_end_pi|xmlwriter_flush|xmlwriter_full_end_element|xmlwriter_open_memory|' +
        'xmlwriter_open_uri|xmlwriter_output_memory|xmlwriter_set_indent|xmlwriter_set_indent_string|xmlwriter_start_attribute|' +
        'xmlwriter_start_attribute_ns|xmlwriter_start_cdata|xmlwriter_start_comment|xmlwriter_start_document|xmlwriter_start_dtd|' +
        'xmlwriter_start_dtd_attlist|xmlwriter_start_dtd_element|xmlwriter_start_dtd_entity|xmlwriter_start_element|xmlwriter_start_element_ns|' +
        'xmlwriter_start_pi|xmlwriter_text|xmlwriter_write_attribute|xmlwriter_write_attribute_ns|xmlwriter_write_cdata|xmlwriter_write_comment|' +
        'xmlwriter_write_dtd|xmlwriter_write_dtd_attlist|xmlwriter_write_dtd_element|xmlwriter_write_dtd_entity|xmlwriter_write_element|' +
        'xmlwriter_write_element_ns|xmlwriter_write_pi|xmlwriter_write_raw|xpath_eval|xpath_eval_expression|xpath_new_context|xpath_register_ns|' +
        'xpath_register_ns_auto|xptr_eval|xptr_new_context|xslt_backend_info|xslt_backend_name|xslt_backend_version|xslt_create|xslt_errno|' +
        'xslt_error|xslt_free|xslt_getopt|xslt_process|xslt_set_base|xslt_set_encoding|xslt_set_error_handler|xslt_set_log|xslt_set_object|' +
        'xslt_set_sax_handler|xslt_set_sax_handlers|xslt_set_scheme_handler|xslt_set_scheme_handlers|xslt_setopt|xsltprocessor|yaml_emit|' +
        'yaml_emit_file|yaml_parse|yaml_parse_file|yaml_parse_url|yaz_addinfo|yaz_ccl_conf|yaz_ccl_parse|yaz_close|yaz_connect|yaz_database|' +
        'yaz_element|yaz_errno|yaz_error|yaz_es|yaz_es_result|yaz_get_option|yaz_hits|yaz_itemorder|yaz_present|yaz_range|yaz_record|yaz_scan|' +
        'yaz_scan_result|yaz_schema|yaz_search|yaz_set_option|yaz_sort|yaz_syntax|yaz_wait|yp_all|yp_cat|yp_err_string|yp_errno|yp_first|' +
        'yp_get_default_domain|yp_master|yp_match|yp_next|yp_order|zend_logo_guid|zend_thread_id|zend_version|zip_close|zip_entry_close|' +
        'zip_entry_compressedsize|zip_entry_compressionmethod|zip_entry_filesize|zip_entry_name|zip_entry_open|zip_entry_read|zip_open|zip_read|' +
        'ziparchive|ziparchive_addemptydir|ziparchive_addfile|ziparchive_addfromstring|ziparchive_close|ziparchive_deleteindex|' +
        'ziparchive_deletename|ziparchive_extractto|ziparchive_getarchivecomment|ziparchive_getcommentindex|ziparchive_getcommentname|' +
        'ziparchive_getfromindex|ziparchive_getfromname|ziparchive_getnameindex|ziparchive_getstatusstring|ziparchive_getstream|' +
        'ziparchive_locatename|ziparchive_open|ziparchive_renameindex|ziparchive_renamename|ziparchive_setCommentName|ziparchive_setarchivecomment|' +
        'ziparchive_setcommentindex|ziparchive_statindex|ziparchive_statname|ziparchive_unchangeall|ziparchive_unchangearchive|' +
        'ziparchive_unchangeindex|ziparchive_unchangename|zlib_get_coding_type').split('|')
    );
    var keywords = lang.arrayToMap(
        ('abstract|and|array|as|break|case|catch|class|clone|const|continue|declare|default|do|else|elseif|enddeclare|endfor|endforeach|endif|' +
        'endswitch|endwhile|extends|final|for|foreach|function|global|goto|if|implements|interface|instanceof|namespace|new|or|private|protected|' +
        'public|static|switch|throw|try|use|var|while|xor').split('|')
    );
    var languageConstructs = lang.arrayToMap(
        ('die|echo|empty|exit|eval|include|include_once|isset|list|require|require_once|return|print|unset').split('|')
    );

    var builtinConstants = lang.arrayToMap(
        ('true|false|null|__CLASS__|__DIR__|__FILE__|__LINE__|__METHOD__|__FUNCTION__|__NAMESPACE__').split('|')
    );

    var builtinVariables = lang.arrayToMap(
        ('$GLOBALS|$_SERVER|$_GET|$_POST|$_FILES|$_REQUEST|$_SESSION|$_ENV|$_COOKIE|$php_errormsg|$HTTP_RAW_POST_DATA|' +
        '$http_response_header|$argc|$argv').split('|')
    );
    var builtinFunctionsDeprecated = lang.arrayToMap(
        ('key_exists|cairo_matrix_create_scale|cairo_matrix_create_translate|call_user_method|call_user_method_array|com_addref|com_get|' +
        'com_invoke|com_isenum|com_load|com_release|com_set|connection_timeout|cubrid_load_from_glo|cubrid_new_glo|cubrid_save_to_glo|' +
        'cubrid_send_glo|define_syslog_variables|dl|ereg|ereg_replace|eregi|eregi_replace|hw_documentattributes|hw_documentbodytag|' +
        'hw_documentsize|hw_outputdocument|imagedashedline|maxdb_bind_param|maxdb_bind_result|maxdb_client_encoding|maxdb_close_long_data|' +
        'maxdb_execute|maxdb_fetch|maxdb_get_metadata|maxdb_param_count|maxdb_send_long_data|mcrypt_ecb|mcrypt_generic_end|mime_content_type|' +
        'mysql_createdb|mysql_dbname|mysql_db_query|mysql_drop_db|mysql_dropdb|mysql_escape_string|mysql_fieldflags|mysql_fieldflags|' +
        'mysql_fieldname|mysql_fieldtable|mysql_fieldtype|mysql_freeresult|mysql_listdbs|mysql_list_fields|mysql_listfields|mysql_list_tables|' +
        'mysql_listtables|mysql_numfields|mysql_numrows|mysql_selectdb|mysql_tablename|mysqli_bind_param|mysqli_bind_result|' +
        'mysqli_disable_reads_from_master|mysqli_disable_rpl_parse|mysqli_enable_reads_from_master|mysqli_enable_rpl_parse|mysqli_execute|' +
        'mysqli_fetch|mysqli_get_metadata|mysqli_master_query|mysqli_param_count|mysqli_rpl_parse_enabled|mysqli_rpl_probe|mysqli_rpl_query_type|' +
        'mysqli_send_long_data|mysqli_send_query|mysqli_slave_query|ocibindbyname|ocicancel|ocicloselob|ocicollappend|ocicollassign|' +
        'ocicollassignelem|ocicollgetelem|ocicollmax|ocicollsize|ocicolltrim|ocicolumnisnull|ocicolumnname|ocicolumnprecision|ocicolumnscale|' +
        'ocicolumnsize|ocicolumntype|ocicolumntyperaw|ocicommit|ocidefinebyname|ocierror|ociexecute|ocifetch|ocifetchinto|ocifetchstatement|' +
        'ocifreecollection|ocifreecursor|ocifreedesc|ocifreestatement|ociinternaldebug|ociloadlob|ocilogoff|ocilogon|ocinewcollection|' +
        'ocinewcursor|ocinewdescriptor|ocinlogon|ocinumcols|ociparse|ociplogon|ociresult|ocirollback|ocirowcount|ocisavelob|ocisavelobfile|' +
        'ociserverversion|ocisetprefetch|ocistatementtype|ociwritelobtofile|ociwritetemporarylob|PDF_add_annotation|PDF_add_bookmark|' +
        'PDF_add_launchlink|PDF_add_locallink|PDF_add_note|PDF_add_outline|PDF_add_pdflink|PDF_add_weblink|PDF_attach_file|PDF_begin_page|' +
        'PDF_begin_template|PDF_close_pdi|PDF_close|PDF_findfont|PDF_get_font|PDF_get_fontname|PDF_get_fontsize|PDF_get_image_height|' +
        'PDF_get_image_width|PDF_get_majorversion|PDF_get_minorversion|PDF_get_pdi_parameter|PDF_get_pdi_value|PDF_open_ccitt|PDF_open_file|' +
        'PDF_open_gif|PDF_open_image_file|PDF_open_image|PDF_open_jpeg|PDF_open_pdi|PDF_open_tiff|PDF_place_image|PDF_place_pdi_page|' +
        'PDF_set_border_color|PDF_set_border_dash|PDF_set_border_style|PDF_set_char_spacing|PDF_set_duration|PDF_set_horiz_scaling|' +
        'PDF_set_info_author|PDF_set_info_creator|PDF_set_info_keywords|PDF_set_info_subject|PDF_set_info_title|PDF_set_leading|' +
        'PDF_set_text_matrix|PDF_set_text_rendering|PDF_set_text_rise|PDF_set_word_spacing|PDF_setgray_fill|PDF_setgray_stroke|PDF_setgray|' +
        'PDF_setpolydash|PDF_setrgbcolor_fill|PDF_setrgbcolor_stroke|PDF_setrgbcolor|PDF_show_boxed|php_check_syntax|px_set_tablename|' +
        'px_set_targetencoding|runkit_sandbox_output_handler|session_is_registered|session_register|session_unregister' +
        'set_magic_quotes_runtime|magic_quotes_runtime|set_socket_blocking|socket_set_blocking|set_socket_timeout|socket_set_timeout|split|spliti|' +
        'sql_regcase').split('|')
    );

    var keywordsDeprecated = lang.arrayToMap(
        ('cfunction|old_function').split('|')
    );

    var futureReserved = lang.arrayToMap([]);

    this.$rules = {
        "start" : [
            {
                token : "comment",
                regex : /(?:#|\/\/)(?:[^?]|\?[^>])*/
            },
            docComment.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : "\\/\\*",
                next : "comment"
            }, {
                token : "string.regexp",
                regex : "[/](?:(?:\\[(?:\\\\]|[^\\]])+\\])|(?:\\\\/|[^\\]/]))*[/][gimy]*\\s*(?=[).,;]|$)"
            }, {
                token : "string", // " string start
                regex : '"',
                next : "qqstring"
            }, {
                token : "string", // ' string start
                regex : "'",
                next : "qstring"
            }, {
                token : "constant.numeric", // hex
                regex : "0[xX][0-9a-fA-F]+\\b"
            }, {
                token : "constant.numeric", // float
                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
            }, {
                token : "constant.language", // constants
                regex : "\\b(?:DEFAULT_INCLUDE_PATH|E_(?:ALL|CO(?:MPILE_(?:ERROR|WARNING)|RE_(?:ERROR|WARNING))|" +
                        "ERROR|NOTICE|PARSE|STRICT|USER_(?:ERROR|NOTICE|WARNING)|WARNING)|P(?:EAR_(?:EXTENSION_DIR|INSTALL_DIR)|" +
                        "HP_(?:BINDIR|CONFIG_FILE_(?:PATH|SCAN_DIR)|DATADIR|E(?:OL|XTENSION_DIR)|INT_(?:MAX|SIZE)|" +
                        "L(?:IBDIR|OCALSTATEDIR)|O(?:S|UTPUT_HANDLER_(?:CONT|END|START))|PREFIX|S(?:API|HLIB_SUFFIX|YSCONFDIR)|" +
                        "VERSION))|__COMPILER_HALT_OFFSET__)\\b"
            }, {
                token : ["keyword", "text", "support.class"],
                regex : "\\b(new)(\\s+)(\\w+)"
            }, {
                token : ["support.class", "keyword.operator"],
                regex : "\\b(\\w+)(::)"
            }, {
                token : "constant.language", // constants
                regex : "\\b(?:A(?:B(?:DAY_(?:1|2|3|4|5|6|7)|MON_(?:1(?:0|1|2|)|2|3|4|5|6|7|8|9))|LT_DIGITS|M_STR|" +
                        "SSERT_(?:ACTIVE|BAIL|CALLBACK|QUIET_EVAL|WARNING))|C(?:ASE_(?:LOWER|UPPER)|HAR_MAX|" +
                        "O(?:DESET|NNECTION_(?:ABORTED|NORMAL|TIMEOUT)|UNT_(?:NORMAL|RECURSIVE))|" +
                        "R(?:EDITS_(?:ALL|DOCS|FULLPAGE|G(?:ENERAL|ROUP)|MODULES|QA|SAPI)|NCYSTR|" +
                        "YPT_(?:BLOWFISH|EXT_DES|MD5|S(?:ALT_LENGTH|TD_DES)))|URRENCY_SYMBOL)|D(?:AY_(?:1|2|3|4|5|6|7)|" +
                        "ECIMAL_POINT|IRECTORY_SEPARATOR|_(?:FMT|T_FMT))|E(?:NT_(?:COMPAT|NOQUOTES|QUOTES)|RA(?:_(?:D_(?:FMT|T_FMT)|" +
                        "T_FMT|YEAR)|)|XTR_(?:IF_EXISTS|OVERWRITE|PREFIX_(?:ALL|I(?:F_EXISTS|NVALID)|SAME)|SKIP))|FRAC_DIGITS|GROUPING|" +
                        "HTML_(?:ENTITIES|SPECIALCHARS)|IN(?:FO_(?:ALL|C(?:ONFIGURATION|REDITS)|ENVIRONMENT|GENERAL|LICENSE|MODULES|VARIABLES)|" +
                        "I_(?:ALL|PERDIR|SYSTEM|USER)|T_(?:CURR_SYMBOL|FRAC_DIGITS))|L(?:C_(?:ALL|C(?:OLLATE|TYPE)|M(?:ESSAGES|ONETARY)|NUMERIC|TIME)|" +
                        "O(?:CK_(?:EX|NB|SH|UN)|G_(?:A(?:LERT|UTH(?:PRIV|))|C(?:ONS|R(?:IT|ON))|D(?:AEMON|EBUG)|E(?:MERG|RR)|INFO|KERN|" +
                        "L(?:OCAL(?:0|1|2|3|4|5|6|7)|PR)|MAIL|N(?:DELAY|EWS|O(?:TICE|WAIT))|ODELAY|P(?:ERROR|ID)|SYSLOG|U(?:SER|UCP)|WARNING)))|" +
                        "M(?:ON_(?:1(?:0|1|2|)|2|3|4|5|6|7|8|9|DECIMAL_POINT|GROUPING|THOUSANDS_SEP)|_(?:1_PI|2_(?:PI|SQRTPI)|E|L(?:N(?:10|2)|" +
                        "OG(?:10E|2E))|PI(?:_(?:2|4)|)|SQRT(?:1_2|2)))|N(?:EGATIVE_SIGN|O(?:EXPR|STR)|_(?:CS_PRECEDES|S(?:EP_BY_SPACE|IGN_POSN)))|" +
                        "P(?:ATH(?:INFO_(?:BASENAME|DIRNAME|EXTENSION)|_SEPARATOR)|M_STR|OSITIVE_SIGN|_(?:CS_PRECEDES|S(?:EP_BY_SPACE|IGN_POSN)))|" +
                        "RADIXCHAR|S(?:EEK_(?:CUR|END|SET)|ORT_(?:ASC|DESC|NUMERIC|REGULAR|STRING)|TR_PAD_(?:BOTH|LEFT|RIGHT))|" +
                        "T(?:HOUS(?:ANDS_SEP|EP)|_FMT(?:_AMPM|))|YES(?:EXPR|STR)|STD(?:IN|OUT|ERR))\\b"
            }, {
                token : function(value) {
                    if (keywords.hasOwnProperty(value))
                        return "keyword";
                    else if (builtinConstants.hasOwnProperty(value))
                        return "constant.language";
                    else if (builtinVariables.hasOwnProperty(value))
                        return "variable.language";
                    else if (futureReserved.hasOwnProperty(value))
                        return "invalid.illegal";
                    else if (builtinFunctions.hasOwnProperty(value))
                        return "support.function";
                    else if (value == "debugger")
                        return "invalid.deprecated";
                    else
                        if(value.match(/^(\$[a-zA-Z_\x7f-\uffff][a-zA-Z0-9_\x7f-\uffff]*|self|parent)$/))
                            return "variable";
                        return "identifier";
                },
                regex : /[a-zA-Z_$\x7f-\uffff][a-zA-Z0-9_\x7f-\uffff]*/
            }, {
                onMatch : function(value, currentSate, state) {
                    value = value.substr(3);
                    if (value[0] == "'" || value[0] == '"')
                        value = value.slice(1, -1);
                    state.unshift(this.next, value);
                    return "markup.list";
                },
                regex : /<<<(?:\w+|'\w+'|"\w+")$/,
                next: "heredoc"
            }, {
                token : "keyword.operator",
                regex : "::|!|\\$|%|&|\\*|\\-\\-|\\-|\\+\\+|\\+|~|===|==|!=|!==|<=|>=|=>|<<=|>>=|>>>=|<>|<|>|=|!|&&|\\|\\||\\?\\:|\\*=|%=|\\+=|\\-=|&=|\\^=|\\b(?:in|instanceof|new|delete|typeof|void)"
            }, {
                token : "paren.lparen",
                regex : "[[({]"
            }, {
                token : "paren.rparen",
                regex : "[\\])}]"
            }, {
                token : "text",
                regex : "\\s+"
            }
        ],
        "heredoc" : [
            {
                onMatch : function(value, currentSate, stack) {
                    if (stack[1] != value)
                        return "string";
                    stack.shift();
                    stack.shift();
                    return "markup.list";
                },
                regex : "^\\w+(?=;?$)",
                next: "start"
            }, {
                token: "string",
                regex : ".*"
            }
        ],
        "comment" : [
            {
                token : "comment",
                regex : "\\*\\/",
                next : "start"
            }, {
                defaultToken : "comment"
            }
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : '\\\\(?:[nrtvef\\\\"$]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2})'
            }, {
                token : "variable",
                regex : /\$[\w]+(?:\[[\w\]+]|[=\-]>\w+)?/
            }, {
                token : "variable",
                regex : /\$\{[^"\}]+\}?/           // this is wrong but ok for now
            },
            {token : "string", regex : '"', next : "start"},
            {defaultToken : "string"}
        ],
        "qstring" : [
            {token : "constant.language.escape", regex : /\\['\\]/},
            {token : "string", regex : "'", next : "start"},
            {defaultToken : "string"}
        ]
    };

    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("start") ]);
};

oop.inherits(PhpLangHighlightRules, TextHighlightRules);


var PhpHighlightRules = function() {
    HtmlHighlightRules.call(this);

    var startRules = [
        {
            token : "support.php_tag", // php open tag
            regex : "<\\?(?:php|=)?",
            push  : "php-start"
        }
    ];

    var endRules = [
        {
            token : "support.php_tag", // php close tag
            regex : "\\?>",
            next  : "pop"
        }
    ];

    for (var key in this.$rules)
        this.$rules[key].unshift.apply(this.$rules[key], startRules);

    this.embedRules(PhpLangHighlightRules, "php-", endRules, ["start"]);

    this.normalizeRules();
};

oop.inherits(PhpHighlightRules, HtmlHighlightRules);

exports.PhpHighlightRules = PhpHighlightRules;
exports.PhpLangHighlightRules = PhpLangHighlightRules;
});

define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};

var CstyleBehaviour = function() {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);

                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;

                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};


CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {

    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);

        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }

        var fw = this._getFoldWidgetBase(session, foldStyle, row);

        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart

        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);

        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);

        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);

            var range = session.getCommentFoldRange(row, i + match[0].length, 1);

            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }

            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };

    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);

            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }

        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;

        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var Range = require("../range").Range;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;

    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(results) {
            session.setAnnotations(results.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/javascript";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/mode/behaviour/css",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;

var CssBehaviour = function () {

    this.inherit(CstyleBehaviour);

    this.add("colon", "insertion", function (state, action, editor, session, text) {
        if (text === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ':') {
                    return {
                       text: '',
                       selection: [1, 1]
                    }
                }
                if (!line.substring(cursor.column).match(/^\s*;/)) {
                    return {
                       text: ':;',
                       selection: [1, 1]
                    }
                }
            }
        }
    });

    this.add("colon", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ';') {
                    range.end.column ++;
                    return range;
                }
            }
        }
    });

    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
        if (text === ';') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
                return {
                   text: '',
                   selection: [1, 1]
                }
            }
        }
    });

}
oop.inherits(CssBehaviour, CstyleBehaviour);

exports.CssBehaviour = CssBehaviour;
});

define("ace/mode/css",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/css_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/css","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CssBehaviour = require("./behaviour/css").CssBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.foldingRules = "cStyle";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/css";
}).call(Mode.prototype);

exports.Mode = Mode;

});

define("ace/mode/behaviour/xml",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

var XmlBehaviour = function () {

    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            }

            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                return {
                    text: "",
                    selection: [1, 1]
                };
            }

            if (!token)
                token = iterator.stepBackward();

            if (!token)
                return;

            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
                return {
                    text: quote + quote,
                    selection: [1, 1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
        if (text == '>') {
            var position = editor.getCursorPosition();
            var iterator = new TokenIterator(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();
            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
                return;
            if (is(token, "reference.attribute-value"))
                return;
            if (is(token, "attribute-value")) {
                var firstChar = token.value.charAt(0);
                if (firstChar == '"' || firstChar == "'") {
                    var lastChar = token.value.charAt(token.value.length - 1);
                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
                        return;
                }
            }
            while (!is(token, "tag-name")) {
                token = iterator.stepBackward();
            }

            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();
            if (is(iterator.stepBackward(), "end-tag-open"))
                return;

            var element = token.value;
            if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);

            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                 return;

            return {
               text: ">" + "</" + element + ">",
               selection: [1, 1]
            };
        }
    });

    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
        if (text == "\n") {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (token && token.type.indexOf("tag-close") !== -1) {
                if (token.value == "/>")
                    return;
                while (token && token.type.indexOf("tag-name") === -1) {
                    token = iterator.stepBackward();
                }

                if (!token) {
                    return;
                }

                var tag = token.value;
                var row = iterator.getCurrentTokenRow();
                token = iterator.stepBackward();
                if (!token || token.type.indexOf("end-tag") !== -1) {
                    return;
                }

                if (this.voidElements && !this.voidElements[tag]) {
                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);
                    var line = session.getLine(row);
                    var nextIndent = this.$getIndent(line);
                    var indent = nextIndent + session.getTabString();

                    if (nextToken && nextToken.value === "</") {
                        return {
                            text: "\n" + indent + "\n" + nextIndent,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        return {
                            text: "\n" + indent
                        };
                    }
                }
            }
        }
    });

};

oop.inherits(XmlBehaviour, Behaviour);

exports.XmlBehaviour = XmlBehaviour;
});

define("ace/mode/folding/mixed",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(defaultMode, subModes) {
    this.defaultMode = defaultMode;
    this.subModes = subModes;
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {


    this.$getMode = function(state) {
        if (typeof state != "string")
            state = state[0];
        for (var key in this.subModes) {
            if (state.indexOf(key) === 0)
                return this.subModes[key];
        }
        return null;
    };

    this.$tryMode = function(state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
    };

    this.getFoldWidget = function(session, foldStyle, row) {
        return (
            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||
            this.$tryMode(session.getState(row), session, foldStyle, row) ||
            this.defaultMode.getFoldWidget(session, foldStyle, row)
        );
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row-1));

        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.$getMode(session.getState(row));

        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.defaultMode;

        return mode.getFoldWidgetRange(session, foldStyle, row);
    };

}).call(FoldMode.prototype);

});

define("ace/mode/folding/xml",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/range","ace/mode/folding/fold_mode","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var lang = require("../../lib/lang");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;
var TokenIterator = require("../../token_iterator").TokenIterator;

var FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {
    BaseFoldMode.call(this);
    this.voidElements = voidElements || {};
    this.optionalEndTags = oop.mixin({}, this.voidElements);
    if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);

};
oop.inherits(FoldMode, BaseFoldMode);

var Tag = function() {
    this.tagName = "";
    this.closing = false;
    this.selfClosing = false;
    this.start = {row: 0, column: 0};
    this.end = {row: 0, column: 0};
};

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

(function() {

    this.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);

        if (!tag)
            return "";

        if (tag.closing || (!tag.tagName && tag.selfClosing))
            return foldStyle == "markbeginend" ? "end" : "";

        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
            return "";

        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
            return "";

        return "start";
    };
    this._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (is(token, "tag-open")) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, "end-tag-open");
                token = tokens[++i];
                if (!token)
                    return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i < tokens.length; i++) {
                    token = tokens[i];
                    tag.end.column += token.value.length;
                    if (is(token, "tag-close")) {
                        tag.selfClosing = token.value == '/>';
                        break;
                    }
                }
                return tag;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == '/>';
                return tag;
            }
            tag.start.column += token.value.length;
        }

        return null;
    };

    this._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            column += token.value.length;
            if (column < startColumn)
                continue;
            if (is(token, "end-tag-open")) {
                token = tokens[i + 1];
                if (token && token.value == tagName)
                    return true;
            }
        }
        return false;
    };
    this._readTagForward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                iterator.stepForward();
                return tag;
            }
        } while(token = iterator.stepForward());

        return null;
    };

    this._readTagBackward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
                iterator.stepBackward();
                return tag;
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
            }
        } while(token = iterator.stepBackward());

        return null;
    };

    this._pop = function(stack, tag) {
        while (stack.length) {

            var top = stack[stack.length-1];
            if (!tag || top.tagName == tag.tagName) {
                return stack.pop();
            }
            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                stack.pop();
                continue;
            } else {
                return null;
            }
        }
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);

        if (!firstTag)
            return null;

        var isBackward = firstTag.closing || firstTag.selfClosing;
        var stack = [];
        var tag;

        if (!isBackward) {
            var iterator = new TokenIterator(session, row, firstTag.start.column);
            var start = {
                row: row,
                column: firstTag.start.column + firstTag.tagName.length + 2
            };
            if (firstTag.start.row == firstTag.end.row)
                start.column = firstTag.end.column;
            while (tag = this._readTagForward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }

                if (tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0)
                        return Range.fromPoints(start, tag.start);
                }
                else {
                    stack.push(tag);
                }
            }
        }
        else {
            var iterator = new TokenIterator(session, row, firstTag.end.column);
            var end = {
                row: row,
                column: firstTag.start.column
            };

            while (tag = this._readTagBackward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }

                if (!tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0) {
                        tag.start.column += tag.tagName.length + 2;
                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
                            tag.start.column = tag.end.column;
                        return Range.fromPoints(tag.start, end);
                    }
                }
                else {
                    stack.push(tag);
                }
            }
        }

    };

}).call(FoldMode.prototype);

});

define("ace/mode/folding/html",["require","exports","module","ace/lib/oop","ace/mode/folding/mixed","ace/mode/folding/xml","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var MixedFoldMode = require("./mixed").FoldMode;
var XmlFoldMode = require("./xml").FoldMode;
var CStyleFoldMode = require("./cstyle").FoldMode;

var FoldMode = exports.FoldMode = function(voidElements, optionalTags) {
    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
        "js-": new CStyleFoldMode(),
        "css-": new CStyleFoldMode()
    });
};

oop.inherits(FoldMode, MixedFoldMode);

});

define("ace/mode/html_completions",["require","exports","module","ace/token_iterator"], function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;

var commonAttributes = [
    "accesskey",
    "class",
    "contenteditable",
    "contextmenu",
    "dir",
    "draggable",
    "dropzone",
    "hidden",
    "id",
    "inert",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
];

var eventAttributes = [
    "onabort",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextmenu",
    "oncuechange",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmousedown",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onpause",
    "onplay",
    "onplaying",
    "onprogress",
    "onratechange",
    "onreset",
    "onscroll",
    "onseeked",
    "onseeking",
    "onselect",
    "onshow",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "onvolumechange",
    "onwaiting"
];

var globalAttributes = commonAttributes.concat(eventAttributes);

var attributeMap = {
    "html": ["manifest"],
    "head": [],
    "title": [],
    "base": ["href", "target"],
    "link": ["href", "hreflang", "rel", "media", "type", "sizes"],
    "meta": ["http-equiv", "name", "content", "charset"],
    "style": ["type", "media", "scoped"],
    "script": ["charset", "type", "src", "defer", "async"],
    "noscript": ["href"],
    "body": ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onmessage", "onoffline", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload"],
    "section": [],
    "nav": [],
    "article": ["pubdate"],
    "aside": [],
    "h1": [],
    "h2": [],
    "h3": [],
    "h4": [],
    "h5": [],
    "h6": [],
    "header": [],
    "footer": [],
    "address": [],
    "main": [],
    "p": [],
    "hr": [],
    "pre": [],
    "blockquote": ["cite"],
    "ol": ["start", "reversed"],
    "ul": [],
    "li": ["value"],
    "dl": [],
    "dt": [],
    "dd": [],
    "figure": [],
    "figcaption": [],
    "div": [],
    "a": ["href", "target", "ping", "rel", "media", "hreflang", "type"],
    "em": [],
    "strong": [],
    "small": [],
    "s": [],
    "cite": [],
    "q": ["cite"],
    "dfn": [],
    "abbr": [],
    "data": [],
    "time": ["datetime"],
    "code": [],
    "var": [],
    "samp": [],
    "kbd": [],
    "sub": [],
    "sup": [],
    "i": [],
    "b": [],
    "u": [],
    "mark": [],
    "ruby": [],
    "rt": [],
    "rp": [],
    "bdi": [],
    "bdo": [],
    "span": [],
    "br": [],
    "wbr": [],
    "ins": ["cite", "datetime"],
    "del": ["cite", "datetime"],
    "img": ["alt", "src", "height", "width", "usemap", "ismap"],
    "iframe": ["name", "src", "height", "width", "sandbox", "seamless"],
    "embed": ["src", "height", "width", "type"],
    "object": ["param", "data", "type", "height" , "width", "usemap", "name", "form", "classid"],
    "param": ["name", "value"],
    "video": ["src", "autobuffer", "autoplay", "loop", "controls", "width", "height", "poster"],
    "audio": ["src", "autobuffer", "autoplay", "loop", "controls"],
    "source": ["src", "type", "media"],
    "track": ["kind", "src", "srclang", "label", "default"],
    "canvas": ["width", "height"],
    "map": ["name"],
    "area": ["shape", "coords", "href", "hreflang", "alt", "target", "media", "rel", "ping", "type"],
    "svg": [],
    "math": [],
    "table": ["summary"],
    "caption": [],
    "colgroup": ["span"],
    "col": ["span"],
    "tbody": [],
    "thead": [],
    "tfoot": [],
    "tr": [],
    "td": ["headers", "rowspan", "colspan"],
    "th": ["headers", "rowspan", "colspan", "scope"],
    "form": ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"],
    "fieldset": ["disabled", "form", "name"],
    "legend": [],
    "label": ["form", "for"],
    "input": ["type", "accept", "alt", "autocomplete", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "list", "max", "maxlength", "min", "multiple", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "width", "files", "value"],
    "button": ["autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "value", "type"],
    "select": ["autofocus", "disabled", "form", "multiple", "name", "size"],
    "datalist": [],
    "optgroup": ["disabled", "label"],
    "option": ["disabled", "selected", "label", "value"],
    "textarea": ["autofocus", "disabled", "form", "maxlength", "name", "placeholder", "readonly", "required", "rows", "cols", "wrap"],
    "keygen": ["autofocus", "challenge", "disabled", "form", "keytype", "name"],
    "output": ["for", "form", "name"],
    "progress": ["value", "max"],
    "meter": ["value", "min", "max", "low", "high", "optimum"],
    "details": ["open"],
    "summary": [],
    "command": ["type", "label", "icon", "disabled", "checked", "radiogroup", "command"],
    "menu": ["type", "label"],
    "dialog": ["open"]
};

var elements = Object.keys(attributeMap);

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

function findTagName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "tag-name")){
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}

var HtmlCompletions = function() {

};

(function() {

    this.getCompletions = function(state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);

        if (!token)
            return [];
        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
            return this.getTagCompletions(state, session, pos, prefix);
        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
            return this.getAttributeCompetions(state, session, pos, prefix);

        return [];
    };

    this.getTagCompletions = function(state, session, pos, prefix) {
        return elements.map(function(element){
            return {
                value: element,
                meta: "tag",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getAttributeCompetions = function(state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
            return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
            attributes = attributes.concat(attributeMap[tagName]);
        }
        return attributes.map(function(attribute){
            return {
                caption: attribute,
                snippet: attribute + '="$0"',
                meta: "attribute",
                score: Number.MAX_VALUE
            };
        });
    };

}).call(HtmlCompletions.prototype);

exports.HtmlCompletions = HtmlCompletions;
});

define("ace/mode/html",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/javascript","ace/mode/css","ace/mode/html_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/html","ace/mode/html_completions","ace/worker/worker_client"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextMode = require("./text").Mode;
var JavaScriptMode = require("./javascript").Mode;
var CssMode = require("./css").Mode;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
var HtmlFoldMode = require("./folding/html").FoldMode;
var HtmlCompletions = require("./html_completions").HtmlCompletions;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

var Mode = function(options) {
    this.fragmentContext = options && options.fragmentContext;
    this.HighlightRules = HtmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();

    this.createModeDelegates({
        "js-": JavaScriptMode,
        "css-": CssMode
    });

    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
};
oop.inherits(Mode, TextMode);

(function() {

    this.blockComment = {start: "<!--", end: "-->"};

    this.voidElements = lang.arrayToMap(voidElements);

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.createWorker = function(session) {
        if (this.constructor != Mode)
            return;
        var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        if (this.fragmentContext)
            worker.call("setOptions", [{context: this.fragmentContext}]);

        worker.on("error", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/html";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/mode/php",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/php_highlight_rules","ace/mode/php_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle","ace/unicode","ace/mode/html","ace/mode/javascript","ace/mode/css"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var PhpHighlightRules = require("./php_highlight_rules").PhpHighlightRules;
var PhpLangHighlightRules = require("./php_highlight_rules").PhpLangHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var Range = require("../range").Range;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var unicode = require("../unicode");
var HtmlMode = require("./html").Mode;
var JavaScriptMode = require("./javascript").Mode;
var CssMode = require("./css").Mode;

var PhpMode = function(opts) {
    this.HighlightRules = PhpLangHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(PhpMode, TextMode);

(function() {

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\_]|\s])+", "g"
    );


    this.lineCommentStart = ["//", "#"];
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start") {
            var match = line.match(/^.*[\{\(\[\:]\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState != "doc-start") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.$id = "ace/mode/php-inline";
}).call(PhpMode.prototype);

var Mode = function(opts) {
    if (opts && opts.inline) {
        var mode = new PhpMode();
        mode.createWorker = this.createWorker;
        mode.inlinePhp = true;
        return mode;
    }
    HtmlMode.call(this);
    this.HighlightRules = PhpHighlightRules;
    this.createModeDelegates({
        "js-": JavaScriptMode,
        "css-": CssMode,
        "php-": PhpMode
    });
    this.foldingRules.subModes["php-"] = new CStyleFoldMode();
};
oop.inherits(Mode, HtmlMode);

(function() {

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/php_worker", "PhpWorker");
        worker.attachToDocument(session.getDocument());

        if (this.inlinePhp)
            worker.call("setOptions", [{inline: true}]);

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/php";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/ext/searchbox",["require","exports","module","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/keyboard/hash_handler","ace/lib/keys"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var lang = require("../lib/lang");
var event = require("../lib/event");
var searchboxCss = "\
.ace_search {\
background-color: #ddd;\
border: 1px solid #cbcbcb;\
border-top: 0 none;\
max-width: 325px;\
overflow: hidden;\
margin: 0;\
padding: 4px;\
padding-right: 6px;\
padding-bottom: 0;\
position: absolute;\
top: 0px;\
z-index: 99;\
white-space: normal;\
}\
.ace_search.left {\
border-left: 0 none;\
border-radius: 0px 0px 5px 0px;\
left: 0;\
}\
.ace_search.right {\
border-radius: 0px 0px 0px 5px;\
border-right: 0 none;\
right: 0;\
}\
.ace_search_form, .ace_replace_form {\
border-radius: 3px;\
border: 1px solid #cbcbcb;\
float: left;\
margin-bottom: 4px;\
overflow: hidden;\
}\
.ace_search_form.ace_nomatch {\
outline: 1px solid red;\
}\
.ace_search_field {\
background-color: white;\
border-right: 1px solid #cbcbcb;\
border: 0 none;\
-webkit-box-sizing: border-box;\
-moz-box-sizing: border-box;\
box-sizing: border-box;\
float: left;\
height: 22px;\
outline: 0;\
padding: 0 7px;\
width: 214px;\
margin: 0;\
}\
.ace_searchbtn,\
.ace_replacebtn {\
background: #fff;\
border: 0 none;\
border-left: 1px solid #dcdcdc;\
cursor: pointer;\
float: left;\
height: 22px;\
margin: 0;\
padding: 0;\
position: relative;\
}\
.ace_searchbtn:last-child,\
.ace_replacebtn:last-child {\
border-top-right-radius: 3px;\
border-bottom-right-radius: 3px;\
}\
.ace_searchbtn:disabled {\
background: none;\
cursor: default;\
}\
.ace_searchbtn {\
background-position: 50% 50%;\
background-repeat: no-repeat;\
width: 27px;\
}\
.ace_searchbtn.prev {\
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADFJREFUeNpiSU1NZUAC/6E0I0yACYskCpsJiySKIiY0SUZk40FyTEgCjGgKwTRAgAEAQJUIPCE+qfkAAAAASUVORK5CYII=);    \
}\
.ace_searchbtn.next {\
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADRJREFUeNpiTE1NZQCC/0DMyIAKwGJMUAYDEo3M/s+EpvM/mkKwCQxYjIeLMaELoLMBAgwAU7UJObTKsvAAAAAASUVORK5CYII=);    \
}\
.ace_searchbtn_close {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\
border-radius: 50%;\
border: 0 none;\
color: #656565;\
cursor: pointer;\
float: right;\
font: 16px/16px Arial;\
height: 14px;\
margin: 5px 1px 9px 5px;\
padding: 0;\
text-align: center;\
width: 14px;\
}\
.ace_searchbtn_close:hover {\
background-color: #656565;\
background-position: 50% 100%;\
color: white;\
}\
.ace_replacebtn.prev {\
width: 54px\
}\
.ace_replacebtn.next {\
width: 27px\
}\
.ace_button {\
margin-left: 2px;\
cursor: pointer;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
overflow: hidden;\
opacity: 0.7;\
border: 1px solid rgba(100,100,100,0.23);\
padding: 1px;\
-moz-box-sizing: border-box;\
box-sizing:    border-box;\
color: black;\
}\
.ace_button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_button:active {\
background-color: #ddd;\
}\
.ace_button.checked {\
border-color: #3399ff;\
opacity:1;\
}\
.ace_search_options{\
margin-bottom: 3px;\
text-align: right;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
}";
var HashHandler = require("../keyboard/hash_handler").HashHandler;
var keyUtil = require("../lib/keys");

dom.importCssString(searchboxCss, "ace_searchbox");

var html = '<div class="ace_search right">\
    <button type="button" action="hide" class="ace_searchbtn_close"></button>\
    <div class="ace_search_form">\
        <input class="ace_search_field" placeholder="Search for" spellcheck="false"></input>\
        <button type="button" action="findNext" class="ace_searchbtn next"></button>\
        <button type="button" action="findPrev" class="ace_searchbtn prev"></button>\
        <button type="button" action="findAll" class="ace_searchbtn" title="Alt-Enter">All</button>\
    </div>\
    <div class="ace_replace_form">\
        <input class="ace_search_field" placeholder="Replace with" spellcheck="false"></input>\
        <button type="button" action="replaceAndFindNext" class="ace_replacebtn">Replace</button>\
        <button type="button" action="replaceAll" class="ace_replacebtn">All</button>\
    </div>\
    <div class="ace_search_options">\
        <span action="toggleRegexpMode" class="ace_button" title="RegExp Search">.*</span>\
        <span action="toggleCaseSensitive" class="ace_button" title="CaseSensitive Search">Aa</span>\
        <span action="toggleWholeWords" class="ace_button" title="Whole Word Search">\\b</span>\
    </div>\
</div>'.replace(/>\s+/g, ">");

var SearchBox = function(editor, range, showReplaceForm) {
    var div = dom.createElement("div");
    div.innerHTML = html;
    this.element = div.firstChild;

    this.$init();
    this.setEditor(editor);
};

(function() {
    this.setEditor = function(editor) {
        editor.searchBox = this;
        editor.container.appendChild(this.element);
        this.editor = editor;
    };

    this.$initElements = function(sb) {
        this.searchBox = sb.querySelector(".ace_search_form");
        this.replaceBox = sb.querySelector(".ace_replace_form");
        this.searchOptions = sb.querySelector(".ace_search_options");
        this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
        this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
        this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
        this.searchInput = this.searchBox.querySelector(".ace_search_field");
        this.replaceInput = this.replaceBox.querySelector(".ace_search_field");
    };

    this.$init = function() {
        var sb = this.element;

        this.$initElements(sb);

        var _this = this;
        event.addListener(sb, "mousedown", function(e) {
            setTimeout(function(){
                _this.activeInput.focus();
            }, 0);
            event.stopPropagation(e);
        });
        event.addListener(sb, "click", function(e) {
            var t = e.target || e.srcElement;
            var action = t.getAttribute("action");
            if (action && _this[action])
                _this[action]();
            else if (_this.$searchBarKb.commands[action])
                _this.$searchBarKb.commands[action].exec(_this);
            event.stopPropagation(e);
        });

        event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
            if (command && command.exec) {
                command.exec(_this);
                event.stopEvent(e);
            }
        });

        this.$onChange = lang.delayedCall(function() {
            _this.find(false, false);
        });

        event.addListener(this.searchInput, "input", function() {
            _this.$onChange.schedule(20);
        });
        event.addListener(this.searchInput, "focus", function() {
            _this.activeInput = _this.searchInput;
            _this.searchInput.value && _this.highlight();
        });
        event.addListener(this.replaceInput, "focus", function() {
            _this.activeInput = _this.replaceInput;
            _this.searchInput.value && _this.highlight();
        });
    };
    this.$closeSearchBarKb = new HashHandler([{
        bindKey: "Esc",
        name: "closeSearchBar",
        exec: function(editor) {
            editor.searchBox.hide();
        }
    }]);
    this.$searchBarKb = new HashHandler();
    this.$searchBarKb.bindKeys({
        "Ctrl-f|Command-f|Ctrl-H|Command-Option-F": function(sb) {
            var isReplace = sb.isReplace = !sb.isReplace;
            sb.replaceBox.style.display = isReplace ? "" : "none";
            sb[isReplace ? "replaceInput" : "searchInput"].focus();
        },
        "Ctrl-G|Command-G": function(sb) {
            sb.findNext();
        },
        "Ctrl-Shift-G|Command-Shift-G": function(sb) {
            sb.findPrev();
        },
        "esc": function(sb) {
            setTimeout(function() { sb.hide();});
        },
        "Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findNext();
        },
        "Shift-Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findPrev();
        },
        "Alt-Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replaceAll();
            sb.findAll();
        },
        "Tab": function(sb) {
            (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();
        }
    });

    this.$searchBarKb.addCommands([{
        name: "toggleRegexpMode",
        bindKey: {win: "Alt-R|Alt-/", mac: "Ctrl-Alt-R|Ctrl-Alt-/"},
        exec: function(sb) {
            sb.regExpOption.checked = !sb.regExpOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleCaseSensitive",
        bindKey: {win: "Alt-C|Alt-I", mac: "Ctrl-Alt-R|Ctrl-Alt-I"},
        exec: function(sb) {
            sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleWholeWords",
        bindKey: {win: "Alt-B|Alt-W", mac: "Ctrl-Alt-B|Ctrl-Alt-W"},
        exec: function(sb) {
            sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
            sb.$syncOptions();
        }
    }]);

    this.$syncOptions = function() {
        dom.setCssClass(this.regExpOption, "checked", this.regExpOption.checked);
        dom.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked);
        dom.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked);
        this.find(false, false);
    };

    this.highlight = function(re) {
        this.editor.session.highlight(re || this.editor.$search.$options.re);
        this.editor.renderer.updateBackMarkers()
    };
    this.find = function(skipCurrent, backwards) {
        var range = this.editor.find(this.searchInput.value, {
            skipCurrent: skipCurrent,
            backwards: backwards,
            wrap: true,
            regExp: this.regExpOption.checked,
            caseSensitive: this.caseSensitiveOption.checked,
            wholeWord: this.wholeWordOption.checked
        });
        var noMatch = !range && this.searchInput.value;
        dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
        this.editor._emit("findSearchBox", { match: !noMatch });
        this.highlight();
    };
    this.findNext = function() {
        this.find(true, false);
    };
    this.findPrev = function() {
        this.find(true, true);
    };
    this.findAll = function(){
        var range = this.editor.findAll(this.searchInput.value, {
            regExp: this.regExpOption.checked,
            caseSensitive: this.caseSensitiveOption.checked,
            wholeWord: this.wholeWordOption.checked
        });
        var noMatch = !range && this.searchInput.value;
        dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
        this.editor._emit("findSearchBox", { match: !noMatch });
        this.highlight();
        this.hide();
    };
    this.replace = function() {
        if (!this.editor.getReadOnly())
            this.editor.replace(this.replaceInput.value);
    };
    this.replaceAndFindNext = function() {
        if (!this.editor.getReadOnly()) {
            this.editor.replace(this.replaceInput.value);
            this.findNext()
        }
    };
    this.replaceAll = function() {
        if (!this.editor.getReadOnly())
            this.editor.replaceAll(this.replaceInput.value);
    };

    this.hide = function() {
        this.element.style.display = "none";
        this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);
        this.editor.focus();
    };
    this.show = function(value, isReplace) {
        this.element.style.display = "";
        this.replaceBox.style.display = isReplace ? "" : "none";

        this.isReplace = isReplace;

        if (value)
            this.searchInput.value = value;
        this.searchInput.focus();
        this.searchInput.select();

        this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
    };

    this.isFocused = function() {
        var el = document.activeElement;
        return el == this.searchInput || el == this.replaceInput;
    }
}).call(SearchBox.prototype);

exports.SearchBox = SearchBox;

exports.Search = function(editor, isReplace) {
    var sb = editor.searchBox || new SearchBox(editor);
    sb.show(editor.session.getTextRange(), isReplace);
};

});
                (function() {
                    window.require(["ace/ext/searchbox"], function() {});
                })();
            


}
Viper.build = true;Viper.version = 'ed4641ddde58ffec5079d59980de1aa7e228cd58';